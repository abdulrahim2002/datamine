Issue_Num,Author_Login,File_Name,Patch_Text,Commit_Message,Commit_Title
2942,Ron Shapiro,"['guava-gwt/test/com/google/common/collect/StreamsTest_gwt.java', 'guava-tests/test/com/google/common/collect/StreamsTest.java', 'guava/src/com/google/common/collect/Streams.java']","@@ -93,11 +93,41 @@ public void testMapWithIndex_arrayListSource() throws Exception {
   testCase.testMapWithIndex_arrayListSource();
 }
 
+public void testMapWithIndex_closeIsPropagated_sizedSource() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_closeIsPropagated_sizedSource();
+}
+
+public void testMapWithIndex_closeIsPropagated_unsizedSource() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_closeIsPropagated_unsizedSource();
+}
+
+public void testMapWithIndex_doubleStream_closeIsPropagated_sized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_doubleStream_closeIsPropagated_sized();
+}
+
+public void testMapWithIndex_doubleStream_closeIsPropagated_unsized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_doubleStream_closeIsPropagated_unsized();
+}
+
 public void testMapWithIndex_intStream() throws Exception {
   com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
   testCase.testMapWithIndex_intStream();
 }
 
+public void testMapWithIndex_intStream_closeIsPropagated_sized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_intStream_closeIsPropagated_sized();
+}
+
+public void testMapWithIndex_intStream_closeIsPropagated_unsized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_intStream_closeIsPropagated_unsized();
+}
+
 public void testMapWithIndex_linkedHashSetSource() throws Exception {
   com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
   testCase.testMapWithIndex_linkedHashSetSource();
@@ -108,6 +138,16 @@ public void testMapWithIndex_longStream() throws Exception {
   testCase.testMapWithIndex_longStream();
 }
 
+public void testMapWithIndex_longStream_closeIsPropagated_sized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_longStream_closeIsPropagated_sized();
+}
+
+public void testMapWithIndex_longStream_closeIsPropagated_unsized() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testMapWithIndex_longStream_closeIsPropagated_unsized();
+}
+
 public void testMapWithIndex_unsizedSource() throws Exception {
   com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
   testCase.testMapWithIndex_unsizedSource();
@@ -172,4 +212,9 @@ public void testZipInfiniteWithInfinite() throws Exception {
   com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
   testCase.testZipInfiniteWithInfinite();
 }
+
+public void testZip_closeIsPropagated() throws Exception {
+  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
+  testCase.testZip_closeIsPropagated();
+}
 }, @@ -201,18 +201,75 @@ public void testMapWithIndex_unsizedSource() {
         elems -> Stream.of((Object) null).flatMap(unused -> ImmutableList.copyOf(elems).stream()));
   }
 
+  public void testMapWithIndex_closeIsPropagated_sizedSource() {
+    testMapWithIndex_closeIsPropagated(Stream.of(""a"", ""b"", ""c""));
+  }
+
+  public void testMapWithIndex_closeIsPropagated_unsizedSource() {
+    testMapWithIndex_closeIsPropagated(
+        Stream.of((Object) null).flatMap(unused -> Stream.of(""a"", ""b"", ""c"")));
+  }
+
+  private void testMapWithIndex_closeIsPropagated(Stream<String> source) {
+    AtomicInteger stringsCloseCount = new AtomicInteger();
+    Stream<String> strings = source.onClose(stringsCloseCount::incrementAndGet);
+    Stream<String> withIndex = Streams.mapWithIndex(strings, (str, i) -> str + "":"" + i);
+
+    withIndex.close();
+
+    Truth.assertThat(stringsCloseCount.get()).isEqualTo(1);
+  }
+
   public void testMapWithIndex_intStream() {
     SpliteratorTester.of(
             () -> Streams.mapWithIndex(IntStream.of(0, 1, 2), (x, i) -> x + "":"" + i).spliterator())
         .expect(""0:0"", ""1:1"", ""2:2"");
   }
 
+  public void testMapWithIndex_intStream_closeIsPropagated_sized() {
+    testMapWithIndex_intStream_closeIsPropagated(IntStream.of(1, 2, 3));
+  }
+
+  public void testMapWithIndex_intStream_closeIsPropagated_unsized() {
+    testMapWithIndex_intStream_closeIsPropagated(
+        IntStream.of(0).flatMap(unused -> IntStream.of(1, 2, 3)));
+  }
+
+  private void testMapWithIndex_intStream_closeIsPropagated(IntStream source) {
+    AtomicInteger intStreamCloseCount = new AtomicInteger();
+    IntStream intStream = source.onClose(intStreamCloseCount::incrementAndGet);
+    Stream<String> withIndex = Streams.mapWithIndex(intStream, (str, i) -> str + "":"" + i);
+
+    withIndex.close();
+
+    Truth.assertThat(intStreamCloseCount.get()).isEqualTo(1);
+  }
+
   public void testMapWithIndex_longStream() {
     SpliteratorTester.of(
             () -> Streams.mapWithIndex(LongStream.of(0, 1, 2), (x, i) -> x + "":"" + i).spliterator())
         .expect(""0:0"", ""1:1"", ""2:2"");
   }
 
+  public void testMapWithIndex_longStream_closeIsPropagated_sized() {
+    testMapWithIndex_longStream_closeIsPropagated(LongStream.of(1, 2, 3));
+  }
+
+  public void testMapWithIndex_longStream_closeIsPropagated_unsized() {
+    testMapWithIndex_longStream_closeIsPropagated(
+        LongStream.of(0).flatMap(unused -> LongStream.of(1, 2, 3)));
+  }
+
+  private void testMapWithIndex_longStream_closeIsPropagated(LongStream source) {
+    AtomicInteger longStreamCloseCount = new AtomicInteger();
+    LongStream longStream = source.onClose(longStreamCloseCount::incrementAndGet);
+    Stream<String> withIndex = Streams.mapWithIndex(longStream, (str, i) -> str + "":"" + i);
+
+    withIndex.close();
+
+    Truth.assertThat(longStreamCloseCount.get()).isEqualTo(1);
+  }
+
   @GwtIncompatible // TODO(b/38490623): reenable after GWT double-to-string conversion is fixed
   public void testMapWithIndex_doubleStream() {
     SpliteratorTester.of(
@@ -221,12 +278,45 @@ public void testMapWithIndex_doubleStream() {
         .expect(""0.0:0"", ""1.0:1"", ""2.0:2"");
   }
 
+  public void testMapWithIndex_doubleStream_closeIsPropagated_sized() {
+    testMapWithIndex_doubleStream_closeIsPropagated(DoubleStream.of(1, 2, 3));
+  }
+
+  public void testMapWithIndex_doubleStream_closeIsPropagated_unsized() {
+    testMapWithIndex_doubleStream_closeIsPropagated(
+        DoubleStream.of(0).flatMap(unused -> DoubleStream.of(1, 2, 3)));
+  }
+
+  private void testMapWithIndex_doubleStream_closeIsPropagated(DoubleStream source) {
+    AtomicInteger doubleStreamCloseCount = new AtomicInteger();
+    DoubleStream doubleStream = source.onClose(doubleStreamCloseCount::incrementAndGet);
+    Stream<String> withIndex = Streams.mapWithIndex(doubleStream, (str, i) -> str + "":"" + i);
+
+    withIndex.close();
+
+    Truth.assertThat(doubleStreamCloseCount.get()).isEqualTo(1);
+  }
+
   public void testZip() {
     assertThat(Streams.zip(Stream.of(""a"", ""b"", ""c""), Stream.of(1, 2, 3), (a, b) -> a + "":"" + b))
         .containsExactly(""a:1"", ""b:2"", ""c:3"")
         .inOrder();
   }
 
+  public void testZip_closeIsPropagated() {
+    AtomicInteger lettersCloseCount = new AtomicInteger();
+    Stream<String> letters = Stream.of(""a"", ""b"", ""c"").onClose(lettersCloseCount::incrementAndGet);
+    AtomicInteger numbersCloseCount = new AtomicInteger();
+    Stream<Integer> numbers = Stream.of(1, 2, 3).onClose(numbersCloseCount::incrementAndGet);
+
+    Stream<String> zipped = Streams.zip(letters, numbers, (a, b) -> a + "":"" + b);
+
+    zipped.close();
+
+    Truth.assertThat(lettersCloseCount.get()).isEqualTo(1);
+    Truth.assertThat(numbersCloseCount.get()).isEqualTo(1);
+  }
+
   public void testZipFiniteWithInfinite() {
     assertThat(
             Streams.zip(, @@ -251,18 +251,20 @@ public static DoubleStream concat(DoubleStream... streams) {
     Iterator<A> itrA = Spliterators.iterator(splitrA);
     Iterator<B> itrB = Spliterators.iterator(splitrB);
     return StreamSupport.stream(
-        new AbstractSpliterator<R>(
-            Math.min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics) {
-          @Override
-          public boolean tryAdvance(Consumer<? super R> action) {
-            if (itrA.hasNext() && itrB.hasNext()) {
-              action.accept(function.apply(itrA.next(), itrB.next()));
-              return true;
-            }
-            return false;
-          }
-        },
-        isParallel);
+            new AbstractSpliterator<R>(
+                Math.min(splitrA.estimateSize(), splitrB.estimateSize()), characteristics) {
+              @Override
+              public boolean tryAdvance(Consumer<? super R> action) {
+                if (itrA.hasNext() && itrB.hasNext()) {
+                  action.accept(function.apply(itrA.next(), itrB.next()));
+                  return true;
+                }
+                return false;
+              }
+            },
+            isParallel)
+        .onClose(streamA::close)
+        .onClose(streamB::close);
   }
 
   /**
@@ -367,7 +369,7 @@ public boolean tryAdvance(Consumer<? super R> action) {
               return false;
             }
           },
-          isParallel);
+          isParallel).onClose(stream::close);
     }
     class Splitr extends MapWithIndexSpliterator<Spliterator<T>, R, Splitr> implements Consumer<T> {
       T holder;
@@ -399,7 +401,7 @@ Splitr createSplit(Spliterator<T> from, long i) {
         return new Splitr(from, i);
       }
     }
-    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);
+    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);
   }
 
   /**
@@ -484,21 +486,22 @@ public int characteristics() {
     if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
       PrimitiveIterator.OfInt fromIterator = Spliterators.iterator(fromSpliterator);
       return StreamSupport.stream(
-          new AbstractSpliterator<R>(
-              fromSpliterator.estimateSize(),
-              fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
-            long index = 0;
-
-            @Override
-            public boolean tryAdvance(Consumer<? super R> action) {
-              if (fromIterator.hasNext()) {
-                action.accept(function.apply(fromIterator.nextInt(), index++));
-                return true;
-              }
-              return false;
-            }
-          },
-          isParallel);
+              new AbstractSpliterator<R>(
+                  fromSpliterator.estimateSize(),
+                  fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
+                long index = 0;
+
+                @Override
+                public boolean tryAdvance(Consumer<? super R> action) {
+                  if (fromIterator.hasNext()) {
+                    action.accept(function.apply(fromIterator.nextInt(), index++));
+                    return true;
+                  }
+                  return false;
+                }
+              },
+              isParallel)
+          .onClose(stream::close);
     }
     class Splitr extends MapWithIndexSpliterator<Spliterator.OfInt, R, Splitr>
         implements IntConsumer, Spliterator<R> {
@@ -527,7 +530,7 @@ Splitr createSplit(Spliterator.OfInt from, long i) {
         return new Splitr(from, i);
       }
     }
-    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);
+    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);
   }
 
   /**
@@ -575,21 +578,22 @@ Splitr createSplit(Spliterator.OfInt from, long i) {
     if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
       PrimitiveIterator.OfLong fromIterator = Spliterators.iterator(fromSpliterator);
       return StreamSupport.stream(
-          new AbstractSpliterator<R>(
-              fromSpliterator.estimateSize(),
-              fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
-            long index = 0;
-
-            @Override
-            public boolean tryAdvance(Consumer<? super R> action) {
-              if (fromIterator.hasNext()) {
-                action.accept(function.apply(fromIterator.nextLong(), index++));
-                return true;
-              }
-              return false;
-            }
-          },
-          isParallel);
+              new AbstractSpliterator<R>(
+                  fromSpliterator.estimateSize(),
+                  fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
+                long index = 0;
+
+                @Override
+                public boolean tryAdvance(Consumer<? super R> action) {
+                  if (fromIterator.hasNext()) {
+                    action.accept(function.apply(fromIterator.nextLong(), index++));
+                    return true;
+                  }
+                  return false;
+                }
+              },
+              isParallel)
+          .onClose(stream::close);
     }
     class Splitr extends MapWithIndexSpliterator<Spliterator.OfLong, R, Splitr>
         implements LongConsumer, Spliterator<R> {
@@ -618,7 +622,7 @@ Splitr createSplit(Spliterator.OfLong from, long i) {
         return new Splitr(from, i);
       }
     }
-    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);
+    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);
   }
 
   /**
@@ -667,21 +671,22 @@ Splitr createSplit(Spliterator.OfLong from, long i) {
     if (!fromSpliterator.hasCharacteristics(Spliterator.SUBSIZED)) {
       PrimitiveIterator.OfDouble fromIterator = Spliterators.iterator(fromSpliterator);
       return StreamSupport.stream(
-          new AbstractSpliterator<R>(
-              fromSpliterator.estimateSize(),
-              fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
-            long index = 0;
-
-            @Override
-            public boolean tryAdvance(Consumer<? super R> action) {
-              if (fromIterator.hasNext()) {
-                action.accept(function.apply(fromIterator.nextDouble(), index++));
-                return true;
-              }
-              return false;
-            }
-          },
-          isParallel);
+              new AbstractSpliterator<R>(
+                  fromSpliterator.estimateSize(),
+                  fromSpliterator.characteristics() & (Spliterator.ORDERED | Spliterator.SIZED)) {
+                long index = 0;
+
+                @Override
+                public boolean tryAdvance(Consumer<? super R> action) {
+                  if (fromIterator.hasNext()) {
+                    action.accept(function.apply(fromIterator.nextDouble(), index++));
+                    return true;
+                  }
+                  return false;
+                }
+              },
+              isParallel)
+          .onClose(stream::close);
     }
     class Splitr extends MapWithIndexSpliterator<Spliterator.OfDouble, R, Splitr>
         implements DoubleConsumer, Spliterator<R> {
@@ -710,7 +715,7 @@ Splitr createSplit(Spliterator.OfDouble from, long i) {
         return new Splitr(from, i);
       }
     }
-    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel);
+    return StreamSupport.stream(new Splitr(fromSpliterator, 0), isParallel).onClose(stream::close);
   }
 
   /**, ",NaN,Moe sync
3050,Ron Shapiro,['guava-tests/test/com/google/common/collect/ImmutableBiMapTest.java'],"@@ -712,7 +712,7 @@ void zero() {
       ImmutableBiMap<?, ?> create(List<? extends Entry<?, ?>> entries, CallsCounter counter) {
         ImmutableBiMap.Builder<Object, Object> builder = ImmutableBiMap.builder();
         for (Entry<?, ?> entry : entries) {
-          builder.put(entry);
+          builder.put(entry.getKey(), entry.getValue());
         }
         return builder.build();
       }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct a typo in ImmutableBiMapTest.

2c5dd53d4a4830bf6cb3a50f26d3d73429932833",Moe Sync
3056,Ron Shapiro,"['android/guava-tests/test/com/google/common/reflect/TypeTokenSubtypeTest.java', 'android/guava/src/com/google/common/reflect/TypeToken.java', 'guava-tests/test/com/google/common/reflect/TypeTokenSubtypeTest.java', 'guava/src/com/google/common/reflect/TypeToken.java']","@@ -87,6 +87,15 @@ public void testSubtypeOfNonStaticAnonymousClass() {
             .isSubtypeOf(superclass));
   }
 
+  public void testGetSubtypeOf_impossibleWildcard() {
+    TypeToken<List<? extends Number>> numberList = new TypeToken<List<? extends Number>>() {};
+    abstract class StringList implements List<String> {}
+    try {
+      numberList.getSubtype(StringList.class);
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+
   private static class OwnerTypeSubtypingTests extends SubtypeTester {
     @TestSubtype
     public Mall<Outdoor>.Shop<Electronics> innerTypeIsSubtype(, @@ -422,6 +422,8 @@ public final TypeSet getTypes() {
     Type resolvedTypeArgs = resolveTypeArgsForSubclass(subclass);
     @SuppressWarnings(""unchecked"") // guarded by the isAssignableFrom() statement above
     TypeToken<? extends T> subtype = (TypeToken<? extends T>) of(resolvedTypeArgs);
+    checkArgument(
+        subtype.isSubtypeOf(this), ""%s does not appear to be a subtype of %s"", subtype, this);
     return subtype;
   }
 , @@ -87,6 +87,15 @@ public void testSubtypeOfNonStaticAnonymousClass() {
             .isSubtypeOf(superclass));
   }
 
+  public void testGetSubtypeOf_impossibleWildcard() {
+    TypeToken<List<? extends Number>> numberList = new TypeToken<List<? extends Number>>() {};
+    abstract class StringList implements List<String> {}
+    try {
+      numberList.getSubtype(StringList.class);
+      fail();
+    } catch (IllegalArgumentException expected) {}
+  }
+
   private static class OwnerTypeSubtypingTests extends SubtypeTester {
     @TestSubtype
     public Mall<Outdoor>.Shop<Electronics> innerTypeIsSubtype(, @@ -422,6 +422,8 @@ public final TypeSet getTypes() {
     Type resolvedTypeArgs = resolveTypeArgsForSubclass(subclass);
     @SuppressWarnings(""unchecked"") // guarded by the isAssignableFrom() statement above
     TypeToken<? extends T> subtype = (TypeToken<? extends T>) of(resolvedTypeArgs);
+    checkArgument(
+        subtype.isSubtypeOf(this), ""%s does not appear to be a subtype of %s"", subtype, this);
     return subtype;
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Traverser.java: add support for multiple start nodes.

Update documentation (in this file and in graphs_explained.md) relating to behavior and definitions of equals() and hashCode().

RELNOTES=`common.graph.Traverser`: add support for traversing from multiple start nodes.

9dce1c3302ec118f73921c9319e7822114325a2d

-------

<p> Fix List<Foo<?>>.isSubtypeOf(List<Foo<?>>).

This used to return false because isSubtypeOf() does a wildcard capture of the Foo<?> type parameter, turning it into Foo<C>, and then List<Foo<C>> isn't a subtype of List<Foo<?>>.

Wildcard capture is needed for resolving types at invariant or contravariant elements (fields and parameters). But for resolving in covariant context, wildcard should remain as is.

I found this when trying to add isSubtypeOf() precondition check in getSubtype(), in response to https://github.com/google/guava/issues/3048.

RELNOTES=TypeToken.isSubtypeOf() bug fix.

9918890013cd07ff00074a28afefd3af2c00c515

-------

<p> Add isSubtypeOf() ""pre""-condition check before getSubtype() returns.

We have to call it before return because before type variable substitution, isSubtypeOf() can't apply.

See https://github.com/google/guava/issues/3048

RELNOTES=Validate `TypeToken.getSubtype()`.

f6d1461e2579f05f1106892c817681a61fc401ae",Moe Sync
3057,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/TrieParser.java', 'guava/src/com/google/thirdparty/publicsuffix/TrieParser.java']","@@ -23,7 +23,6 @@
 /** Parser for a map of reversed domain names stored as a serialized radix tree. */
 @GwtCompatible
 final class TrieParser {
-
   private static final Joiner PREFIX_JOINER = Joiner.on("""");
 
   /**
@@ -35,9 +34,7 @@
     int encodedLen = encoded.length();
     int idx = 0;
     while (idx < encodedLen) {
-      idx +=
-          doParseTrieToBuilder(
-              Lists.<CharSequence>newLinkedList(), encoded.subSequence(idx, encodedLen), builder);
+      idx += doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(), encoded, idx, builder);
     }
     return builder.build();
   }
@@ -48,16 +45,18 @@
    * @param stack The prefixes that precede the characters represented by this node. Each entry of
    *     the stack is in reverse order.
    * @param encoded The serialized trie.
+   * @param start An index in the encoded serialized trie to begin reading characters from.
    * @param builder A map builder to which all entries will be added.
    * @return The number of characters consumed from {@code encoded}.
    */
   private static int doParseTrieToBuilder(
       List<CharSequence> stack,
       CharSequence encoded,
+      int start,
       ImmutableMap.Builder<String, PublicSuffixType> builder) {
 
     int encodedLen = encoded.length();
-    int idx = 0;
+    int idx = start;
     char c = '\0';
 
     // Read all of the characters for this node.
@@ -68,7 +67,7 @@ private static int doParseTrieToBuilder(
       }
     }
 
-    stack.add(0, reverse(encoded.subSequence(0, idx)));
+    stack.add(0, reverse(encoded.subSequence(start, idx)));
 
     if (c == '!' || c == '?' || c == ':' || c == ',') {
       // '!' represents an interior node that represents a REGISTRY entry in the map.
@@ -85,7 +84,7 @@ private static int doParseTrieToBuilder(
     if (c != '?' && c != ',') {
       while (idx < encodedLen) {
         // Read all the children
-        idx += doParseTrieToBuilder(stack, encoded.subSequence(idx, encodedLen), builder);
+        idx += doParseTrieToBuilder(stack, encoded, idx, builder);
         if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {
           // An extra '?' or ',' after a child node indicates the end of all children of this node.
           idx++;
@@ -94,7 +93,7 @@ private static int doParseTrieToBuilder(
       }
     }
     stack.remove(0);
-    return idx;
+    return idx - start;
   }
 
   private static CharSequence reverse(CharSequence s) {, @@ -23,7 +23,6 @@
 /** Parser for a map of reversed domain names stored as a serialized radix tree. */
 @GwtCompatible
 final class TrieParser {
-
   private static final Joiner PREFIX_JOINER = Joiner.on("""");
 
   /**
@@ -35,9 +34,7 @@
     int encodedLen = encoded.length();
     int idx = 0;
     while (idx < encodedLen) {
-      idx +=
-          doParseTrieToBuilder(
-              Lists.<CharSequence>newLinkedList(), encoded.subSequence(idx, encodedLen), builder);
+      idx += doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(), encoded, idx, builder);
     }
     return builder.build();
   }
@@ -48,16 +45,18 @@
    * @param stack The prefixes that precede the characters represented by this node. Each entry of
    *     the stack is in reverse order.
    * @param encoded The serialized trie.
+   * @param start An index in the encoded serialized trie to begin reading characters from.
    * @param builder A map builder to which all entries will be added.
    * @return The number of characters consumed from {@code encoded}.
    */
   private static int doParseTrieToBuilder(
       List<CharSequence> stack,
       CharSequence encoded,
+      int start,
       ImmutableMap.Builder<String, PublicSuffixType> builder) {
 
     int encodedLen = encoded.length();
-    int idx = 0;
+    int idx = start;
     char c = '\0';
 
     // Read all of the characters for this node.
@@ -68,7 +67,7 @@ private static int doParseTrieToBuilder(
       }
     }
 
-    stack.add(0, reverse(encoded.subSequence(0, idx)));
+    stack.add(0, reverse(encoded.subSequence(start, idx)));
 
     if (c == '!' || c == '?' || c == ':' || c == ',') {
       // '!' represents an interior node that represents a REGISTRY entry in the map.
@@ -85,7 +84,7 @@ private static int doParseTrieToBuilder(
     if (c != '?' && c != ',') {
       while (idx < encodedLen) {
         // Read all the children
-        idx += doParseTrieToBuilder(stack, encoded.subSequence(idx, encodedLen), builder);
+        idx += doParseTrieToBuilder(stack, encoded, idx, builder);
         if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {
           // An extra '?' or ',' after a child node indicates the end of all children of this node.
           idx++;
@@ -94,7 +93,7 @@ private static int doParseTrieToBuilder(
       }
     }
     stack.remove(0);
-    return idx;
+    return idx - start;
   }
 
   private static CharSequence reverse(CharSequence s) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Change all instances of encoded.subSequence() to use a simple start index offset, which reduces the Java memory footprint for TrieParser by at at least 130 MBs. This is because the original call to subSequence() would generate a new String on the heap for each call, where as just using an offset avoids the need to generate a new String all together.

This memory enhancement was found while investigating flakiness issues for some tests which had the same root cause of: java.lang.OutOfMemoryError: GC overhead limit exceeded, mostly in the TrieParser class.

100-test runs at original code:
Memory usage
- maximum: 503MiB (527,769,600 bytes)
- average: 388MiB (407,225,077 bytes)

100-test runs with my changes:
Memory usage
- maximum: 316MiB (325,271,552 bytes)
- average: 221MiB (239,355,320 bytes)

At maximum: 187 MB saved
At average: 167 MB saved

RELNOTES=Reduced heap memory usage when parsing domain names

521c77000b665d5077524842cc0902583015043f",Moe Sync
3070,Ron Shapiro,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -349,6 +349,17 @@ private ReferrerPolicyValues() {}
   public static final String X_REQUESTED_WITH = ""X-Requested-With"";
   /** The HTTP {@code X-User-IP} header field name. */
   public static final String X_USER_IP = ""X-User-IP"";
+  /**
+   * The HTTP <a href=""https://goo.gl/VKpXxa"">{@code X-Download-Options}</a> header field name.
+   *
+   * <p>When the new X-Download-Options header is present with the value {@code noopen}, the user is
+   * prevented from opening a file download directly; instead, they must first save the file
+   * locally.
+   *
+   * @since NEXT
+   */
+  @Beta
+  public static final String X_DOWNLOAD_OPTIONS = ""X-Download-Options"";
   /** The HTTP {@code X-XSS-Protection} header field name. */
   public static final String X_XSS_PROTECTION = ""X-XSS-Protection"";
   /**, @@ -349,6 +349,17 @@ private ReferrerPolicyValues() {}
   public static final String X_REQUESTED_WITH = ""X-Requested-With"";
   /** The HTTP {@code X-User-IP} header field name. */
   public static final String X_USER_IP = ""X-User-IP"";
+  /**
+   * The HTTP <a href=""https://goo.gl/VKpXxa"">{@code X-Download-Options}</a> header field name.
+   *
+   * <p>When the new X-Download-Options header is present with the value {@code noopen}, the user is
+   * prevented from opening a file download directly; instead, they must first save the file
+   * locally.
+   *
+   * @since NEXT
+   */
+  @Beta
+  public static final String X_DOWNLOAD_OPTIONS = ""X-Download-Options"";
   /** The HTTP {@code X-XSS-Protection} header field name. */
   public static final String X_XSS_PROTECTION = ""X-XSS-Protection"";
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add X-Download-Options header (IE8 header to control the ""Open"" button on the download dialog).

RELNOTES=Defined an [X-Download-Options](https://blogs.msdn.microsoft.com/ieinternals/2009/06/30/internet-explorer-and-custom-http-headers) header

b3acfc69329e40befab52f50a5ee66e37ad9f602",Moe Sync
3074,Ron Shapiro,"['android/guava/src/com/google/common/base/Ascii.java', 'guava/src/com/google/common/base/Ascii.java']","@@ -32,7 +32,7 @@
  *       which operate only on the ASCII characters of a string.
  * </ul>
  *
- * @author Craig Berry
+ * @author Catherine Berry
  * @author Gregory Kick
  * @since 7.0
  */
@@ -395,6 +395,9 @@ private Ascii() {}
    */
   public static final char MAX = 127;
 
+  /** A bit mask which selects the bit encoding ASCII character case. */
+  private static final char CASE_MASK = 0x20;
+
   /**
    * Returns a copy of the input string in which all {@linkplain #isUpperCase(char) uppercase ASCII
    * characters} have been converted to lowercase. All other characters are copied without
@@ -408,7 +411,7 @@ public static String toLowerCase(String string) {
         for (; i < length; i++) {
           char c = chars[i];
           if (isUpperCase(c)) {
-            chars[i] = (char) (c ^ 0x20);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
@@ -440,7 +443,7 @@ public static String toLowerCase(CharSequence chars) {
    * lowercase equivalent. Otherwise returns the argument.
    */
   public static char toLowerCase(char c) {
-    return isUpperCase(c) ? (char) (c ^ 0x20) : c;
+    return isUpperCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
@@ -456,7 +459,7 @@ public static String toUpperCase(String string) {
         for (; i < length; i++) {
           char c = chars[i];
           if (isLowerCase(c)) {
-            chars[i] = (char) (c & 0x5f);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
@@ -488,7 +491,7 @@ public static String toUpperCase(CharSequence chars) {
    * uppercase equivalent. Otherwise returns the argument.
    */
   public static char toUpperCase(char c) {
-    return isLowerCase(c) ? (char) (c & 0x5f) : c;
+    return isLowerCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
@@ -627,6 +630,6 @@ public static boolean equalsIgnoreCase(CharSequence s1, CharSequence s2) {
    */
   private static int getAlphaIndex(char c) {
     // Fold upper-case ASCII to lower-case and make zero-indexed and unsigned (by casting to char).
-    return (char) ((c | 0x20) - 'a');
+    return (char) ((c | CASE_MASK) - 'a');
   }
 }, @@ -32,7 +32,7 @@
  *       which operate only on the ASCII characters of a string.
  * </ul>
  *
- * @author Craig Berry
+ * @author Catherine Berry
  * @author Gregory Kick
  * @since 7.0
  */
@@ -395,6 +395,9 @@ private Ascii() {}
    */
   public static final char MAX = 127;
 
+  /** A bit mask which selects the bit encoding ASCII character case. */
+  private static final char CASE_MASK = 0x20;
+
   /**
    * Returns a copy of the input string in which all {@linkplain #isUpperCase(char) uppercase ASCII
    * characters} have been converted to lowercase. All other characters are copied without
@@ -408,7 +411,7 @@ public static String toLowerCase(String string) {
         for (; i < length; i++) {
           char c = chars[i];
           if (isUpperCase(c)) {
-            chars[i] = (char) (c ^ 0x20);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
@@ -440,7 +443,7 @@ public static String toLowerCase(CharSequence chars) {
    * lowercase equivalent. Otherwise returns the argument.
    */
   public static char toLowerCase(char c) {
-    return isUpperCase(c) ? (char) (c ^ 0x20) : c;
+    return isUpperCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
@@ -456,7 +459,7 @@ public static String toUpperCase(String string) {
         for (; i < length; i++) {
           char c = chars[i];
           if (isLowerCase(c)) {
-            chars[i] = (char) (c & 0x5f);
+            chars[i] = (char) (c ^ CASE_MASK);
           }
         }
         return String.valueOf(chars);
@@ -488,7 +491,7 @@ public static String toUpperCase(CharSequence chars) {
    * uppercase equivalent. Otherwise returns the argument.
    */
   public static char toUpperCase(char c) {
-    return isLowerCase(c) ? (char) (c & 0x5f) : c;
+    return isLowerCase(c) ? (char) (c ^ CASE_MASK) : c;
   }
 
   /**
@@ -627,6 +630,6 @@ public static boolean equalsIgnoreCase(CharSequence s1, CharSequence s2) {
    */
   private static int getAlphaIndex(char c) {
     // Fold upper-case ASCII to lower-case and make zero-indexed and unsigned (by casting to char).
-    return (char) ((c | 0x20) - 'a');
+    return (char) ((c | CASE_MASK) - 'a');
   }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> In Ascii, define a constant for the character case bitmask, and use it in place of 0x20 and 0x5f throughout the class.

c58f51bd68f89cd6119131a256e9de9d0f02b45f",Moe Sync
3077,Ron Shapiro,"['android/guava/src/com/google/common/reflect/TypeToken.java', 'guava/src/com/google/common/reflect/TypeToken.java']","@@ -1439,4 +1439,8 @@ K getSuperclass(K type) {
       }
     }
   }
+
+  // This happens to be the hash of the class as of now. So setting it makes a backward compatible
+  // change. Going forward, if any incompatible change is added, we can change the UID back to 1.
+  private static final long serialVersionUID = 3637540370352322684L;
 }, @@ -1439,4 +1439,8 @@ K getSuperclass(K type) {
       }
     }
   }
+
+  // This happens to be the hash of the class as of now. So setting it makes a backward compatible
+  // change. Going forward, if any incompatible change is added, we can change the UID back to 1.
+  private static final long serialVersionUID = 3637540370352322684L;
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make ByteSource.read() use sizeIfKnown(), if available, to help avoid extra byte array allocations/copies.

Also don't use 32 as the initial ByteArrayOutputStream size in either version of ByteStreams.toByteArray(); just seems way too small. Use the default size for buffers instead, at a minimum.

Also change ConcatenatedByteSource.sizeIfKnown() to return absent if its Iterable of sources is not a Collection; this is to prevent sizeIfKnown() trying to loop over an infinite Iterable, which previous caused an infinite loop. That is also fixed in this CL; ConcatenatedByteSource.size() and sizeIfKnown() now stop and return Long.MAX_VALUE if the result would exceed that rather than going negative and continuing. But looping over an infinite Iterable in sizeIfKnown() seems potentially slow even if it will eventually stop, and as such against the spirit of sizeIfKnown(), which should be fast.

27d33d4fd1bbbf6f5aacd8835633943da33300a3

-------

<p> Stop using ByteArrayOutputStream in ByteStreams.toByteArray methods.

They were using ByteStreams.copy to copy the source to the BAOS. This meant reading from the source into a buffer, then copying from that buffer to a different buffer in the BAOS. Additionally, the way BAOS operates is not great: whenever it needs more space, it creates a new array twice as large as the previous, copies all bytes from the previous array to the new one, and discards the previous array.

Instead, read directly from the source into a sequence of buffers. When a buffer fills up, don't discard it, but instead create a new, twice as large, buffer and start reading into it.

47530cebb974612862c1e0f12e304ae1773ca9ce

-------

<p> Set serialVersionUID in TypeToken.java

RELNOTES=Add a `serialVersionUID` to `TypeToken`

dc8ef1a7ac05b17d3be6e2918809ada5e68b31bc",Moe Sync
3079,Ron Shapiro,"['android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -430,55 +430,28 @@ public void testNewDataOutput_BAOS() {
     assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
   }
 
-  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
-
-  public void testToByteArray() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_emptyStream() throws IOException {
-    InputStream in = newTestStream(0);
-    byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(b, new byte[0]);
-  }
-
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    // this results in toByteArrayInternal being called when the stream is actually exhausted
-    byte[] b = ByteStreams.toByteArray(in, 99);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    byte[] b = ByteStreams.toByteArray(in, 98);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testExhaust() throws IOException {, @@ -20,7 +20,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.math.IntMath;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -37,10 +36,7 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
-import java.util.ArrayDeque;
 import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -155,79 +151,6 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
-  /** Max array length on JVM */
-  private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
-
-  /**
-   * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have
-   * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
-   * input stream.
-   */
-  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
-      throws IOException {
-    // ByteArrayOutputStream uses a single byte array as a buffer and copies it to a new, larger
-    // buffer each time it needs more space. By contrast, this method just allocates a new buffer
-    // each time it needs more space and then copies all the buffers to a single array at the end.
-    // Like ByteArrayOutputStream, the size of each successive buffer is larger than the previous
-    // one (doubling each time, in this case), to reduce the number of allocations and potentially
-    // the number of calls to read() needed.
-    if (totalLen == MAX_ARRAY_LEN) {
-      // true iff called from toByteArray(in, MAX_ARRAY_LEN - 1)
-      return toByteArrayAtMaxLength(in, bufs);
-    }
-    byte[] buf = new byte[Math.min(BUFFER_SIZE, MAX_ARRAY_LEN - totalLen)];
-    bufs.add(buf);
-    int off = 0;
-    int r;
-    // always OK to completely fill buf; its size plus the rest of bufs is never more than
-    // MAX_ARRAY_LEN
-    while ((r = in.read(buf, off, buf.length - off)) != -1) {
-      if ((totalLen += r) == MAX_ARRAY_LEN) {
-        return toByteArrayAtMaxLength(in, bufs);
-      }
-      if ((off += r) == buf.length) {
-        // need a new buffer if we're going to read any more
-        int nextBufLen = IntMath.saturatedMultiply(buf.length, 2);
-        buf = new byte[Math.min(nextBufLen, MAX_ARRAY_LEN - totalLen)];
-        bufs.add(buf);
-        off = 0;
-      }
-    }
-
-    return combineBuffers(bufs, totalLen);
-  }
-
-  private static byte[] combineBuffers(Iterable<byte[]> bufs, int totalLen) {
-    byte[] result = new byte[totalLen];
-    Iterator<byte[]> iter = bufs.iterator();
-    int remaining = totalLen;
-    while (remaining > 0) {
-      byte[] buf = iter.next(); // since uncopied bytes remain, it's guaranteed there is a next
-      int bytesToCopy = Math.min(remaining, buf.length);
-      int resultOffset = totalLen - remaining;
-      System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
-      remaining -= bytesToCopy;
-    }
-    return result;
-  }
-
-  /**
-   * Called when toByteArray has not finished reading and cannot read anymore bytes into a single
-   * array. Typically throws OOME but may, if the stream was somehow exactly the right length,
-   * return an array of max length.
-   */
-  private static byte[] toByteArrayAtMaxLength(InputStream in, Iterable<byte[]> bufs)
-      throws IOException {
-    if (in.read() == -1) {
-      return combineBuffers(bufs, MAX_ARRAY_LEN);
-    } else {
-      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
-    }
-  }
-
-  /** Large enough to never need to expand, given the geometric progression of buffer sizes. */
-  private static final int TO_BYTE_ARRAY_DEQUE_SIZE = 22;
-
   /**
    * Reads all bytes from an input stream into a byte array. Does not close the stream.
    *
@@ -236,8 +159,9 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * @throws IOException if an I/O error occurs
    */
   public static byte[] toByteArray(InputStream in) throws IOException {
-    checkNotNull(in);
-    return toByteArrayInternal(in, new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
+    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(BUFFER_SIZE, in.available()));
+    copy(in, out);
+    return out.toByteArray();
   }
 
   /**
@@ -247,7 +171,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    */
   static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {
     checkArgument(expectedSize >= 0, ""expectedSize (%s) must be non-negative"", expectedSize);
-    if (expectedSize > MAX_ARRAY_LEN) {
+    if (expectedSize > Integer.MAX_VALUE) {
       throw new OutOfMemoryError(expectedSize + "" bytes is too large to fit in a byte array"");
     }
 
@@ -272,10 +196,28 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE);
-    bufs.add(bytes);
-    bufs.add(new byte[] { (byte) b });
-    return toByteArrayInternal(in, bufs, bytes.length + 1);
+    FastByteArrayOutputStream out = new FastByteArrayOutputStream(BUFFER_SIZE);
+    copy(in, out);
+
+    byte[] result = Arrays.copyOf(bytes, bytes.length + 1 + out.size());
+    result[bytes.length] = (byte) b;
+    out.writeTo(result, bytes.length + 1);
+    return result;
+  }
+
+  /** BAOS that provides limited access to its internal byte array. */
+  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {
+    FastByteArrayOutputStream(int initialSize) {
+      super(initialSize);
+    }
+
+    /**
+     * Writes the contents of the internal buffer to the given array starting at the given offset.
+     * Assumes the array has space to hold count bytes.
+     */
+    void writeTo(byte[] b, int off) {
+      System.arraycopy(buf, 0, b, off, count);
+    }
   }
 
   /**, @@ -430,55 +430,28 @@ public void testNewDataOutput_BAOS() {
     assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
   }
 
-  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
-
-  public void testToByteArray() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_emptyStream() throws IOException {
-    InputStream in = newTestStream(0);
-    byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(b, new byte[0]);
-  }
-
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    InputStream in = newTestStream(100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    // this results in toByteArrayInternal being called when the stream is actually exhausted
-    byte[] b = ByteStreams.toByteArray(in, 99);
-    assertEquals(b, PRE_FILLED_100);
-  }
-
-  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
-    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
-    byte[] b = ByteStreams.toByteArray(in, 98);
-    assertEquals(b, PRE_FILLED_100);
+    assertEquals(100, b.length);
   }
 
   public void testExhaust() throws IOException {, @@ -20,7 +20,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.math.IntMath;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -37,10 +36,7 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
-import java.util.ArrayDeque;
 import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -155,79 +151,6 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
-  /** Max array length on JVM */
-  private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
-
-  /**
-   * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have
-   * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
-   * input stream.
-   */
-  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
-      throws IOException {
-    // ByteArrayOutputStream uses a single byte array as a buffer and copies it to a new, larger
-    // buffer each time it needs more space. By contrast, this method just allocates a new buffer
-    // each time it needs more space and then copies all the buffers to a single array at the end.
-    // Like ByteArrayOutputStream, the size of each successive buffer is larger than the previous
-    // one (doubling each time, in this case), to reduce the number of allocations and potentially
-    // the number of calls to read() needed.
-    if (totalLen == MAX_ARRAY_LEN) {
-      // true iff called from toByteArray(in, MAX_ARRAY_LEN - 1)
-      return toByteArrayAtMaxLength(in, bufs);
-    }
-    byte[] buf = new byte[Math.min(BUFFER_SIZE, MAX_ARRAY_LEN - totalLen)];
-    bufs.add(buf);
-    int off = 0;
-    int r;
-    // always OK to completely fill buf; its size plus the rest of bufs is never more than
-    // MAX_ARRAY_LEN
-    while ((r = in.read(buf, off, buf.length - off)) != -1) {
-      if ((totalLen += r) == MAX_ARRAY_LEN) {
-        return toByteArrayAtMaxLength(in, bufs);
-      }
-      if ((off += r) == buf.length) {
-        // need a new buffer if we're going to read any more
-        int nextBufLen = IntMath.saturatedMultiply(buf.length, 2);
-        buf = new byte[Math.min(nextBufLen, MAX_ARRAY_LEN - totalLen)];
-        bufs.add(buf);
-        off = 0;
-      }
-    }
-
-    return combineBuffers(bufs, totalLen);
-  }
-
-  private static byte[] combineBuffers(Iterable<byte[]> bufs, int totalLen) {
-    byte[] result = new byte[totalLen];
-    Iterator<byte[]> iter = bufs.iterator();
-    int remaining = totalLen;
-    while (remaining > 0) {
-      byte[] buf = iter.next(); // since uncopied bytes remain, it's guaranteed there is a next
-      int bytesToCopy = Math.min(remaining, buf.length);
-      int resultOffset = totalLen - remaining;
-      System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
-      remaining -= bytesToCopy;
-    }
-    return result;
-  }
-
-  /**
-   * Called when toByteArray has not finished reading and cannot read anymore bytes into a single
-   * array. Typically throws OOME but may, if the stream was somehow exactly the right length,
-   * return an array of max length.
-   */
-  private static byte[] toByteArrayAtMaxLength(InputStream in, Iterable<byte[]> bufs)
-      throws IOException {
-    if (in.read() == -1) {
-      return combineBuffers(bufs, MAX_ARRAY_LEN);
-    } else {
-      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
-    }
-  }
-
-  /** Large enough to never need to expand, given the geometric progression of buffer sizes. */
-  private static final int TO_BYTE_ARRAY_DEQUE_SIZE = 22;
-
   /**
    * Reads all bytes from an input stream into a byte array. Does not close the stream.
    *
@@ -236,8 +159,9 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * @throws IOException if an I/O error occurs
    */
   public static byte[] toByteArray(InputStream in) throws IOException {
-    checkNotNull(in);
-    return toByteArrayInternal(in, new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
+    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(BUFFER_SIZE, in.available()));
+    copy(in, out);
+    return out.toByteArray();
   }
 
   /**
@@ -247,7 +171,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    */
   static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {
     checkArgument(expectedSize >= 0, ""expectedSize (%s) must be non-negative"", expectedSize);
-    if (expectedSize > MAX_ARRAY_LEN) {
+    if (expectedSize > Integer.MAX_VALUE) {
       throw new OutOfMemoryError(expectedSize + "" bytes is too large to fit in a byte array"");
     }
 
@@ -272,10 +196,28 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE);
-    bufs.add(bytes);
-    bufs.add(new byte[] { (byte) b });
-    return toByteArrayInternal(in, bufs, bytes.length + 1);
+    FastByteArrayOutputStream out = new FastByteArrayOutputStream(BUFFER_SIZE);
+    copy(in, out);
+
+    byte[] result = Arrays.copyOf(bytes, bytes.length + 1 + out.size());
+    result[bytes.length] = (byte) b;
+    out.writeTo(result, bytes.length + 1);
+    return result;
+  }
+
+  /** BAOS that provides limited access to its internal byte array. */
+  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {
+    FastByteArrayOutputStream(int initialSize) {
+      super(initialSize);
+    }
+
+    /**
+     * Writes the contents of the internal buffer to the given array starting at the given offset.
+     * Assumes the array has space to hold count bytes.
+     */
+    void writeTo(byte[] b, int off) {
+      System.arraycopy(buf, 0, b, off, count);
+    }
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Automated rollback of e50ce7e7ed79fbce1901081838c8e0f9269d4128

*** Reason for rollback ***

Causing OutOfMemoryError in some tests.

*** Original change description ***

Stop using ByteArrayOutputStream in ByteStreams.toByteArray methods.

They were using ByteStreams.copy to copy the source to the BAOS. This meant reading from the source into a buffer, then copying from that buffer to a different buffer in the BAOS. Additionally, the way BAOS operates is not great: whenever it needs more space, it creates a new array twice as large as the previous, copies all bytes from the previous array to the new one, and discards the previous array.

Instead, read directly from the source into a sequence of buffers. When a buffer fills up, don't discard it, but instead create a new, twice as large, buffer and start reading into it.

***

8e341060fcef24921ecc5a079c256b184ca164f2",Moe Sync
3080,Ron Shapiro,"['android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -430,28 +430,63 @@ public void testNewDataOutput_BAOS() {
     assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
   }
 
+  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
+
+  public void testToByteArray() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_emptyStream() throws IOException {
+    InputStream in = newTestStream(0);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(new byte[0], b);
+  }
+
+  public void testToByteArray_largeStream() throws IOException {
+    // well, large enough to require multiple buffers
+    byte[] expected = newPreFilledByteArray(10000000);
+    InputStream in = new ByteArrayInputStream(expected);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(expected, b);
+  }
+
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    // this results in toByteArrayInternal being called when the stream is actually exhausted
+    byte[] b = ByteStreams.toByteArray(in, 99);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    byte[] b = ByteStreams.toByteArray(in, 98);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testExhaust() throws IOException {, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.math.IntMath;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -36,7 +37,9 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
+import java.util.ArrayDeque;
 import java.util.Arrays;
+import java.util.Deque;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -151,6 +154,61 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
+  /** Max array length on JVM. */
+  private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
+
+  /** Large enough to never need to expand, given the geometric progression of buffer sizes. */
+  private static final int TO_BYTE_ARRAY_DEQUE_SIZE = 20;
+
+  /**
+   * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have
+   * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
+   * input stream.
+   */
+  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
+      throws IOException {
+    // Starting with an 8k buffer, double the size of each sucessive buffer. Buffers are retained
+    // in a deque so that there's no copying between buffers while reading and so all of the bytes
+    // in each new allocated buffer are available for reading from the stream.
+    for (int bufSize = BUFFER_SIZE;
+         totalLen < MAX_ARRAY_LEN;
+         bufSize = IntMath.saturatedMultiply(bufSize, 2)) {
+      byte[] buf = new byte[Math.min(bufSize, MAX_ARRAY_LEN - totalLen)];
+      bufs.add(buf);
+      int off = 0;
+      while (off < buf.length) {
+        // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN
+        int r = in.read(buf, off, buf.length - off);
+        if (r == -1) {
+          return combineBuffers(bufs, totalLen);
+        }
+        off += r;
+        totalLen += r;
+      }
+    }
+
+    // read MAX_ARRAY_LEN bytes without seeing end of stream
+    if (in.read() == -1) {
+      // oh, there's the end of the stream
+      return combineBuffers(bufs, MAX_ARRAY_LEN);
+    } else {
+      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
+    }
+  }
+
+  private static byte[] combineBuffers(Deque<byte[]> bufs, int totalLen) {
+    byte[] result = new byte[totalLen];
+    int remaining = totalLen;
+    while (remaining > 0) {
+      byte[] buf = bufs.removeFirst();
+      int bytesToCopy = Math.min(remaining, buf.length);
+      int resultOffset = totalLen - remaining;
+      System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
+      remaining -= bytesToCopy;
+    }
+    return result;
+  }
+
   /**
    * Reads all bytes from an input stream into a byte array. Does not close the stream.
    *
@@ -159,9 +217,8 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * @throws IOException if an I/O error occurs
    */
   public static byte[] toByteArray(InputStream in) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(BUFFER_SIZE, in.available()));
-    copy(in, out);
-    return out.toByteArray();
+    checkNotNull(in);
+    return toByteArrayInternal(in, new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
   }
 
   /**
@@ -171,7 +228,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    */
   static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {
     checkArgument(expectedSize >= 0, ""expectedSize (%s) must be non-negative"", expectedSize);
-    if (expectedSize > Integer.MAX_VALUE) {
+    if (expectedSize > MAX_ARRAY_LEN) {
       throw new OutOfMemoryError(expectedSize + "" bytes is too large to fit in a byte array"");
     }
 
@@ -196,28 +253,10 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    FastByteArrayOutputStream out = new FastByteArrayOutputStream(BUFFER_SIZE);
-    copy(in, out);
-
-    byte[] result = Arrays.copyOf(bytes, bytes.length + 1 + out.size());
-    result[bytes.length] = (byte) b;
-    out.writeTo(result, bytes.length + 1);
-    return result;
-  }
-
-  /** BAOS that provides limited access to its internal byte array. */
-  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {
-    FastByteArrayOutputStream(int initialSize) {
-      super(initialSize);
-    }
-
-    /**
-     * Writes the contents of the internal buffer to the given array starting at the given offset.
-     * Assumes the array has space to hold count bytes.
-     */
-    void writeTo(byte[] b, int off) {
-      System.arraycopy(buf, 0, b, off, count);
-    }
+    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
+    bufs.add(bytes);
+    bufs.add(new byte[] { (byte) b });
+    return toByteArrayInternal(in, bufs, bytes.length + 1);
   }
 
   /**, @@ -430,28 +430,63 @@ public void testNewDataOutput_BAOS() {
     assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
   }
 
+  private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
+
+  public void testToByteArray() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_emptyStream() throws IOException {
+    InputStream in = newTestStream(0);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(new byte[0], b);
+  }
+
+  public void testToByteArray_largeStream() throws IOException {
+    // well, large enough to require multiple buffers
+    byte[] expected = newPreFilledByteArray(10000000);
+    InputStream in = new ByteArrayInputStream(expected);
+    byte[] b = ByteStreams.toByteArray(in);
+    assertEquals(expected, b);
+  }
+
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
-    InputStream in = newTestStream(100);
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(100, b.length);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    // this results in toByteArrayInternal being called when the stream is actually exhausted
+    byte[] b = ByteStreams.toByteArray(in, 99);
+    assertEquals(PRE_FILLED_100, b);
+  }
+
+  public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
+    InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
+    byte[] b = ByteStreams.toByteArray(in, 98);
+    assertEquals(PRE_FILLED_100, b);
   }
 
   public void testExhaust() throws IOException {, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.math.IntMath;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
@@ -36,7 +37,9 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
+import java.util.ArrayDeque;
 import java.util.Arrays;
+import java.util.Deque;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -151,6 +154,61 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
+  /** Max array length on JVM. */
+  private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
+
+  /** Large enough to never need to expand, given the geometric progression of buffer sizes. */
+  private static final int TO_BYTE_ARRAY_DEQUE_SIZE = 20;
+
+  /**
+   * Returns a byte array containing the bytes from the buffers already in {@code bufs} (which have
+   * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
+   * input stream.
+   */
+  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
+      throws IOException {
+    // Starting with an 8k buffer, double the size of each sucessive buffer. Buffers are retained
+    // in a deque so that there's no copying between buffers while reading and so all of the bytes
+    // in each new allocated buffer are available for reading from the stream.
+    for (int bufSize = BUFFER_SIZE;
+         totalLen < MAX_ARRAY_LEN;
+         bufSize = IntMath.saturatedMultiply(bufSize, 2)) {
+      byte[] buf = new byte[Math.min(bufSize, MAX_ARRAY_LEN - totalLen)];
+      bufs.add(buf);
+      int off = 0;
+      while (off < buf.length) {
+        // always OK to fill buf; its size plus the rest of bufs is never more than MAX_ARRAY_LEN
+        int r = in.read(buf, off, buf.length - off);
+        if (r == -1) {
+          return combineBuffers(bufs, totalLen);
+        }
+        off += r;
+        totalLen += r;
+      }
+    }
+
+    // read MAX_ARRAY_LEN bytes without seeing end of stream
+    if (in.read() == -1) {
+      // oh, there's the end of the stream
+      return combineBuffers(bufs, MAX_ARRAY_LEN);
+    } else {
+      throw new OutOfMemoryError(""input is too large to fit in a byte array"");
+    }
+  }
+
+  private static byte[] combineBuffers(Deque<byte[]> bufs, int totalLen) {
+    byte[] result = new byte[totalLen];
+    int remaining = totalLen;
+    while (remaining > 0) {
+      byte[] buf = bufs.removeFirst();
+      int bytesToCopy = Math.min(remaining, buf.length);
+      int resultOffset = totalLen - remaining;
+      System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
+      remaining -= bytesToCopy;
+    }
+    return result;
+  }
+
   /**
    * Reads all bytes from an input stream into a byte array. Does not close the stream.
    *
@@ -159,9 +217,8 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * @throws IOException if an I/O error occurs
    */
   public static byte[] toByteArray(InputStream in) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(BUFFER_SIZE, in.available()));
-    copy(in, out);
-    return out.toByteArray();
+    checkNotNull(in);
+    return toByteArrayInternal(in, new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE), 0);
   }
 
   /**
@@ -171,7 +228,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    */
   static byte[] toByteArray(InputStream in, long expectedSize) throws IOException {
     checkArgument(expectedSize >= 0, ""expectedSize (%s) must be non-negative"", expectedSize);
-    if (expectedSize > Integer.MAX_VALUE) {
+    if (expectedSize > MAX_ARRAY_LEN) {
       throw new OutOfMemoryError(expectedSize + "" bytes is too large to fit in a byte array"");
     }
 
@@ -196,28 +253,10 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    FastByteArrayOutputStream out = new FastByteArrayOutputStream(BUFFER_SIZE);
-    copy(in, out);
-
-    byte[] result = Arrays.copyOf(bytes, bytes.length + 1 + out.size());
-    result[bytes.length] = (byte) b;
-    out.writeTo(result, bytes.length + 1);
-    return result;
-  }
-
-  /** BAOS that provides limited access to its internal byte array. */
-  private static final class FastByteArrayOutputStream extends ByteArrayOutputStream {
-    FastByteArrayOutputStream(int initialSize) {
-      super(initialSize);
-    }
-
-    /**
-     * Writes the contents of the internal buffer to the given array starting at the given offset.
-     * Assumes the array has space to hold count bytes.
-     */
-    void writeTo(byte[] b, int off) {
-      System.arraycopy(buf, 0, b, off, count);
-    }
+    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
+    bufs.add(bytes);
+    bufs.add(new byte[] { (byte) b });
+    return toByteArrayInternal(in, bufs, bytes.length + 1);
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> HashBiMap: unnecessary call to rehashIfNecessary

Closes https://github.com/google/guava/pull/3076

532ab835043d451e6884f463e2b97c4416e55cc6

-------

<p> Stop using ByteArrayOutputStream in ByteStreams.toByteArray methods.

They were using ByteStreams.copy to copy the source to the BAOS. This meant reading from the source into a buffer, then copying from that buffer to a different buffer in the BAOS. Additionally, the way BAOS operates is not great: whenever it needs more space, it creates a new array twice as large as the previous, copies all bytes from the previous array to the new one, and discards the previous array.

Instead, read directly from the source into a sequence of buffers. When a buffer fills up, don't discard it, but instead create a new, twice as large, buffer and start reading into it.

(Roll-forward of previously rolled back e50ce7e7ed79fbce1901081838c8e0f9269d4128 now that the tests failing because they were mocking InputStream are fixed.)

e1b6d117a5b1d688d7e7348c3ce36324f6283c7b",Moe Sync
3087,Ron Shapiro,"['android/guava-tests/test/com/google/common/base/FinalizableReferenceQueueClassLoaderUnloadingTest.java', 'android/guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'guava-tests/test/com/google/common/base/FinalizableReferenceQueueClassLoaderUnloadingTest.java', 'guava/src/com/google/common/base/FinalizableReferenceQueue.java']","@@ -17,6 +17,7 @@
 package com.google.common.base;
 
 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.JAVA_SPECIFICATION_VERSION;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 
 import com.google.common.collect.ImmutableList;
@@ -45,6 +46,7 @@
  *
  * @author Eamonn McManus
  */
+
 public class FinalizableReferenceQueueClassLoaderUnloadingTest extends TestCase {
 
   /*
@@ -133,9 +135,14 @@ private void doTestUnloadable() throws Exception {
     GcFinalization.awaitClear(loaderRef);
   }
 
+  /**
+   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
+   * loader of that class from being garbage-collected.
+   */
   public void testUnloadableWithoutSecurityManager() throws Exception {
-    // Test that the use of a FinalizableReferenceQueue does not subsequently prevent the
-    // loader of that class from being garbage-collected.
+    if (isJdk9()) {
+      return;
+    }
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
       System.setSecurityManager(null);
@@ -145,12 +152,18 @@ public void testUnloadableWithoutSecurityManager() throws Exception {
     }
   }
 
+  /**
+   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
+   * loader of that class from being garbage-collected even if there is a {@link SecurityManager}.
+   * The {@link SecurityManager} environment makes such leaks more likely because when you create a
+   * {@link URLClassLoader} with a {@link SecurityManager}, the creating code's {@link
+   * java.security.AccessControlContext} is captured, and that references the creating code's {@link
+   * ClassLoader}.
+   */
   public void testUnloadableWithSecurityManager() throws Exception {
-    // Test that the use of a FinalizableReferenceQueue does not subsequently prevent the
-    // loader of that class from being garbage-collected even if there is a SecurityManager.
-    // The SecurityManager environment makes such leaks more likely because when you create
-    // a URLClassLoader with a SecurityManager, the creating code's AccessControlContext is
-    // captured, and that references the creating code's ClassLoader.
+    if (isJdk9()) {
+      return;
+    }
     Policy oldPolicy = Policy.getPolicy();
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
@@ -181,6 +194,9 @@ public void finalizeReferent() {
   }
 
   public void testUnloadableInStaticFieldIfClosed() throws Exception {
+    if (isJdk9()) {
+      return;
+    }
     Policy oldPolicy = Policy.getPolicy();
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
@@ -270,4 +286,13 @@ public void testUnloadableInStaticFieldIfClosed() throws Exception {
     }
     return urls.build();
   }
+
+  /**
+   * These tests fail in JDK 9 for an unknown reason. It might be the test; it might be the
+   * underlying functionality. Fixing this is not a high priority; if you need it to be fixed,
+   * please comment on <a href=""https://github.com/google/guava/issues/3086"">issue 3086</a>.
+   */
+  private static boolean isJdk9() {
+    return JAVA_SPECIFICATION_VERSION.value().startsWith(""9"");
+  }
 }, @@ -124,6 +124,10 @@
    *
    * If any of this fails along the way, we fall back to loading Finalizer directly in the
    * application class loader.
+   *
+   * NOTE: The tests for this behavior (FinalizableReferenceQueueClassLoaderUnloadingTest) fail
+   * strangely when run in JDK 9. We are considering this a known issue. Please see
+   * https://github.com/google/guava/issues/3086 for more information.
    */
 
   private static final Logger logger = Logger.getLogger(FinalizableReferenceQueue.class.getName());, @@ -17,6 +17,7 @@
 package com.google.common.base;
 
 import static com.google.common.base.StandardSystemProperty.JAVA_CLASS_PATH;
+import static com.google.common.base.StandardSystemProperty.JAVA_SPECIFICATION_VERSION;
 import static com.google.common.base.StandardSystemProperty.PATH_SEPARATOR;
 
 import com.google.common.collect.ImmutableList;
@@ -45,6 +46,7 @@
  *
  * @author Eamonn McManus
  */
+
 public class FinalizableReferenceQueueClassLoaderUnloadingTest extends TestCase {
 
   /*
@@ -133,9 +135,14 @@ private void doTestUnloadable() throws Exception {
     GcFinalization.awaitClear(loaderRef);
   }
 
+  /**
+   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
+   * loader of that class from being garbage-collected.
+   */
   public void testUnloadableWithoutSecurityManager() throws Exception {
-    // Test that the use of a FinalizableReferenceQueue does not subsequently prevent the
-    // loader of that class from being garbage-collected.
+    if (isJdk9()) {
+      return;
+    }
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
       System.setSecurityManager(null);
@@ -145,12 +152,18 @@ public void testUnloadableWithoutSecurityManager() throws Exception {
     }
   }
 
+  /**
+   * Tests that the use of a {@link FinalizableReferenceQueue} does not subsequently prevent the
+   * loader of that class from being garbage-collected even if there is a {@link SecurityManager}.
+   * The {@link SecurityManager} environment makes such leaks more likely because when you create a
+   * {@link URLClassLoader} with a {@link SecurityManager}, the creating code's {@link
+   * java.security.AccessControlContext} is captured, and that references the creating code's {@link
+   * ClassLoader}.
+   */
   public void testUnloadableWithSecurityManager() throws Exception {
-    // Test that the use of a FinalizableReferenceQueue does not subsequently prevent the
-    // loader of that class from being garbage-collected even if there is a SecurityManager.
-    // The SecurityManager environment makes such leaks more likely because when you create
-    // a URLClassLoader with a SecurityManager, the creating code's AccessControlContext is
-    // captured, and that references the creating code's ClassLoader.
+    if (isJdk9()) {
+      return;
+    }
     Policy oldPolicy = Policy.getPolicy();
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
@@ -181,6 +194,9 @@ public void finalizeReferent() {
   }
 
   public void testUnloadableInStaticFieldIfClosed() throws Exception {
+    if (isJdk9()) {
+      return;
+    }
     Policy oldPolicy = Policy.getPolicy();
     SecurityManager oldSecurityManager = System.getSecurityManager();
     try {
@@ -270,4 +286,13 @@ public void testUnloadableInStaticFieldIfClosed() throws Exception {
     }
     return urls.build();
   }
+
+  /**
+   * These tests fail in JDK 9 for an unknown reason. It might be the test; it might be the
+   * underlying functionality. Fixing this is not a high priority; if you need it to be fixed,
+   * please comment on <a href=""https://github.com/google/guava/issues/3086"">issue 3086</a>.
+   */
+  private static boolean isJdk9() {
+    return JAVA_SPECIFICATION_VERSION.value().startsWith(""9"");
+  }
 }, @@ -124,6 +124,10 @@
    *
    * If any of this fails along the way, we fall back to loading Finalizer directly in the
    * application class loader.
+   *
+   * NOTE: The tests for this behavior (FinalizableReferenceQueueClassLoaderUnloadingTest) fail
+   * strangely when run in JDK 9. We are considering this a known issue. Please see
+   * https://github.com/google/guava/issues/3086 for more information.
    */
 
   private static final Logger logger = Logger.getLogger(FinalizableReferenceQueue.class.getName());, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Supersource nullToEmpty and emptyToNull in Strings.java to native JS.

This allows us to improve performance in docs/xplat code that uses those methods.

RELNOTES=GWT: Supersource `Strings.nullToEmpty()` and `Strings.emptyToNull()`

1850b425de37bf017b0fc57dd02e9de3302b08dc

-------

<p> Open source refactorings directory.  This is knowingly very simple, without yet documentation or many refactorings; it's a prototype first.

694060c9ab57a299607f025902ff920fcd438f25

-------

<p> Ignore FinalizableReferenceQueueClassLoaderUnloadingTest in JDK 9.

ae891f29a5ccba8ef90a6733dc26be22eca3426b",Moe Sync
3097,Ron Shapiro,"['guava-tests/test/com/google/common/cache/LocalCacheTest.java', 'guava/src/com/google/common/cache/LocalCache.java']","@@ -61,6 +61,7 @@
 import java.io.Serializable;
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -696,6 +697,22 @@ public void testValues() {
     assertEquals(1, map.size());
   }
 
+  public void testComputeIfAbsent_RemovalListener() {
+    List<RemovalNotification<Object, Object>> notifications = new ArrayList<>();
+    RemovalListener<Object, Object> removalListener =
+        new RemovalListener<Object, Object>() {
+          @Override
+          public void onRemoval(RemovalNotification<Object, Object> notification) {
+            notifications.add(notification);
+          }
+        };
+    Cache<Object, Object> cache =
+        CacheBuilder.newBuilder().removalListener(removalListener).build();
+    cache.put(""a"", ""b"");
+    cache.asMap().computeIfAbsent(""a"", k -> ""c"");
+    assertTrue(notifications.toString(), notifications.isEmpty());
+  }
+
   public void testCopyEntry_computing() {
     final CountDownLatch startSignal = new CountDownLatch(1);
     final CountDownLatch computingSignal = new CountDownLatch(1);, @@ -2243,6 +2243,9 @@ V compute(K key, int hash, BiFunction<? super K, ? super V, ? extends V> functio
 
         newValue = loadingValueReference.compute(key, function);
         if (newValue != null) {
+          if (valueReference != null && newValue == valueReference.get()) {
+            return newValue;
+          }
           try {
             return getAndRecordStats(
                 key, hash, loadingValueReference, Futures.immediateFuture(newValue));, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix https://github.com/google/guava/issues/3081.

a446dd1890a324769ef7dc829052d5118e053abb",Moe Sync
3099,Ron Shapiro,['README.md'],"@@ -1,7 +1,7 @@
 # Guava: Google Core Libraries for Java
 
 [![Build Status](https://travis-ci.org/google/guava.svg?branch=master)](https://travis-ci.org/google/guava)
-[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.google.guava/guava/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.google.guava/guava)
+[![Maven Central](https://img.shields.io/maven-central/v/com.google.guava/guava.svg)](https://mvnrepository.com/artifact/com.google.guava/guava/latest)
 
 Guava is a set of core libraries that includes new collection types (such as
 multimap and multiset), immutable collections, a graph library, functional, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add java.time.Duration overloads to CacheBuilder:
  cacheBuilder.expireAfterAccess(Duration)
  cacheBuilder.expireAfterWrite(Duration)
  cacheBuilder.refreshAfterWrite(Duration)

Fixes https://github.com/google/guava/issues/2999

RELNOTES=Add `java.time.Duration` overloads to `CacheBuilder`.

ffa5051884eacf180b5511ab270885960eb792d0

-------

<p> remove maven-badges.herokuapp.com from readme

Fixes #3090

de5a62a3d185b41875be8318e633698e85c045bf",Moe Sync
3103,Ron Shapiro,['guava-gwt/src-super/java/util/super/java/util/concurrent/Future.java'],"@@ -18,7 +18,7 @@
 
 /**
  * Emulation of Future. Since GWT environment is single threaded, attempting to block on the future
- * by calling {@link #get()} or {@link #get(long, TimeUnit)} when the it is not yet done is
+ * by calling {@link #get()} or {@link #get(long, TimeUnit)} when the future is not yet done is
  * considered illegal because it would lead to a deadlock. Future implementations must throw {@link
  * IllegalStateException} to avoid a deadlock.
  *, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Slightly discourage the use of the <long, TimeUnit> overloads on CacheBuilder.

babed10eeb8bc5571bdebecec94d48eb3b4748e8

-------

<p> Fix tests that failed if we couldn't recursively delete securely by using Jimfs and just getting rid of the whole file system each time.

Fixes https://github.com/google/guava/issues/3100

1974d26799780c448ef72c09eee2201dc7812fbb

-------

<p> Fix typo in Future javadoc.

7416b725e7a657cd215783651984217aad0840cc",Moe Sync
3109,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove pre-mature optimization of storing a total bit size for ConcatenatedHashFunction.

d7874ed808bad3031796854432c39358894eff08

-------

<p> Update Public Suffix data.

This copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

3c3aedeb600306c689655fc8ca950f662cada625",Moe Sync
3117,Ron Shapiro,"['android/guava/src/com/google/common/hash/LittleEndianByteArray.java', 'guava/src/com/google/common/hash/LittleEndianByteArray.java']","@@ -233,16 +233,17 @@ public void putLongLittleEndian(byte[] sink, int offset, long value) {
     try {
       /*
         UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes
-        on 32-bit Android (ARMv7 with ART). Ideally, we shouldn't use Unsafe.getLong() at all, but
-        the performance benefit on x86_64 is too great to ignore, so as a compromise, we enable the
-        optimization only on platforms that we specifically know to work.
+        on Android when running in 32-bit mode. For maximum safety, we shouldn't use
+        Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as
+        a compromise, we enable the optimization only on platforms that we specifically know to
+        work.
 
         In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which
         will have an efficient native implementation in JDK 9.
 
       */
       final String arch = System.getProperty(""os.arch"");
-      if (""amd64"".equals(arch) || ""aarch64"".equals(arch)) {
+      if (""amd64"".equals(arch)) {
         theGetter =
             ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)
                 ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN, @@ -233,16 +233,17 @@ public void putLongLittleEndian(byte[] sink, int offset, long value) {
     try {
       /*
         UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes
-        on 32-bit Android (ARMv7 with ART). Ideally, we shouldn't use Unsafe.getLong() at all, but
-        the performance benefit on x86_64 is too great to ignore, so as a compromise, we enable the
-        optimization only on platforms that we specifically know to work.
+        on Android when running in 32-bit mode. For maximum safety, we shouldn't use
+        Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as
+        a compromise, we enable the optimization only on platforms that we specifically know to
+        work.
 
         In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which
         will have an efficient native implementation in JDK 9.
 
       */
       final String arch = System.getProperty(""os.arch"");
-      if (""amd64"".equals(arch) || ""aarch64"".equals(arch)) {
+      if (""amd64"".equals(arch)) {
         theGetter =
             ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)
                 ? UnsafeByteArray.UNSAFE_LITTLE_ENDIAN, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix toString of NonSerializableMemoizingSupplier

Fixes #3107

9185822ee16cdd641657c0f8e7ead755c9e9a564

-------

<p> Use Splitter instead of String.split, in InternetDomainName.

e56f1aa3d21b04eed8f5481d4103c05af5c51ec7

-------

<p> Use Splitter for IPv6, too. This eliminates usage of java.util.regex from this file (which is used via String.split, otherwise).

65a2a7de4ef4eea913f769a5cbbce6e35e1fccce

-------

<p> Use Diamond.

27eb336c2a2d9068878edbf49edcca493cd69cd8

-------

<p> Automated rollback of a12ef6b46b26fe178021c099e3db6a8a99f5174e.

It looks like the original change can cause an infinite loop in LocalCache.LoadingValueReference.get().

c2266a6ff8c6f298673688d6779b8b7368fe9147

-------

<p> Don't enable use of Unsafe.getLong() on aarch64 devices.

Android devices may report to run aarch64 while running in 32-bit mode, and then
crash when loading 64-bit values at unaligned addresses.

263bbcf6cf0cfae6768ddf9e9f3d749da555e422",Moe Sync
3121,Ron Shapiro,"['android/guava-tests/test/com/google/common/util/concurrent/StripedTest.java', 'android/guava/src/com/google/common/util/concurrent/Striped.java', 'guava-tests/test/com/google/common/util/concurrent/StripedTest.java', 'guava/src/com/google/common/util/concurrent/Striped.java']","@@ -50,6 +50,18 @@
         Striped.readWriteLock(256),
         Striped.lock(100),
         Striped.lock(256),
+        Striped.custom(100, new Supplier<Lock>() {
+          @Override
+          public Lock get() {
+            return new ReentrantLock(true);
+          }
+        }),
+        Striped.custom(256, new Supplier<Lock>() {
+          @Override
+          public Lock get() {
+            return new ReentrantLock(true);
+          }
+        }),
         Striped.semaphore(100, 1),
         Striped.semaphore(256, 1));
   }, @@ -183,6 +183,18 @@ private Striped() {}
 
   // Static factories
 
+  /**
+   * Creates a {@code Striped<L>} with eagerly initialized, strongly referenced locks. Every lock
+   * is obtained from the passed supplier.
+   *
+   * @param stripes the minimum number of stripes (locks) required
+   * @param supplier a {@code Supplier<L>} object to obtain locks from
+   * @return a new {@code Striped<L>}
+   */
+  static <L> Striped<L> custom(int stripes, Supplier<L> supplier) {
+    return new CompactStriped<>(stripes, supplier);
+  }
+
   /**
    * Creates a {@code Striped<Lock>} with eagerly initialized, strongly referenced locks. Every lock
    * is reentrant.
@@ -191,14 +203,12 @@ private Striped() {}
    * @return a new {@code Striped<Lock>}
    */
   public static Striped<Lock> lock(int stripes) {
-    return new CompactStriped<>(
-        stripes,
-        new Supplier<Lock>() {
-          @Override
-          public Lock get() {
-            return new PaddedLock();
-          }
-        });
+    return custom(stripes, new Supplier<Lock>() {
+      @Override
+      public Lock get() {
+        return new PaddedLock();
+      }
+    });
   }
 
   /**
@@ -234,7 +244,7 @@ public Lock get() {
    * @return a new {@code Striped<Semaphore>}
    */
   public static Striped<Semaphore> semaphore(int stripes, final int permits) {
-    return new CompactStriped<>(
+    return custom(
         stripes,
         new Supplier<Semaphore>() {
           @Override
@@ -271,7 +281,7 @@ public Semaphore get() {
    * @return a new {@code Striped<ReadWriteLock>}
    */
   public static Striped<ReadWriteLock> readWriteLock(int stripes) {
-    return new CompactStriped<>(stripes, READ_WRITE_LOCK_SUPPLIER);
+    return custom(stripes, READ_WRITE_LOCK_SUPPLIER);
   }
 
   /**, @@ -50,6 +50,18 @@
         Striped.readWriteLock(256),
         Striped.lock(100),
         Striped.lock(256),
+        Striped.custom(100, new Supplier<Lock>() {
+          @Override
+          public Lock get() {
+            return new ReentrantLock(true);
+          }
+        }),
+        Striped.custom(256, new Supplier<Lock>() {
+          @Override
+          public Lock get() {
+            return new ReentrantLock(true);
+          }
+        }),
         Striped.semaphore(100, 1),
         Striped.semaphore(256, 1));
   }, @@ -183,6 +183,18 @@ private Striped() {}
 
   // Static factories
 
+  /**
+   * Creates a {@code Striped<L>} with eagerly initialized, strongly referenced locks. Every lock
+   * is obtained from the passed supplier.
+   *
+   * @param stripes the minimum number of stripes (locks) required
+   * @param supplier a {@code Supplier<L>} object to obtain locks from
+   * @return a new {@code Striped<L>}
+   */
+  static <L> Striped<L> custom(int stripes, Supplier<L> supplier) {
+    return new CompactStriped<>(stripes, supplier);
+  }
+
   /**
    * Creates a {@code Striped<Lock>} with eagerly initialized, strongly referenced locks. Every lock
    * is reentrant.
@@ -191,14 +203,12 @@ private Striped() {}
    * @return a new {@code Striped<Lock>}
    */
   public static Striped<Lock> lock(int stripes) {
-    return new CompactStriped<>(
-        stripes,
-        new Supplier<Lock>() {
-          @Override
-          public Lock get() {
-            return new PaddedLock();
-          }
-        });
+    return custom(stripes, new Supplier<Lock>() {
+      @Override
+      public Lock get() {
+        return new PaddedLock();
+      }
+    });
   }
 
   /**
@@ -234,7 +244,7 @@ public Lock get() {
    * @return a new {@code Striped<Semaphore>}
    */
   public static Striped<Semaphore> semaphore(int stripes, final int permits) {
-    return new CompactStriped<>(
+    return custom(
         stripes,
         new Supplier<Semaphore>() {
           @Override
@@ -271,7 +281,7 @@ public Semaphore get() {
    * @return a new {@code Striped<ReadWriteLock>}
    */
   public static Striped<ReadWriteLock> readWriteLock(int stripes) {
-    return new CompactStriped<>(stripes, READ_WRITE_LOCK_SUPPLIER);
+    return custom(stripes, READ_WRITE_LOCK_SUPPLIER);
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adding a new (initially internal, pending API Review) static factory to Striped.

This allows for custom Lock injection, which might be useful for cases not covered by the currently existing factories. With this, Striped<Lock> with fair sync is possible.

69a5c285ca6be0e63c521dcb5ecf8782eb1d6379",Moe Sync
3124,Ron Shapiro,['README.md'],"@@ -99,8 +99,8 @@ correctly in other environments. For the Android flavor, our unit tests run on
 API level 15 (Ice Cream Sandwich).
 
 [current release]: https://github.com/google/guava/releases/tag/v24.1
-[guava-snapshot-api-docs]: http://google.github.io/guava/releases/snapshot-jre/api/docs/
-[guava-snapshot-api-diffs]: http://google.github.io/guava/releases/snapshot-jre/api/diffs/
+[guava-snapshot-api-docs]: https://google.github.io/guava/releases/snapshot-jre/api/docs/
+[guava-snapshot-api-diffs]: https://google.github.io/guava/releases/snapshot-jre/api/diffs/
 [Guava Explained]: https://github.com/google/guava/wiki/Home
 [Guava Beta Checker]: https://github.com/google/guava-beta-checker
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make SuppliersTest.testMemoizeExceptionThrown() actually memoize the suppliers before testing them.

Fixes https://github.com/google/guava/issues/3122

7622bb803ff6c0ae1e3d1d1b2311c7ad1be9c6f3

-------

<p> Use https for API docs

938839f401cadd29fbd94b1e9afc82b663c5a641",Moe Sync
3125,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/FluentFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/FluentFuture.java']","@@ -25,7 +25,6 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.errorprone.annotations.ForOverride;
 import com.google.j2objc.annotations.ReflectionSupport;
 import java.security.AccessController;
@@ -64,7 +63,6 @@
  * @since 1.0
  */
 @SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
-@DoNotMock(""Use Futures.immediate*Future or SettableFuture"")
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 public abstract class AbstractFuture<V> extends FluentFuture<V> {, @@ -18,7 +18,6 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
@@ -67,7 +66,6 @@
  * @since 23.0
  */
 @Beta
-@DoNotMock(""Use FluentFuture.from(Futures.immediate*Future) or SettableFuture"")
 @GwtCompatible(emulated = true)
 public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {
   FluentFuture() {}, @@ -25,7 +25,6 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Ascii;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.errorprone.annotations.ForOverride;
 import com.google.j2objc.annotations.ReflectionSupport;
 import java.security.AccessController;
@@ -64,7 +63,6 @@
  * @since 1.0
  */
 @SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
-@DoNotMock(""Use Futures.immediate*Future or SettableFuture"")
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 public abstract class AbstractFuture<V> extends FluentFuture<V> {, @@ -18,7 +18,6 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
-import com.google.errorprone.annotations.DoNotMock;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
@@ -67,7 +66,6 @@
  * @since 23.0
  */
 @Beta
-@DoNotMock(""Use FluentFuture.from(Futures.immediate*Future) or SettableFuture"")
 @GwtCompatible(emulated = true)
 public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {
   FluentFuture() {}, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Strip @DoNotMock annotations

RELNOTES=N/A

88134a2ed0b37c219b2912bdbff320e15dbe1a2e",Moe Sync
3130,Ron Shapiro,"['android/guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/Sets.java']","@@ -1286,6 +1286,7 @@ public E last() {
    *     provided set is null
    * @since 2.0
    */
+  @SafeVarargs
   public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets) {
     return cartesianProduct(Arrays.asList(sets));
   }, @@ -1380,6 +1380,7 @@ public E last() {
    *     provided set is null
    * @since 2.0
    */
+  @SafeVarargs
   public static <B> Set<List<B>> cartesianProduct(Set<? extends B>... sets) {
     return cartesianProduct(Arrays.asList(sets));
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use @SafeVarargs annotation for Sets.cartesianProduct().

Fixes https://github.com/google/guava/pull/3127
Fixes https://github.com/google/guava/issues/2724

63a2f5a3928b64f9892f9751269ad1e27a718162",Moe Sync
3132,Ron Shapiro,"['android/guava/src/com/google/common/collect/Collections2.java', 'android/guava/src/com/google/common/collect/Iterators.java', 'android/guava/src/com/google/common/collect/LinkedListMultimap.java', 'android/guava/src/com/google/common/io/MultiReader.java', 'android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'guava/src/com/google/common/collect/Collections2.java', 'guava/src/com/google/common/collect/ImmutableCollection.java', 'guava/src/com/google/common/collect/Iterators.java', 'guava/src/com/google/common/collect/LinkedListMultimap.java', 'guava/src/com/google/common/io/MultiReader.java', 'guava/src/com/google/common/util/concurrent/AbstractScheduledService.java']","@@ -486,8 +486,7 @@ public String toString() {
   }
 
   private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
-    @NullableDecl
-    List<E> nextPermutation;
+    @NullableDecl List<E> nextPermutation;
     final Comparator<? super E> comparator;
 
     OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator) {, @@ -1291,7 +1291,7 @@ public T next() {
 
   private static class ConcatenatedIterator<T> implements Iterator<T> {
     /* The last iterator to return an element.  Calls to remove() go to this iterator. */
-   @NullableDecl private Iterator<? extends T> toRemove;
+    @NullableDecl private Iterator<? extends T> toRemove;
 
     /* The iterator currently returning elements. */
     private Iterator<? extends T> iterator;, @@ -32,7 +32,6 @@
 import java.util.AbstractSequentialList;
 import java.util.Collection;
 import java.util.ConcurrentModificationException;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;, @@ -46,7 +46,7 @@ private void advance() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl char cbuf[], int off, int len) throws IOException {
+  public int read(@NullableDecl char[] cbuf, int off, int len) throws IOException {
     if (current == null) {
       return -1;
     }, @@ -466,7 +466,8 @@ public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutExc
 
       /** The future that represents the next execution of this task. */
       @GuardedBy(""lock"")
-      @NullableDecl private Future<Void> currentFuture;
+      @NullableDecl
+      private Future<Void> currentFuture;
 
       ReschedulableCallable(
           AbstractService service, ScheduledExecutorService executor, Runnable runnable) {, @@ -509,8 +509,7 @@ public String toString() {
   }
 
   private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
-    @NullableDecl
-    List<E> nextPermutation;
+    @NullableDecl List<E> nextPermutation;
     final Comparator<? super E> comparator;
 
     OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator) {, @@ -17,14 +17,11 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.CollectPreconditions.checkNonnegative;
-import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.AbstractCollection;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;, @@ -1291,7 +1291,7 @@ public T next() {
 
   private static class ConcatenatedIterator<T> implements Iterator<T> {
     /* The last iterator to return an element.  Calls to remove() go to this iterator. */
-   @NullableDecl private Iterator<? extends T> toRemove;
+    @NullableDecl private Iterator<? extends T> toRemove;
 
     /* The iterator currently returning elements. */
     private Iterator<? extends T> iterator;, @@ -33,7 +33,6 @@
 import java.util.AbstractSequentialList;
 import java.util.Collection;
 import java.util.ConcurrentModificationException;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;, @@ -46,7 +46,7 @@ private void advance() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl char cbuf[], int off, int len) throws IOException {
+  public int read(@NullableDecl char[] cbuf, int off, int len) throws IOException {
     if (current == null) {
       return -1;
     }, @@ -466,7 +466,8 @@ public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutExc
 
       /** The future that represents the next execution of this task. */
       @GuardedBy(""lock"")
-      @NullableDecl private Future<Void> currentFuture;
+      @NullableDecl
+      private Future<Void> currentFuture;
 
       ReschedulableCallable(
           AbstractService service, ScheduledExecutorService executor, Runnable runnable) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix a few formatting nits

RELNOTES=N/A

6251cc89ad889458ed7ad4911f5b41d9733cc0b1",Moe Sync
3134,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -221,7 +221,7 @@
       <dependency>
         <groupId>com.google.code.findbugs</groupId>
         <artifactId>jsr305</artifactId>
-        <version>1.3.9</version>
+        <version>3.0.2</version>
       </dependency>
       <dependency>
         <groupId>org.checkerframework</groupId>, @@ -217,7 +217,7 @@
       <dependency>
         <groupId>com.google.code.findbugs</groupId>
         <artifactId>jsr305</artifactId>
-        <version>1.3.9</version>
+        <version>3.0.2</version>
       </dependency>
       <dependency>
         <groupId>org.checkerframework</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Bump jsr305 version.

31047249de250f2835640e02485f47a0b8bb4e84",Moe Sync
3138,Ron Shapiro,"['android/guava/pom.xml', 'guava/pom.xml']","@@ -141,7 +141,7 @@
             </offlineLink>
           </offlineLinks>
           <links>
-            <link>http://errorprone.info/api/latest/</link>
+            <link>https://errorprone.info/api/latest/</link>
           </links>
         </configuration>
         <executions>, @@ -141,7 +141,7 @@
             </offlineLink>
           </offlineLinks>
           <links>
-            <link>http://errorprone.info/api/latest/</link>
+            <link>https://errorprone.info/api/latest/</link>
           </links>
         </configuration>
         <executions>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Replace http://errorprone.info with https://errorprone.info since that site
serves from https now

9cccb7fa18d8b8da45edada58a439e9d7632b9ac",Moe Sync
3139,Ron Shapiro,"['android/guava-testlib/src/com/google/common/testing/ClassSanityTester.java', 'android/guava-testlib/src/com/google/common/testing/NullPointerTester.java', 'android/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java', 'android/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java', 'android/guava/src/com/google/common/collect/LinkedListMultimap.java', 'guava-gwt/src-super/com/google/common/base/super/com/google/common/base/ExtraObjectsMethodsForWeb.java', 'guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java', 'guava-gwt/src-super/com/google/common/cache/super/com/google/common/cache/LocalCache.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/AbstractSortedMultiset.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ForwardingImmutableCollection.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ForwardingImmutableList.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ForwardingImmutableMap.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ForwardingImmutableSet.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableCollection.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableList.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMap.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java', 'guava-gwt/src/com/google/common/base/GwtSerializationDependencies.java', 'guava-testlib/pom.xml', 'guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java', 'guava-testlib/src/com/google/common/testing/ArbitraryInstances.java', 'guava-testlib/src/com/google/common/testing/CollectorTester.java', 'guava-testlib/src/com/google/common/testing/FreshValueGenerator.java', 'guava-testlib/src/com/google/common/testing/NullPointerTester.java', 'guava-testlib/src/com/google/common/testing/TestLogHandler.java', 'guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java', 'guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java', 'guava-tests/benchmark/com/google/common/collect/ConcurrentHashMultisetBenchmark.java', 'guava-tests/benchmark/com/google/common/util/concurrent/ExecutionListBenchmark.java', 'guava-tests/benchmark/com/google/common/util/concurrent/MonitorBasedArrayBlockingQueue.java', 'guava-tests/benchmark/com/google/common/util/concurrent/MonitorBasedPriorityBlockingQueue.java', 'guava-tests/pom.xml', 'guava-tests/test/com/google/common/cache/CacheBuilderFactory.java', 'guava-tests/test/com/google/common/cache/CacheTesting.java', 'guava-tests/test/com/google/common/cache/TestingCacheLoaders.java', 'guava-tests/test/com/google/common/collect/FluentIterableTest.java', 'guava-tests/test/com/google/common/collect/ForwardingSortedMultisetTest.java', 'guava-tests/test/com/google/common/collect/ImmutableBiMapTest.java', 'guava-tests/test/com/google/common/collect/ImmutableMapTest.java', 'guava-tests/test/com/google/common/collect/ImmutableMultisetTest.java', 'guava-tests/test/com/google/common/collect/ImmutableSetTest.java', 'guava-tests/test/com/google/common/collect/MapsCollectionTest.java', 'guava-tests/test/com/google/common/collect/MapsTransformValuesTest.java', 'guava-tests/test/com/google/common/collect/MapsTransformValuesUnmodifiableIteratorTest.java', 'guava-tests/test/com/google/common/collect/MultimapsTest.java', 'guava-tests/test/com/google/common/collect/OrderingTest.java', 'guava-tests/test/com/google/common/collect/SetsTest.java', 'guava-tests/test/com/google/common/collect/SimpleAbstractMultisetTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedMultimapTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedSetTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedTableTest.java', 'guava-tests/test/com/google/common/hash/BloomFilterTest.java', 'guava-tests/test/com/google/common/io/BaseEncodingTest.java', 'guava-tests/test/com/google/common/io/CloserTest.java', 'guava-tests/test/com/google/common/io/SourceSinkFactories.java', 'guava-tests/test/com/google/common/math/QuantilesTest.java', 'guava-tests/test/com/google/common/reflect/InvokableTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureBenchmarks.java', 'guava-tests/test/com/google/common/util/concurrent/FutureCallbackTest.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava-tests/test/com/google/common/util/concurrent/ListenableFutureTester.java', 'guava-tests/test/com/google/common/util/concurrent/TestThread.java', 'guava/pom.xml', 'guava/src/com/google/common/base/Absent.java', 'guava/src/com/google/common/base/AbstractIterator.java', 'guava/src/com/google/common/base/CaseFormat.java', 'guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/Defaults.java', 'guava/src/com/google/common/base/Enums.java', 'guava/src/com/google/common/base/Equivalence.java', 'guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'guava/src/com/google/common/base/Function.java', 'guava/src/com/google/common/base/FunctionalEquivalence.java', 'guava/src/com/google/common/base/Functions.java', 'guava/src/com/google/common/base/Joiner.java', 'guava/src/com/google/common/base/MoreObjects.java', 'guava/src/com/google/common/base/Objects.java', 'guava/src/com/google/common/base/Optional.java', 'guava/src/com/google/common/base/PairwiseEquivalence.java', 'guava/src/com/google/common/base/Platform.java', 'guava/src/com/google/common/base/Preconditions.java', 'guava/src/com/google/common/base/Predicate.java', 'guava/src/com/google/common/base/Predicates.java', 'guava/src/com/google/common/base/Present.java', 'guava/src/com/google/common/base/StandardSystemProperty.java', 'guava/src/com/google/common/base/Strings.java', 'guava/src/com/google/common/base/Suppliers.java', 'guava/src/com/google/common/base/Throwables.java', 'guava/src/com/google/common/base/Verify.java', 'guava/src/com/google/common/base/VerifyException.java', 'guava/src/com/google/common/base/internal/Finalizer.java', 'guava/src/com/google/common/cache/Cache.java', 'guava/src/com/google/common/cache/CacheBuilderSpec.java', 'guava/src/com/google/common/cache/CacheStats.java', 'guava/src/com/google/common/cache/ForwardingCache.java', 'guava/src/com/google/common/cache/LocalCache.java', 'guava/src/com/google/common/cache/ReferenceEntry.java', 'guava/src/com/google/common/cache/RemovalNotification.java', 'guava/src/com/google/common/cache/Striped64.java', 'guava/src/com/google/common/collect/AbstractBiMap.java', 'guava/src/com/google/common/collect/AbstractIterator.java', 'guava/src/com/google/common/collect/AbstractListMultimap.java', 'guava/src/com/google/common/collect/AbstractMapBasedMultimap.java', 'guava/src/com/google/common/collect/AbstractMapBasedMultiset.java', 'guava/src/com/google/common/collect/AbstractMapEntry.java', 'guava/src/com/google/common/collect/AbstractMultimap.java', 'guava/src/com/google/common/collect/AbstractMultiset.java', 'guava/src/com/google/common/collect/AbstractNavigableMap.java', 'guava/src/com/google/common/collect/AbstractRangeSet.java', 'guava/src/com/google/common/collect/AbstractSequentialIterator.java', 'guava/src/com/google/common/collect/AbstractSetMultimap.java', 'guava/src/com/google/common/collect/AbstractSortedMultiset.java', 'guava/src/com/google/common/collect/AbstractSortedSetMultimap.java', 'guava/src/com/google/common/collect/AbstractTable.java', 'guava/src/com/google/common/collect/AllEqualOrdering.java', 'guava/src/com/google/common/collect/ArrayTable.java', 'guava/src/com/google/common/collect/BiMap.java', 'guava/src/com/google/common/collect/ByFunctionOrdering.java', 'guava/src/com/google/common/collect/CartesianList.java', 'guava/src/com/google/common/collect/ClassToInstanceMap.java', 'guava/src/com/google/common/collect/CollectSpliterators.java', 'guava/src/com/google/common/collect/Collections2.java', 'guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/CompactHashSet.java', 'guava/src/com/google/common/collect/ComparatorOrdering.java', 'guava/src/com/google/common/collect/ComparisonChain.java', 'guava/src/com/google/common/collect/ComputationException.java', 'guava/src/com/google/common/collect/ConcurrentHashMultiset.java', 'guava/src/com/google/common/collect/Count.java', 'guava/src/com/google/common/collect/Cut.java', 'guava/src/com/google/common/collect/DenseImmutableTable.java', 'guava/src/com/google/common/collect/DescendingImmutableSortedMultiset.java', 'guava/src/com/google/common/collect/DescendingImmutableSortedSet.java', 'guava/src/com/google/common/collect/EmptyContiguousSet.java', 'guava/src/com/google/common/collect/EnumHashBiMap.java', 'guava/src/com/google/common/collect/EnumMultiset.java', 'guava/src/com/google/common/collect/ExplicitOrdering.java', 'guava/src/com/google/common/collect/FilteredEntryMultimap.java', 'guava/src/com/google/common/collect/FilteredKeyListMultimap.java', 'guava/src/com/google/common/collect/FilteredKeyMultimap.java', 'guava/src/com/google/common/collect/FilteredKeySetMultimap.java', 'guava/src/com/google/common/collect/FilteredMultimapValues.java', 'guava/src/com/google/common/collect/FluentIterable.java', 'guava/src/com/google/common/collect/ForwardingCollection.java', 'guava/src/com/google/common/collect/ForwardingList.java', 'guava/src/com/google/common/collect/ForwardingListMultimap.java', 'guava/src/com/google/common/collect/ForwardingMap.java', 'guava/src/com/google/common/collect/ForwardingMapEntry.java', 'guava/src/com/google/common/collect/ForwardingMultimap.java', 'guava/src/com/google/common/collect/ForwardingMultiset.java', 'guava/src/com/google/common/collect/ForwardingSet.java', 'guava/src/com/google/common/collect/ForwardingSetMultimap.java', 'guava/src/com/google/common/collect/ForwardingSortedMap.java', 'guava/src/com/google/common/collect/ForwardingSortedSet.java', 'guava/src/com/google/common/collect/ForwardingSortedSetMultimap.java', 'guava/src/com/google/common/collect/GeneralRange.java', 'guava/src/com/google/common/collect/HashBasedTable.java', 'guava/src/com/google/common/collect/HashBiMap.java', 'guava/src/com/google/common/collect/Hashing.java', 'guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java', 'guava/src/com/google/common/collect/ImmutableCollection.java', 'guava/src/com/google/common/collect/ImmutableEntry.java', 'guava/src/com/google/common/collect/ImmutableEnumMap.java', 'guava/src/com/google/common/collect/ImmutableList.java', 'guava/src/com/google/common/collect/ImmutableListMultimap.java', 'guava/src/com/google/common/collect/ImmutableMap.java', 'guava/src/com/google/common/collect/ImmutableMapEntry.java', 'guava/src/com/google/common/collect/ImmutableMapEntrySet.java', 'guava/src/com/google/common/collect/ImmutableMapKeySet.java', 'guava/src/com/google/common/collect/ImmutableMapValues.java', 'guava/src/com/google/common/collect/ImmutableMultimap.java', 'guava/src/com/google/common/collect/ImmutableMultiset.java', 'guava/src/com/google/common/collect/ImmutableRangeMap.java', 'guava/src/com/google/common/collect/ImmutableRangeSet.java', 'guava/src/com/google/common/collect/ImmutableSet.java', 'guava/src/com/google/common/collect/ImmutableSetMultimap.java', 'guava/src/com/google/common/collect/ImmutableSortedAsList.java', 'guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava/src/com/google/common/collect/ImmutableSortedSet.java', 'guava/src/com/google/common/collect/ImmutableTable.java', 'guava/src/com/google/common/collect/Iterables.java', 'guava/src/com/google/common/collect/Iterators.java', 'guava/src/com/google/common/collect/JdkBackedImmutableBiMap.java', 'guava/src/com/google/common/collect/JdkBackedImmutableMap.java', 'guava/src/com/google/common/collect/JdkBackedImmutableMultiset.java', 'guava/src/com/google/common/collect/JdkBackedImmutableSet.java', 'guava/src/com/google/common/collect/LexicographicalOrdering.java', 'guava/src/com/google/common/collect/LinkedHashMultimap.java', 'guava/src/com/google/common/collect/LinkedListMultimap.java', 'guava/src/com/google/common/collect/ListMultimap.java', 'guava/src/com/google/common/collect/Lists.java', 'guava/src/com/google/common/collect/MapDifference.java', 'guava/src/com/google/common/collect/MapMakerInternalMap.java', 'guava/src/com/google/common/collect/Maps.java', 'guava/src/com/google/common/collect/MinMaxPriorityQueue.java', 'guava/src/com/google/common/collect/MoreCollectors.java', 'guava/src/com/google/common/collect/Multimap.java', 'guava/src/com/google/common/collect/Multimaps.java', 'guava/src/com/google/common/collect/Multiset.java', 'guava/src/com/google/common/collect/Multisets.java', 'guava/src/com/google/common/collect/NullsFirstOrdering.java', 'guava/src/com/google/common/collect/NullsLastOrdering.java', 'guava/src/com/google/common/collect/ObjectArrays.java', 'guava/src/com/google/common/collect/Ordering.java', 'guava/src/com/google/common/collect/Range.java', 'guava/src/com/google/common/collect/RangeMap.java', 'guava/src/com/google/common/collect/RangeSet.java', 'guava/src/com/google/common/collect/RegularContiguousSet.java', 'guava/src/com/google/common/collect/RegularImmutableBiMap.java', 'guava/src/com/google/common/collect/RegularImmutableMap.java', 'guava/src/com/google/common/collect/RegularImmutableMultiset.java', 'guava/src/com/google/common/collect/RegularImmutableSet.java', 'guava/src/com/google/common/collect/RegularImmutableSortedMultiset.java', 'guava/src/com/google/common/collect/RegularImmutableSortedSet.java', 'guava/src/com/google/common/collect/RegularImmutableTable.java', 'guava/src/com/google/common/collect/ReverseOrdering.java', 'guava/src/com/google/common/collect/SetMultimap.java', 'guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/SingletonImmutableBiMap.java', 'guava/src/com/google/common/collect/SortedLists.java', 'guava/src/com/google/common/collect/SortedMultisets.java', 'guava/src/com/google/common/collect/SortedSetMultimap.java', 'guava/src/com/google/common/collect/StandardTable.java', 'guava/src/com/google/common/collect/Streams.java', 'guava/src/com/google/common/collect/Synchronized.java', 'guava/src/com/google/common/collect/Table.java', 'guava/src/com/google/common/collect/Tables.java', 'guava/src/com/google/common/collect/TopKSelector.java', 'guava/src/com/google/common/collect/TreeBasedTable.java', 'guava/src/com/google/common/collect/TreeMultimap.java', 'guava/src/com/google/common/collect/TreeMultiset.java', 'guava/src/com/google/common/collect/TreeRangeMap.java', 'guava/src/com/google/common/collect/TreeRangeSet.java', 'guava/src/com/google/common/graph/AbstractBaseGraph.java', 'guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java', 'guava/src/com/google/common/graph/AbstractGraph.java', 'guava/src/com/google/common/graph/AbstractNetwork.java', 'guava/src/com/google/common/graph/AbstractValueGraph.java', 'guava/src/com/google/common/graph/ConfigurableNetwork.java', 'guava/src/com/google/common/graph/ConfigurableValueGraph.java', 'guava/src/com/google/common/graph/DirectedGraphConnections.java', 'guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java', 'guava/src/com/google/common/graph/EdgesConnecting.java', 'guava/src/com/google/common/graph/ElementOrder.java', 'guava/src/com/google/common/graph/EndpointPair.java', 'guava/src/com/google/common/graph/ForwardingValueGraph.java', 'guava/src/com/google/common/graph/Graph.java', 'guava/src/com/google/common/graph/GraphConnections.java', 'guava/src/com/google/common/graph/Graphs.java', 'guava/src/com/google/common/graph/MapIteratorCache.java', 'guava/src/com/google/common/graph/MapRetrievalCache.java', 'guava/src/com/google/common/graph/MultiEdgesConnecting.java', 'guava/src/com/google/common/graph/Network.java', 'guava/src/com/google/common/graph/Traverser.java', 'guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java', 'guava/src/com/google/common/graph/ValueGraph.java', 'guava/src/com/google/common/hash/BloomFilter.java', 'guava/src/com/google/common/hash/BloomFilterStrategies.java', 'guava/src/com/google/common/hash/Funnels.java', 'guava/src/com/google/common/hash/HashCode.java', 'guava/src/com/google/common/hash/Hashing.java', 'guava/src/com/google/common/hash/Murmur3_128HashFunction.java', 'guava/src/com/google/common/hash/Murmur3_32HashFunction.java', 'guava/src/com/google/common/hash/SipHashFunction.java', 'guava/src/com/google/common/hash/Striped64.java', 'guava/src/com/google/common/io/AppendableWriter.java', 'guava/src/com/google/common/io/BaseEncoding.java', 'guava/src/com/google/common/io/CharSource.java', 'guava/src/com/google/common/io/Closeables.java', 'guava/src/com/google/common/io/Closer.java', 'guava/src/com/google/common/io/FileBackedOutputStream.java', 'guava/src/com/google/common/io/InsecureRecursiveDeleteException.java', 'guava/src/com/google/common/io/LineReader.java', 'guava/src/com/google/common/io/MoreFiles.java', 'guava/src/com/google/common/io/MultiInputStream.java', 'guava/src/com/google/common/io/MultiReader.java', 'guava/src/com/google/common/io/PatternFilenameFilter.java', 'guava/src/com/google/common/math/MathPreconditions.java', 'guava/src/com/google/common/math/PairedStats.java', 'guava/src/com/google/common/math/Stats.java', 'guava/src/com/google/common/primitives/Booleans.java', 'guava/src/com/google/common/primitives/Bytes.java', 'guava/src/com/google/common/primitives/Chars.java', 'guava/src/com/google/common/primitives/Doubles.java', 'guava/src/com/google/common/primitives/Floats.java', 'guava/src/com/google/common/primitives/ImmutableDoubleArray.java', 'guava/src/com/google/common/primitives/ImmutableIntArray.java', 'guava/src/com/google/common/primitives/ImmutableLongArray.java', 'guava/src/com/google/common/primitives/Ints.java', 'guava/src/com/google/common/primitives/Longs.java', 'guava/src/com/google/common/primitives/Shorts.java', 'guava/src/com/google/common/primitives/UnsignedInteger.java', 'guava/src/com/google/common/primitives/UnsignedLong.java', 'guava/src/com/google/common/reflect/AbstractInvocationHandler.java', 'guava/src/com/google/common/reflect/ClassPath.java', 'guava/src/com/google/common/reflect/Element.java', 'guava/src/com/google/common/reflect/Invokable.java', 'guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java', 'guava/src/com/google/common/reflect/Parameter.java']","@@ -767,7 +767,7 @@ private static Object generateDummyArg(Parameter param, FreshValueGenerator gene
     T returnValue = factory.invoke(null, args.toArray());
     if (returnValue == null) {
       Assert.assertTrue(
-          factory + "" returns null but it's not annotated with @NullableDecl"", isNullable(factory));
+          factory + "" returns null but it's not annotated with @Nullable"", isNullable(factory));
     }
     return returnValue;
   }, @@ -52,9 +52,8 @@
 /**
  * A test utility that verifies that your methods and constructors throw {@link
  * NullPointerException} or {@link UnsupportedOperationException} whenever null is passed to a
- * parameter that isn't annotated with {@link javax.annotation.Nullable}, {@link
- * javax.annotation.CheckForNull}, or {@link
- * org.checkerframework.checker.nullness.compatqual.NullableDecl}.
+ * parameter that isn't annotated with an annotation with the simple name {@code Nullable}, {@lcode
+ * CheckForNull}, {@link NullableType}, or {@link NullableDecl}.
  *
  * <p>The tested methods and constructors are invoked -- each time with one parameter being null and
  * the rest not null -- and the test fails if no expected exception is thrown. {@code, @@ -477,7 +477,7 @@ public void testInstantiate_factoryMethodReturnsNullButNotAnnotated() throws Exc
     try {
       tester.instantiate(FactoryMethodReturnsNullButNotAnnotated.class);
     } catch (AssertionFailedError expected) {
-      assertThat(expected.getMessage()).contains(""@NullableDecl"");
+      assertThat(expected.getMessage()).contains(""@Nullable"");
       return;
     }
     fail(""should have failed"");, @@ -85,8 +85,7 @@ public static void staticOneArgCheckForNullCorrectlyDoesNotThrowNPE(
       // null?  no problem
     }
 
-    public static void staticOneArgJsr305NullableCorrectlyDoesNotThrowNPE(
-        @javax.annotation.Nullable String s) {
+    public static void staticOneArgJsr305NullableCorrectlyDoesNotThrowNPE(@NullableDecl String s) {
       // null?  no problem
     }
 
@@ -498,7 +497,7 @@ public void twoMixedArgsThrows(@NullableDecl Integer i, String s) {
       doThrow(i);
     }
 
-    public void twoNullableArgs(@NullableDecl String s, @javax.annotation.Nullable Integer i) {}
+    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {}
 
     public void twoNullableArgsThrowsFirstArg(@NullableDecl String s, @NullableDecl Integer i) {
       doThrow(s);, @@ -675,7 +675,7 @@ public void clear() {
    * <p>The returned list is not serializable and does not have random access.
    */
   @Override
-  public List<V> get(final @NullableDecl K key) {
+  public List<V> get(@NullableDecl final K key) {
     return new AbstractSequentialList<V>() {
       @Override
       public int size() {, @@ -14,11 +14,11 @@
 
 package com.google.common.base;
 
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Holder for extra methods of {@code Objects} only in web. */
 abstract class ExtraObjectsMethodsForWeb {
-  public static boolean equal(@NullableDecl String a, @NullableDecl String b) {
+  public static boolean equal(@Nullable String a, @Nullable String b) {
     return a == b;
   }
 }, @@ -21,7 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import jsinterop.annotations.JsMethod;
 import jsinterop.annotations.JsType;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** @author Jesse Wilson */
 final class Platform {
@@ -52,17 +52,17 @@ static String formatCompact4Digits(double value) {
   }
 
   @JsMethod
-  static native boolean stringIsNullOrEmpty(@NullableDecl String string) /*-{
+  static native boolean stringIsNullOrEmpty(@Nullable String string) /*-{
     return !string;
   }-*/;
 
   @JsMethod
-  static native String nullToEmpty(@NullableDecl String string) /*-{
+  static native String nullToEmpty(@Nullable String string) /*-{
     return string || """";
   }-*/;
 
   @JsMethod
-  static native String emptyToNull(@NullableDecl String string) /*-{
+  static native String emptyToNull(@Nullable String string) /*-{
     return string || null;
   }-*/;
 , @@ -39,7 +39,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * LocalCache emulation for GWT.
@@ -375,7 +375,7 @@ public V get(K key, Callable<? extends V> valueLoader) throws ExecutionException
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public V getIfPresent(Object key) {
       return localCache.getIfPresent(key);
     }
@@ -476,7 +476,7 @@ public CapacityEnforcingLinkedHashMap(
         boolean accessOrder,
         long maximumSize,
         StatsCounter statsCounter,
-        @NullableDecl RemovalListener removalListener) {
+        @Nullable RemovalListener removalListener) {
       super(initialCapacity, loadFactor, accessOrder);
       this.maximumSize = maximumSize;
       this.statsCounter = statsCounter;
@@ -682,7 +682,7 @@ public V getValue() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       // Cannot use key and value equivalence
       if (object instanceof Entry) {
         Entry<?, ?> that = (Entry<?, ?>) object;, @@ -20,7 +20,7 @@
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link SortedMultiset} interface.
@@ -98,9 +98,9 @@
 
   @Override
   public SortedMultiset<E> subMultiset(
-      @NullableDecl E fromElement,
+      @Nullable E fromElement,
       BoundType fromBoundType,
-      @NullableDecl E toElement,
+      @Nullable E toElement,
       BoundType toBoundType) {
     // These are checked elsewhere, but NullPointerTester wants them checked eagerly.
     checkNotNull(fromBoundType);, @@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import java.util.Collection;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A GWT-only class only used by GWT emulations. It is used to consolidate the definitions of method
@@ -40,7 +40,7 @@
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return object != null && delegate.contains(object);
   }
 , @@ -18,7 +18,7 @@
 
 import java.util.Collection;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT emulated version of {@link ImmutableList}. TODO(cpovirk): more doc
@@ -31,11 +31,11 @@
 
   abstract List<E> delegateList();
 
-  public int indexOf(@NullableDecl Object object) {
+  public int indexOf(@Nullable Object object) {
     return delegateList().indexOf(object);
   }
 
-  public int lastIndexOf(@NullableDecl Object object) {
+  public int lastIndexOf(@Nullable Object object) {
     return delegateList().lastIndexOf(object);
   }
 
@@ -70,7 +70,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return object != null && delegateList().contains(object);
   }
 , @@ -21,7 +21,7 @@
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT implementation of {@link ImmutableMap} that forwards to another map.
@@ -57,15 +57,15 @@ public final boolean isEmpty() {
     return delegate.isEmpty();
   }
 
-  public final boolean containsKey(@NullableDecl Object key) {
+  public final boolean containsKey(@Nullable Object key) {
     return Maps.safeContainsKey(delegate, key);
   }
 
-  public final boolean containsValue(@NullableDecl Object value) {
+  public final boolean containsValue(@Nullable Object value) {
     return delegate.containsValue(value);
   }
 
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return (key == null) ? null : Maps.safeGet(delegate, key);
   }
 
@@ -119,7 +119,7 @@ public int size() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return delegate.equals(object);
   }
 , @@ -19,7 +19,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT implementation of {@link ImmutableSet} that forwards to another {@code Set} implementation.
@@ -41,7 +41,7 @@
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return object != null && delegate.contains(object);
   }
 , @@ -24,7 +24,7 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.Spliterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT emulated version of {@link ImmutableCollection}.
@@ -43,7 +43,7 @@
 
   public abstract UnmodifiableIterator<E> iterator();
 
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return object != null && super.contains(object);
   }
 , @@ -30,7 +30,7 @@
 import java.util.List;
 import java.util.RandomAccess;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT emulated version of {@link com.google.common.collect.ImmutableList}. TODO(cpovirk): more doc
@@ -216,12 +216,12 @@ private static void arrayCopy(Object[] dest, int pos, Object... source) {
   }
 
   @Override
-  public int indexOf(@NullableDecl Object object) {
+  public int indexOf(@Nullable Object object) {
     return (object == null) ? -1 : Lists.indexOfImpl(this, object);
   }
 
   @Override
-  public int lastIndexOf(@NullableDecl Object object) {
+  public int lastIndexOf(@Nullable Object object) {
     return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object);
   }
 
@@ -272,7 +272,7 @@ protected E get(int index) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     return Lists.equalsImpl(this, obj);
   }
 , @@ -37,7 +37,7 @@
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT emulation of {@link com.google.common.collect.ImmutableMap}. For non sorted maps, it is a
@@ -283,12 +283,12 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return get(key) != null;
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return values().contains(value);
   }
 
@@ -368,12 +368,12 @@ public int size() {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return ImmutableMap.this.containsKey(key);
     }
 
     @Override
-    public ImmutableSet<V> get(@NullableDecl Object key) {
+    public ImmutableSet<V> get(@Nullable Object key) {
       V outerValue = ImmutableMap.this.get(key);
       return (outerValue == null) ? null : ImmutableSet.of(outerValue);
     }
@@ -422,7 +422,7 @@ public K getKey() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return Maps.equalsImpl(this, object);
   }
 , @@ -29,7 +29,7 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * GWT emulation of {@link com.google.common.collect.ImmutableSortedSet}.
@@ -270,7 +270,7 @@ private static boolean hasSameComparator(Iterable<?> elements, Comparator<?> com
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     try {
       // This set never contains null.  We need to explicitly check here
       // because some comparator might throw NPE (e.g. the natural ordering)., @@ -32,7 +32,7 @@
 import java.util.concurrent.TimeoutException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Emulation for AbstractFuture in GWT. */
 public abstract class AbstractFuture<V> extends FluentFuture<V> {
@@ -192,7 +192,7 @@ final Throwable trustedGetException() {
     return throwable;
   }
 
-  final void maybePropagateCancellationTo(@NullableDecl Future<?> related) {
+  final void maybePropagateCancellationTo(@Nullable Future<?> related) {
     if (related != null & isCancelled()) {
       related.cancel(wasInterrupted());
     }
@@ -232,7 +232,7 @@ public String toString() {
    *
    * @return null if an explanation cannot be provided because the future is done.
    */
-  @NullableDecl
+  @Nullable
   String pendingToString() {
     if (state == State.DELEGATED) {
       return ""setFuture=["" + delegate + ""]"";, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Contains dummy collection implementations to convince GWT that part of serializing a collection
@@ -34,7 +34,7 @@
   private GwtSerializationDependencies() {}
 
   static final class OptionalDependencies<T> extends Optional<T> {
-    @NullableDecl T value;
+    @Nullable T value;
 
     OptionalDependencies() {
       super();
@@ -81,7 +81,7 @@ public T orNull() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       throw new AssertionError();
     }
 , @@ -22,6 +22,10 @@
       <groupId>org.checkerframework</groupId>
       <artifactId>checker-compat-qual</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.checkerframework</groupId>
+      <artifactId>checker-qual</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.errorprone</groupId>
       <artifactId>error_prone_annotations</artifactId>, @@ -36,7 +36,7 @@
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Tester for {@code Spliterator} implementations. */
 @GwtCompatible
@@ -104,7 +104,7 @@
     abstract <E> void forEach(Spliterator<E> spliterator, Consumer<? super E> consumer);
   }
 
-  @NullableDecl
+  @Nullable
   private static <E> Spliterator<E> trySplitTestingSize(Spliterator<E> spliterator) {
     boolean subsized = spliterator.hasCharacteristics(Spliterator.SUBSIZED);
     long originalSize = spliterator.estimateSize();, @@ -146,7 +146,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Supplies an arbitrary ""default"" instance for a wide range of types, often useful in testing
@@ -334,7 +334,7 @@ private static MatchResult newMatchResult() {
   }
 
   @SuppressWarnings(""unchecked"") // it's a subtype map
-  @NullableDecl
+  @Nullable
   private static <T> Class<? extends T> getImplementation(Class<T> type) {
     return (Class<? extends T>) implementations.get(type);
   }
@@ -345,7 +345,7 @@ private static MatchResult newMatchResult() {
    * Returns an arbitrary instance for {@code type}, or {@code null} if no arbitrary instance can be
    * determined.
    */
-  @NullableDecl
+  @Nullable
   public static <T> T get(Class<T> type) {
     T defaultValue = DEFAULTS.getInstance(type);
     if (defaultValue != null) {
@@ -389,7 +389,7 @@ private static MatchResult newMatchResult() {
     }
   }
 
-  @NullableDecl
+  @Nullable
   private static <T> T arbitraryConstantInstanceOrNull(Class<T> type) {
     Field[] fields = type.getDeclaredFields();
     Arrays.sort(fields, BY_FIELD_NAME);, @@ -29,7 +29,7 @@
 import java.util.Objects;
 import java.util.function.BiPredicate;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tester for {@code Collector} implementations.
@@ -140,8 +140,7 @@ private CollectorTester(
    * inputs, regardless of how the elements are divided.
    */
   @SafeVarargs
-  public final CollectorTester<T, A, R> expectCollects(
-      @NullableDecl R expectedResult, T... inputs) {
+  public final CollectorTester<T, A, R> expectCollects(@Nullable R expectedResult, T... inputs) {
     List<T> list = Arrays.asList(inputs);
     doExpectCollects(expectedResult, list);
     if (collector.characteristics().contains(Collector.Characteristics.UNORDERED)) {
@@ -151,7 +150,7 @@ private CollectorTester(
     return this;
   }
 
-  private void doExpectCollects(@NullableDecl R expectedResult, List<T> inputs) {
+  private void doExpectCollects(@Nullable R expectedResult, List<T> inputs) {
     for (CollectStrategy scheme : EnumSet.allOf(CollectStrategy.class)) {
       A finalAccum = scheme.result(collector, inputs);
       if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
@@ -161,7 +160,7 @@ private void doExpectCollects(@NullableDecl R expectedResult, List<T> inputs) {
     }
   }
 
-  private void assertEquivalent(@NullableDecl R expected, @NullableDecl R actual) {
+  private void assertEquivalent(@Nullable R expected, @Nullable R actual) {
     assertTrue(
         ""Expected "" + expected + "" got "" + actual + "" modulo equivalence "" + equivalence,
         equivalence.test(expected, actual));, @@ -122,7 +122,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.regex.Pattern;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Generates fresh instances of types that are different from each other (if possible).
@@ -179,7 +179,7 @@
    *   <li>null if no value can be generated.
    * </ul>
    */
-  @NullableDecl
+  @Nullable
   final Object generateFresh(TypeToken<?> type) {
     Object generated = generate(type);
     if (generated != null) {
@@ -188,7 +188,7 @@ final Object generateFresh(TypeToken<?> type) {
     return generated;
   }
 
-  @NullableDecl
+  @Nullable
   final <T> T generateFresh(Class<T> type) {
     return Primitives.wrap(type).cast(generateFresh(TypeToken.of(type)));
   }
@@ -303,7 +303,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof FreshInvocationHandler) {
         FreshInvocationHandler that = (FreshInvocationHandler) obj;
         return identity == that.identity;, @@ -46,14 +46,13 @@
 import java.util.concurrent.ConcurrentMap;
 import junit.framework.Assert;
 import junit.framework.AssertionFailedError;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A test utility that verifies that your methods and constructors throw {@link
  * NullPointerException} or {@link UnsupportedOperationException} whenever null is passed to a
- * parameter that isn't annotated with {@link javax.annotation.Nullable}, {@link
- * javax.annotation.CheckForNull}, or {@link
- * org.checkerframework.checker.nullness.compatqual.NullableDecl}.
+ * parameter whose declaration or type isn't annotated with an annotation with the simple name
+ * {@code Nullable}, {@lcode CheckForNull}, {@link NullableType}, or {@link NullableDecl}.
  *
  * <p>The tested methods and constructors are invoked -- each time with one parameter being null and
  * the rest not null -- and the test fails if no expected exception is thrown. {@code
@@ -176,7 +175,7 @@ public void testAllPublicInstanceMethods(Object instance) {
    *
    * @param instance the instance to invoke {@code method} on, or null if {@code method} is static
    */
-  public void testMethod(@NullableDecl Object instance, Method method) {
+  public void testMethod(@Nullable Object instance, Method method) {
     Class<?>[] types = method.getParameterTypes();
     for (int nullIndex = 0; nullIndex < types.length; nullIndex++) {
       testMethodParameter(instance, method, nullIndex);
@@ -208,7 +207,7 @@ public void testConstructor(Constructor<?> ctor) {
    * @param instance the instance to invoke {@code method} on, or null if {@code method} is static
    */
   public void testMethodParameter(
-      @NullableDecl final Object instance, final Method method, int paramIndex) {
+      @Nullable final Object instance, final Method method, int paramIndex) {
     method.setAccessible(true);
     testParameter(instance, invokable(instance, method), paramIndex, method.getDeclaringClass());
   }
@@ -461,7 +460,7 @@ protected F doBackward(T b) {
     }.newProxy(type);
   }
 
-  private static Invokable<?, ?> invokable(@NullableDecl Object instance, Method method) {
+  private static Invokable<?, ?> invokable(@Nullable Object instance, Method method) {
     if (instance == null) {
       return Invokable.from(method);
     } else {
@@ -503,7 +502,7 @@ private boolean isIgnored(Member member) {
    * Returns true if the the given member is a method that overrides {@link Object#equals(Object)}.
    *
    * <p>The documentation for {@link Object#equals} says it should accept null, so don't require an
-   * explicit {@code @NullableDecl} annotation (see <a
+   * explicit {@code @Nullable} annotation (see <a
    * href=""https://github.com/google/guava/issues/1819"">#1819</a>).
    *
    * <p>It is not necessary to consider visibility, return type, or type parameter declarations. The, @@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests may use this to intercept messages that are logged by the code under test. Example:
@@ -60,7 +60,7 @@
 
   /** Adds the most recently logged record to our list. */
   @Override
-  public synchronized void publish(@NullableDecl LogRecord record) {
+  public synchronized void publish(@Nullable LogRecord record) {
     list.add(record);
   }
 , @@ -38,7 +38,7 @@
 import java.util.stream.Stream;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit tests for {@link ClassSanityTester}.
@@ -60,7 +60,7 @@ public static Object good(
         // oneConstantOnly doesn't matter since it's not nullable and can be only 1 value.
         @SuppressWarnings(""unused"") OneConstantEnum oneConstantOnly,
         // noConstant doesn't matter since it can only be null
-        @SuppressWarnings(""unused"") @NullableDecl NoConstantEnum noConstant) {
+        @SuppressWarnings(""unused"") @Nullable NoConstantEnum noConstant) {
       return new GoodEquals(a, b);
     }
     // instance method ignored
@@ -107,7 +107,7 @@ public void testEqualsOnReturnValues_bad() throws Exception {
   private static class BadEqualsFactory {
     /** oneConstantOnly matters now since it can be either null or the constant. */
     @SuppressWarnings(""unused"") // Called by reflection
-    public static Object bad(String a, int b, @NullableDecl OneConstantEnum oneConstantOnly) {
+    public static Object bad(String a, int b, @Nullable OneConstantEnum oneConstantOnly) {
       return new GoodEquals(a, b);
     }
   }
@@ -287,7 +287,7 @@ public void testEqualsAndSerializableForReturnValues_factoryReturnsNullAndAnnota
   }
 
   public static class FactoryThatReturnsNullAndAnnotated {
-    @NullableDecl
+    @Nullable
     public static Object bad() {
       return null;
     }
@@ -483,7 +483,7 @@ public void testInstantiate_factoryMethodReturnsNullButNotAnnotated() throws Exc
     try {
       tester.instantiate(FactoryMethodReturnsNullButNotAnnotated.class);
     } catch (AssertionFailedError expected) {
-      assertThat(expected.getMessage()).contains(""@NullableDecl"");
+      assertThat(expected.getMessage()).contains(""@Nullable"");
       return;
     }
     fail(""should have failed"");
@@ -620,7 +620,7 @@ public HasAnInterface(AnInterface i) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof HasAnInterface) {
         HasAnInterface that = (HasAnInterface) obj;
         return i.equals(that.i);
@@ -677,7 +677,7 @@ public void testEquals_setOfNonInstantiable() throws Exception {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       // In general getClass().isInstance() is bad for equals.
       // But here we fully control the subclasses to ensure symmetry.
       if (getClass().isInstance(obj)) {
@@ -757,13 +757,13 @@ static GoodEquals create(String a, int b) {
 
     // keep trying
     @SuppressWarnings(""unused"")
-    @NullableDecl
+    @Nullable
     public static GoodEquals createMayReturnNull(int a, int b) {
       return null;
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof GoodEquals) {
         GoodEquals that = (GoodEquals) obj;
         return a.equals(that.a) && b == that.b;
@@ -782,12 +782,12 @@ public int hashCode() {
 
     public BadEquals() {} // ignored by testEquals() since it has less parameters.
 
-    public static BadEquals create(@SuppressWarnings(""unused"") @NullableDecl String s) {
+    public static BadEquals create(@SuppressWarnings(""unused"") @Nullable String s) {
       return new BadEquals();
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       return obj instanceof BadEquals;
     }
 
@@ -1136,7 +1136,7 @@ public static BadEqualsWithParameterizedType create(
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       return obj instanceof BadEqualsWithParameterizedType;
     }
 
@@ -1170,12 +1170,12 @@ public NoNullCheckNeededDespitNotInstantiable(NotInstantiable x) {
     void primitiveOnly(int i) {}
 
     @SuppressWarnings(""unused"") // reflected
-    void nullableOnly(@NullableDecl String s) {}
+    void nullableOnly(@Nullable String s) {}
 
     public void noParameter() {}
 
     @SuppressWarnings(""unused"") // reflected
-    void primitiveAndNullable(@NullableDecl String s, int i) {}
+    void primitiveAndNullable(@Nullable String s, int i) {}
   }
 
   static class FactoryMethodReturnsNullButNotAnnotated {
@@ -1189,7 +1189,7 @@ static FactoryMethodReturnsNullButNotAnnotated returnsNull() {
   static class FactoryMethodReturnsNullAndAnnotated {
     private FactoryMethodReturnsNullAndAnnotated() {}
 
-    @NullableDecl
+    @Nullable
     public static FactoryMethodReturnsNullAndAnnotated returnsNull() {
       return null;
     }
@@ -1203,7 +1203,7 @@ private FactoryMethodAcceptsNull(String name) {
       this.name = name;
     }
 
-    static FactoryMethodAcceptsNull create(@NullableDecl String name) {
+    static FactoryMethodAcceptsNull create(@Nullable String name) {
       return new FactoryMethodAcceptsNull(name);
     }
   }
@@ -1225,7 +1225,7 @@ public static FactoryMethodDoesNotAcceptNull create(String name) {
 
     final String name;
 
-    public ConstructorAcceptsNull(@NullableDecl String name) {
+    public ConstructorAcceptsNull(@Nullable String name) {
       this.name = name;
     }
   }
@@ -1251,7 +1251,7 @@ public ConstructorParameterMapOfNotInstantiable(Map<NotInstantiable, NotInstanti
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof ConstructorParameterMapOfNotInstantiable) {
         return m.equals(((ConstructorParameterMapOfNotInstantiable) obj).m);
       } else {
@@ -1272,7 +1272,7 @@ public ConstructorParameterWithOptionalNotInstantiable(Optional<NotInstantiable>
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       throw new UnsupportedOperationException();
     }
 , @@ -46,7 +46,7 @@
 import java.util.SortedSet;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@link NullPointerTester}.
@@ -90,7 +90,7 @@ public static void staticOneArgJsr305NullableCorrectlyDoesNotThrowNPE(
       // null?  no problem
     }
 
-    public static void staticOneArgNullableCorrectlyDoesNotThrowNPE(@NullableDecl String s) {
+    public static void staticOneArgNullableCorrectlyDoesNotThrowNPE(@Nullable String s) {
       // null?  no problem
     }
 
@@ -99,15 +99,15 @@ public static void staticOneArgCheckForNullCorrectlyThrowsOtherThanNPE(
       throw new FooException(); // ok, as long as it's not NullPointerException
     }
 
-    public static void staticOneArgNullableCorrectlyThrowsOtherThanNPE(@NullableDecl String s) {
+    public static void staticOneArgNullableCorrectlyThrowsOtherThanNPE(@Nullable String s) {
       throw new FooException(); // ok, as long as it's not NullPointerException
     }
 
     public static void staticOneArgCheckForNullThrowsNPE(@javax.annotation.CheckForNull String s) {
       checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
-    public static void staticOneArgNullableThrowsNPE(@NullableDecl String s) {
+    public static void staticOneArgNullableThrowsNPE(@Nullable String s) {
       checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
@@ -128,7 +128,7 @@ public void oneArgCheckForNullCorrectlyDoesNotThrowNPE(
       // null?  no problem
     }
 
-    public void oneArgNullableCorrectlyDoesNotThrowNPE(@NullableDecl String s) {
+    public void oneArgNullableCorrectlyDoesNotThrowNPE(@Nullable String s) {
       // null?  no problem
     }
 
@@ -137,15 +137,15 @@ public void oneArgCheckForNullCorrectlyThrowsOtherThanNPE(
       throw new FooException(); // ok, as long as it's not NullPointerException
     }
 
-    public void oneArgNullableCorrectlyThrowsOtherThanNPE(@NullableDecl String s) {
+    public void oneArgNullableCorrectlyThrowsOtherThanNPE(@Nullable String s) {
       throw new FooException(); // ok, as long as it's not NullPointerException
     }
 
     public void oneArgCheckForNullThrowsNPE(@javax.annotation.CheckForNull String s) {
       checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
     }
 
-    public void oneArgNullableThrowsNPE(@NullableDecl String s) {
+    public void oneArgNullableThrowsNPE(@Nullable String s) {
       checkNotNull(s); // doesn't check if you said you'd accept null, but you don't
     }
   }
@@ -397,17 +397,17 @@ public void normalNormal(String first, Integer second) {
     }
 
     /** Two-arg method with the second param Nullable. */
-    public void normalNullable(String first, @NullableDecl Integer second) {
+    public void normalNullable(String first, @Nullable Integer second) {
       reactToNullParameters(first, second);
     }
 
     /** Two-arg method with the first param Nullable. */
-    public void nullableNormal(@NullableDecl String first, Integer second) {
+    public void nullableNormal(@Nullable String first, Integer second) {
       reactToNullParameters(first, second);
     }
 
     /** Two-arg method with the both params Nullable. */
-    public void nullableNullable(@NullableDecl String first, @NullableDecl Integer second) {
+    public void nullableNullable(@Nullable String first, @Nullable Integer second) {
       reactToNullParameters(first, second);
     }
 
@@ -521,9 +521,9 @@ protected void protectedOneArg(String s) {
       checkNotNull(s);
     }
 
-    public void oneNullableArg(@NullableDecl String s) {}
+    public void oneNullableArg(@Nullable String s) {}
 
-    public void oneNullableArgThrows(@NullableDecl String s) {
+    public void oneNullableArgThrows(@Nullable String s) {
       doThrow(s);
     }
 
@@ -532,41 +532,41 @@ public void twoArg(String s, Integer i) {
       i.intValue();
     }
 
-    public void twoMixedArgs(String s, @NullableDecl Integer i) {
+    public void twoMixedArgs(String s, @Nullable Integer i) {
       checkNotNull(s);
     }
 
-    public void twoMixedArgs(@NullableDecl Integer i, String s) {
+    public void twoMixedArgs(@Nullable Integer i, String s) {
       checkNotNull(s);
     }
 
-    public void twoMixedArgsThrows(String s, @NullableDecl Integer i) {
+    public void twoMixedArgsThrows(String s, @Nullable Integer i) {
       checkNotNull(s);
       doThrow(i);
     }
 
-    public void twoMixedArgsThrows(@NullableDecl Integer i, String s) {
+    public void twoMixedArgsThrows(@Nullable Integer i, String s) {
       checkNotNull(s);
       doThrow(i);
     }
 
-    public void twoNullableArgs(@NullableDecl String s, @javax.annotation.Nullable Integer i) {}
+    public void twoNullableArgs(@Nullable String s, @javax.annotation.Nullable Integer i) {}
 
-    public void twoNullableArgsThrowsFirstArg(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgsThrowsFirstArg(@Nullable String s, @Nullable Integer i) {
       doThrow(s);
     }
 
-    public void twoNullableArgsThrowsSecondArg(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgsThrowsSecondArg(@Nullable String s, @Nullable Integer i) {
       doThrow(i);
     }
 
     public static void staticOneArg(String s) {
       checkNotNull(s);
     }
 
-    public static void staticOneNullableArg(@NullableDecl String s) {}
+    public static void staticOneNullableArg(@Nullable String s) {}
 
-    public static void staticOneNullableArgThrows(@NullableDecl String s) {
+    public static void staticOneNullableArgThrows(@Nullable String s) {
       doThrow(s);
     }
   }
@@ -599,7 +599,7 @@ public void testFailOneArgThrowsWrongType() {
 
   private static class PassOneNullableArgThrowsNPE extends PassObject {
     @Override
-    public void oneNullableArg(@NullableDecl String s) {
+    public void oneNullableArg(@Nullable String s) {
       checkNotNull(s); // ok to throw NPE
     }
   }
@@ -658,7 +658,7 @@ public void testFailTwoArgsSecondArgThrowsWrongType() {
 
   private static class FailTwoMixedArgsFirstArgDoesntThrowNPE extends PassObject {
     @Override
-    public void twoMixedArgs(String s, @NullableDecl Integer i) {
+    public void twoMixedArgs(String s, @Nullable Integer i) {
       // Fail: missing NPE for s
     }
   }
@@ -669,7 +669,7 @@ public void testFailTwoMixedArgsFirstArgDoesntThrowNPE() {
 
   private static class FailTwoMixedArgsFirstArgThrowsWrongType extends PassObject {
     @Override
-    public void twoMixedArgs(String s, @NullableDecl Integer i) {
+    public void twoMixedArgs(String s, @Nullable Integer i) {
       doThrow(s); // Fail:  throwing non-NPE exception for null s
     }
   }
@@ -680,7 +680,7 @@ public void testFailTwoMixedArgsFirstArgThrowsWrongType() {
 
   private static class PassTwoMixedArgsNullableArgThrowsNPE extends PassObject {
     @Override
-    public void twoMixedArgs(String s, @NullableDecl Integer i) {
+    public void twoMixedArgs(String s, @Nullable Integer i) {
       checkNotNull(s);
       i.intValue(); // ok to throw NPE?
     }
@@ -692,7 +692,7 @@ public void testPassTwoMixedArgsNullableArgThrowsNPE() {
 
   private static class PassTwoMixedArgSecondNullableArgThrowsOther extends PassObject {
     @Override
-    public void twoMixedArgs(String s, @NullableDecl Integer i) {
+    public void twoMixedArgs(String s, @Nullable Integer i) {
       checkNotNull(s);
       doThrow(i); // ok to throw non-NPE exception for null i
     }
@@ -704,7 +704,7 @@ public void testPassTwoMixedArgSecondNullableArgThrowsOther() {
 
   private static class FailTwoMixedArgsSecondArgDoesntThrowNPE extends PassObject {
     @Override
-    public void twoMixedArgs(@NullableDecl Integer i, String s) {
+    public void twoMixedArgs(@Nullable Integer i, String s) {
       // Fail: missing NPE for null s
     }
   }
@@ -715,7 +715,7 @@ public void testFailTwoMixedArgsSecondArgDoesntThrowNPE() {
 
   private static class FailTwoMixedArgsSecondArgThrowsWrongType extends PassObject {
     @Override
-    public void twoMixedArgs(@NullableDecl Integer i, String s) {
+    public void twoMixedArgs(@Nullable Integer i, String s) {
       doThrow(s); // Fail:  throwing non-NPE exception for null s
     }
   }
@@ -726,7 +726,7 @@ public void testFailTwoMixedArgsSecondArgThrowsWrongType() {
 
   private static class PassTwoNullableArgsFirstThrowsNPE extends PassObject {
     @Override
-    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
       checkNotNull(s); // ok to throw NPE?
     }
   }
@@ -737,7 +737,7 @@ public void testPassTwoNullableArgsFirstThrowsNPE() {
 
   private static class PassTwoNullableArgsFirstThrowsOther extends PassObject {
     @Override
-    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
       doThrow(s); // ok to throw non-NPE exception for null s
     }
   }
@@ -748,7 +748,7 @@ public void testPassTwoNullableArgsFirstThrowsOther() {
 
   private static class PassTwoNullableArgsSecondThrowsNPE extends PassObject {
     @Override
-    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
       i.intValue(); // ok to throw NPE?
     }
   }
@@ -759,7 +759,7 @@ public void testPassTwoNullableArgsSecondThrowsNPE() {
 
   private static class PassTwoNullableArgsSecondThrowsOther extends PassObject {
     @Override
-    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
       doThrow(i); // ok to throw non-NPE exception for null i
     }
   }
@@ -770,7 +770,7 @@ public void testPassTwoNullableArgsSecondThrowsOther() {
 
   private static class PassTwoNullableArgsNeitherThrowsAnything extends PassObject {
     @Override
-    public void twoNullableArgs(@NullableDecl String s, @NullableDecl Integer i) {
+    public void twoNullableArgs(@Nullable String s, @Nullable Integer i) {
       // ok to do nothing
     }
   }
@@ -816,7 +816,7 @@ public void testSubclassWithBadSuperclassForPackageProtectedMethod() {
 
   private static class SubclassThatOverridesBadSuperclassMethod extends BaseClassThatFailsToThrow {
     @Override
-    public void oneArg(@NullableDecl String s) {}
+    public void oneArg(@Nullable String s) {}
   }
 
   public void testSubclassThatOverridesBadSuperclassMethod() {
@@ -825,7 +825,7 @@ public void testSubclassThatOverridesBadSuperclassMethod() {
 
   @SuppressWarnings(""unused"") // for NullPointerTester
   private static class SubclassOverridesTheWrongMethod extends BaseClassThatFailsToThrow {
-    public void oneArg(@NullableDecl CharSequence s) {}
+    public void oneArg(@Nullable CharSequence s) {}
   }
 
   public void testSubclassOverridesTheWrongMethod() {
@@ -849,7 +849,7 @@ public void testSubclassThatFailsToThrowForStatic() {
 
   private static class SubclassThatTriesToOverrideBadStaticMethod
       extends ClassThatFailsToThrowForStatic {
-    static void staticOneArg(@NullableDecl String s) {}
+    static void staticOneArg(@Nullable String s) {}
   }
 
   public void testSubclassThatTriesToOverrideBadStaticMethod() {
@@ -862,7 +862,7 @@ private HardToCreate(HardToCreate x) {}
 
   @SuppressWarnings(""unused"") // used by reflection
   private static class CanCreateDefault {
-    public void foo(@NullableDecl HardToCreate ignored, String required) {
+    public void foo(@Nullable HardToCreate ignored, String required) {
       checkNotNull(required);
     }
   }
@@ -925,7 +925,7 @@ private static void shouldFail(Class<?> cls) {
 
   @SuppressWarnings(""unused"") // used by reflection
   private static class PrivateClassWithPrivateConstructor {
-    private PrivateClassWithPrivateConstructor(@NullableDecl Integer argument) {}
+    private PrivateClassWithPrivateConstructor(@Nullable Integer argument) {}
   }
 
   public void testPrivateClass() {, @@ -37,7 +37,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Benchmarks for {@link ConcurrentHashMultiset}.
@@ -192,7 +192,7 @@ private long runAddRemoveSingleThread(int reps) {
      * @return the nonnegative number of occurrences of the element
      */
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       try {
         return unbox(countMap.get(element));
       } catch (NullPointerException | ClassCastException e) {
@@ -295,7 +295,7 @@ public int add(E element, int occurrences) {
      * @throws IllegalArgumentException if {@code occurrences} is negative
      */
     @Override
-    public int remove(@NullableDecl Object element, int occurrences) {
+    public int remove(@Nullable Object element, int occurrences) {
       if (occurrences == 0) {
         return count(element);
       }
@@ -330,7 +330,7 @@ public int remove(@NullableDecl Object element, int occurrences) {
      * @param element the element whose occurrences should all be removed
      * @return the number of occurrences successfully removed, possibly zero
      */
-    private int removeAllOccurrences(@NullableDecl Object element) {
+    private int removeAllOccurrences(@Nullable Object element) {
       try {
         return unbox(countMap.remove(element));
       } catch (NullPointerException | ClassCastException e) {
@@ -349,7 +349,7 @@ private int removeAllOccurrences(@NullableDecl Object element) {
      * @param occurrences the number of occurrences of {@code element} to remove
      * @return {@code true} if the removal was possible (including if {@code occurrences} is zero)
      */
-    public boolean removeExactly(@NullableDecl Object element, int occurrences) {
+    public boolean removeExactly(@Nullable Object element, int occurrences) {
       if (occurrences == 0) {
         return true;
       }
@@ -543,7 +543,7 @@ public int hashCode() {
     }
 
     /** We use a special form of unboxing that treats null as zero. */
-    private static int unbox(@NullableDecl Integer i) {
+    private static int unbox(@Nullable Integer i) {
       return (i == null) ? 0 : i;
     }
   }, @@ -38,7 +38,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Benchmarks for {@link ExecutionList}. */
 @VmOptions({""-Xms8g"", ""-Xmx8g""})
@@ -488,7 +488,7 @@ private static void executeListener(Runnable runnable, Executor executor) {
     private static final class RunnableExecutorPair {
       final Runnable runnable;
       final Executor executor;
-      @NullableDecl RunnableExecutorPair next;
+      @Nullable RunnableExecutorPair next;
 
       RunnableExecutorPair(Runnable runnable, Executor executor, RunnableExecutorPair next) {
         this.runnable = runnable;
@@ -563,7 +563,7 @@ private static void executeListener(Runnable runnable, Executor executor) {
     private static final class RunnableExecutorPair {
       Runnable runnable;
       Executor executor;
-      @NullableDecl RunnableExecutorPair next;
+      @Nullable RunnableExecutorPair next;
 
       RunnableExecutorPair(Runnable runnable, Executor executor) {
         this.runnable = runnable;
@@ -669,7 +669,7 @@ public void execute() {
       final Runnable runnable;
       final Executor executor;
       // Volatile because this is written on one thread and read on another with no synchronization.
-      @NullableDecl volatile RunnableExecutorPair next;
+      @Nullable volatile RunnableExecutorPair next;
 
       RunnableExecutorPair(Runnable runnable, Executor executor) {
         this.runnable = runnable;, @@ -25,7 +25,7 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A bounded {@linkplain BlockingQueue blocking queue} backed by an array. This queue orders
@@ -388,7 +388,7 @@ public int remainingCapacity() {
    * @return <tt>true</tt> if this queue changed as a result of the call
    */
   @Override
-  public boolean remove(@NullableDecl Object o) {
+  public boolean remove(@Nullable Object o) {
     if (o == null) return false;
     final E[] items = this.items;
     final Monitor monitor = this.monitor;
@@ -418,7 +418,7 @@ public boolean remove(@NullableDecl Object o) {
    * @return <tt>true</tt> if this queue contains the specified element
    */
   @Override
-  public boolean contains(@NullableDecl Object o) {
+  public boolean contains(@Nullable Object o) {
     if (o == null) return false;
     final E[] items = this.items;
     final Monitor monitor = this.monitor;, @@ -30,7 +30,7 @@
 import java.util.SortedSet;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An unbounded {@linkplain BlockingQueue blocking queue} that uses the same ordering rules as class
@@ -124,7 +124,7 @@ public MonitorBasedPriorityBlockingQueue(int initialCapacity) {
    * @throws IllegalArgumentException if <tt>initialCapacity</tt> is less than 1
    */
   public MonitorBasedPriorityBlockingQueue(
-      int initialCapacity, @NullableDecl Comparator<? super E> comparator) {
+      int initialCapacity, @Nullable Comparator<? super E> comparator) {
     q = new PriorityQueue<E>(initialCapacity, comparator);
   }
 
@@ -303,7 +303,7 @@ public int remainingCapacity() {
    * @return <tt>true</tt> if this queue changed as a result of the call
    */
   @Override
-  public boolean remove(@NullableDecl Object o) {
+  public boolean remove(@Nullable Object o) {
     final Monitor monitor = this.monitor;
     monitor.enter();
     try {
@@ -322,7 +322,7 @@ public boolean remove(@NullableDecl Object o) {
    * @return <tt>true</tt> if this queue contains the specified element
    */
   @Override
-  public boolean contains(@NullableDecl Object o) {
+  public boolean contains(@Nullable Object o) {
     final Monitor monitor = this.monitor;
     monitor.enter();
     try {, @@ -29,6 +29,10 @@
       <groupId>org.checkerframework</groupId>
       <artifactId>checker-compat-qual</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.checkerframework</groupId>
+      <artifactId>checker-qual</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.errorprone</groupId>
       <artifactId>error_prone_annotations</artifactId>, @@ -26,7 +26,7 @@
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper class for creating {@link CacheBuilder} instances with all combinations of several sets of
@@ -120,7 +120,7 @@ CacheBuilderFactory withValueStrengths(Set<Strength> valueStrengths) {
   private static final Function<Object, Optional<?>> NULLABLE_TO_OPTIONAL =
       new Function<Object, Optional<?>>() {
         @Override
-        public Optional<?> apply(@NullableDecl Object obj) {
+        public Optional<?> apply(@Nullable Object obj) {
           return Optional.fromNullable(obj);
         }
       };, @@ -44,7 +44,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection of utilities for {@link Cache} testing.
@@ -367,7 +367,7 @@ static void processPendingNotifications(Cache<?, ?> cache) {
   }
 
   interface Receiver<T> {
-    void accept(@NullableDecl T object);
+    void accept(@Nullable T object);
   }
 
   /**, @@ -23,7 +23,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utility {@link CacheLoader} implementations intended for use in testing.
@@ -57,7 +57,7 @@ public V load(K key) throws Exception {
   }
 
   /** Returns a {@link CacheLoader} that returns the given {@code constant} for every request. */
-  static <K, V> ConstantLoader<K, V> constantLoader(@NullableDecl V constant) {
+  static <K, V> ConstantLoader<K, V> constantLoader(@Nullable V constant) {
     return new ConstantLoader<>(constant);
   }
 , @@ -44,7 +44,7 @@
 import java.util.stream.Stream;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@link FluentIterable}.
@@ -854,7 +854,7 @@ public void testUniqueIndex_nullValue() {
               .uniqueIndex(
                   new Function<Integer, Object>() {
                     @Override
-                    public Object apply(@NullableDecl Integer input) {
+                    public Object apply(@Nullable Integer input) {
                       return String.valueOf(input);
                     }
                   });, @@ -30,7 +30,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link ForwardingSortedMultiset}.
@@ -93,12 +93,12 @@
     }
 
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       return standardCount(element);
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return standardEquals(object);
     }
 
@@ -123,7 +123,7 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       return standardContains(object);
     }
 
@@ -143,7 +143,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object object) {
+    public boolean remove(@Nullable Object object) {
       return standardRemove(object);
     }
 , @@ -50,7 +50,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link ImmutableBiMap}.
@@ -656,7 +656,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       onEquals.run();
       return other instanceof CountsHashCodeAndEquals
           && delegateString.equals(((CountsHashCodeAndEquals) other).delegateString);, @@ -67,7 +67,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link ImmutableMap}.
@@ -871,7 +871,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       onEquals.run();
       return other instanceof CountsHashCodeAndEquals
           && delegateString.equals(((CountsHashCodeAndEquals) other).delegateString);, @@ -50,7 +50,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link ImmutableMultiset}.
@@ -694,7 +694,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       onEquals.run();
       return other instanceof CountsHashCodeAndEquals
           && delegateString.equals(((CountsHashCodeAndEquals) other).delegateString);, @@ -48,7 +48,7 @@
 import java.util.stream.Collector;
 import junit.framework.Test;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@link ImmutableSet}.
@@ -404,7 +404,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       onEquals.run();
       return other instanceof CountsHashCodeAndEquals
           && delegateString.equals(((CountsHashCodeAndEquals) other).delegateString);, @@ -52,7 +52,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Test suites for wrappers in {@code Maps}.
@@ -561,15 +561,15 @@ static void putEntries(Map<String, String> map, Entry<String, String>[] entries)
   static final Predicate<String> FILTER_KEYS =
       new Predicate<String>() {
         @Override
-        public boolean apply(@NullableDecl String string) {
+        public boolean apply(@Nullable String string) {
           return !""banana"".equals(string) && !""eggplant"".equals(string);
         }
       };
 
   static final Predicate<String> FILTER_VALUES =
       new Predicate<String>() {
         @Override
-        public boolean apply(@NullableDecl String string) {
+        public boolean apply(@Nullable String string) {
           return !""toast"".equals(string) && !""spam"".equals(string);
         }
       };, @@ -25,7 +25,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link Maps#transformValues}.
@@ -156,7 +156,7 @@ public void testTransformEqualityOfMapsWithNullValues() {
             underlying,
             new Function<String, Boolean>() {
               @Override
-              public Boolean apply(@NullableDecl String from) {
+              public Boolean apply(@Nullable String from) {
                 return from == null;
               }
             });
@@ -274,7 +274,7 @@ public void testTransformEntrySetContains() {
             underlying,
             new Function<Boolean, Boolean>() {
               @Override
-              public Boolean apply(@NullableDecl Boolean from) {
+              public Boolean apply(@Nullable Boolean from) {
                 return (from == null) ? true : null;
               }
             });, @@ -25,7 +25,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link Maps#transformValues} when the backing map's views have iterators that don't
@@ -232,7 +232,7 @@ public void testTransformEqualityOfMapsWithNullValues() {
             underlying,
             new Function<String, Boolean>() {
               @Override
-              public Boolean apply(@NullableDecl String from) {
+              public Boolean apply(@Nullable String from) {
                 return from == null;
               }
             });
@@ -350,7 +350,7 @@ public void testTransformEntrySetContains() {
             underlying,
             new Function<Boolean, Boolean>() {
               @Override
-              public Boolean apply(@NullableDecl Boolean from) {
+              public Boolean apply(@Nullable Boolean from) {
                 return (from == null) ? true : null;
               }
             });, @@ -62,7 +62,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@code Multimaps}.
@@ -324,8 +324,8 @@ private static void checkUnmodifiableMultimap(
   private static void checkUnmodifiableMultimap(
       Multimap<String, Integer> multimap,
       boolean permitsDuplicates,
-      @NullableDecl String nullKey,
-      @NullableDecl Integer nullValue) {
+      @Nullable String nullKey,
+      @Nullable Integer nullValue) {
     Multimap<String, Integer> unmodifiable =
         prepareUnmodifiableTests(multimap, permitsDuplicates, nullKey, nullValue);
 
@@ -354,8 +354,8 @@ private static void checkUnmodifiableMultimap(
   private static Multimap<String, Integer> prepareUnmodifiableTests(
       Multimap<String, Integer> multimap,
       boolean permitsDuplicates,
-      @NullableDecl String nullKey,
-      @NullableDecl Integer nullValue) {
+      @Nullable String nullKey,
+      @Nullable Integer nullValue) {
     multimap.clear();
     multimap.put(""foo"", 1);
     multimap.put(""foo"", 2);, @@ -41,7 +41,7 @@
 import java.util.Random;
 import java.util.RandomAccess;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit tests for {@code Ordering}.
@@ -1030,7 +1030,7 @@ void testSortedCopy() {
             scenario.ordering.onResultOf(
                 new Function<Integer, T>() {
                   @Override
-                  public T apply(@NullableDecl Integer from) {
+                  public T apply(@Nullable Integer from) {
                     return scenario.strictlyOrderedList.get(from);
                   }
                 });, @@ -76,7 +76,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@code Sets}.
@@ -1074,7 +1074,7 @@ public boolean apply(Set<Integer> input) {
    * same as the given comparator.
    */
   private static <E> void verifySortedSetContents(
-      SortedSet<E> set, Iterable<E> iterable, @NullableDecl Comparator<E> comparator) {
+      SortedSet<E> set, Iterable<E> iterable, @Nullable Comparator<E> comparator) {
     assertSame(comparator, set.comparator());
     verifySetContents(set, iterable);
   }, @@ -31,7 +31,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit test for {@link AbstractMultiset}.
@@ -106,7 +106,7 @@ public void clear() {
     }
 
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       for (Entry<E> entry : entrySet()) {
         if (Objects.equal(entry.getElement(), element)) {
           return entry.getCount();
@@ -116,7 +116,7 @@ public int count(@NullableDecl Object element) {
     }
 
     @Override
-    public int add(@NullableDecl E element, int occurrences) {
+    public int add(@Nullable E element, int occurrences) {
       checkArgument(occurrences >= 0);
       Integer frequency = backingMap.get(element);
       if (frequency == null) {, @@ -33,7 +33,7 @@
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@code Synchronized#multimap}.
@@ -89,7 +89,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       assertTrue(Thread.holdsLock(mutex));
       return super.equals(o);
     }
@@ -113,25 +113,25 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       assertTrue(Thread.holdsLock(mutex));
       return super.containsKey(key);
     }
 
     @Override
-    public boolean containsValue(@NullableDecl Object value) {
+    public boolean containsValue(@Nullable Object value) {
       assertTrue(Thread.holdsLock(mutex));
       return super.containsValue(value);
     }
 
     @Override
-    public boolean containsEntry(@NullableDecl Object key, @NullableDecl Object value) {
+    public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
       assertTrue(Thread.holdsLock(mutex));
       return super.containsEntry(key, value);
     }
 
     @Override
-    public Set<V> get(@NullableDecl K key) {
+    public Set<V> get(@Nullable K key) {
       assertTrue(Thread.holdsLock(mutex));
       /* TODO: verify that the Collection is also synchronized? */
       return super.get(key);
@@ -144,7 +144,7 @@ public boolean put(K key, V value) {
     }
 
     @Override
-    public boolean putAll(@NullableDecl K key, Iterable<? extends V> values) {
+    public boolean putAll(@Nullable K key, Iterable<? extends V> values) {
       assertTrue(Thread.holdsLock(mutex));
       return super.putAll(key, values);
     }
@@ -156,19 +156,19 @@ public boolean putAll(Multimap<? extends K, ? extends V> map) {
     }
 
     @Override
-    public Set<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+    public Set<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
       assertTrue(Thread.holdsLock(mutex));
       return super.replaceValues(key, values);
     }
 
     @Override
-    public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
+    public boolean remove(@Nullable Object key, @Nullable Object value) {
       assertTrue(Thread.holdsLock(mutex));
       return super.remove(key, value);
     }
 
     @Override
-    public Set<V> removeAll(@NullableDecl Object key) {
+    public Set<V> removeAll(@Nullable Object key) {
       assertTrue(Thread.holdsLock(mutex));
       return super.removeAll(key);
     }, @@ -27,7 +27,7 @@
 import java.util.Set;
 import junit.framework.Test;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@code Synchronized#set}.
@@ -80,7 +80,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       assertTrue(Thread.holdsLock(mutex));
       return super.equals(o);
     }
@@ -92,7 +92,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean add(@NullableDecl E o) {
+    public boolean add(@Nullable E o) {
       assertTrue(Thread.holdsLock(mutex));
       return super.add(o);
     }
@@ -110,7 +110,7 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       assertTrue(Thread.holdsLock(mutex));
       return super.contains(o);
     }
@@ -130,7 +130,7 @@ public boolean isEmpty() {
     /* Don't test iterator(); it may or may not hold the mutex. */
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       assertTrue(Thread.holdsLock(mutex));
       return super.remove(o);
     }, @@ -20,7 +20,7 @@
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 public class SynchronizedTableTest extends AbstractTableTest {
   private static final class TestTable<R, C, V> implements Table<R, C, V>, Serializable {
@@ -34,7 +34,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       assertTrue(Thread.holdsLock(mutex));
       return delegate.equals(o);
     }
@@ -58,7 +58,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean containsValue(@NullableDecl Object value) {
+    public boolean containsValue(@Nullable Object value) {
       assertTrue(Thread.holdsLock(mutex));
       return delegate.containsValue(value);
     }, @@ -38,7 +38,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Stream;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for SimpleGenericBloomFilter and derived BloomFilter views.
@@ -422,7 +422,7 @@ public void funnel(Long value, PrimitiveSink into) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return (object instanceof CustomFunnel);
     }
 , @@ -34,7 +34,7 @@
 import java.io.StringReader;
 import java.io.StringWriter;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@code BaseEncoding}.
@@ -388,7 +388,7 @@ private static void assertFailsToDecode(BaseEncoding encoding, String cannotDeco
   }
 
   private static void assertFailsToDecode(
-      BaseEncoding encoding, String cannotDecode, @NullableDecl String expectedMessage) {
+      BaseEncoding encoding, String cannotDecode, @Nullable String expectedMessage) {
     assertFalse(encoding.canDecode(cannotDecode));
     try {
       encoding.decode(cannotDecode);, @@ -31,7 +31,7 @@
 import java.util.List;
 import java.util.logging.LogRecord;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link Closer}.
@@ -435,7 +435,7 @@ static TestCloseable throwsOnCreate() throws IOException {
       throw new IOException();
     }
 
-    private TestCloseable(@NullableDecl Throwable throwOnClose) {
+    private TestCloseable(@Nullable Throwable throwOnClose) {
       this.throwOnClose = throwOnClose;
     }
 , @@ -40,7 +40,7 @@
 import java.util.Arrays;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@link SourceSinkFactory} implementations.
@@ -340,7 +340,7 @@ public ByteSource createSource(byte[] bytes) throws IOException {
 
     private final byte[] initialBytes;
 
-    private FileByteSinkFactory(@NullableDecl byte[] initialBytes) {
+    private FileByteSinkFactory(byte @Nullable [] initialBytes) {
       this.initialBytes = initialBytes;
     }
 
@@ -410,7 +410,7 @@ public String getExpected(String string) {
 
     private final String initialString;
 
-    private FileCharSinkFactory(@NullableDecl String initialString) {
+    private FileCharSinkFactory(@Nullable String initialString) {
       this.initialString = initialString;
     }
 
@@ -520,7 +520,7 @@ public ByteSource createSource(byte[] bytes) throws IOException {
 
     private final byte[] initialBytes;
 
-    private PathByteSinkFactory(@NullableDecl byte[] initialBytes) {
+    private PathByteSinkFactory(byte @Nullable [] initialBytes) {
       this.initialBytes = initialBytes;
     }
 
@@ -577,7 +577,7 @@ public String getExpected(String string) {
 
     private final String initialString;
 
-    private PathCharSinkFactory(@NullableDecl String initialString) {
+    private PathCharSinkFactory(@Nullable String initialString) {
       this.initialString = initialString;
     }
 , @@ -40,7 +40,7 @@
 import java.util.List;
 import java.util.Random;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Tests for {@link Quantiles}.
@@ -90,7 +90,7 @@
       new Correspondence<Double, Double>() {
 
         @Override
-        public boolean compare(@NullableDecl Double actual, @NullableDecl Double expected) {
+        public boolean compare(@Nullable Double actual, @Nullable Double expected) {
           // Test for equality to allow non-finite values to match; otherwise, use the finite test.
           return actual.equals(expected)
               || FINITE_QUANTILE_CORRESPONDENCE.compare(actual, expected);, @@ -30,7 +30,7 @@
 import java.lang.reflect.TypeVariable;
 import java.util.Collections;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit tests for {@link Invokable}.
@@ -343,7 +343,7 @@ public void testInnerClassWithOneParameterConstructor() {
 
   private class InnerWithAnnotatedConstructorParameter {
     @SuppressWarnings(""unused"") // called by reflection
-    InnerWithAnnotatedConstructorParameter(@NullableDecl String s) {}
+    InnerWithAnnotatedConstructorParameter(@Nullable String s) {}
   }
 
   public void testInnerClassWithAnnotatedConstructorParameter() {
@@ -506,7 +506,7 @@ public LocalWithOneParameterConstructor(String x) {
   public void testLocalClassWithAnnotatedConstructorParameter() throws Exception {
     class LocalWithAnnotatedConstructorParameter {
       @SuppressWarnings(""unused"") // called by reflection
-      LocalWithAnnotatedConstructorParameter(@NullableDecl String s) {}
+      LocalWithAnnotatedConstructorParameter(@Nullable String s) {}
     }
     Constructor<?> constructor =
         LocalWithAnnotatedConstructorParameter.class.getDeclaredConstructors()[0];, @@ -25,7 +25,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.AbstractQueuedSynchronizer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Utilities for the AbstractFutureBenchmarks */
 final class AbstractFutureBenchmarks {
@@ -218,7 +218,7 @@ public void addListener(Runnable listener, Executor exec) {
      * @return true if the state was successfully changed.
      */
     @CanIgnoreReturnValue
-    protected boolean set(@NullableDecl V value) {
+    protected boolean set(@Nullable V value) {
       boolean result = sync.set(value);
       if (result) {
         executionList.execute();
@@ -360,7 +360,7 @@ boolean wasInterrupted() {
       }
 
       /** Transition to the COMPLETED state and set the value. */
-      boolean set(@NullableDecl V v) {
+      boolean set(@Nullable V v) {
         return complete(v, null, COMPLETED);
       }
 
@@ -384,7 +384,7 @@ boolean cancel(boolean interrupt) {
        * @param t the exception to set as the result of the computation.
        * @param finalState the state to transition to.
        */
-      private boolean complete(@NullableDecl V v, @NullableDecl Throwable t, int finalState) {
+      private boolean complete(@Nullable V v, @Nullable Throwable t, int finalState) {
         boolean doCompletion = compareAndSetState(RUNNING, COMPLETING);
         if (doCompletion) {
           // If this thread successfully transitioned to COMPLETING, set the value
@@ -406,7 +406,7 @@ private boolean complete(@NullableDecl V v, @NullableDecl Throwable t, int final
     }
 
     static final CancellationException cancellationExceptionWithCause(
-        @NullableDecl String message, @NullableDecl Throwable cause) {
+        @Nullable String message, @Nullable Throwable cause) {
       CancellationException exception = new CancellationException(message);
       exception.initCause(cause);
       return exception;, @@ -25,7 +25,7 @@
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.Executor;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.mockito.Mockito;
 
 /**
@@ -157,8 +157,8 @@ public void execute(Runnable command) {
   }
 
   private final class MockCallback implements FutureCallback<String> {
-    @NullableDecl private String value = null;
-    @NullableDecl private Throwable failure = null;
+    @Nullable private String value = null;
+    @Nullable private Throwable failure = null;
     private boolean wasCalled = false;
 
     MockCallback(String expectedValue) {, @@ -90,7 +90,7 @@
 import java.util.logging.Logger;
 import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Unit tests for {@link Futures}.
@@ -3508,7 +3508,7 @@ public void testNonCancellationPropagating_doesNotPropagate() throws Exception {
   @GwtIncompatible // used only in GwtIncompatible tests
   private static class TestException extends Exception {
 
-    TestException(@NullableDecl Throwable cause) {
+    TestException(@Nullable Throwable cause) {
       super(cause);
     }
   }, @@ -29,7 +29,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Used to test listenable future implementations.
@@ -67,7 +67,7 @@ public void tearDown() {
     exec.shutdown();
   }
 
-  public void testCompletedFuture(@NullableDecl Object expectedValue)
+  public void testCompletedFuture(@Nullable Object expectedValue)
       throws InterruptedException, ExecutionException {
     assertTrue(future.isDone());
     assertFalse(future.isCancelled());
@@ -94,7 +94,7 @@ public void testCancelledFuture() throws InterruptedException, ExecutionExceptio
     }
   }
 
-  public void testFailedFuture(@NullableDecl String message) throws InterruptedException {
+  public void testFailedFuture(@Nullable String message) throws InterruptedException {
     assertTrue(future.isDone());
     assertFalse(future.isCancelled());
 , @@ -29,7 +29,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import junit.framework.AssertionFailedError;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A helper for concurrency testing. One or more {@code TestThread} instances are instantiated in a
@@ -168,15 +168,15 @@ public void callAndAssertWaits(String methodName, Object conditionLikeObject) th
    * Asserts that a prior call that had caused this thread to block or wait has since returned
    * normally.
    */
-  public void assertPriorCallReturns(@NullableDecl String methodName) throws Exception {
+  public void assertPriorCallReturns(@Nullable String methodName) throws Exception {
     assertEquals(null, getResponse(methodName).getResult());
   }
 
   /**
    * Asserts that a prior call that had caused this thread to block or wait has since returned the
    * expected boolean value.
    */
-  public void assertPriorCallReturns(boolean expected, @NullableDecl String methodName)
+  public void assertPriorCallReturns(boolean expected, @Nullable String methodName)
       throws Exception {
     assertEquals(expected, getResponse(methodName).getResult());
   }, @@ -24,6 +24,10 @@
       <groupId>org.checkerframework</groupId>
       <artifactId>checker-compat-qual</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.checkerframework</groupId>
+      <artifactId>checker-qual</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.errorprone</groupId>
       <artifactId>error_prone_annotations</artifactId>, @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.util.Collections;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Implementation of an {@link Optional} not containing a reference. */
 @GwtCompatible
@@ -61,7 +61,7 @@ public T or(Supplier<? extends T> supplier) {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public T orNull() {
     return null;
   }
@@ -78,7 +78,7 @@ public T orNull() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this;
   }
 , @@ -20,7 +20,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Note this class is a copy of {@link com.google.common.collect.AbstractIterator} (for dependency
@@ -39,11 +39,11 @@ protected AbstractIterator() {}
     FAILED,
   }
 
-  @NullableDecl private T next;
+  @Nullable private T next;
 
   protected abstract T computeNext();
 
-  @NullableDecl
+  @Nullable
   @CanIgnoreReturnValue
   protected final T endOfData() {
     state = State.DONE;, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utility class for converting between various ASCII case formats. Behavior is undefined for
@@ -174,7 +174,7 @@ protected String doBackward(String s) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof StringConverter) {
         StringConverter that = (StringConverter) object;
         return sourceFormat.equals(that.sourceFormat) && targetFormat.equals(that.targetFormat);, @@ -23,7 +23,7 @@
 import java.io.Serializable;
 import java.util.Iterator;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}
@@ -164,14 +164,14 @@ protected Converter() {
    *
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
-  @NullableDecl
+  @Nullable
   @CanIgnoreReturnValue
-  public final B convert(@NullableDecl A a) {
+  public final B convert(@Nullable A a) {
     return correctedDoForward(a);
   }
 
-  @NullableDecl
-  B correctedDoForward(@NullableDecl A a) {
+  @Nullable
+  B correctedDoForward(@Nullable A a) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return a == null ? null : checkNotNull(doForward(a));
@@ -180,8 +180,8 @@ B correctedDoForward(@NullableDecl A a) {
     }
   }
 
-  @NullableDecl
-  A correctedDoBackward(@NullableDecl B b) {
+  @Nullable
+  A correctedDoBackward(@Nullable B b) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return b == null ? null : checkNotNull(doBackward(b));
@@ -266,14 +266,14 @@ protected B doBackward(A a) {
     }
 
     @Override
-    @NullableDecl
-    A correctedDoForward(@NullableDecl B b) {
+    @Nullable
+    A correctedDoForward(@Nullable B b) {
       return original.correctedDoBackward(b);
     }
 
     @Override
-    @NullableDecl
-    B correctedDoBackward(@NullableDecl A a) {
+    @Nullable
+    B correctedDoBackward(@Nullable A a) {
       return original.correctedDoForward(a);
     }
 
@@ -283,7 +283,7 @@ B correctedDoBackward(@NullableDecl A a) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof ReverseConverter) {
         ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;
         return this.original.equals(that.original);
@@ -348,19 +348,19 @@ protected A doBackward(C c) {
     }
 
     @Override
-    @NullableDecl
-    C correctedDoForward(@NullableDecl A a) {
+    @Nullable
+    C correctedDoForward(@Nullable A a) {
       return second.correctedDoForward(first.correctedDoForward(a));
     }
 
     @Override
-    @NullableDecl
-    A correctedDoBackward(@NullableDecl C c) {
+    @Nullable
+    A correctedDoBackward(@Nullable C c) {
       return first.correctedDoBackward(second.correctedDoBackward(c));
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof ConverterComposition) {
         ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;
         return this.first.equals(that.first) && this.second.equals(that.second);
@@ -386,9 +386,9 @@ public String toString() {
    */
   @Deprecated
   @Override
-  @NullableDecl
+  @Nullable
   @CanIgnoreReturnValue
-  public final B apply(@NullableDecl A a) {
+  public final B apply(@Nullable A a) {
     return convert(a);
   }
 
@@ -404,7 +404,7 @@ public final B apply(@NullableDecl A a) {
    * interchangeable.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return super.equals(object);
   }
 
@@ -453,7 +453,7 @@ protected A doBackward(B b) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof FunctionBasedConverter) {
         FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;
         return this.forwardFunction.equals(that.forwardFunction), @@ -17,7 +17,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides default values for all Java types, as defined by the JLS.
@@ -37,7 +37,7 @@ private Defaults() {}
    * false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
    * {@code void}, {@code null} is returned.
    */
-  @NullableDecl
+  @Nullable
   @SuppressWarnings(""unchecked"")
   public static <T> T defaultValue(Class<T> type) {
     checkNotNull(type);, @@ -25,7 +25,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.WeakHashMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utility methods for working with {@link Enum} instances.
@@ -128,7 +128,7 @@ protected String doBackward(T enumValue) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof StringConverter) {
         StringConverter<?> that = (StringConverter<?>) object;
         return this.enumClass.equals(that.enumClass);, @@ -20,7 +20,7 @@
 import com.google.errorprone.annotations.ForOverride;
 import java.io.Serializable;
 import java.util.function.BiPredicate;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A strategy for determining whether two instances are considered equivalent, and for computing
@@ -55,7 +55,7 @@ protected Equivalence() {}
    * <p>Note that all calls to {@code equivalent(x, y)} are expected to return the same result as
    * long as neither {@code x} nor {@code y} is modified.
    */
-  public final boolean equivalent(@NullableDecl T a, @NullableDecl T b) {
+  public final boolean equivalent(@Nullable T a, @Nullable T b) {
     if (a == b) {
       return true;
     }
@@ -72,7 +72,7 @@ public final boolean equivalent(@NullableDecl T a, @NullableDecl T b) {
    */
   @Deprecated
   @Override
-  public final boolean test(@NullableDecl T t, @NullableDecl T u) {
+  public final boolean test(@Nullable T t, @Nullable T u) {
     return equivalent(t, u);
   }
 
@@ -105,7 +105,7 @@ public final boolean test(@NullableDecl T t, @NullableDecl T u) {
    *   <li>{@code hash(null)} is {@code 0}.
    * </ul>
    */
-  public final int hash(@NullableDecl T t) {
+  public final int hash(@Nullable T t) {
     if (t == null) {
       return 0;
     }
@@ -158,7 +158,7 @@ public final int hash(@NullableDecl T t) {
    *
    * @since 10.0
    */
-  public final <S extends T> Wrapper<S> wrap(@NullableDecl S reference) {
+  public final <S extends T> Wrapper<S> wrap(@Nullable S reference) {
     return new Wrapper<S>(this, reference);
   }
 
@@ -184,15 +184,15 @@ public final int hash(@NullableDecl T t) {
    */
   public static final class Wrapper<T> implements Serializable {
     private final Equivalence<? super T> equivalence;
-    @NullableDecl private final T reference;
+    @Nullable private final T reference;
 
-    private Wrapper(Equivalence<? super T> equivalence, @NullableDecl T reference) {
+    private Wrapper(Equivalence<? super T> equivalence, @Nullable T reference) {
       this.equivalence = checkNotNull(equivalence);
       this.reference = reference;
     }
 
     /** Returns the (possibly null) reference wrapped by this instance. */
-    @NullableDecl
+    @Nullable
     public T get() {
       return reference;
     }
@@ -203,7 +203,7 @@ public T get() {
      * equivalence.
      */
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj == this) {
         return true;
       }
@@ -265,27 +265,27 @@ public String toString() {
    *
    * @since 10.0
    */
-  public final Predicate<T> equivalentTo(@NullableDecl T target) {
+  public final Predicate<T> equivalentTo(@Nullable T target) {
     return new EquivalentToPredicate<T>(this, target);
   }
 
   private static final class EquivalentToPredicate<T> implements Predicate<T>, Serializable {
 
     private final Equivalence<T> equivalence;
-    @NullableDecl private final T target;
+    @Nullable private final T target;
 
-    EquivalentToPredicate(Equivalence<T> equivalence, @NullableDecl T target) {
+    EquivalentToPredicate(Equivalence<T> equivalence, @Nullable T target) {
       this.equivalence = checkNotNull(equivalence);
       this.target = target;
     }
 
     @Override
-    public boolean apply(@NullableDecl T input) {
+    public boolean apply(@Nullable T input) {
       return equivalence.equivalent(input, target);
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (this == obj) {
         return true;
       }, @@ -27,7 +27,7 @@
 import java.net.URLClassLoader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A reference queue with an associated background thread that dequeues references and invokes
@@ -228,7 +228,7 @@ void cleanUp() {
      *
      * @throws SecurityException if we don't have the appropriate privileges
      */
-    @NullableDecl
+    @Nullable
     Class<?> loadFinalizer();
   }
 
@@ -241,7 +241,7 @@ void cleanUp() {
     // finding Finalizer on the system class path even if it is there.
     @VisibleForTesting static boolean disabled;
 
-    @NullableDecl
+    @Nullable
     @Override
     public Class<?> loadFinalizer() {
       if (disabled) {
@@ -279,7 +279,7 @@ void cleanUp() {
             + ""loader. To support reclaiming this class loader, either resolve the underlying ""
             + ""issue, or move Guava to your system class path."";
 
-    @NullableDecl
+    @Nullable
     @Override
     public Class<?> loadFinalizer() {
       try {, @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Legacy version of {@link java.util.function.Function java.util.function.Function}.
@@ -43,9 +43,9 @@
 @FunctionalInterface
 public interface Function<F, T> extends java.util.function.Function<F, T> {
   @Override
-  @NullableDecl
+  @Nullable
   @CanIgnoreReturnValue // TODO(kevinb): remove this
-  T apply(@NullableDecl F input);
+  T apply(@Nullable F input);
 
   /**
    * <i>May</i> return {@code true} if {@code object} is a {@code Function} that behaves identically
@@ -59,5 +59,5 @@
    * disappear. It is best not to depend on it.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Equivalence applied on functional result.
@@ -52,7 +52,7 @@ protected int doHash(F a) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     }, @@ -20,7 +20,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code com.google.common.base.Function} instances; see that
@@ -88,8 +88,8 @@ public String toString() {
     INSTANCE;
 
     @Override
-    @NullableDecl
-    public Object apply(@NullableDecl Object o) {
+    @Nullable
+    public Object apply(@Nullable Object o) {
       return o;
     }
 
@@ -129,8 +129,7 @@ public String toString() {
    * @return function that returns {@code map.get(a)} when {@code a} is a key, or {@code
    *     defaultValue} otherwise
    */
-  public static <K, V> Function<K, V> forMap(
-      Map<K, ? extends V> map, @NullableDecl V defaultValue) {
+  public static <K, V> Function<K, V> forMap(Map<K, ? extends V> map, @Nullable V defaultValue) {
     return new ForMapWithDefault<>(map, defaultValue);
   }
 
@@ -142,14 +141,14 @@ public String toString() {
     }
 
     @Override
-    public V apply(@NullableDecl K key) {
+    public V apply(@Nullable K key) {
       V result = map.get(key);
       checkArgument(result != null || map.containsKey(key), ""Key '%s' not present in map"", key);
       return result;
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof FunctionForMapNoDefault) {
         FunctionForMapNoDefault<?, ?> that = (FunctionForMapNoDefault<?, ?>) o;
         return map.equals(that.map);
@@ -172,21 +171,21 @@ public String toString() {
 
   private static class ForMapWithDefault<K, V> implements Function<K, V>, Serializable {
     final Map<K, ? extends V> map;
-    @NullableDecl final V defaultValue;
+    @Nullable final V defaultValue;
 
-    ForMapWithDefault(Map<K, ? extends V> map, @NullableDecl V defaultValue) {
+    ForMapWithDefault(Map<K, ? extends V> map, @Nullable V defaultValue) {
       this.map = checkNotNull(map);
       this.defaultValue = defaultValue;
     }
 
     @Override
-    public V apply(@NullableDecl K key) {
+    public V apply(@Nullable K key) {
       V result = map.get(key);
       return (result != null || map.containsKey(key)) ? result : defaultValue;
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof ForMapWithDefault) {
         ForMapWithDefault<?, ?> that = (ForMapWithDefault<?, ?>) o;
         return map.equals(that.map) && Objects.equal(defaultValue, that.defaultValue);
@@ -234,12 +233,12 @@ public FunctionComposition(Function<B, C> g, Function<A, ? extends B> f) {
     }
 
     @Override
-    public C apply(@NullableDecl A a) {
+    public C apply(@Nullable A a) {
       return g.apply(f.apply(a));
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof FunctionComposition) {
         FunctionComposition<?, ?, ?> that = (FunctionComposition<?, ?, ?>) obj;
         return f.equals(that.f) && g.equals(that.g);
@@ -282,12 +281,12 @@ private PredicateFunction(Predicate<T> predicate) {
     }
 
     @Override
-    public Boolean apply(@NullableDecl T t) {
+    public Boolean apply(@Nullable T t) {
       return predicate.apply(t);
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof PredicateFunction) {
         PredicateFunction<?> that = (PredicateFunction<?>) obj;
         return predicate.equals(that.predicate);
@@ -316,24 +315,24 @@ public String toString() {
    * @param value the constant value for the function to return
    * @return a function that always returns {@code value}
    */
-  public static <E> Function<Object, E> constant(@NullableDecl E value) {
+  public static <E> Function<Object, E> constant(@Nullable E value) {
     return new ConstantFunction<E>(value);
   }
 
   private static class ConstantFunction<E> implements Function<Object, E>, Serializable {
-    @NullableDecl private final E value;
+    @Nullable private final E value;
 
-    public ConstantFunction(@NullableDecl E value) {
+    public ConstantFunction(@Nullable E value) {
       this.value = value;
     }
 
     @Override
-    public E apply(@NullableDecl Object from) {
+    public E apply(@Nullable Object from) {
       return value;
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof ConstantFunction) {
         ConstantFunction<?> that = (ConstantFunction<?>) obj;
         return Objects.equal(value, that.value);
@@ -375,12 +374,12 @@ private SupplierFunction(Supplier<T> supplier) {
     }
 
     @Override
-    public T apply(@NullableDecl Object input) {
+    public T apply(@Nullable Object input) {
       return supplier.get();
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof SupplierFunction) {
         SupplierFunction<?> that = (SupplierFunction<?>) obj;
         return this.supplier.equals(that.supplier);, @@ -25,7 +25,7 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object which joins pieces of text (specified as an array, {@link Iterable}, varargs or even a
@@ -124,7 +124,7 @@ private Joiner(Joiner prototype) {
   /** Appends to {@code appendable} the string representation of each of the remaining arguments. */
   @CanIgnoreReturnValue
   public final <A extends Appendable> A appendTo(
-      A appendable, @NullableDecl Object first, @NullableDecl Object second, Object... rest)
+      A appendable, @Nullable Object first, @Nullable Object second, Object... rest)
       throws IOException {
     return appendTo(appendable, iterable(first, second, rest));
   }
@@ -173,10 +173,7 @@ public final StringBuilder appendTo(StringBuilder builder, Object[] parts) {
    */
   @CanIgnoreReturnValue
   public final StringBuilder appendTo(
-      StringBuilder builder,
-      @NullableDecl Object first,
-      @NullableDecl Object second,
-      Object... rest) {
+      StringBuilder builder, @Nullable Object first, @Nullable Object second, Object... rest) {
     return appendTo(builder, iterable(first, second, rest));
   }
 
@@ -210,8 +207,7 @@ public final String join(Object[] parts) {
    * Returns a string containing the string representation of each argument, using the previously
    * configured separator between each.
    */
-  public final String join(
-      @NullableDecl Object first, @NullableDecl Object second, Object... rest) {
+  public final String join(@Nullable Object first, @Nullable Object second, Object... rest) {
     return join(iterable(first, second, rest));
   }
 
@@ -223,7 +219,7 @@ public Joiner useForNull(final String nullText) {
     checkNotNull(nullText);
     return new Joiner(this) {
       @Override
-      CharSequence toString(@NullableDecl Object part) {
+      CharSequence toString(@Nullable Object part) {
         return (part == null) ? nullText : Joiner.this.toString(part);
       }
 , @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper functions that operate on any {@code Object}, and are not already provided in {@link
@@ -51,7 +51,7 @@
    * @throws NullPointerException if both {@code first} and {@code second} are null
    * @since 18.0 (since 3.0 as {@code Objects.firstNonNull()}).
    */
-  public static <T> T firstNonNull(@NullableDecl T first, @NullableDecl T second) {
+  public static <T> T firstNonNull(@Nullable T first, @Nullable T second) {
     if (first != null) {
       return first;
     }
@@ -167,7 +167,7 @@ public ToStringHelper omitNullValues() {
      * called, in which case this name/value pair will not be added.
      */
     @CanIgnoreReturnValue
-    public ToStringHelper add(String name, @NullableDecl Object value) {
+    public ToStringHelper add(String name, @Nullable Object value) {
       return addHolder(name, value);
     }
 
@@ -238,7 +238,7 @@ public ToStringHelper add(String name, long value) {
      * readable name.
      */
     @CanIgnoreReturnValue
-    public ToStringHelper addValue(@NullableDecl Object value) {
+    public ToStringHelper addValue(@Nullable Object value) {
       return addHolder(value);
     }
 
@@ -363,23 +363,23 @@ private ValueHolder addHolder() {
       return valueHolder;
     }
 
-    private ToStringHelper addHolder(@NullableDecl Object value) {
+    private ToStringHelper addHolder(@Nullable Object value) {
       ValueHolder valueHolder = addHolder();
       valueHolder.value = value;
       return this;
     }
 
-    private ToStringHelper addHolder(String name, @NullableDecl Object value) {
+    private ToStringHelper addHolder(String name, @Nullable Object value) {
       ValueHolder valueHolder = addHolder();
       valueHolder.value = value;
       valueHolder.name = checkNotNull(name);
       return this;
     }
 
     private static final class ValueHolder {
-      @NullableDecl String name;
-      @NullableDecl Object value;
-      @NullableDecl ValueHolder next;
+      @Nullable String name;
+      @Nullable Object value;
+      @Nullable ValueHolder next;
     }
   }
 , @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Helper functions that can operate on any {@code Object}.
@@ -48,7 +48,7 @@ private Objects() {}
    * <p><b>Note for Java 7 and later:</b> This method should be treated as deprecated; use {@link
    * java.util.Objects#equals} instead.
    */
-  public static boolean equal(@NullableDecl Object a, @NullableDecl Object b) {
+  public static boolean equal(@Nullable Object a, @Nullable Object b) {
     return a == b || (a != null && a.equals(b));
   }
 
@@ -73,7 +73,7 @@ public static boolean equal(@NullableDecl Object a, @NullableDecl Object b) {
    * <p><b>Note for Java 7 and later:</b> This method should be treated as deprecated; use {@link
    * java.util.Objects#hash} instead.
    */
-  public static int hashCode(@NullableDecl Object... objects) {
+  public static int hashCode(Object @Nullable... objects) {
     return Arrays.hashCode(objects);
   }
 }, @@ -21,7 +21,7 @@
 import java.io.Serializable;
 import java.util.Iterator;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable object that may contain a non-null reference to another object. Each instance of
@@ -110,7 +110,7 @@
    * <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
    * {@code Optional.ofNullable}.
    */
-  public static <T> Optional<T> fromNullable(@NullableDecl T nullableReference) {
+  public static <T> Optional<T> fromNullable(@Nullable T nullableReference) {
     return (nullableReference == null) ? Optional.<T>absent() : new Present<T>(nullableReference);
   }
 
@@ -120,8 +120,8 @@
    *
    * @since 21.0
    */
-  @NullableDecl
-  public static <T> Optional<T> fromJavaUtil(@NullableDecl java.util.Optional<T> javaUtilOptional) {
+  @Nullable
+  public static <T> Optional<T> fromJavaUtil(java.util.@Nullable Optional<T> javaUtilOptional) {
     return (javaUtilOptional == null) ? null : fromNullable(javaUtilOptional.orElse(null));
   }
 
@@ -138,8 +138,8 @@
    *
    * @since 21.0
    */
-  @NullableDecl
-  public static <T> java.util.Optional<T> toJavaUtil(@NullableDecl Optional<T> googleOptional) {
+  public static <T> java.util.@Nullable Optional<T> toJavaUtil(
+      @Nullable Optional<T> googleOptional) {
     return googleOptional == null ? null : googleOptional.toJavaUtil();
   }
 
@@ -246,7 +246,7 @@
    * <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
    * {@code Optional.orElse(null)}.
    */
-  @NullableDecl
+  @Nullable
   public abstract T orNull();
 
   /**
@@ -293,7 +293,7 @@
    * <p><b>Comparison to {@code java.util.Optional}:</b> no differences.
    */
   @Override
-  public abstract boolean equals(@NullableDecl Object object);
+  public abstract boolean equals(@Nullable Object object);
 
   /**
    * Returns a hash code for this instance., @@ -17,7 +17,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 @GwtCompatible(serializable = true)
 final class PairwiseEquivalence<T> extends Equivalence<Iterable<T>> implements Serializable {
@@ -52,7 +52,7 @@ protected int doHash(Iterable<T> iterable) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof PairwiseEquivalence) {
       PairwiseEquivalence<?> that = (PairwiseEquivalence<?>) object;
       return this.elementEquivalence.equals(that.elementEquivalence);, @@ -23,7 +23,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.regex.Pattern;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Methods factored out so that they can be emulated differently in GWT.
@@ -55,15 +55,15 @@ static String formatCompact4Digits(double value) {
     return String.format(Locale.ROOT, ""%.4g"", value);
   }
 
-  static boolean stringIsNullOrEmpty(@NullableDecl String string) {
+  static boolean stringIsNullOrEmpty(@Nullable String string) {
     return string == null || string.isEmpty();
   }
 
-  static String nullToEmpty(@NullableDecl String string) {
+  static String nullToEmpty(@Nullable String string) {
     return (string == null) ? """" : string;
   }
 
-  static String emptyToNull(@NullableDecl String string) {
+  static String emptyToNull(@Nullable String string) {
     return stringIsNullOrEmpty(string) ? null : string;
   }
 , @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static convenience methods that help a method or constructor check whether it was invoked
@@ -130,7 +130,7 @@ public static void checkArgument(boolean expression) {
    *     string using {@link String#valueOf(Object)}
    * @throws IllegalArgumentException if {@code expression} is false
    */
-  public static void checkArgument(boolean expression, @NullableDecl Object errorMessage) {
+  public static void checkArgument(boolean expression, @Nullable Object errorMessage) {
     if (!expression) {
       throw new IllegalArgumentException(String.valueOf(errorMessage));
     }
@@ -151,8 +151,8 @@ public static void checkArgument(boolean expression, @NullableDecl Object errorM
    */
   public static void checkArgument(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object... errorMessageArgs) {
+      @Nullable String errorMessageTemplate,
+      Object @Nullable... errorMessageArgs) {
     if (!expression) {
       throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
     }
@@ -165,7 +165,7 @@ public static void checkArgument(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, char p1) {
+  public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
@@ -178,7 +178,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, int p1) {
+  public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
@@ -191,7 +191,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, long p1) {
+  public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
@@ -205,7 +205,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1));
     }
@@ -219,7 +219,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -233,7 +233,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, int p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -247,7 +247,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -261,7 +261,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -275,7 +275,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -289,7 +289,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, int p2) {
+      boolean b, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -303,7 +303,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -317,7 +317,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -331,7 +331,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -345,7 +345,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, int p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -359,7 +359,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -373,7 +373,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -387,7 +387,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -401,7 +401,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -415,7 +415,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -429,10 +429,7 @@ public static void checkArgument(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkArgument(
-      boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
     }
@@ -447,10 +444,10 @@ public static void checkArgument(
    */
   public static void checkArgument(
       boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3));
     }
@@ -465,11 +462,11 @@ public static void checkArgument(
    */
   public static void checkArgument(
       boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3,
-      @NullableDecl Object p4) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3,
+      @Nullable Object p4) {
     if (!b) {
       throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
     }
@@ -499,7 +496,7 @@ public static void checkState(boolean expression) {
    * @throws IllegalStateException if {@code expression} is false
    * @see Verify#verify Verify.verify()
    */
-  public static void checkState(boolean expression, @NullableDecl Object errorMessage) {
+  public static void checkState(boolean expression, @Nullable Object errorMessage) {
     if (!expression) {
       throw new IllegalStateException(String.valueOf(errorMessage));
     }
@@ -522,8 +519,8 @@ public static void checkState(boolean expression, @NullableDecl Object errorMess
    */
   public static void checkState(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object... errorMessageArgs) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object @Nullable... errorMessageArgs) {
     if (!expression) {
       throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
     }
@@ -537,7 +534,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, char p1) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
@@ -551,7 +548,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, int p1) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
@@ -565,7 +562,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, long p1) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
@@ -580,7 +577,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1));
     }
@@ -595,7 +592,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -609,8 +606,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, int p2) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -625,7 +621,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -640,7 +636,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -654,8 +650,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, char p2) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -669,8 +664,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, int p2) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -684,8 +678,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, long p2) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -700,7 +693,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -715,7 +708,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -729,8 +722,7 @@ public static void checkState(
    *
    * @since 20.0 (varargs overload since 2.0)
    */
-  public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, int p2) {
+  public static void checkState(boolean b, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -745,7 +737,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -760,7 +752,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -775,7 +767,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -790,7 +782,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -805,7 +797,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -820,10 +812,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   public static void checkState(
-      boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2) {
+      boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
     }
@@ -839,10 +828,10 @@ public static void checkState(
    */
   public static void checkState(
       boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3));
     }
@@ -858,11 +847,11 @@ public static void checkState(
    */
   public static void checkState(
       boolean b,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3,
-      @NullableDecl Object p4) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3,
+      @Nullable Object p4) {
     if (!b) {
       throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3, p4));
     }
@@ -895,7 +884,7 @@ public static void checkState(
    * @see Verify#verifyNotNull Verify.verifyNotNull()
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(T reference, @NullableDecl Object errorMessage) {
+  public static <T> T checkNotNull(T reference, @Nullable Object errorMessage) {
     if (reference == null) {
       throw new NullPointerException(String.valueOf(errorMessage));
     }
@@ -919,9 +908,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T reference,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object... errorMessageArgs) {
+      T reference, @Nullable String errorMessageTemplate, Object @Nullable... errorMessageArgs) {
     if (reference == null) {
       throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
     }
@@ -936,7 +923,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, char p1) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
@@ -951,7 +938,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, int p1) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
@@ -966,7 +953,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, long p1) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
@@ -982,7 +969,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
+      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1));
     }
@@ -997,8 +984,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, char p1, char p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1013,8 +999,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, char p1, int p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1029,8 +1014,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, char p1, long p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1046,7 +1030,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
+      T obj, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1061,8 +1045,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, int p1, char p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1077,8 +1060,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, int p1, int p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1093,8 +1075,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, int p1, long p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1110,7 +1091,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
+      T obj, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1125,8 +1106,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, long p1, char p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1141,8 +1121,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, long p1, int p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1157,8 +1136,7 @@ public static void checkState(
    * @since 20.0 (varargs overload since 2.0)
    */
   @CanIgnoreReturnValue
-  public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, long p1, long p2) {
+  public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1174,7 +1152,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
+      T obj, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1190,7 +1168,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
+      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1206,7 +1184,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
+      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1222,7 +1200,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
+      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1238,10 +1216,7 @@ public static void checkState(
    */
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
-      T obj,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2) {
+      T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2));
     }
@@ -1258,10 +1233,10 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       T obj,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3));
     }
@@ -1278,11 +1253,11 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(
       T obj,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3,
-      @NullableDecl Object p4) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3,
+      @Nullable Object p4) {
     if (obj == null) {
       throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3, p4));
     }
@@ -1342,15 +1317,15 @@ public static int checkElementIndex(int index, int size) {
    * @throws IllegalArgumentException if {@code size} is negative
    */
   @CanIgnoreReturnValue
-  public static int checkElementIndex(int index, int size, @NullableDecl String desc) {
+  public static int checkElementIndex(int index, int size, @Nullable String desc) {
     // Carefully optimized for execution by hotspot (explanatory comment above)
     if (index < 0 || index >= size) {
       throw new IndexOutOfBoundsException(badElementIndex(index, size, desc));
     }
     return index;
   }
 
-  private static String badElementIndex(int index, int size, @NullableDecl String desc) {
+  private static String badElementIndex(int index, int size, @Nullable String desc) {
     if (index < 0) {
       return format(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
@@ -1387,15 +1362,15 @@ public static int checkPositionIndex(int index, int size) {
    * @throws IllegalArgumentException if {@code size} is negative
    */
   @CanIgnoreReturnValue
-  public static int checkPositionIndex(int index, int size, @NullableDecl String desc) {
+  public static int checkPositionIndex(int index, int size, @Nullable String desc) {
     // Carefully optimized for execution by hotspot (explanatory comment above)
     if (index < 0 || index > size) {
       throw new IndexOutOfBoundsException(badPositionIndex(index, size, desc));
     }
     return index;
   }
 
-  private static String badPositionIndex(int index, int size, @NullableDecl String desc) {
+  private static String badPositionIndex(int index, int size, @Nullable String desc) {
     if (index < 0) {
       return format(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
@@ -1447,7 +1422,7 @@ private static String badPositionIndexes(int start, int end, int size) {
    *     to strings using {@link String#valueOf(Object)}. Arguments can be null.
    */
   // Note that this is somewhat-improperly used from Verify.java as well.
-  static String format(@NullableDecl String template, @NullableDecl Object... args) {
+  static String format(@Nullable String template, @Nullable Object @Nullable... args) {
     template = String.valueOf(template); // null -> ""null""
 
     args = args == null ? new Object[] {""(Object[])null""} : args;, @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Legacy version of {@link java.util.function.Predicate java.util.function.Predicate}. Determines a
@@ -59,7 +59,7 @@
    *     arguments
    */
   @CanIgnoreReturnValue
-  boolean apply(@NullableDecl T input);
+  boolean apply(@Nullable T input);
 
   /**
    * Indicates whether another object is equal to this predicate.
@@ -72,10 +72,10 @@
    * predicates are known <i>not</i> to be interchangeable.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   @Override
-  default boolean test(@NullableDecl T input) {
+  default boolean test(@Nullable T input) {
     return apply(input);
   }
 }, @@ -25,7 +25,7 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.regex.Pattern;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code Predicate} instances.
@@ -151,7 +151,7 @@ private Predicates() {}
    * Returns a predicate that evaluates to {@code true} if the object being tested {@code equals()}
    * the given target or both are null.
    */
-  public static <T> Predicate<T> equalTo(@NullableDecl T target) {
+  public static <T> Predicate<T> equalTo(@Nullable T target) {
     return (target == null) ? Predicates.<T>isNull() : new IsEqualToPredicate<T>(target);
   }
 
@@ -251,7 +251,7 @@ private Predicates() {}
     /** @see Predicates#alwaysTrue() */
     ALWAYS_TRUE {
       @Override
-      public boolean apply(@NullableDecl Object o) {
+      public boolean apply(@Nullable Object o) {
         return true;
       }
 
@@ -263,7 +263,7 @@ public String toString() {
     /** @see Predicates#alwaysFalse() */
     ALWAYS_FALSE {
       @Override
-      public boolean apply(@NullableDecl Object o) {
+      public boolean apply(@Nullable Object o) {
         return false;
       }
 
@@ -275,7 +275,7 @@ public String toString() {
     /** @see Predicates#isNull() */
     IS_NULL {
       @Override
-      public boolean apply(@NullableDecl Object o) {
+      public boolean apply(@Nullable Object o) {
         return o == null;
       }
 
@@ -287,7 +287,7 @@ public String toString() {
     /** @see Predicates#notNull() */
     NOT_NULL {
       @Override
-      public boolean apply(@NullableDecl Object o) {
+      public boolean apply(@Nullable Object o) {
         return o != null;
       }
 
@@ -312,7 +312,7 @@ public String toString() {
     }
 
     @Override
-    public boolean apply(@NullableDecl T t) {
+    public boolean apply(@Nullable T t) {
       return !predicate.apply(t);
     }
 
@@ -322,7 +322,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof NotPredicate) {
         NotPredicate<?> that = (NotPredicate<?>) obj;
         return predicate.equals(that.predicate);
@@ -347,7 +347,7 @@ private AndPredicate(List<? extends Predicate<? super T>> components) {
     }
 
     @Override
-    public boolean apply(@NullableDecl T t) {
+    public boolean apply(@Nullable T t) {
       // Avoid using the Iterator to avoid generating garbage (issue 820).
       for (int i = 0; i < components.size(); i++) {
         if (!components.get(i).apply(t)) {
@@ -364,7 +364,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof AndPredicate) {
         AndPredicate<?> that = (AndPredicate<?>) obj;
         return components.equals(that.components);
@@ -389,7 +389,7 @@ private OrPredicate(List<? extends Predicate<? super T>> components) {
     }
 
     @Override
-    public boolean apply(@NullableDecl T t) {
+    public boolean apply(@Nullable T t) {
       // Avoid using the Iterator to avoid generating garbage (issue 820).
       for (int i = 0; i < components.size(); i++) {
         if (components.get(i).apply(t)) {
@@ -406,7 +406,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof OrPredicate) {
         OrPredicate<?> that = (OrPredicate<?>) obj;
         return components.equals(that.components);
@@ -454,7 +454,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof IsEqualToPredicate) {
         IsEqualToPredicate<?> that = (IsEqualToPredicate<?>) obj;
         return target.equals(that.target);
@@ -480,7 +480,7 @@ private InstanceOfPredicate(Class<?> clazz) {
     }
 
     @Override
-    public boolean apply(@NullableDecl Object o) {
+    public boolean apply(@Nullable Object o) {
       return clazz.isInstance(o);
     }
 
@@ -490,7 +490,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof InstanceOfPredicate) {
         InstanceOfPredicate that = (InstanceOfPredicate) obj;
         return clazz == that.clazz;
@@ -526,7 +526,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof SubtypeOfPredicate) {
         SubtypeOfPredicate that = (SubtypeOfPredicate) obj;
         return clazz == that.clazz;
@@ -551,7 +551,7 @@ private InPredicate(Collection<?> target) {
     }
 
     @Override
-    public boolean apply(@NullableDecl T t) {
+    public boolean apply(@Nullable T t) {
       try {
         return target.contains(t);
       } catch (NullPointerException | ClassCastException e) {
@@ -560,7 +560,7 @@ public boolean apply(@NullableDecl T t) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof InPredicate) {
         InPredicate<?> that = (InPredicate<?>) obj;
         return target.equals(that.target);
@@ -592,12 +592,12 @@ private CompositionPredicate(Predicate<B> p, Function<A, ? extends B> f) {
     }
 
     @Override
-    public boolean apply(@NullableDecl A a) {
+    public boolean apply(@Nullable A a) {
       return p.apply(f.apply(a));
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof CompositionPredicate) {
         CompositionPredicate<?, ?> that = (CompositionPredicate<?, ?>) obj;
         return f.equals(that.f) && p.equals(that.p);
@@ -642,7 +642,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof ContainsPatternPredicate) {
         ContainsPatternPredicate that = (ContainsPatternPredicate) obj;
 , @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.util.Collections;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Implementation of an {@link Optional} containing a reference. */
 @GwtCompatible
@@ -77,7 +77,7 @@ public T orNull() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Present) {
       Present<?> other = (Present<?>) object;
       return reference.equals(other.reference);, @@ -15,7 +15,7 @@
 package com.google.common.base;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Represents a {@linkplain System#getProperties() standard system property}.
@@ -125,7 +125,7 @@ public String key() {
    * Returns the current value for this system property by delegating to {@link
    * System#getProperty(String)}.
    */
-  @NullableDecl
+  @Nullable
   public String value() {
     return System.getProperty(key);
   }, @@ -19,7 +19,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.VisibleForTesting;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code String} or {@code CharSequence} instances.
@@ -37,7 +37,7 @@ private Strings() {}
    * @param string the string to test and possibly return
    * @return {@code string} itself if it is non-null; {@code """"} if it is null
    */
-  public static String nullToEmpty(@NullableDecl String string) {
+  public static String nullToEmpty(@Nullable String string) {
     return Platform.nullToEmpty(string);
   }
 
@@ -47,8 +47,8 @@ public static String nullToEmpty(@NullableDecl String string) {
    * @param string the string to test and possibly return
    * @return {@code string} itself if it is nonempty; {@code null} if it is empty or null
    */
-  @NullableDecl
-  public static String emptyToNull(@NullableDecl String string) {
+  @Nullable
+  public static String emptyToNull(@Nullable String string) {
     return Platform.emptyToNull(string);
   }
 
@@ -63,7 +63,7 @@ public static String emptyToNull(@NullableDecl String string) {
    * @param string a string reference to check
    * @return {@code true} if the string is null or is the empty string
    */
-  public static boolean isNullOrEmpty(@NullableDecl String string) {
+  public static boolean isNullOrEmpty(@Nullable String string) {
     return Platform.stringIsNullOrEmpty(string);
   }
 , @@ -18,7 +18,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import java.io.Serializable;
 import java.util.concurrent.TimeUnit;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Useful suppliers.
@@ -60,7 +60,7 @@ public T get() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof SupplierComposition) {
         SupplierComposition<?, ?> that = (SupplierComposition<?, ?>) obj;
         return function.equals(that.function) && supplier.equals(that.supplier);
@@ -113,7 +113,7 @@ public String toString() {
     transient volatile boolean initialized;
     // ""value"" does not need to be volatile; visibility piggy-backs
     // on volatile read of ""initialized"".
-    @NullableDecl transient T value;
+    @Nullable transient T value;
 
     MemoizingSupplier(Supplier<T> delegate) {
       this.delegate = Preconditions.checkNotNull(delegate);
@@ -151,7 +151,7 @@ public String toString() {
     volatile boolean initialized;
     // ""value"" does not need to be volatile; visibility piggy-backs
     // on volatile read of ""initialized"".
-    @NullableDecl T value;
+    @Nullable T value;
 
     NonSerializableMemoizingSupplier(Supplier<T> delegate) {
       this.delegate = Preconditions.checkNotNull(delegate);
@@ -214,7 +214,7 @@ public String toString() {
   static class ExpiringMemoizingSupplier<T> implements Supplier<T>, Serializable {
     final Supplier<T> delegate;
     final long durationNanos;
-    @NullableDecl transient volatile T value;
+    @Nullable transient volatile T value;
     // The special value 0 means ""not yet initialized"".
     transient volatile long expirationNanos;
 
@@ -261,14 +261,14 @@ public String toString() {
   }
 
   /** Returns a supplier that always supplies {@code instance}. */
-  public static <T> Supplier<T> ofInstance(@NullableDecl T instance) {
+  public static <T> Supplier<T> ofInstance(@Nullable T instance) {
     return new SupplierOfInstance<T>(instance);
   }
 
   private static class SupplierOfInstance<T> implements Supplier<T>, Serializable {
-    @NullableDecl final T instance;
+    @Nullable final T instance;
 
-    SupplierOfInstance(@NullableDecl T instance) {
+    SupplierOfInstance(@Nullable T instance) {
       this.instance = instance;
     }
 
@@ -278,7 +278,7 @@ public T get() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof SupplierOfInstance) {
         SupplierOfInstance<?> that = (SupplierOfInstance<?>) obj;
         return Objects.equal(instance, that.instance);, @@ -32,7 +32,7 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to instances of {@link Throwable}.
@@ -99,7 +99,7 @@ private Throwables() {}
   @Deprecated
   @GwtIncompatible // throwIfInstanceOf
   public static <X extends Throwable> void propagateIfInstanceOf(
-      @NullableDecl Throwable throwable, Class<X> declaredType) throws X {
+      @Nullable Throwable throwable, Class<X> declaredType) throws X {
     if (throwable != null) {
       throwIfInstanceOf(throwable, declaredType);
     }
@@ -154,7 +154,7 @@ public static void throwIfUnchecked(Throwable throwable) {
    */
   @Deprecated
   @GwtIncompatible
-  public static void propagateIfPossible(@NullableDecl Throwable throwable) {
+  public static void propagateIfPossible(@Nullable Throwable throwable) {
     if (throwable != null) {
       throwIfUnchecked(throwable);
     }
@@ -180,7 +180,7 @@ public static void propagateIfPossible(@NullableDecl Throwable throwable) {
    */
   @GwtIncompatible // propagateIfInstanceOf
   public static <X extends Throwable> void propagateIfPossible(
-      @NullableDecl Throwable throwable, Class<X> declaredType) throws X {
+      @Nullable Throwable throwable, Class<X> declaredType) throws X {
     propagateIfInstanceOf(throwable, declaredType);
     propagateIfPossible(throwable);
   }
@@ -198,7 +198,7 @@ public static void propagateIfPossible(@NullableDecl Throwable throwable) {
    */
   @GwtIncompatible // propagateIfInstanceOf
   public static <X1 extends Throwable, X2 extends Throwable> void propagateIfPossible(
-      @NullableDecl Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)
+      @Nullable Throwable throwable, Class<X1> declaredType1, Class<X2> declaredType2)
       throws X1, X2 {
     checkNotNull(declaredType2);
     propagateIfInstanceOf(throwable, declaredType1);
@@ -448,31 +448,31 @@ private static Object invokeAccessibleNonThrowingMethod(
 
   /** Access to some fancy internal JVM internals. */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static final Object jla = getJLA();
 
   /**
    * The ""getStackTraceElementMethod"" method, only available on some JDKs so we use reflection to
    * find it when available. When this is null, use the slow way.
    */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static final Method getStackTraceElementMethod = (jla == null) ? null : getGetMethod();
 
   /**
    * The ""getStackTraceDepth"" method, only available on some JDKs so we use reflection to find it
    * when available. When this is null, use the slow way.
    */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod();
 
   /**
    * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for
    * AppEngine, and not present in non-Sun JDKs.
    */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static Object getJLA() {
     try {
       /*
@@ -498,7 +498,7 @@ private static Object getJLA() {
    * method cannot be found (it is only to be found in fairly recent JDKs).
    */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static Method getGetMethod() {
     return getJlaMethod(""getStackTraceElement"", Throwable.class, int.class);
   }
@@ -513,7 +513,7 @@ private static Method getGetMethod() {
    * UnsupportedOperationException</a>.
    */
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static Method getSizeMethod() {
     try {
       Method getStackTraceDepth = getJlaMethod(""getStackTraceDepth"", Throwable.class);
@@ -528,7 +528,7 @@ private static Method getSizeMethod() {
   }
 
   @GwtIncompatible // java.lang.reflect
-  @NullableDecl
+  @Nullable
   private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {
     try {
       return Class.forName(JAVA_LANG_ACCESS_CLASSNAME, false, null).getMethod(name, parameterTypes);, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static convenience methods that serve the same purpose as Java language <a
@@ -117,8 +117,8 @@ public static void verify(boolean expression) {
    */
   public static void verify(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object... errorMessageArgs) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object @Nullable... errorMessageArgs) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, errorMessageArgs));
     }
@@ -132,8 +132,7 @@ public static void verify(
    *
    * @since 23.1 (varargs overload since 17.0)
    */
-  public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, char p1) {
+  public static void verify(boolean expression, @Nullable String errorMessageTemplate, char p1) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1));
     }
@@ -147,7 +146,7 @@ public static void verify(
    *
    * @since 23.1 (varargs overload since 17.0)
    */
-  public static void verify(boolean expression, @NullableDecl String errorMessageTemplate, int p1) {
+  public static void verify(boolean expression, @Nullable String errorMessageTemplate, int p1) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1));
     }
@@ -161,8 +160,7 @@ public static void verify(boolean expression, @NullableDecl String errorMessageT
    *
    * @since 23.1 (varargs overload since 17.0)
    */
-  public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, long p1) {
+  public static void verify(boolean expression, @Nullable String errorMessageTemplate, long p1) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1));
     }
@@ -177,7 +175,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
+      boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1));
     }
@@ -192,7 +190,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, char p1, char p2) {
+      boolean expression, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -207,7 +205,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, int p1, char p2) {
+      boolean expression, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -222,7 +220,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, long p1, char p2) {
+      boolean expression, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -237,10 +235,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      char p2) {
+      boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -255,7 +250,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, char p1, int p2) {
+      boolean expression, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -270,7 +265,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, int p1, int p2) {
+      boolean expression, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -285,7 +280,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, long p1, int p2) {
+      boolean expression, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -300,10 +295,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      int p2) {
+      boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -318,7 +310,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, char p1, long p2) {
+      boolean expression, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -333,7 +325,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, int p1, long p2) {
+      boolean expression, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -348,7 +340,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression, @NullableDecl String errorMessageTemplate, long p1, long p2) {
+      boolean expression, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -363,10 +355,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      long p2) {
+      boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -381,10 +370,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      char p1,
-      @NullableDecl Object p2) {
+      boolean expression, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -399,10 +385,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      int p1,
-      @NullableDecl Object p2) {
+      boolean expression, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -417,10 +400,7 @@ public static void verify(
    * @since 23.1 (varargs overload since 17.0)
    */
   public static void verify(
-      boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      long p1,
-      @NullableDecl Object p2) {
+      boolean expression, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -436,9 +416,9 @@ public static void verify(
    */
   public static void verify(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2));
     }
@@ -454,10 +434,10 @@ public static void verify(
    */
   public static void verify(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2, p3));
     }
@@ -473,11 +453,11 @@ public static void verify(
    */
   public static void verify(
       boolean expression,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object p1,
-      @NullableDecl Object p2,
-      @NullableDecl Object p3,
-      @NullableDecl Object p4) {
+      @Nullable String errorMessageTemplate,
+      @Nullable Object p1,
+      @Nullable Object p2,
+      @Nullable Object p3,
+      @Nullable Object p4) {
     if (!expression) {
       throw new VerifyException(format(errorMessageTemplate, p1, p2, p3, p4));
     }
@@ -492,7 +472,7 @@ public static void verify(
    * @see Preconditions#checkNotNull Preconditions.checkNotNull()
    */
   @CanIgnoreReturnValue
-  public static <T> T verifyNotNull(@NullableDecl T reference) {
+  public static <T> T verifyNotNull(@Nullable T reference) {
     return verifyNotNull(reference, ""expected a non-null reference"");
   }
 
@@ -513,9 +493,9 @@ public static void verify(
    */
   @CanIgnoreReturnValue
   public static <T> T verifyNotNull(
-      @NullableDecl T reference,
-      @NullableDecl String errorMessageTemplate,
-      @NullableDecl Object... errorMessageArgs) {
+      @Nullable T reference,
+      @Nullable String errorMessageTemplate,
+      @Nullable Object @Nullable... errorMessageArgs) {
     verify(reference != null, errorMessageTemplate, errorMessageArgs);
     return reference;
   }, @@ -15,7 +15,7 @@
 package com.google.common.base;
 
 import com.google.common.annotations.GwtCompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Exception thrown upon the failure of a <a
@@ -30,7 +30,7 @@
   public VerifyException() {}
 
   /** Constructs a {@code VerifyException} with the message {@code message}. */
-  public VerifyException(@NullableDecl String message) {
+  public VerifyException(@Nullable String message) {
     super(message);
   }
 
@@ -40,7 +40,7 @@ public VerifyException(@NullableDecl String message) {
    *
    * @since 19.0
    */
-  public VerifyException(@NullableDecl Throwable cause) {
+  public VerifyException(@Nullable Throwable cause) {
     super(cause);
   }
 
@@ -50,7 +50,7 @@ public VerifyException(@NullableDecl Throwable cause) {
    *
    * @since 19.0
    */
-  public VerifyException(@NullableDecl String message, @NullableDecl Throwable cause) {
+  public VerifyException(@Nullable String message, @Nullable Throwable cause) {
     super(message, cause);
   }
 }, @@ -23,7 +23,7 @@
 import java.lang.reflect.Method;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Thread that finalizes referents. All references should implement {@code
@@ -116,10 +116,10 @@ public static void startFinalizer(
   // By preference, we will use the Thread constructor that has an `inheritThreadLocals` parameter.
   // But before Java 9, our only way not to inherit ThreadLocals is to zap them after the thread
   // is created, by accessing a private field.
-  @NullableDecl
+  @Nullable
   private static final Constructor<Thread> bigThreadConstructor = getBigThreadConstructor();
 
-  @NullableDecl
+  @Nullable
   private static final Field inheritableThreadLocals =
       (bigThreadConstructor == null) ? getInheritableThreadLocalsField() : null;
 
@@ -192,7 +192,7 @@ private boolean cleanUp(Reference<?> reference) {
   }
 
   /** Looks up FinalizableReference.finalizeReferent() method. */
-  @NullableDecl
+  @Nullable
   private Method getFinalizeReferentMethod() {
     Class<?> finalizableReferenceClass = finalizableReferenceClassReference.get();
     if (finalizableReferenceClass == null) {
@@ -211,7 +211,7 @@ private Method getFinalizeReferentMethod() {
     }
   }
 
-  @NullableDecl
+  @Nullable
   private static Field getInheritableThreadLocalsField() {
     try {
       Field inheritableThreadLocals = Thread.class.getDeclaredField(""inheritableThreadLocals"");
@@ -226,7 +226,7 @@ private static Field getInheritableThreadLocalsField() {
     }
   }
 
-  @NullableDecl
+  @Nullable
   private static Constructor<Thread> getBigThreadConstructor() {
     try {
       return Thread.class.getConstructor(, @@ -23,7 +23,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A semi-persistent mapping from keys to values. Cache entries are manually added using {@link
@@ -45,7 +45,7 @@
    *
    * @since 11.0
    */
-  @NullableDecl
+  @Nullable
   V getIfPresent(@CompatibleWith(""K"") Object key);
 
   /**, @@ -28,7 +28,7 @@
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A specification of a {@link CacheBuilder} configuration.
@@ -81,7 +81,7 @@
 public final class CacheBuilderSpec {
   /** Parses a single value. */
   private interface ValueParser {
-    void parse(CacheBuilderSpec spec, String key, @NullableDecl String value);
+    void parse(CacheBuilderSpec spec, String key, @Nullable String value);
   }
 
   /** Splits each key-value pair. */
@@ -248,7 +248,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (this == obj) {
       return true;
     }
@@ -278,8 +278,8 @@ public boolean equals(@NullableDecl Object obj) {
    * Converts an expiration duration/unit pair into a single Long for hashing and equality. Uses
    * nanos to match CacheBuilder implementation.
    */
-  @NullableDecl
-  private static Long durationInNanos(long duration, @NullableDecl TimeUnit unit) {
+  @Nullable
+  private static Long durationInNanos(long duration, @Nullable TimeUnit unit) {
     return (unit == null) ? null : unit.toNanos(duration);
   }
 
@@ -370,7 +370,7 @@ public KeyStrengthParser(Strength strength) {
     }
 
     @Override
-    public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value) {
+    public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
       checkArgument(value == null, ""key %s does not take values"", key);
       checkArgument(spec.keyStrength == null, ""%s was already set to %s"", key, spec.keyStrength);
       spec.keyStrength = strength;
@@ -386,7 +386,7 @@ public ValueStrengthParser(Strength strength) {
     }
 
     @Override
-    public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value) {
+    public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
       checkArgument(value == null, ""key %s does not take values"", key);
       checkArgument(
           spec.valueStrength == null, ""%s was already set to %s"", key, spec.valueStrength);
@@ -399,7 +399,7 @@ public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value)
   static class RecordStatsParser implements ValueParser {
 
     @Override
-    public void parse(CacheBuilderSpec spec, String key, @NullableDecl String value) {
+    public void parse(CacheBuilderSpec spec, String key, @Nullable String value) {
       checkArgument(value == null, ""recordStats does not take values"");
       checkArgument(spec.recordStats == null, ""recordStats already set"");
       spec.recordStats = true;, @@ -20,7 +20,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Objects;
 import java.util.concurrent.Callable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Statistics about the performance of a {@link Cache}. Instances of this class are immutable.
@@ -249,7 +249,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof CacheStats) {
       CacheStats other = (CacheStats) object;
       return hitCount == other.hitCount, @@ -22,7 +22,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A cache which forwards all its method calls to another cache. Subclasses should override one or
@@ -43,7 +43,7 @@ protected ForwardingCache() {}
 
   /** @since 11.0 */
   @Override
-  @NullableDecl
+  @Nullable
   public V getIfPresent(Object key) {
     return delegate().getIfPresent(key);
   }, @@ -86,7 +86,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * The concurrent hash map implementation built by {@link CacheBuilder}.
@@ -230,13 +230,13 @@
   final StatsCounter globalStatsCounter;
 
   /** The default cache loader to use on loading operations. */
-  @NullableDecl final CacheLoader<? super K, V> defaultLoader;
+  @Nullable final CacheLoader<? super K, V> defaultLoader;
 
   /**
    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.
    */
   LocalCache(
-      CacheBuilder<? super K, ? super V> builder, @NullableDecl CacheLoader<? super K, V> loader) {
+      CacheBuilder<? super K, ? super V> builder, @Nullable CacheLoader<? super K, V> loader) {
     concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS);
 
     keyStrength = builder.getKeyStrength();
@@ -440,14 +440,14 @@ boolean usesValueReferences() {
     STRONG {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new StrongEntry<>(key, hash, next);
       }
     },
     STRONG_ACCESS {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new StrongAccessEntry<>(key, hash, next);
       }
 
@@ -462,7 +462,7 @@ boolean usesValueReferences() {
     STRONG_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new StrongWriteEntry<>(key, hash, next);
       }
 
@@ -477,7 +477,7 @@ boolean usesValueReferences() {
     STRONG_ACCESS_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new StrongAccessWriteEntry<>(key, hash, next);
       }
 
@@ -493,14 +493,14 @@ boolean usesValueReferences() {
     WEAK {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new WeakEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
     },
     WEAK_ACCESS {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new WeakAccessEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -515,7 +515,7 @@ boolean usesValueReferences() {
     WEAK_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new WeakWriteEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -530,7 +530,7 @@ boolean usesValueReferences() {
     WEAK_ACCESS_WRITE {
       @Override
       <K, V> ReferenceEntry<K, V> newEntry(
-          Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+          Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
         return new WeakAccessWriteEntry<>(segment.keyReferenceQueue, key, hash, next);
       }
 
@@ -580,7 +580,7 @@ static EntryFactory getFactory(
      * @param next entry in the same bucket
      */
     abstract <K, V> ReferenceEntry<K, V> newEntry(
-        Segment<K, V> segment, K key, int hash, @NullableDecl ReferenceEntry<K, V> next);
+        Segment<K, V> segment, K key, int hash, @Nullable ReferenceEntry<K, V> next);
 
     /**
      * Copies an entry, assigning it a new {@code next} entry.
@@ -622,7 +622,7 @@ static EntryFactory getFactory(
   /** A reference to a value. */
   interface ValueReference<K, V> {
     /** Returns the value. Does not block or throw exceptions. */
-    @NullableDecl
+    @Nullable
     V get();
 
     /**
@@ -641,7 +641,7 @@ static EntryFactory getFactory(
      * Returns the entry associated with this value reference, or {@code null} if this value
      * reference is independent of any entry.
      */
-    @NullableDecl
+    @Nullable
     ReferenceEntry<K, V> getEntry();
 
     /**
@@ -650,13 +650,13 @@ static EntryFactory getFactory(
      * <p>{@code value} may be null only for a loading reference.
      */
     ValueReference<K, V> copyFor(
-        ReferenceQueue<V> queue, @NullableDecl V value, ReferenceEntry<K, V> entry);
+        ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry);
 
     /**
      * Notify pending loads that a new value was set. This is only relevant to loading value
      * references.
      */
-    void notifyNewValue(@NullableDecl V newValue);
+    void notifyNewValue(@Nullable V newValue);
 
     /**
      * Returns true if a new value is currently loading, regardless of whether or not there is an
@@ -696,7 +696,7 @@ public int getWeight() {
         @Override
         public ValueReference<Object, Object> copyFor(
             ReferenceQueue<Object> queue,
-            @NullableDecl Object value,
+            @Nullable Object value,
             ReferenceEntry<Object, Object> entry) {
           return this;
         }
@@ -939,7 +939,7 @@ public int size() {
   static class StrongEntry<K, V> extends AbstractReferenceEntry<K, V> {
     final K key;
 
-    StrongEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    StrongEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       this.key = key;
       this.hash = hash;
       this.next = next;
@@ -953,7 +953,7 @@ public K getKey() {
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    @NullableDecl final ReferenceEntry<K, V> next;
+    @Nullable final ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -978,7 +978,7 @@ public int getHash() {
   }
 
   static final class StrongAccessEntry<K, V> extends StrongEntry<K, V> {
-    StrongAccessEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    StrongAccessEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1024,7 +1024,7 @@ public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
   }
 
   static final class StrongWriteEntry<K, V> extends StrongEntry<K, V> {
-    StrongWriteEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    StrongWriteEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1070,7 +1070,7 @@ public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
   }
 
   static final class StrongAccessWriteEntry<K, V> extends StrongEntry<K, V> {
-    StrongAccessWriteEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    StrongAccessWriteEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -1157,7 +1157,7 @@ public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
 
   /** Used for weakly-referenced keys. */
   static class WeakEntry<K, V> extends WeakReference<K> implements ReferenceEntry<K, V> {
-    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    WeakEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(key, queue);
       this.hash = hash;
       this.next = next;
@@ -1240,7 +1240,7 @@ public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    @NullableDecl final ReferenceEntry<K, V> next;
+    @Nullable final ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -1265,8 +1265,7 @@ public int getHash() {
   }
 
   static final class WeakAccessEntry<K, V> extends WeakEntry<K, V> {
-    WeakAccessEntry(
-        ReferenceQueue<K> queue, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    WeakAccessEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1312,8 +1311,7 @@ public void setPreviousInAccessQueue(ReferenceEntry<K, V> previous) {
   }
 
   static final class WeakWriteEntry<K, V> extends WeakEntry<K, V> {
-    WeakWriteEntry(
-        ReferenceQueue<K> queue, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    WeakWriteEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1360,7 +1358,7 @@ public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
 
   static final class WeakAccessWriteEntry<K, V> extends WeakEntry<K, V> {
     WeakAccessWriteEntry(
-        ReferenceQueue<K> queue, K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -1664,7 +1662,7 @@ static int rehash(int h) {
    * This method is a convenience for testing. Code should call {@link Segment#newEntry} directly.
    */
   @VisibleForTesting
-  ReferenceEntry<K, V> newEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+  ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
     Segment<K, V> segment = segmentFor(hash);
     segment.lock();
     try {
@@ -1694,7 +1692,7 @@ static int rehash(int h) {
     return valueStrength.referenceValue(segmentFor(hash), entry, checkNotNull(value), weight);
   }
 
-  int hash(@NullableDecl Object key) {
+  int hash(@Nullable Object key) {
     int h = keyEquivalence.hash(key);
     return rehash(h);
   }
@@ -1741,7 +1739,7 @@ boolean isLive(ReferenceEntry<K, V> entry, long now) {
    * cleanup stale entries. As such it should only be called outside of a segment context, such as
    * during iteration.
    */
-  @NullableDecl
+  @Nullable
   V getLiveValue(ReferenceEntry<K, V> entry, long now) {
     if (entry.getKey() == null) {
       return null;
@@ -1895,13 +1893,13 @@ void processPendingNotifications() {
      * The key reference queue contains entries whose keys have been garbage collected, and which
      * need to be cleaned up internally.
      */
-    @NullableDecl final ReferenceQueue<K> keyReferenceQueue;
+    @Nullable final ReferenceQueue<K> keyReferenceQueue;
 
     /**
      * The value reference queue contains value references whose values have been garbage collected,
      * and which need to be cleaned up internally.
      */
-    @NullableDecl final ReferenceQueue<V> valueReferenceQueue;
+    @Nullable final ReferenceQueue<V> valueReferenceQueue;
 
     /**
      * The recency queue is used to record which entries were accessed for updating the access
@@ -1977,7 +1975,7 @@ void initTable(AtomicReferenceArray<ReferenceEntry<K, V>> newTable) {
     }
 
     @GuardedBy(""this"")
-    ReferenceEntry<K, V> newEntry(K key, int hash, @NullableDecl ReferenceEntry<K, V> next) {
+    ReferenceEntry<K, V> newEntry(K key, int hash, @Nullable ReferenceEntry<K, V> next) {
       return map.entryFactory.newEntry(this, checkNotNull(key), hash, next);
     }
 
@@ -2057,7 +2055,7 @@ V get(K key, int hash, CacheLoader<? super K, V> loader) throws ExecutionExcepti
       }
     }
 
-    @NullableDecl
+    @Nullable
     V get(Object key, int hash) {
       try {
         if (count != 0) { // read-volatile
@@ -2349,7 +2347,7 @@ V scheduleRefresh(
      * {@code null} if another thread is performing the refresh or if an error occurs during
      * refresh.
      */
-    @NullableDecl
+    @Nullable
     V refresh(K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime) {
       final LoadingValueReference<K, V> loadingValueReference =
           insertLoadingValueReference(key, hash, checkTime);
@@ -2372,7 +2370,7 @@ V refresh(K key, int hash, CacheLoader<? super K, V> loader, boolean checkTime)
      * Returns a newly inserted {@code LoadingValueReference}, or null if the live value reference
      * is already loading.
      */
-    @NullableDecl
+    @Nullable
     LoadingValueReference<K, V> insertLoadingValueReference(
         final K key, final int hash, boolean checkTime) {
       ReferenceEntry<K, V> e = null;
@@ -2602,7 +2600,7 @@ void expireEntries(long now) {
 
     @GuardedBy(""this"")
     void enqueueNotification(
-        @NullableDecl K key, int hash, @NullableDecl V value, int weight, RemovalCause cause) {
+        @Nullable K key, int hash, @Nullable V value, int weight, RemovalCause cause) {
       totalWeight -= weight;
       if (cause.wasEvicted()) {
         statsCounter.recordEviction();
@@ -2664,7 +2662,7 @@ void evictEntries(ReferenceEntry<K, V> newest) {
 
     // Specialized implementations of map methods
 
-    @NullableDecl
+    @Nullable
     ReferenceEntry<K, V> getEntry(Object key, int hash) {
       for (ReferenceEntry<K, V> e = getFirst(hash); e != null; e = e.getNext()) {
         if (e.getHash() != hash) {
@@ -2685,7 +2683,7 @@ void evictEntries(ReferenceEntry<K, V> newest) {
       return null;
     }
 
-    @NullableDecl
+    @Nullable
     ReferenceEntry<K, V> getLiveEntry(Object key, int hash, long now) {
       ReferenceEntry<K, V> e = getEntry(key, hash);
       if (e == null) {
@@ -2766,7 +2764,7 @@ boolean containsValue(Object value) {
       }
     }
 
-    @NullableDecl
+    @Nullable
     V put(K key, int hash, V value, boolean onlyIfAbsent) {
       lock();
       try {
@@ -2972,7 +2970,7 @@ boolean replace(K key, int hash, V oldValue, V newValue) {
       }
     }
 
-    @NullableDecl
+    @Nullable
     V replace(K key, int hash, V newValue) {
       lock();
       try {
@@ -3027,7 +3025,7 @@ V replace(K key, int hash, V newValue) {
       }
     }
 
-    @NullableDecl
+    @Nullable
     V remove(Object key, int hash) {
       lock();
       try {
@@ -3219,11 +3217,11 @@ void clear() {
     }
 
     @GuardedBy(""this"")
-    @NullableDecl
+    @Nullable
     ReferenceEntry<K, V> removeValueFromChain(
         ReferenceEntry<K, V> first,
         ReferenceEntry<K, V> entry,
-        @NullableDecl K key,
+        @Nullable K key,
         int hash,
         V value,
         ValueReference<K, V> valueReference,
@@ -3241,7 +3239,7 @@ void clear() {
     }
 
     @GuardedBy(""this"")
-    @NullableDecl
+    @Nullable
     ReferenceEntry<K, V> removeEntryFromChain(
         ReferenceEntry<K, V> first, ReferenceEntry<K, V> entry) {
       int newCount = count;
@@ -3495,7 +3493,7 @@ public int getWeight() {
       return oldValue.getWeight();
     }
 
-    public boolean set(@NullableDecl V newValue) {
+    public boolean set(@Nullable V newValue) {
       return futureValue.set(newValue);
     }
 
@@ -3508,7 +3506,7 @@ public boolean setException(Throwable t) {
     }
 
     @Override
-    public void notifyNewValue(@NullableDecl V newValue) {
+    public void notifyNewValue(@Nullable V newValue) {
       if (newValue != null) {
         // The pending load was clobbered by a manual write.
         // Unblock all pending gets, and have them return the new value.
@@ -3592,7 +3590,7 @@ public V get() {
 
     @Override
     public ValueReference<K, V> copyFor(
-        ReferenceQueue<V> queue, @NullableDecl V value, ReferenceEntry<K, V> entry) {
+        ReferenceQueue<V> queue, @Nullable V value, ReferenceEntry<K, V> entry) {
       return this;
     }
   }
@@ -3934,8 +3932,8 @@ public int size() {
   }
 
   @Override
-  @NullableDecl
-  public V get(@NullableDecl Object key) {
+  @Nullable
+  public V get(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -3948,7 +3946,7 @@ V get(K key, CacheLoader<? super K, V> loader) throws ExecutionException {
     return segmentFor(hash).get(key, hash, loader);
   }
 
-  @NullableDecl
+  @Nullable
   public V getIfPresent(Object key) {
     int hash = hash(checkNotNull(key));
     V value = segmentFor(hash).get(key, hash);
@@ -3962,8 +3960,8 @@ public V getIfPresent(Object key) {
 
   // Only becomes available in Java 8 when it's on the interface.
   // @Override
-  @NullableDecl
-  public V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
+  @Nullable
+  public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
     V result = get(key);
     return (result != null) ? result : defaultValue;
   }
@@ -4043,7 +4041,7 @@ V getOrLoad(K key) throws ExecutionException {
    * Returns the result of calling {@link CacheLoader#loadAll}, or null if {@code loader} doesn't
    * implement {@code loadAll}.
    */
-  @NullableDecl
+  @Nullable
   Map<K, V> loadAll(Set<? extends K> keys, CacheLoader<? super K, V> loader)
       throws ExecutionException {
     checkNotNull(loader);
@@ -4107,7 +4105,7 @@ V getOrLoad(K key) throws ExecutionException {
    * Returns the internal entry for the specified key. The entry may be loading, expired, or
    * partially collected.
    */
-  ReferenceEntry<K, V> getEntry(@NullableDecl Object key) {
+  ReferenceEntry<K, V> getEntry(@Nullable Object key) {
     // does not impact recency ordering
     if (key == null) {
       return null;
@@ -4122,7 +4120,7 @@ void refresh(K key) {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     // does not impact recency ordering
     if (key == null) {
       return false;
@@ -4132,7 +4130,7 @@ public boolean containsKey(@NullableDecl Object key) {
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     // does not impact recency ordering
     if (value == null) {
       return false;
@@ -4226,7 +4224,7 @@ public void putAll(Map<? extends K, ? extends V> m) {
   }
 
   @Override
-  public V remove(@NullableDecl Object key) {
+  public V remove(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -4235,7 +4233,7 @@ public V remove(@NullableDecl Object key) {
   }
 
   @Override
-  public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean remove(@Nullable Object key, @Nullable Object value) {
     if (key == null || value == null) {
       return false;
     }
@@ -4244,7 +4242,7 @@ public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
   }
 
   @Override
-  public boolean replace(K key, @NullableDecl V oldValue, V newValue) {
+  public boolean replace(K key, @Nullable V oldValue, V newValue) {
     checkNotNull(key);
     checkNotNull(newValue);
     if (oldValue == null) {
@@ -4312,9 +4310,9 @@ void invalidateAll(Iterable<?> keys) {
     int nextTableIndex;
     @MonotonicNonNullDecl Segment<K, V> currentSegment;
     @MonotonicNonNullDecl AtomicReferenceArray<ReferenceEntry<K, V>> currentTable;
-    @NullableDecl ReferenceEntry<K, V> nextEntry;
-    @NullableDecl WriteThroughEntry nextExternal;
-    @NullableDecl WriteThroughEntry lastReturned;
+    @Nullable ReferenceEntry<K, V> nextEntry;
+    @Nullable WriteThroughEntry nextExternal;
+    @Nullable WriteThroughEntry lastReturned;
 
     HashIterator() {
       nextSegmentIndex = segments.length - 1;
@@ -4455,7 +4453,7 @@ public V getValue() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       // Cannot use key and value equivalence
       if (object instanceof Entry) {
         Entry<?, ?> that = (Entry<?, ?>) object;
@@ -4695,7 +4693,7 @@ public boolean remove(Object o) {
     final Weigher<K, V> weigher;
     final int concurrencyLevel;
     final RemovalListener<? super K, ? super V> removalListener;
-    @NullableDecl final Ticker ticker;
+    @Nullable final Ticker ticker;
     final CacheLoader<? super K, V> loader;
 
     @MonotonicNonNullDecl transient Cache<K, V> delegate;
@@ -4859,7 +4857,7 @@ private LocalManualCache(LocalCache<K, V> localCache) {
     // Cache methods
 
     @Override
-    @NullableDecl
+    @Nullable
     public V getIfPresent(Object key) {
       return localCache.getIfPresent(key);
     }, @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.cache.LocalCache.ValueReference;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An entry in a reference map.
@@ -47,14 +47,14 @@
   void setValueReference(ValueReference<K, V> valueReference);
 
   /** Returns the next entry in the chain. */
-  @NullableDecl
+  @Nullable
   ReferenceEntry<K, V> getNext();
 
   /** Returns the entry's hash. */
   int getHash();
 
   /** Returns the key for this entry. */
-  @NullableDecl
+  @Nullable
   K getKey();
 
   /*, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.AbstractMap.SimpleImmutableEntry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A notification of the removal of a single entry. The key and/or value may be null if they were
@@ -43,11 +43,11 @@
    * @since 19.0
    */
   public static <K, V> RemovalNotification<K, V> create(
-      @NullableDecl K key, @NullableDecl V value, RemovalCause cause) {
+      @Nullable K key, @Nullable V value, RemovalCause cause) {
     return new RemovalNotification(key, value, cause);
   }
 
-  private RemovalNotification(@NullableDecl K key, @NullableDecl V value, RemovalCause cause) {
+  private RemovalNotification(@Nullable K key, @Nullable V value, RemovalCause cause) {
     super(key, value);
     this.cause = checkNotNull(cause);
   }, @@ -13,7 +13,7 @@
 
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Random;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A package-local class holding common representation and mechanics for classes supporting dynamic
@@ -134,7 +134,7 @@ final boolean cas(long cmp, long val) {
   static final int NCPU = Runtime.getRuntime().availableProcessors();
 
   /** Table of cells. When non-null, size is a power of 2. */
-  @NullableDecl transient volatile Cell[] cells;
+  transient volatile Cell @Nullable [] cells;
 
   /**
    * Base value, used mainly when there is no contention, but also as a fallback during table, @@ -36,7 +36,7 @@
 import java.util.Set;
 import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A general-purpose bimap implementation using any two backing {@code Map} instances.
@@ -72,13 +72,13 @@ private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {
 
   /** Returns its input, or throws an exception if this is not a valid key. */
   @CanIgnoreReturnValue
-  K checkKey(@NullableDecl K key) {
+  K checkKey(@Nullable K key) {
     return key;
   }
 
   /** Returns its input, or throws an exception if this is not a valid value. */
   @CanIgnoreReturnValue
-  V checkValue(@NullableDecl V value) {
+  V checkValue(@Nullable V value) {
     return value;
   }
 
@@ -107,25 +107,25 @@ void setInverse(AbstractBiMap<V, K> inverse) {
   // Query Operations (optimizations)
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return inverse.containsKey(value);
   }
 
   // Modification Operations
 
   @CanIgnoreReturnValue
   @Override
-  public V put(@NullableDecl K key, @NullableDecl V value) {
+  public V put(@Nullable K key, @Nullable V value) {
     return putInBothMaps(key, value, false);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public V forcePut(@NullableDecl K key, @NullableDecl V value) {
+  public V forcePut(@Nullable K key, @Nullable V value) {
     return putInBothMaps(key, value, true);
   }
 
-  private V putInBothMaps(@NullableDecl K key, @NullableDecl V value, boolean force) {
+  private V putInBothMaps(@Nullable K key, @Nullable V value, boolean force) {
     checkKey(key);
     checkValue(value);
     boolean containedKey = containsKey(key);
@@ -151,7 +151,7 @@ private void updateInverseMap(K key, boolean containedKey, V oldValue, V newValu
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object key) {
+  public V remove(@Nullable Object key) {
     return containsKey(key) ? removeFromBothMaps(key) : null;
   }
 
@@ -338,7 +338,7 @@ public V setValue(V value) {
   Iterator<Entry<K, V>> entrySetIterator() {
     final Iterator<Entry<K, V>> iterator = delegate.entrySet().iterator();
     return new Iterator<Entry<K, V>>() {
-      @NullableDecl Entry<K, V> entry;
+      @Nullable Entry<K, V> entry;
 
       @Override
       public boolean hasNext() {, @@ -21,7 +21,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@code Iterator} interface, to make this
@@ -81,7 +81,7 @@ protected AbstractIterator() {}
     FAILED,
   }
 
-  @NullableDecl private T next;
+  @Nullable private T next;
 
   /**
    * Returns the next element. <b>Note:</b> the implementation must call {@link #endOfData()} when, @@ -22,7 +22,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link ListMultimap} interface. It's a wrapper around {@link
@@ -72,7 +72,7 @@ protected AbstractListMultimap(Map<K, Collection<V>> map) {
    * Multimap} interface.
    */
   @Override
-  public List<V> get(@NullableDecl K key) {
+  public List<V> get(@Nullable K key) {
     return (List<V>) super.get(key);
   }
 
@@ -85,7 +85,7 @@ protected AbstractListMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public List<V> removeAll(@NullableDecl Object key) {
+  public List<V> removeAll(@Nullable Object key) {
     return (List<V>) super.removeAll(key);
   }
 
@@ -98,7 +98,7 @@ protected AbstractListMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public List<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public List<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     return (List<V>) super.replaceValues(key, values);
   }
 
@@ -111,7 +111,7 @@ protected AbstractListMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public boolean put(@NullableDecl K key, @NullableDecl V value) {
+  public boolean put(@Nullable K key, @Nullable V value) {
     return super.put(key, value);
   }
 
@@ -133,7 +133,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    * in the same order. If the value orderings disagree, the multimaps will not be considered equal.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return super.equals(object);
   }
 , @@ -45,7 +45,7 @@
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link Multimap} interface. This class represents a multimap as a map
@@ -160,7 +160,7 @@ final void setMap(Map<K, Collection<V>> map) {
    * @param key key to associate with values in the collection
    * @return an empty collection of values
    */
-  Collection<V> createCollection(@NullableDecl K key) {
+  Collection<V> createCollection(@Nullable K key) {
     return createCollection();
   }
 
@@ -176,14 +176,14 @@ public int size() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return map.containsKey(key);
   }
 
   // Modification Operations
 
   @Override
-  public boolean put(@NullableDecl K key, @NullableDecl V value) {
+  public boolean put(@Nullable K key, @Nullable V value) {
     Collection<V> collection = map.get(key);
     if (collection == null) {
       collection = createCollection(key);
@@ -202,7 +202,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
     }
   }
 
-  private Collection<V> getOrCreateCollection(@NullableDecl K key) {
+  private Collection<V> getOrCreateCollection(@Nullable K key) {
     Collection<V> collection = map.get(key);
     if (collection == null) {
       collection = createCollection(key);
@@ -219,7 +219,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    * <p>The returned collection is immutable.
    */
   @Override
-  public Collection<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     Iterator<? extends V> iterator = values.iterator();
     if (!iterator.hasNext()) {
       return removeAll(key);
@@ -248,7 +248,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    * <p>The returned collection is immutable.
    */
   @Override
-  public Collection<V> removeAll(@NullableDecl Object key) {
+  public Collection<V> removeAll(@Nullable Object key) {
     Collection<V> collection = map.remove(key);
 
     if (collection == null) {
@@ -285,7 +285,7 @@ public void clear() {
    * <p>The returned collection is not serializable.
    */
   @Override
-  public Collection<V> get(@NullableDecl K key) {
+  public Collection<V> get(@Nullable K key) {
     Collection<V> collection = map.get(key);
     if (collection == null) {
       collection = createCollection(key);
@@ -297,12 +297,11 @@ public void clear() {
    * Generates a decorated collection that remains consistent with the values in the multimap for
    * the provided key. Changes to the multimap may alter the returned collection, and vice versa.
    */
-  Collection<V> wrapCollection(@NullableDecl K key, Collection<V> collection) {
+  Collection<V> wrapCollection(@Nullable K key, Collection<V> collection) {
     return new WrappedCollection(key, collection, null);
   }
 
-  final List<V> wrapList(
-      @NullableDecl K key, List<V> list, @NullableDecl WrappedCollection ancestor) {
+  final List<V> wrapList(@Nullable K key, List<V> list, @Nullable WrappedCollection ancestor) {
     return (list instanceof RandomAccess)
         ? new RandomAccessWrappedList(key, list, ancestor)
         : new WrappedList(key, list, ancestor);
@@ -325,13 +324,13 @@ public void clear() {
    */
   @WeakOuter
   class WrappedCollection extends AbstractCollection<V> {
-    @NullableDecl final K key;
+    @Nullable final K key;
     Collection<V> delegate;
-    @NullableDecl final WrappedCollection ancestor;
-    @NullableDecl final Collection<V> ancestorDelegate;
+    @Nullable final WrappedCollection ancestor;
+    @Nullable final Collection<V> ancestorDelegate;
 
     WrappedCollection(
-        @NullableDecl K key, Collection<V> delegate, @NullableDecl WrappedCollection ancestor) {
+        @Nullable K key, Collection<V> delegate, @Nullable WrappedCollection ancestor) {
       this.key = key;
       this.delegate = delegate;
       this.ancestor = ancestor;
@@ -396,7 +395,7 @@ public int size() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }
@@ -589,7 +588,7 @@ public boolean retainAll(Collection<?> c) {
   /** Set decorator that stays in sync with the multimap values for a key. */
   @WeakOuter
   class WrappedSet extends WrappedCollection implements Set<V> {
-    WrappedSet(@NullableDecl K key, Set<V> delegate) {
+    WrappedSet(@Nullable K key, Set<V> delegate) {
       super(key, delegate, null);
     }
 
@@ -616,8 +615,7 @@ public boolean removeAll(Collection<?> c) {
   /** SortedSet decorator that stays in sync with the multimap values for a key. */
   @WeakOuter
   class WrappedSortedSet extends WrappedCollection implements SortedSet<V> {
-    WrappedSortedSet(
-        @NullableDecl K key, SortedSet<V> delegate, @NullableDecl WrappedCollection ancestor) {
+    WrappedSortedSet(@Nullable K key, SortedSet<V> delegate, @Nullable WrappedCollection ancestor) {
       super(key, delegate, ancestor);
     }
 
@@ -673,7 +671,7 @@ public V last() {
   @WeakOuter
   class WrappedNavigableSet extends WrappedSortedSet implements NavigableSet<V> {
     WrappedNavigableSet(
-        @NullableDecl K key, NavigableSet<V> delegate, @NullableDecl WrappedCollection ancestor) {
+        @Nullable K key, NavigableSet<V> delegate, @Nullable WrappedCollection ancestor) {
       super(key, delegate, ancestor);
     }
 
@@ -747,7 +745,7 @@ public V pollLast() {
   /** List decorator that stays in sync with the multimap values for a key. */
   @WeakOuter
   class WrappedList extends WrappedCollection implements List<V> {
-    WrappedList(@NullableDecl K key, List<V> delegate, @NullableDecl WrappedCollection ancestor) {
+    WrappedList(@Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {
       super(key, delegate, ancestor);
     }
 
@@ -892,7 +890,7 @@ public void add(V value) {
    */
   private class RandomAccessWrappedList extends WrappedList implements RandomAccess {
     RandomAccessWrappedList(
-        @NullableDecl K key, List<V> delegate, @NullableDecl WrappedCollection ancestor) {
+        @Nullable K key, List<V> delegate, @Nullable WrappedCollection ancestor) {
       super(key, delegate, ancestor);
     }
   }
@@ -922,7 +920,7 @@ public void add(V value) {
     public Iterator<K> iterator() {
       final Iterator<Entry<K, Collection<V>>> entryIterator = map().entrySet().iterator();
       return new Iterator<K>() {
-        @NullableDecl Entry<K, Collection<V>> entry;
+        @Nullable Entry<K, Collection<V>> entry;
 
         @Override
         public boolean hasNext() {
@@ -977,7 +975,7 @@ public boolean containsAll(Collection<?> c) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return this == object || this.map().keySet().equals(object);
     }
 
@@ -1126,7 +1124,7 @@ private void removeValuesForKey(Object key) {
 
   private abstract class Itr<T> implements Iterator<T> {
     final Iterator<Entry<K, Collection<V>>> keyIterator;
-    @NullableDecl K key;
+    @Nullable K key;
     @MonotonicNonNullDecl Collection<V> collection;
     Iterator<V> valueIterator;
 
@@ -1345,7 +1343,7 @@ public int size() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return this == object || submap.equals(object);
     }
 
@@ -1411,7 +1409,7 @@ public boolean remove(Object o) {
     /** Iterator across all keys and value collections. */
     class AsMapIterator implements Iterator<Entry<K, Collection<V>>> {
       final Iterator<Entry<K, Collection<V>>> delegateIterator = submap.entrySet().iterator();
-      @NullableDecl Collection<V> collection;
+      @Nullable Collection<V> collection;
 
       @Override
       public boolean hasNext() {, @@ -34,7 +34,7 @@
 import java.util.Set;
 import java.util.function.ObjIntConsumer;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of {@code Multiset<E>} backed by an instance of {@code Map<E, Count>}.
@@ -85,7 +85,7 @@ void setBackingMap(Map<E, Count> backingMap) {
   Iterator<E> elementIterator() {
     final Iterator<Map.Entry<E, Count>> backingEntries = backingMap.entrySet().iterator();
     return new Iterator<E>() {
-      @NullableDecl Map.Entry<E, Count> toRemove;
+      Map.@Nullable Entry<E, Count> toRemove;
 
       @Override
       public boolean hasNext() {
@@ -113,7 +113,7 @@ public void remove() {
   Iterator<Entry<E>> entryIterator() {
     final Iterator<Map.Entry<E, Count>> backingEntries = backingMap.entrySet().iterator();
     return new Iterator<Multiset.Entry<E>>() {
-      @NullableDecl Map.Entry<E, Count> toRemove;
+      Map.@Nullable Entry<E, Count> toRemove;
 
       @Override
       public boolean hasNext() {
@@ -233,7 +233,7 @@ public void remove() {
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     Count frequency = Maps.safeGet(backingMap, element);
     return (frequency == null) ? 0 : frequency.get();
   }
@@ -248,7 +248,7 @@ public int count(@NullableDecl Object element) {
    */
   @CanIgnoreReturnValue
   @Override
-  public int add(@NullableDecl E element, int occurrences) {
+  public int add(@Nullable E element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
@@ -270,7 +270,7 @@ public int add(@NullableDecl E element, int occurrences) {
 
   @CanIgnoreReturnValue
   @Override
-  public int remove(@NullableDecl Object element, int occurrences) {
+  public int remove(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
@@ -298,7 +298,7 @@ public int remove(@NullableDecl Object element, int occurrences) {
   // Roughly a 33% performance improvement over AbstractMultiset.setCount().
   @CanIgnoreReturnValue
   @Override
-  public int setCount(@NullableDecl E element, int count) {
+  public int setCount(@Nullable E element, int count) {
     checkNonnegative(count, ""count"");
 
     Count existingCounter;
@@ -319,7 +319,7 @@ public int setCount(@NullableDecl E element, int count) {
     return oldCount;
   }
 
-  private static int getAndSet(@NullableDecl Count i, int count) {
+  private static int getAndSet(@Nullable Count i, int count) {
     if (i == null) {
       return 0;
     }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Objects;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@code
@@ -42,7 +42,7 @@ public V setValue(V value) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Entry) {
       Entry<?, ?> that = (Entry<?, ?>) object;
       return Objects.equal(this.getKey(), that.getKey()), @@ -30,7 +30,7 @@
 import java.util.Spliterator;
 import java.util.Spliterators;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A skeleton {@code Multimap} implementation, not necessarily in terms of a {@code Map}.
@@ -45,7 +45,7 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     for (Collection<V> collection : asMap().values()) {
       if (collection.contains(value)) {
         return true;
@@ -56,27 +56,27 @@ public boolean containsValue(@NullableDecl Object value) {
   }
 
   @Override
-  public boolean containsEntry(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
     Collection<V> collection = asMap().get(key);
     return collection != null && collection.contains(value);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean remove(@Nullable Object key, @Nullable Object value) {
     Collection<V> collection = asMap().get(key);
     return collection != null && collection.remove(value);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public boolean put(@NullableDecl K key, @NullableDecl V value) {
+  public boolean put(@Nullable K key, @Nullable V value) {
     return get(key).add(value);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public boolean putAll(@NullableDecl K key, Iterable<? extends V> values) {
+  public boolean putAll(@Nullable K key, Iterable<? extends V> values) {
     checkNotNull(values);
     // make sure we only call values.iterator() once
     // and we only call get(key) if values is nonempty
@@ -101,7 +101,7 @@ public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
 
   @CanIgnoreReturnValue
   @Override
-  public Collection<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     checkNotNull(values);
     Collection<V> result = removeAll(key);
     putAll(key, values);
@@ -144,7 +144,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       return Sets.equalsImpl(this, obj);
     }
   }
@@ -204,7 +204,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       return AbstractMultimap.this.containsValue(o);
     }
 
@@ -235,7 +235,7 @@ public void clear() {
   // Comparison and hashing
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return Multimaps.equalsImpl(this, object);
   }
 , @@ -26,7 +26,7 @@
 import java.util.Iterator;
 import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link Multiset} interface. A new multiset
@@ -51,45 +51,45 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object element) {
+  public boolean contains(@Nullable Object element) {
     return count(element) > 0;
   }
 
   // Modification Operations
   @CanIgnoreReturnValue
   @Override
-  public final boolean add(@NullableDecl E element) {
+  public final boolean add(@Nullable E element) {
     add(element, 1);
     return true;
   }
 
   @CanIgnoreReturnValue
   @Override
-  public int add(@NullableDecl E element, int occurrences) {
+  public int add(@Nullable E element, int occurrences) {
     throw new UnsupportedOperationException();
   }
 
   @CanIgnoreReturnValue
   @Override
-  public final boolean remove(@NullableDecl Object element) {
+  public final boolean remove(@Nullable Object element) {
     return remove(element, 1) > 0;
   }
 
   @CanIgnoreReturnValue
   @Override
-  public int remove(@NullableDecl Object element, int occurrences) {
+  public int remove(@Nullable Object element, int occurrences) {
     throw new UnsupportedOperationException();
   }
 
   @CanIgnoreReturnValue
   @Override
-  public int setCount(@NullableDecl E element, int count) {
+  public int setCount(@Nullable E element, int count) {
     return setCountImpl(this, element, count);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public boolean setCount(@NullableDecl E element, int oldCount, int newCount) {
+  public boolean setCount(@Nullable E element, int oldCount, int newCount) {
     return setCountImpl(this, element, oldCount, newCount);
   }
 
@@ -204,7 +204,7 @@ public int size() {
    * and if, for each element, the two multisets have the same count.
    */
   @Override
-  public final boolean equals(@NullableDecl Object object) {
+  public final boolean equals(@Nullable Object object) {
     return Multisets.equalsImpl(this, object);
   }
 , @@ -24,7 +24,7 @@
 import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.SortedMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeletal implementation of {@link NavigableMap}.
@@ -36,29 +36,29 @@
     implements NavigableMap<K, V> {
 
   @Override
-  @NullableDecl
-  public abstract V get(@NullableDecl Object key);
+  @Nullable
+  public abstract V get(@Nullable Object key);
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> firstEntry() {
     return Iterators.getNext(entryIterator(), null);
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> lastEntry() {
     return Iterators.getNext(descendingEntryIterator(), null);
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> pollFirstEntry() {
     return Iterators.pollNext(entryIterator());
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> pollLastEntry() {
     return Iterators.pollNext(descendingEntryIterator());
   }
@@ -84,25 +84,25 @@ public K lastKey() {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> lowerEntry(K key) {
     return headMap(key, false).lastEntry();
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> floorEntry(K key) {
     return headMap(key, true).lastEntry();
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> ceilingEntry(K key) {
     return tailMap(key, true).firstEntry();
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<K, V> higherEntry(K key) {
     return tailMap(key, false).firstEntry();
   }, @@ -15,7 +15,7 @@
 package com.google.common.collect;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A skeletal implementation of {@code RangeSet}.
@@ -78,7 +78,7 @@ public boolean intersects(Range<C> otherRange) {
   public abstract boolean encloses(Range<C> otherRange);
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     } else if (obj instanceof RangeSet) {, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@code Iterator} interface for sequences
@@ -41,13 +41,13 @@
  */
 @GwtCompatible
 public abstract class AbstractSequentialIterator<T> extends UnmodifiableIterator<T> {
-  @NullableDecl private T nextOrNull;
+  @Nullable private T nextOrNull;
 
   /**
    * Creates a new iterator with the given first element, or, if {@code firstOrNull} is null,
    * creates a new empty iterator.
    */
-  protected AbstractSequentialIterator(@NullableDecl T firstOrNull) {
+  protected AbstractSequentialIterator(@Nullable T firstOrNull) {
     this.nextOrNull = firstOrNull;
   }
 , @@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link SetMultimap} interface. It's a wrapper around {@link
@@ -71,7 +71,7 @@ protected AbstractSetMultimap(Map<K, Collection<V>> map) {
    * {@link Set}, instead of the {@link Collection} specified in the {@link Multimap} interface.
    */
   @Override
-  public Set<V> get(@NullableDecl K key) {
+  public Set<V> get(@Nullable K key) {
     return (Set<V>) super.get(key);
   }
 
@@ -94,7 +94,7 @@ protected AbstractSetMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public Set<V> removeAll(@NullableDecl Object key) {
+  public Set<V> removeAll(@Nullable Object key) {
     return (Set<V>) super.removeAll(key);
   }
 
@@ -108,7 +108,7 @@ protected AbstractSetMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public Set<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public Set<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     return (Set<V>) super.replaceValues(key, values);
   }
 
@@ -133,7 +133,7 @@ protected AbstractSetMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public boolean put(@NullableDecl K key, @NullableDecl V value) {
+  public boolean put(@Nullable K key, @Nullable V value) {
     return super.put(key, value);
   }
 
@@ -144,7 +144,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    * Equality does not depend on the ordering of keys or values.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return super.equals(object);
   }
 , @@ -22,7 +22,7 @@
 import java.util.Iterator;
 import java.util.NavigableSet;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link SortedMultiset} interface.
@@ -100,9 +100,9 @@
 
   @Override
   public SortedMultiset<E> subMultiset(
-      @NullableDecl E fromElement,
+      @Nullable E fromElement,
       BoundType fromBoundType,
-      @NullableDecl E toElement,
+      @Nullable E toElement,
       BoundType toBoundType) {
     // These are checked elsewhere, but NullPointerTester wants them checked eagerly.
     checkNotNull(fromBoundType);, @@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Basic implementation of the {@link SortedSetMultimap} interface. It's a wrapper around {@link
@@ -83,7 +83,7 @@ protected AbstractSortedSetMultimap(Map<K, Collection<V>> map) {
    * Multimap} interface.
    */
   @Override
-  public SortedSet<V> get(@NullableDecl K key) {
+  public SortedSet<V> get(@Nullable K key) {
     return (SortedSet<V>) super.get(key);
   }
 
@@ -96,7 +96,7 @@ protected AbstractSortedSetMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public SortedSet<V> removeAll(@NullableDecl Object key) {
+  public SortedSet<V> removeAll(@Nullable Object key) {
     return (SortedSet<V>) super.removeAll(key);
   }
 
@@ -112,7 +112,7 @@ protected AbstractSortedSetMultimap(Map<K, Collection<V>> map) {
    */
   @CanIgnoreReturnValue
   @Override
-  public SortedSet<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public SortedSet<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     return (SortedSet<V>) super.replaceValues(key, values);
   }
 , @@ -26,7 +26,7 @@
 import java.util.Set;
 import java.util.Spliterator;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeletal, implementation-agnostic implementation of the {@link Table} interface.
@@ -37,12 +37,12 @@
 abstract class AbstractTable<R, C, V> implements Table<R, C, V> {
 
   @Override
-  public boolean containsRow(@NullableDecl Object rowKey) {
+  public boolean containsRow(@Nullable Object rowKey) {
     return Maps.safeContainsKey(rowMap(), rowKey);
   }
 
   @Override
-  public boolean containsColumn(@NullableDecl Object columnKey) {
+  public boolean containsColumn(@Nullable Object columnKey) {
     return Maps.safeContainsKey(columnMap(), columnKey);
   }
 
@@ -57,7 +57,7 @@ public boolean containsColumn(@NullableDecl Object columnKey) {
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     for (Map<C, V> row : rowMap().values()) {
       if (row.containsValue(value)) {
         return true;
@@ -67,13 +67,13 @@ public boolean containsValue(@NullableDecl Object value) {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
     Map<C, V> row = Maps.safeGet(rowMap(), rowKey);
     return row != null && Maps.safeContainsKey(row, columnKey);
   }
 
   @Override
-  public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
     Map<C, V> row = Maps.safeGet(rowMap(), rowKey);
     return (row == null) ? null : Maps.safeGet(row, columnKey);
   }
@@ -90,7 +90,7 @@ public void clear() {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
     Map<C, V> row = Maps.safeGet(rowMap(), rowKey);
     return (row == null) ? null : Maps.safeRemove(row, columnKey);
   }
@@ -139,7 +139,7 @@ public boolean contains(Object o) {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       if (o instanceof Cell) {
         Cell<?, ?, ?> cell = (Cell<?, ?, ?>) o;
         Map<C, V> row = Maps.safeGet(rowMap(), cell.getRowKey());
@@ -225,7 +225,7 @@ public int size() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     return Tables.equalsImpl(this, obj);
   }
 , @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An ordering that treats all references as equals, even nulls.
@@ -31,7 +31,7 @@
   static final AllEqualOrdering INSTANCE = new AllEqualOrdering();
 
   @Override
-  public int compare(@NullableDecl Object left, @NullableDecl Object right) {
+  public int compare(@Nullable Object left, @Nullable Object right) {
     return 0;
   }
 , @@ -36,7 +36,7 @@
 import java.util.Set;
 import java.util.Spliterator;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Fixed-size {@link Table} implementation backed by a two-dimensional array.
@@ -190,10 +190,10 @@ K getKey(int index) {
 
     abstract String getKeyRole();
 
-    @NullableDecl
+    @Nullable
     abstract V getValue(int index);
 
-    @NullableDecl
+    @Nullable
     abstract V setValue(int index, V newValue);
 
     @Override
@@ -244,12 +244,12 @@ public V setValue(V value) {
     // TODO(lowasser): consider an optimized values() implementation
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return keyIndex.containsKey(key);
     }
 
     @Override
-    public V get(@NullableDecl Object key) {
+    public V get(@Nullable Object key) {
       Integer index = keyIndex.get(key);
       if (index == null) {
         return null;
@@ -328,7 +328,7 @@ public V at(int rowIndex, int columnIndex) {
    *     to the number of allowed column keys
    */
   @CanIgnoreReturnValue
-  public V set(int rowIndex, int columnIndex, @NullableDecl V value) {
+  public V set(int rowIndex, int columnIndex, @Nullable V value) {
     // In GWT array access never throws IndexOutOfBoundsException.
     checkElementIndex(rowIndex, rowList.size());
     checkElementIndex(columnIndex, columnList.size());
@@ -380,7 +380,7 @@ public void eraseAll() {
    * constructed.
    */
   @Override
-  public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
     return containsRow(rowKey) && containsColumn(columnKey);
   }
 
@@ -389,7 +389,7 @@ public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object column
    * table was constructed.
    */
   @Override
-  public boolean containsColumn(@NullableDecl Object columnKey) {
+  public boolean containsColumn(@Nullable Object columnKey) {
     return columnKeyToIndex.containsKey(columnKey);
   }
 
@@ -398,12 +398,12 @@ public boolean containsColumn(@NullableDecl Object columnKey) {
    * constructed.
    */
   @Override
-  public boolean containsRow(@NullableDecl Object rowKey) {
+  public boolean containsRow(@Nullable Object rowKey) {
     return rowKeyToIndex.containsKey(rowKey);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     for (V[] row : array) {
       for (V element : row) {
         if (Objects.equal(value, element)) {
@@ -415,7 +415,7 @@ public boolean containsValue(@NullableDecl Object value) {
   }
 
   @Override
-  public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
     return (rowIndex == null || columnIndex == null) ? null : at(rowIndex, columnIndex);
@@ -437,7 +437,7 @@ public boolean isEmpty() {
    */
   @CanIgnoreReturnValue
   @Override
-  public V put(R rowKey, C columnKey, @NullableDecl V value) {
+  public V put(R rowKey, C columnKey, @Nullable V value) {
     checkNotNull(rowKey);
     checkNotNull(columnKey);
     Integer rowIndex = rowKeyToIndex.get(rowKey);
@@ -494,7 +494,7 @@ public V remove(Object rowKey, Object columnKey) {
    *     for the keys
    */
   @CanIgnoreReturnValue
-  public V erase(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V erase(@Nullable Object rowKey, @Nullable Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
     if (rowIndex == null || columnIndex == null) {, @@ -20,7 +20,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A bimap (or ""bidirectional map"") is a map that preserves the uniqueness of its values as well as
@@ -46,8 +46,8 @@
    */
   @CanIgnoreReturnValue
   @Override
-  @NullableDecl
-  V put(@NullableDecl K key, @NullableDecl V value);
+  @Nullable
+  V put(@Nullable K key, @Nullable V value);
 
   /**
    * An alternate form of {@code put} that silently removes any existing entry with the value {@code
@@ -66,8 +66,8 @@
    *     {@code null} if there was no previous entry
    */
   @CanIgnoreReturnValue
-  @NullableDecl
-  V forcePut(@NullableDecl K key, @NullableDecl V value);
+  @Nullable
+  V forcePut(@Nullable K key, @Nullable V value);
 
   // Bulk Operations
 , @@ -22,7 +22,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An ordering that orders elements by applying an order to the result of a function on those
@@ -44,7 +44,7 @@ public int compare(F left, F right) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.ListIterator;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Lists#cartesianProduct(List)}.
@@ -96,7 +96,7 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object o) {
+  public boolean contains(@Nullable Object o) {
     if (!(o instanceof List)) {
       return false;
     }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map, each entry of which maps a Java <a href=""http://tinyurl.com/2cmwkz"">raw type</a> to an
@@ -58,5 +58,5 @@
    *     null} if there was no previous entry.
    */
   @CanIgnoreReturnValue
-  <T extends B> T putInstance(Class<T> type, @NullableDecl T value);
+  <T extends B> T putInstance(Class<T> type, @Nullable T value);
 }, @@ -28,7 +28,7 @@
 import java.util.function.IntFunction;
 import java.util.function.Predicate;
 import java.util.stream.IntStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Spliterator utilities for {@code common.collect} internals. */
 @GwtCompatible
@@ -65,7 +65,7 @@ public void forEachRemaining(Consumer<? super T> action) {
       }
 
       @Override
-      @NullableDecl
+      @Nullable
       public Spliterator<T> trySplit() {
         Spliterator.OfInt split = delegate.trySplit();
         return (split == null) ? null : new WithCharacteristics(split);
@@ -209,7 +209,7 @@ public int characteristics() {
     checkNotNull(fromSpliterator);
     checkNotNull(function);
     class FlatMapSpliterator implements Spliterator<T> {
-      @NullableDecl Spliterator<T> prefix;
+      @Nullable Spliterator<T> prefix;
       final Spliterator<F> from;
       int characteristics;
       long estimatedSize;, @@ -37,7 +37,7 @@
 import java.util.List;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods for working with {@code Collection} instances.
@@ -97,7 +97,7 @@ private Collections2() {}
    * Delegates to {@link Collection#contains}. Returns {@code false} if the {@code contains} method
    * throws a {@code ClassCastException} or {@code NullPointerException}.
    */
-  static boolean safeContains(Collection<?> collection, @NullableDecl Object object) {
+  static boolean safeContains(Collection<?> collection, @Nullable Object object) {
     checkNotNull(collection);
     try {
       return collection.contains(object);
@@ -110,7 +110,7 @@ static boolean safeContains(Collection<?> collection, @NullableDecl Object objec
    * Delegates to {@link Collection#remove}. Returns {@code false} if the {@code remove} method
    * throws a {@code ClassCastException} or {@code NullPointerException}.
    */
-  static boolean safeRemove(Collection<?> collection, @NullableDecl Object object) {
+  static boolean safeRemove(Collection<?> collection, @Nullable Object object) {
     checkNotNull(collection);
     try {
       return collection.remove(object);
@@ -153,7 +153,7 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object element) {
+    public boolean contains(@Nullable Object element) {
       if (safeContains(unfiltered, element)) {
         @SuppressWarnings(""unchecked"") // element is in unfiltered, so it must be an E
         E e = (E) element;
@@ -494,7 +494,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object obj) {
+    public boolean contains(@Nullable Object obj) {
       if (obj instanceof List) {
         List<?> list = (List<?>) obj;
         return isPermutation(inputList, list);
@@ -509,7 +509,7 @@ public String toString() {
   }
 
   private static final class OrderedPermutationIterator<E> extends AbstractIterator<List<E>> {
-    @NullableDecl List<E> nextPermutation;
+    @Nullable List<E> nextPermutation;
     final Comparator<? super E> comparator;
 
     OrderedPermutationIterator(List<E> list, Comparator<? super E> comparator) {
@@ -605,7 +605,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object obj) {
+    public boolean contains(@Nullable Object obj) {
       if (obj instanceof List) {
         List<?> list = (List<?>) obj;
         return isPermutation(inputList, list);, @@ -44,7 +44,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactHashMap is an implementation of a Map. All optional operations (put and remove) are
@@ -236,8 +236,8 @@ void accessEntry(int index) {
 
   @CanIgnoreReturnValue
   @Override
-  @NullableDecl
-  public V put(@NullableDecl K key, @NullableDecl V value) {
+  @Nullable
+  public V put(@Nullable K key, @Nullable V value) {
     long[] entries = this.entries;
     Object[] keys = this.keys;
     Object[] values = this.values;
@@ -256,7 +256,7 @@ public V put(@NullableDecl K key, @NullableDecl V value) {
         entry = entries[next];
         if (getHash(entry) == hash && Objects.equal(key, keys[next])) {
           @SuppressWarnings(""unchecked"") // known to be a V
-          @NullableDecl
+          @Nullable
           V oldValue = (V) values[next];
 
           values[next] = value;
@@ -284,7 +284,7 @@ public V put(@NullableDecl K key, @NullableDecl V value) {
   /**
    * Creates a fresh entry with the specified object at the specified position in the entry arrays.
    */
-  void insertEntry(int entryIndex, @NullableDecl K key, @NullableDecl V value, int hash) {
+  void insertEntry(int entryIndex, @Nullable K key, @Nullable V value, int hash) {
     this.entries[entryIndex] = ((long) hash << 32) | (NEXT_MASK & UNSET);
     this.keys[entryIndex] = key;
     this.values[entryIndex] = value;
@@ -345,7 +345,7 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
     this.table = newTable;
   }
 
-  private int indexOf(@NullableDecl Object key) {
+  private int indexOf(@Nullable Object key) {
     int hash = smearedHash(key);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -359,27 +359,27 @@ private int indexOf(@NullableDecl Object key) {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return indexOf(key) != -1;
   }
 
   @SuppressWarnings(""unchecked"") // values only contains Vs
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     int index = indexOf(key);
     accessEntry(index);
     return (index == -1) ? null : (V) values[index];
   }
 
   @CanIgnoreReturnValue
   @Override
-  @NullableDecl
-  public V remove(@NullableDecl Object key) {
+  @Nullable
+  public V remove(@Nullable Object key) {
     return remove(key, smearedHash(key));
   }
 
-  @NullableDecl
-  private V remove(@NullableDecl Object key, int hash) {
+  @Nullable
+  private V remove(@Nullable Object key, int hash) {
     int tableIndex = hash & hashTableMask();
     int next = table[tableIndex];
     if (next == UNSET) { // empty bucket
@@ -390,7 +390,7 @@ private V remove(@NullableDecl Object key, int hash) {
       if (getHash(entries[next]) == hash) {
         if (Objects.equal(key, keys[next])) {
           @SuppressWarnings(""unchecked"") // values only contains Vs
-          @NullableDecl
+          @Nullable
           V oldValue = (V) values[next];
 
           if (last == UNSET) {
@@ -554,7 +554,7 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       int index = indexOf(o);
       if (index == -1) {
         return false;
@@ -631,7 +631,7 @@ public void forEach(BiConsumer<? super K, ? super V> action) {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) o;
         int index = indexOf(entry.getKey());
@@ -641,7 +641,7 @@ public boolean contains(@NullableDecl Object o) {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) o;
         int index = indexOf(entry.getKey());
@@ -664,7 +664,7 @@ public boolean remove(@NullableDecl Object o) {
   }
 
   final class MapEntry extends AbstractMapEntry<K, V> {
-    @NullableDecl private final K key;
+    @Nullable private final K key;
 
     private int lastKnownIndex;
 
@@ -720,7 +720,7 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     for (int i = 0; i < size; i++) {
       if (Objects.equal(value, values[i])) {
         return true;, @@ -39,7 +39,7 @@
 import java.util.Spliterators;
 import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * CompactHashSet is an implementation of a Set. All optional operations (adding and removing) are
@@ -226,7 +226,7 @@ private int hashTableMask() {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean add(@NullableDecl E object) {
+  public boolean add(@Nullable E object) {
     long[] entries = this.entries;
     Object[] elements = this.elements;
     int hash = smearedHash(object);
@@ -325,7 +325,7 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     int hash = smearedHash(object);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -340,7 +340,7 @@ public boolean contains(@NullableDecl Object object) {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean remove(@NullableDecl Object object) {
+  public boolean remove(@Nullable Object object) {
     return remove(object, smearedHash(object));
   }
 , @@ -21,7 +21,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Comparator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering for a pre-existing comparator. */
 @GwtCompatible(serializable = true)
@@ -38,7 +38,7 @@ public int compare(T a, T b) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -21,7 +21,7 @@
 import com.google.common.primitives.Ints;
 import com.google.common.primitives.Longs;
 import java.util.Comparator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A utility for performing a chained comparison statement. For example:
@@ -75,7 +75,7 @@ public ComparisonChain compare(Comparable left, Comparable right) {
 
         @Override
         public <T> ComparisonChain compare(
-            @NullableDecl T left, @NullableDecl T right, Comparator<T> comparator) {
+            @Nullable T left, @Nullable T right, Comparator<T> comparator) {
           return classify(comparator.compare(left, right));
         }
 
@@ -131,13 +131,13 @@ public int result() {
     }
 
     @Override
-    public ComparisonChain compare(@NullableDecl Comparable left, @NullableDecl Comparable right) {
+    public ComparisonChain compare(@Nullable Comparable left, @Nullable Comparable right) {
       return this;
     }
 
     @Override
     public <T> ComparisonChain compare(
-        @NullableDecl T left, @NullableDecl T right, @NullableDecl Comparator<T> comparator) {
+        @Nullable T left, @Nullable T right, @Nullable Comparator<T> comparator) {
       return this;
     }
 
@@ -188,7 +188,7 @@ public int result() {
    * already been determined.
    */
   public abstract <T> ComparisonChain compare(
-      @NullableDecl T left, @NullableDecl T right, Comparator<T> comparator);
+      @Nullable T left, @Nullable T right, Comparator<T> comparator);
 
   /**
    * Compares two {@code int} values as specified by {@link Ints#compare}, <i>if</i> the result of, @@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import com.google.common.annotations.GwtCompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Wraps an exception that occurred during a computation.
@@ -28,7 +28,7 @@
 @GwtCompatible
 public class ComputationException extends RuntimeException {
   /** Creates a new instance with the given cause. */
-  public ComputationException(@NullableDecl Throwable cause) {
+  public ComputationException(@Nullable Throwable cause) {
     super(cause);
   }
 , @@ -41,7 +41,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset that supports concurrent modifications and that provides atomic versions of most
@@ -137,7 +137,7 @@
    * @return the nonnegative number of occurrences of the element
    */
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     AtomicInteger existingCounter = Maps.safeGet(countMap, element);
     return (existingCounter == null) ? 0 : existingCounter.get();
   }
@@ -261,13 +261,13 @@ public int add(E element, int occurrences) {
    * if occurrences == 0. This satisfies both NullPointerTester and
    * CollectionRemoveTester.testRemove_nullAllowed, but it's not clear that it's
    * a good policy, especially because, in order for the test to pass, the
-   * parameter must be misleadingly annotated as @NullableDecl. I suspect that
-   * we'll want to remove @NullableDecl, add an eager checkNotNull, and loosen up
+   * parameter must be misleadingly annotated as @Nullable. I suspect that
+   * we'll want to remove @Nullable, add an eager checkNotNull, and loosen up
    * testRemove_nullAllowed.
    */
   @CanIgnoreReturnValue
   @Override
-  public int remove(@NullableDecl Object element, int occurrences) {
+  public int remove(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
@@ -308,7 +308,7 @@ public int remove(@NullableDecl Object element, int occurrences) {
    * @throws IllegalArgumentException if {@code occurrences} is negative
    */
   @CanIgnoreReturnValue
-  public boolean removeExactly(@NullableDecl Object element, int occurrences) {
+  public boolean removeExactly(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return true;
     }
@@ -454,7 +454,7 @@ public boolean setCount(E element, int expectedOldCount, int newCount) {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object object) {
+      public boolean contains(@Nullable Object object) {
         return object != null && Collections2.safeContains(delegate, object);
       }
 
@@ -522,7 +522,7 @@ public boolean isEmpty() {
         };
 
     return new ForwardingIterator<Entry<E>>() {
-      @NullableDecl private Entry<E> last;
+      @Nullable private Entry<E> last;
 
       @Override
       protected Iterator<Entry<E>> delegate() {, @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mutable value of type {@code int}, for multisets to use in tracking counts of values.
@@ -59,7 +59,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     return obj instanceof Count && ((Count) obj).value == value;
   }
 , @@ -20,7 +20,7 @@
 import com.google.common.primitives.Booleans;
 import java.io.Serializable;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation detail for the internal structure of {@link Range} instances. Represents a unique
@@ -33,9 +33,9 @@
  */
 @GwtCompatible
 abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializable {
-  @NullableDecl final C endpoint;
+  @Nullable final C endpoint;
 
-  Cut(@NullableDecl C endpoint) {
+  Cut(@Nullable C endpoint) {
     this.endpoint = endpoint;
   }
 
@@ -326,7 +326,7 @@ BoundType typeAsUpperBound() {
         case CLOSED:
           return this;
         case OPEN:
-          @NullableDecl C previous = domain.previous(endpoint);
+          @Nullable C previous = domain.previous(endpoint);
           return (previous == null) ? Cut.<C>belowAll() : new AboveValue<C>(previous);
         default:
           throw new AssertionError();
@@ -337,7 +337,7 @@ BoundType typeAsUpperBound() {
     Cut<C> withUpperBoundType(BoundType boundType, DiscreteDomain<C> domain) {
       switch (boundType) {
         case CLOSED:
-          @NullableDecl C previous = domain.previous(endpoint);
+          @Nullable C previous = domain.previous(endpoint);
           return (previous == null) ? Cut.<C>aboveAll() : new AboveValue<C>(previous);
         case OPEN:
           return this;
@@ -409,7 +409,7 @@ BoundType typeAsUpperBound() {
         case OPEN:
           return this;
         case CLOSED:
-          @NullableDecl C next = domain.next(endpoint);
+          @Nullable C next = domain.next(endpoint);
           return (next == null) ? Cut.<C>belowAll() : belowValue(next);
         default:
           throw new AssertionError();
@@ -420,7 +420,7 @@ BoundType typeAsUpperBound() {
     Cut<C> withUpperBoundType(BoundType boundType, DiscreteDomain<C> domain) {
       switch (boundType) {
         case OPEN:
-          @NullableDecl C next = domain.next(endpoint);
+          @Nullable C next = domain.next(endpoint);
           return (next == null) ? Cut.<C>aboveAll() : belowValue(next);
         case CLOSED:
           return this;, @@ -21,7 +21,7 @@
 import com.google.errorprone.annotations.Immutable;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** A {@code RegularImmutableTable} optimized for dense data. */
 @GwtCompatible
@@ -101,7 +101,7 @@ K getKey(int index) {
       return keyToIndex().keySet().asList().get(index);
     }
 
-    @NullableDecl
+    @Nullable
     abstract V getValue(int keyIndex);
 
     @Override
@@ -115,7 +115,7 @@ public int size() {
     }
 
     @Override
-    public V get(@NullableDecl Object key) {
+    public V get(@Nullable Object key) {
       Integer keyIndex = keyToIndex().get(key);
       return (keyIndex == null) ? null : getValue(keyIndex);
     }
@@ -247,7 +247,7 @@ boolean isPartialView() {
   }
 
   @Override
-  public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
     Integer rowIndex = rowKeyToIndex.get(rowKey);
     Integer columnIndex = columnKeyToIndex.get(columnKey);
     return ((rowIndex == null) || (columnIndex == null)) ? null : values[rowIndex][columnIndex];, @@ -15,7 +15,7 @@
 package com.google.common.collect;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A descending wrapper around an {@code ImmutableSortedMultiset}
@@ -32,7 +32,7 @@
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     return forward.count(element);
   }
 , @@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Skeletal implementation of {@link ImmutableSortedSet#descendingSet()}.
@@ -34,7 +34,7 @@
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return forward.contains(object);
   }
 
@@ -103,7 +103,7 @@ public E higher(E element) {
   }
 
   @Override
-  int indexOf(@NullableDecl Object target) {
+  int indexOf(@Nullable Object target) {
     int index = forward.indexOf(target);
     if (index == -1) {
       return index;, @@ -18,7 +18,7 @@
 import java.io.Serializable;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An empty contiguous set.
@@ -121,7 +121,7 @@ public String toString() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Set) {
       Set<?> that = (Set<?>) object;
       return that.isEmpty();, @@ -27,7 +27,7 @@
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code BiMap} backed by an {@code EnumMap} instance for keys-to-values, and a {@code HashMap}
@@ -85,13 +85,13 @@ K checkKey(K key) {
 
   @CanIgnoreReturnValue
   @Override
-  public V put(K key, @NullableDecl V value) {
+  public V put(K key, @Nullable V value) {
     return super.put(key, value);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public V forcePut(K key, @NullableDecl V value) {
+  public V forcePut(K key, @Nullable V value) {
     return super.forcePut(key, value);
   }
 , @@ -31,7 +31,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.function.ObjIntConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Multiset implementation specialized for enum elements, supporting all single-element operations
@@ -94,7 +94,7 @@ private EnumMultiset(Class<E> type) {
     this.counts = new int[enumConstants.length];
   }
 
-  private boolean isActuallyE(@NullableDecl Object o) {
+  private boolean isActuallyE(@Nullable Object o) {
     if (o instanceof Enum) {
       Enum<?> e = (Enum<?>) o;
       int index = e.ordinal();
@@ -108,7 +108,7 @@ private boolean isActuallyE(@NullableDecl Object o) {
    * either a NullPointerException or a ClassCastException as appropriate.
    */
   @SuppressWarnings(""unchecked"")
-  void checkIsE(@NullableDecl Object element) {
+  void checkIsE(@Nullable Object element) {
     checkNotNull(element);
     if (!isActuallyE(element)) {
       throw new ClassCastException(""Expected an "" + type + "" but got "" + element);
@@ -126,7 +126,7 @@ public int size() {
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     if (element == null || !isActuallyE(element)) {
       return 0;
     }
@@ -158,7 +158,7 @@ public int add(E element, int occurrences) {
   // Modification Operations
   @CanIgnoreReturnValue
   @Override
-  public int remove(@NullableDecl Object element, int occurrences) {
+  public int remove(@Nullable Object element, int occurrences) {
     if (element == null || !isActuallyE(element)) {
       return 0;
     }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that compares objects according to a given order. */
 @GwtCompatible(serializable = true)
@@ -48,7 +48,7 @@ private int rank(T value) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof ExplicitOrdering) {
       ExplicitOrdering<?> that = (ExplicitOrdering<?>) object;
       return this.rankMap.equals(that.rankMap);, @@ -33,7 +33,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterEntries(Multimap, Predicate)}.
@@ -78,7 +78,7 @@ private boolean satisfies(K key, V value) {
     }
 
     @Override
-    public boolean apply(@NullableDecl V value) {
+    public boolean apply(@Nullable V value) {
       return satisfies(key, value);
     }
   }
@@ -93,12 +93,12 @@ public boolean apply(@NullableDecl V value) {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return asMap().get(key) != null;
   }
 
   @Override
-  public Collection<V> removeAll(@NullableDecl Object key) {
+  public Collection<V> removeAll(@Nullable Object key) {
     return MoreObjects.firstNonNull(asMap().remove(key), unmodifiableEmptyCollection());
   }
 
@@ -166,7 +166,7 @@ boolean removeEntriesIf(Predicate<? super Entry<K, Collection<V>>> predicate) {
   @WeakOuter
   class AsMap extends ViewCachingAbstractMap<K, Collection<V>> {
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return get(key) != null;
     }
 
@@ -176,7 +176,7 @@ public void clear() {
     }
 
     @Override
-    public Collection<V> get(@NullableDecl Object key) {
+    public Collection<V> get(@Nullable Object key) {
       Collection<V> result = unfiltered.asMap().get(key);
       if (result == null) {
         return null;
@@ -188,7 +188,7 @@ public void clear() {
     }
 
     @Override
-    public Collection<V> remove(@NullableDecl Object key) {
+    public Collection<V> remove(@Nullable Object key) {
       Collection<V> collection = unfiltered.asMap().get(key);
       if (collection == null) {
         return null;
@@ -232,7 +232,7 @@ public boolean retainAll(Collection<?> c) {
         }
 
         @Override
-        public boolean remove(@NullableDecl Object o) {
+        public boolean remove(@Nullable Object o) {
           return AsMap.this.remove(o) != null;
         }
       }
@@ -297,7 +297,7 @@ public int size() {
         }
 
         @Override
-        public boolean remove(@NullableDecl Object o) {
+        public boolean remove(@Nullable Object o) {
           if (o instanceof Collection) {
             Collection<?> c = (Collection<?>) o;
             Iterator<Entry<K, Collection<V>>> entryIterator =
@@ -346,7 +346,7 @@ public boolean retainAll(Collection<?> c) {
     }
 
     @Override
-    public int remove(@NullableDecl Object key, int occurrences) {
+    public int remove(@Nullable Object key, int occurrences) {
       checkNonnegative(occurrences, ""occurrences"");
       if (occurrences == 0) {
         return count(key);, @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.base.Predicate;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(ListMultimap, Predicate)}.
@@ -44,7 +44,7 @@
   }
 
   @Override
-  public List<V> removeAll(@NullableDecl Object key) {
+  public List<V> removeAll(@Nullable Object key) {
     return (List<V>) super.removeAll(key);
   }
 , @@ -28,7 +28,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(Multimap, Predicate)}.
@@ -65,7 +65,7 @@ public int size() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     if (unfiltered.containsKey(key)) {
       @SuppressWarnings(""unchecked"") // k is equal to a K, if not one itself
       K k = (K) key;
@@ -190,7 +190,7 @@ public boolean addAll(int index, Collection<? extends V> elements) {
 
     @Override
     @SuppressWarnings(""unchecked"")
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       if (o instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) o;
         if (unfiltered.containsKey(entry.getKey()), @@ -20,7 +20,7 @@
 import com.google.common.base.Predicate;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Multimaps#filterKeys(SetMultimap, Predicate)}.
@@ -72,7 +72,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       return Sets.equalsImpl(this, o);
     }
   }, @@ -25,7 +25,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation for {@link FilteredMultimap#values()}.
@@ -46,7 +46,7 @@
   }
 
   @Override
-  public boolean contains(@NullableDecl Object o) {
+  public boolean contains(@Nullable Object o) {
     return multimap.containsValue(o);
   }
 
@@ -56,7 +56,7 @@ public int size() {
   }
 
   @Override
-  public boolean remove(@NullableDecl Object o) {
+  public boolean remove(@Nullable Object o) {
     Predicate<? super Entry<K, V>> entryPredicate = multimap.entryPredicate();
     for (Iterator<Entry<K, V>> unfilteredItr = multimap.unfiltered().entries().iterator();
         unfilteredItr.hasNext(); ) {, @@ -31,7 +31,7 @@
 import java.util.List;
 import java.util.SortedSet;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A discouraged (but not deprecated) precursor to Java's superior {@link Stream} library.
@@ -321,7 +321,7 @@ protected FluentIterable() {
    * @since 20.0
    */
   @Beta
-  public static <E> FluentIterable<E> of(@NullableDecl E element, E... elements) {
+  public static <E> FluentIterable<E> of(@Nullable E element, E... elements) {
     return from(Lists.asList(element, elements));
   }
 
@@ -352,7 +352,7 @@ public final int size() {
    *
    * <p><b>{@code Stream} equivalent:</b> {@code stream.anyMatch(Predicate.isEqual(target))}.
    */
-  public final boolean contains(@NullableDecl Object target) {
+  public final boolean contains(@Nullable Object target) {
     return Iterables.contains(getDelegate(), target);
   }
 
@@ -822,7 +822,7 @@ public final String join(Joiner joiner) {
    * @throws IndexOutOfBoundsException if {@code position} is negative or greater than or equal to
    *     the size of this fluent iterable
    */
-  // TODO(kevinb): add @NullableDecl?
+  // TODO(kevinb): add @Nullable?
   public final E get(int position) {
     return Iterables.get(getDelegate(), position);
   }, @@ -21,7 +21,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Collection;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection which forwards all its method calls to another collection. Subclasses should
@@ -133,7 +133,7 @@ public void clear() {
    *
    * @since 7.0
    */
-  protected boolean standardContains(@NullableDecl Object object) {
+  protected boolean standardContains(@Nullable Object object) {
     return Iterators.contains(iterator(), object);
   }
 
@@ -165,7 +165,7 @@ protected boolean standardAddAll(Collection<? extends E> collection) {
    *
    * @since 7.0
    */
-  protected boolean standardRemove(@NullableDecl Object object) {
+  protected boolean standardRemove(@Nullable Object object) {
     Iterator<E> iterator = iterator();
     while (iterator.hasNext()) {
       if (Objects.equal(iterator.next(), object)) {, @@ -23,7 +23,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list which forwards all its method calls to another list. Subclasses should override one or
@@ -114,7 +114,7 @@ public E set(int index, E element) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this || delegate().equals(object);
   }
 
@@ -153,7 +153,7 @@ protected boolean standardAddAll(int index, Iterable<? extends E> elements) {
    *
    * @since 7.0
    */
-  protected int standardIndexOf(@NullableDecl Object element) {
+  protected int standardIndexOf(@Nullable Object element) {
     return Lists.indexOfImpl(this, element);
   }
 
@@ -164,7 +164,7 @@ protected int standardIndexOf(@NullableDecl Object element) {
    *
    * @since 7.0
    */
-  protected int standardLastIndexOf(@NullableDecl Object element) {
+  protected int standardLastIndexOf(@Nullable Object element) {
     return Lists.lastIndexOfImpl(this, element);
   }
 
@@ -222,7 +222,7 @@ protected int standardLastIndexOf(@NullableDecl Object element) {
    * @since 7.0
    */
   @Beta
-  protected boolean standardEquals(@NullableDecl Object object) {
+  protected boolean standardEquals(@Nullable Object object) {
     return Lists.equalsImpl(this, object);
   }
 , @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A list multimap which forwards all its method calls to another list multimap. Subclasses should
@@ -44,13 +44,13 @@ protected ForwardingListMultimap() {}
   protected abstract ListMultimap<K, V> delegate();
 
   @Override
-  public List<V> get(@NullableDecl K key) {
+  public List<V> get(@Nullable K key) {
     return delegate().get(key);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public List<V> removeAll(@NullableDecl Object key) {
+  public List<V> removeAll(@Nullable Object key) {
     return delegate().removeAll(key);
   }
 , @@ -24,7 +24,7 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map which forwards all its method calls to another map. Subclasses should override one or more
@@ -86,17 +86,17 @@ public void clear() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return delegate().containsKey(key);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return delegate().containsValue(value);
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return delegate().get(key);
   }
 
@@ -127,7 +127,7 @@ public void putAll(Map<? extends K, ? extends V> map) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this || delegate().equals(object);
   }
 
@@ -158,7 +158,7 @@ protected void standardPutAll(Map<? extends K, ? extends V> map) {
    * @since 7.0
    */
   @Beta
-  protected V standardRemove(@NullableDecl Object key) {
+  protected V standardRemove(@Nullable Object key) {
     Iterator<Entry<K, V>> entryIterator = entrySet().iterator();
     while (entryIterator.hasNext()) {
       Entry<K, V> entry = entryIterator.next();
@@ -207,7 +207,7 @@ public StandardKeySet() {
    * @since 7.0
    */
   @Beta
-  protected boolean standardContainsKey(@NullableDecl Object key) {
+  protected boolean standardContainsKey(@Nullable Object key) {
     return Maps.containsKeyImpl(this, key);
   }
 
@@ -235,7 +235,7 @@ public StandardValues() {
    *
    * @since 7.0
    */
-  protected boolean standardContainsValue(@NullableDecl Object value) {
+  protected boolean standardContainsValue(@Nullable Object value) {
     return Maps.containsValueImpl(this, value);
   }
 
@@ -277,7 +277,7 @@ protected boolean standardIsEmpty() {
    *
    * @since 7.0
    */
-  protected boolean standardEquals(@NullableDecl Object object) {
+  protected boolean standardEquals(@Nullable Object object) {
     return Maps.equalsImpl(this, object);
   }
 , @@ -21,7 +21,7 @@
 import com.google.common.base.Objects;
 import java.util.Map;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map entry which forwards all its method calls to another map entry. Subclasses should override
@@ -72,7 +72,7 @@ public V setValue(V value) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return delegate().equals(object);
   }
 
@@ -88,7 +88,7 @@ public int hashCode() {
    *
    * @since 7.0
    */
-  protected boolean standardEquals(@NullableDecl Object object) {
+  protected boolean standardEquals(@Nullable Object object) {
     if (object instanceof Entry) {
       Entry<?, ?> that = (Entry<?, ?>) object;
       return Objects.equal(this.getKey(), that.getKey()), @@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multimap which forwards all its method calls to another multimap. Subclasses should override
@@ -56,17 +56,17 @@ public void clear() {
   }
 
   @Override
-  public boolean containsEntry(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean containsEntry(@Nullable Object key, @Nullable Object value) {
     return delegate().containsEntry(key, value);
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return delegate().containsKey(key);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return delegate().containsValue(value);
   }
 
@@ -76,7 +76,7 @@ public boolean containsValue(@NullableDecl Object value) {
   }
 
   @Override
-  public Collection<V> get(@NullableDecl K key) {
+  public Collection<V> get(@Nullable K key) {
     return delegate().get(key);
   }
 
@@ -115,13 +115,13 @@ public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean remove(@Nullable Object key, @Nullable Object value) {
     return delegate().remove(key, value);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public Collection<V> removeAll(@NullableDecl Object key) {
+  public Collection<V> removeAll(@Nullable Object key) {
     return delegate().removeAll(key);
   }
 
@@ -142,7 +142,7 @@ public int size() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this || delegate().equals(object);
   }
 , @@ -23,7 +23,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset which forwards all its method calls to another multiset. Subclasses should override
@@ -84,7 +84,7 @@ public int remove(Object element, int occurrences) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this || delegate().equals(object);
   }
 
@@ -112,7 +112,7 @@ public boolean setCount(E element, int oldCount, int newCount) {
    * @since 7.0
    */
   @Override
-  protected boolean standardContains(@NullableDecl Object object) {
+  protected boolean standardContains(@Nullable Object object) {
     return count(object) > 0;
   }
 
@@ -136,7 +136,7 @@ protected void standardClear() {
    * @since 7.0
    */
   @Beta
-  protected int standardCount(@NullableDecl Object object) {
+  protected int standardCount(@Nullable Object object) {
     for (Entry<?> entry : this.entrySet()) {
       if (Objects.equal(entry.getElement(), object)) {
         return entry.getCount();
@@ -285,7 +285,7 @@ protected int standardSize() {
    *
    * @since 7.0
    */
-  protected boolean standardEquals(@NullableDecl Object object) {
+  protected boolean standardEquals(@Nullable Object object) {
     return Multisets.equalsImpl(this, object);
   }
 , @@ -21,7 +21,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.util.Collection;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A set which forwards all its method calls to another set. Subclasses should override one or more
@@ -56,7 +56,7 @@ protected ForwardingSet() {}
   protected abstract Set<E> delegate();
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return object == this || delegate().equals(object);
   }
 
@@ -84,7 +84,7 @@ protected boolean standardRemoveAll(Collection<?> collection) {
    *
    * @since 7.0
    */
-  protected boolean standardEquals(@NullableDecl Object object) {
+  protected boolean standardEquals(@Nullable Object object) {
     return Sets.equalsImpl(this, object);
   }
 , @@ -20,7 +20,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A set multimap which forwards all its method calls to another set multimap. Subclasses should
@@ -47,13 +47,13 @@
   }
 
   @Override
-  public Set<V> get(@NullableDecl K key) {
+  public Set<V> get(@Nullable K key) {
     return delegate().get(key);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public Set<V> removeAll(@NullableDecl Object key) {
+  public Set<V> removeAll(@Nullable Object key) {
     return delegate().removeAll(key);
   }
 , @@ -23,7 +23,7 @@
 import java.util.Comparator;
 import java.util.NoSuchElementException;
 import java.util.SortedMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted map which forwards all its method calls to another sorted map. Subclasses should
@@ -126,7 +126,7 @@ private int unsafeCompare(Object k1, Object k2) {
    */
   @Override
   @Beta
-  protected boolean standardContainsKey(@NullableDecl Object key) {
+  protected boolean standardContainsKey(@Nullable Object key) {
     try {
       // any CCE will be caught
       @SuppressWarnings(""unchecked""), @@ -22,7 +22,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted set which forwards all its method calls to another sorted set. Subclasses should
@@ -92,7 +92,7 @@ public E last() {
 
   // unsafe, but worst case is a CCE is thrown, which callers will be expecting
   @SuppressWarnings(""unchecked"")
-  private int unsafeCompare(@NullableDecl Object o1, @NullableDecl Object o2) {
+  private int unsafeCompare(@Nullable Object o1, @Nullable Object o2) {
     Comparator<? super E> comparator = comparator();
     return (comparator == null)
         ? ((Comparable<Object>) o1).compareTo(o2)
@@ -108,7 +108,7 @@ private int unsafeCompare(@NullableDecl Object o1, @NullableDecl Object o2) {
    */
   @Override
   @Beta
-  protected boolean standardContains(@NullableDecl Object object) {
+  protected boolean standardContains(@Nullable Object object) {
     try {
       // any ClassCastExceptions are caught
       @SuppressWarnings(""unchecked"")
@@ -129,7 +129,7 @@ protected boolean standardContains(@NullableDecl Object object) {
    */
   @Override
   @Beta
-  protected boolean standardRemove(@NullableDecl Object object) {
+  protected boolean standardRemove(@Nullable Object object) {
     try {
       // any ClassCastExceptions are caught
       @SuppressWarnings(""unchecked""), @@ -19,7 +19,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.util.Comparator;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A sorted set multimap which forwards all its method calls to another sorted set multimap.
@@ -44,12 +44,12 @@ protected ForwardingSortedSetMultimap() {}
   protected abstract SortedSetMultimap<K, V> delegate();
 
   @Override
-  public SortedSet<V> get(@NullableDecl K key) {
+  public SortedSet<V> get(@Nullable K key) {
     return delegate().get(key);
   }
 
   @Override
-  public SortedSet<V> removeAll(@NullableDecl Object key) {
+  public SortedSet<V> removeAll(@Nullable Object key) {
     return delegate().removeAll(key);
   }
 , @@ -24,7 +24,7 @@
 import java.io.Serializable;
 import java.util.Comparator;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A generalized interval on any ordering, for internal use. Supports {@code null}. Unlike {@link
@@ -39,10 +39,10 @@
 final class GeneralRange<T> implements Serializable {
   /** Converts a Range to a GeneralRange. */
   static <T extends Comparable> GeneralRange<T> from(Range<T> range) {
-    @NullableDecl T lowerEndpoint = range.hasLowerBound() ? range.lowerEndpoint() : null;
+    @Nullable T lowerEndpoint = range.hasLowerBound() ? range.lowerEndpoint() : null;
     BoundType lowerBoundType = range.hasLowerBound() ? range.lowerBoundType() : OPEN;
 
-    @NullableDecl T upperEndpoint = range.hasUpperBound() ? range.upperEndpoint() : null;
+    @Nullable T upperEndpoint = range.hasUpperBound() ? range.upperEndpoint() : null;
     BoundType upperBoundType = range.hasUpperBound() ? range.upperBoundType() : OPEN;
     return new GeneralRange<T>(
         Ordering.natural(),
@@ -64,7 +64,7 @@
    * endpoint behavior.
    */
   static <T> GeneralRange<T> downTo(
-      Comparator<? super T> comparator, @NullableDecl T endpoint, BoundType boundType) {
+      Comparator<? super T> comparator, @Nullable T endpoint, BoundType boundType) {
     return new GeneralRange<T>(comparator, true, endpoint, boundType, false, null, OPEN);
   }
 
@@ -73,7 +73,7 @@
    * endpoint behavior.
    */
   static <T> GeneralRange<T> upTo(
-      Comparator<? super T> comparator, @NullableDecl T endpoint, BoundType boundType) {
+      Comparator<? super T> comparator, @Nullable T endpoint, BoundType boundType) {
     return new GeneralRange<T>(comparator, false, null, OPEN, true, endpoint, boundType);
   }
 
@@ -83,28 +83,28 @@
    */
   static <T> GeneralRange<T> range(
       Comparator<? super T> comparator,
-      @NullableDecl T lower,
+      @Nullable T lower,
       BoundType lowerType,
-      @NullableDecl T upper,
+      @Nullable T upper,
       BoundType upperType) {
     return new GeneralRange<T>(comparator, true, lower, lowerType, true, upper, upperType);
   }
 
   private final Comparator<? super T> comparator;
   private final boolean hasLowerBound;
-  @NullableDecl private final T lowerEndpoint;
+  @Nullable private final T lowerEndpoint;
   private final BoundType lowerBoundType;
   private final boolean hasUpperBound;
-  @NullableDecl private final T upperEndpoint;
+  @Nullable private final T upperEndpoint;
   private final BoundType upperBoundType;
 
   private GeneralRange(
       Comparator<? super T> comparator,
       boolean hasLowerBound,
-      @NullableDecl T lowerEndpoint,
+      @Nullable T lowerEndpoint,
       BoundType lowerBoundType,
       boolean hasUpperBound,
-      @NullableDecl T upperEndpoint,
+      @Nullable T upperEndpoint,
       BoundType upperBoundType) {
     this.comparator = checkNotNull(comparator);
     this.hasLowerBound = hasLowerBound;
@@ -148,7 +148,7 @@ boolean isEmpty() {
         || (hasLowerBound() && tooHigh(getLowerEndpoint()));
   }
 
-  boolean tooLow(@NullableDecl T t) {
+  boolean tooLow(@Nullable T t) {
     if (!hasLowerBound()) {
       return false;
     }
@@ -157,7 +157,7 @@ boolean tooLow(@NullableDecl T t) {
     return cmp < 0 | (cmp == 0 & getLowerBoundType() == OPEN);
   }
 
-  boolean tooHigh(@NullableDecl T t) {
+  boolean tooHigh(@Nullable T t) {
     if (!hasUpperBound()) {
       return false;
     }
@@ -166,7 +166,7 @@ boolean tooHigh(@NullableDecl T t) {
     return cmp > 0 | (cmp == 0 & getUpperBoundType() == OPEN);
   }
 
-  boolean contains(@NullableDecl T t) {
+  boolean contains(@Nullable T t) {
     return !tooLow(t) && !tooHigh(t);
   }
 
@@ -178,7 +178,7 @@ boolean contains(@NullableDecl T t) {
     checkArgument(comparator.equals(other.comparator));
 
     boolean hasLowBound = this.hasLowerBound;
-    @NullableDecl T lowEnd = getLowerEndpoint();
+    @Nullable T lowEnd = getLowerEndpoint();
     BoundType lowType = getLowerBoundType();
     if (!hasLowerBound()) {
       hasLowBound = other.hasLowerBound;
@@ -193,7 +193,7 @@ boolean contains(@NullableDecl T t) {
     }
 
     boolean hasUpBound = this.hasUpperBound;
-    @NullableDecl T upEnd = getUpperEndpoint();
+    @Nullable T upEnd = getUpperEndpoint();
     BoundType upType = getUpperBoundType();
     if (!hasUpperBound()) {
       hasUpBound = other.hasUpperBound;
@@ -221,7 +221,7 @@ boolean contains(@NullableDecl T t) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj instanceof GeneralRange) {
       GeneralRange<?> r = (GeneralRange<?>) obj;
       return comparator.equals(r.comparator), @@ -24,7 +24,7 @@
 import java.io.Serializable;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link Table} using linked hash tables. This guarantees predictable iteration
@@ -106,38 +106,38 @@
   // Overriding so NullPointerTester test passes.
 
   @Override
-  public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
     return super.contains(rowKey, columnKey);
   }
 
   @Override
-  public boolean containsColumn(@NullableDecl Object columnKey) {
+  public boolean containsColumn(@Nullable Object columnKey) {
     return super.containsColumn(columnKey);
   }
 
   @Override
-  public boolean containsRow(@NullableDecl Object rowKey) {
+  public boolean containsRow(@Nullable Object rowKey) {
     return super.containsRow(rowKey);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return super.containsValue(value);
   }
 
   @Override
-  public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
     return super.get(rowKey, columnKey);
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     return super.equals(obj);
   }
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
     return super.remove(rowKey, columnKey);
   }
 , @@ -40,7 +40,7 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link BiMap} backed by two hash tables. This implementation allows null keys and values. A
@@ -88,11 +88,11 @@
     final int keyHash;
     final int valueHash;
 
-    @NullableDecl BiEntry<K, V> nextInKToVBucket;
-    @NullableDecl BiEntry<K, V> nextInVToKBucket;
+    @Nullable BiEntry<K, V> nextInKToVBucket;
+    @Nullable BiEntry<K, V> nextInVToKBucket;
 
-    @NullableDecl BiEntry<K, V> nextInKeyInsertionOrder;
-    @NullableDecl BiEntry<K, V> prevInKeyInsertionOrder;
+    @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
+    @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
 
     BiEntry(K key, int keyHash, V value, int valueHash) {
       super(key, value);
@@ -105,8 +105,8 @@
 
   private transient BiEntry<K, V>[] hashTableKToV;
   private transient BiEntry<K, V>[] hashTableVToK;
-  @NullableDecl private transient BiEntry<K, V> firstInKeyInsertionOrder;
-  @NullableDecl private transient BiEntry<K, V> lastInKeyInsertionOrder;
+  @Nullable private transient BiEntry<K, V> firstInKeyInsertionOrder;
+  @Nullable private transient BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -180,7 +180,7 @@ private void delete(BiEntry<K, V> entry) {
     modCount++;
   }
 
-  private void insert(BiEntry<K, V> entry, @NullableDecl BiEntry<K, V> oldEntryForKey) {
+  private void insert(BiEntry<K, V> entry, @Nullable BiEntry<K, V> oldEntryForKey) {
     int keyBucket = entry.keyHash & mask;
     entry.nextInKToVBucket = hashTableKToV[keyBucket];
     hashTableKToV[keyBucket] = entry;
@@ -217,7 +217,7 @@ private void insert(BiEntry<K, V> entry, @NullableDecl BiEntry<K, V> oldEntryFor
     modCount++;
   }
 
-  private BiEntry<K, V> seekByKey(@NullableDecl Object key, int keyHash) {
+  private BiEntry<K, V> seekByKey(@Nullable Object key, int keyHash) {
     for (BiEntry<K, V> entry = hashTableKToV[keyHash & mask];
         entry != null;
         entry = entry.nextInKToVBucket) {
@@ -228,7 +228,7 @@ private void insert(BiEntry<K, V> entry, @NullableDecl BiEntry<K, V> oldEntryFor
     return null;
   }
 
-  private BiEntry<K, V> seekByValue(@NullableDecl Object value, int valueHash) {
+  private BiEntry<K, V> seekByValue(@Nullable Object value, int valueHash) {
     for (BiEntry<K, V> entry = hashTableVToK[valueHash & mask];
         entry != null;
         entry = entry.nextInVToKBucket) {
@@ -240,28 +240,28 @@ private void insert(BiEntry<K, V> entry, @NullableDecl BiEntry<K, V> oldEntryFor
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return seekByKey(key, smearedHash(key)) != null;
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return seekByValue(value, smearedHash(value)) != null;
   }
 
-  @NullableDecl
+  @Nullable
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return Maps.valueOrNull(seekByKey(key, smearedHash(key)));
   }
 
   @CanIgnoreReturnValue
   @Override
-  public V put(@NullableDecl K key, @NullableDecl V value) {
+  public V put(@Nullable K key, @Nullable V value) {
     return put(key, value, false);
   }
 
-  private V put(@NullableDecl K key, @NullableDecl V value, boolean force) {
+  private V put(@Nullable K key, @Nullable V value, boolean force) {
     int keyHash = smearedHash(key);
     int valueHash = smearedHash(value);
 
@@ -297,12 +297,12 @@ private V put(@NullableDecl K key, @NullableDecl V value, boolean force) {
 
   @CanIgnoreReturnValue
   @Override
-  public V forcePut(@NullableDecl K key, @NullableDecl V value) {
+  public V forcePut(@Nullable K key, @Nullable V value) {
     return put(key, value, true);
   }
 
-  @NullableDecl
-  private K putInverse(@NullableDecl V value, @NullableDecl K key, boolean force) {
+  @Nullable
+  private K putInverse(@Nullable V value, @Nullable K key, boolean force) {
     int valueHash = smearedHash(value);
     int keyHash = smearedHash(key);
 
@@ -372,7 +372,7 @@ private void rehashIfNecessary() {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object key) {
+  public V remove(@Nullable Object key) {
     BiEntry<K, V> entry = seekByKey(key, smearedHash(key));
     if (entry == null) {
       return null;
@@ -462,7 +462,7 @@ K output(BiEntry<K, V> entry) {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       BiEntry<K, V> entry = seekByKey(o, smearedHash(o));
       if (entry == null) {
         return false;
@@ -574,28 +574,28 @@ public void clear() {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object value) {
+    public boolean containsKey(@Nullable Object value) {
       return forward().containsValue(value);
     }
 
     @Override
-    public K get(@NullableDecl Object value) {
+    public K get(@Nullable Object value) {
       return Maps.keyOrNull(seekByValue(value, smearedHash(value)));
     }
 
     @CanIgnoreReturnValue
     @Override
-    public K put(@NullableDecl V value, @NullableDecl K key) {
+    public K put(@Nullable V value, @Nullable K key) {
       return putInverse(value, key, false);
     }
 
     @Override
-    public K forcePut(@NullableDecl V value, @NullableDecl K key) {
+    public K forcePut(@Nullable V value, @Nullable K key) {
       return putInverse(value, key, true);
     }
 
     @Override
-    public K remove(@NullableDecl Object value) {
+    public K remove(@Nullable Object value) {
       BiEntry<K, V> entry = seekByValue(value, smearedHash(value));
       if (entry == null) {
         return null;
@@ -624,7 +624,7 @@ public K remove(@NullableDecl Object value) {
       }
 
       @Override
-      public boolean remove(@NullableDecl Object o) {
+      public boolean remove(@Nullable Object o) {
         BiEntry<K, V> entry = seekByValue(o, smearedHash(o));
         if (entry == null) {
           return false;, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.primitives.Ints;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static methods for implementing hash-based collections.
@@ -50,7 +50,7 @@ static int smear(int hashCode) {
     return (int) (C2 * Integer.rotateLeft((int) (hashCode * C1), 15));
   }
 
-  static int smearedHash(@NullableDecl Object o) {
+  static int smearedHash(@Nullable Object o) {
     return smear((o == null) ? 0 : o.hashCode());
   }
 , @@ -23,7 +23,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ClassToInstanceMap} whose contents will never change, with many other important
@@ -169,7 +169,7 @@ private ImmutableClassToInstanceMap(ImmutableMap<Class<? extends B>, B> delegate
 
   @Override
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @NullableDecl
+  @Nullable
   public <T extends B> T getInstance(Class<T> type) {
     return (T) delegate.get(checkNotNull(type));
   }, @@ -29,7 +29,7 @@
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Predicate;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Collection} whose contents will never change, and which offers a few additional
@@ -207,7 +207,7 @@
   }
 
   @Override
-  public abstract boolean contains(@NullableDecl Object object);
+  public abstract boolean contains(@Nullable Object object);
 
   /**
    * Guaranteed to throw an exception and leave the collection unmodified., @@ -18,26 +18,26 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** @see com.google.common.collect.Maps#immutableEntry(Object, Object) */
 @GwtCompatible(serializable = true)
 class ImmutableEntry<K, V> extends AbstractMapEntry<K, V> implements Serializable {
-  @NullableDecl final K key;
-  @NullableDecl final V value;
+  @Nullable final K key;
+  @Nullable final V value;
 
-  ImmutableEntry(@NullableDecl K key, @NullableDecl V value) {
+  ImmutableEntry(@Nullable K key, @Nullable V value) {
     this.key = key;
     this.value = value;
   }
 
-  @NullableDecl
+  @Nullable
   @Override
   public final K getKey() {
     return key;
   }
 
-  @NullableDecl
+  @Nullable
   @Override
   public final V getValue() {
     return value;, @@ -24,7 +24,7 @@
 import java.util.EnumMap;
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMap} backed by a non-empty {@link java.util.EnumMap}.
@@ -69,7 +69,7 @@ public int size() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return delegate.containsKey(key);
   }
 , @@ -42,7 +42,7 @@
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link List} whose contents will never change, with many other important properties detailed at
@@ -409,17 +409,17 @@ public void forEach(Consumer<? super E> consumer) {
   }
 
   @Override
-  public int indexOf(@NullableDecl Object object) {
+  public int indexOf(@Nullable Object object) {
     return (object == null) ? -1 : Lists.indexOfImpl(this, object);
   }
 
   @Override
-  public int lastIndexOf(@NullableDecl Object object) {
+  public int lastIndexOf(@Nullable Object object) {
     return (object == null) ? -1 : Lists.lastIndexOfImpl(this, object);
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return indexOf(object) >= 0;
   }
 
@@ -617,18 +617,18 @@ private int reversePosition(int index) {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       return forwardList.contains(object);
     }
 
     @Override
-    public int indexOf(@NullableDecl Object object) {
+    public int indexOf(@Nullable Object object) {
       int index = forwardList.lastIndexOf(object);
       return (index >= 0) ? reverseIndex(index) : -1;
     }
 
     @Override
-    public int lastIndexOf(@NullableDecl Object object) {
+    public int lastIndexOf(@Nullable Object object) {
       int index = forwardList.indexOf(object);
       return (index >= 0) ? reverseIndex(index) : -1;
     }
@@ -657,7 +657,7 @@ boolean isPartialView() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     return Lists.equalsImpl(this, obj);
   }
 , @@ -37,7 +37,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link ListMultimap} whose contents will never change, with many other important properties
@@ -365,7 +365,7 @@ public Builder() {}
   /** Creates an ImmutableListMultimap from an asMap.entrySet. */
   static <K, V> ImmutableListMultimap<K, V> fromMapEntries(
       Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,
-      @NullableDecl Comparator<? super V> valueComparator) {
+      @Nullable Comparator<? super V> valueComparator) {
     if (mapEntries.isEmpty()) {
       return of();
     }
@@ -401,7 +401,7 @@ public Builder() {}
    * parameters used to build this multimap.
    */
   @Override
-  public ImmutableList<V> get(@NullableDecl K key) {
+  public ImmutableList<V> get(@Nullable K key) {
     // This cast is safe as its type is known in constructor.
     ImmutableList<V> list = (ImmutableList<V>) map.get(key);
     return (list == null) ? ImmutableList.<V>of() : list;, @@ -46,7 +46,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Map} whose contents will never change, with many other important properties detailed at
@@ -682,26 +682,26 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return get(key) != null;
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return values().contains(value);
   }
 
   // Overriding to mark it Nullable
   @Override
-  public abstract V get(@NullableDecl Object key);
+  public abstract V get(@Nullable Object key);
 
   /**
    * @since 21.0 (but only since 23.5 in the Android <a
    *     href=""https://github.com/google/guava#guava-google-core-libraries-for-java"">flavor</a>).
    *     Note, however, that Java 8 users can call this method with any version and flavor of Guava.
    */
   @Override
-  public final V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
+  public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
     V result = get(key);
     return (result != null) ? result : defaultValue;
   }
@@ -811,12 +811,12 @@ public int size() {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return ImmutableMap.this.containsKey(key);
     }
 
     @Override
-    public ImmutableSet<V> get(@NullableDecl Object key) {
+    public ImmutableSet<V> get(@Nullable Object key) {
       V outerValue = ImmutableMap.this.get(key);
       return (outerValue == null) ? null : ImmutableSet.of(outerValue);
     }
@@ -866,7 +866,7 @@ public K getKey() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return Maps.equalsImpl(this, object);
   }
 , @@ -19,7 +19,7 @@
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 
 import com.google.common.annotations.GwtIncompatible;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Entry} for {@link ImmutableMap} that adds extra methods to traverse hash
@@ -53,12 +53,12 @@
     // null check would be redundant
   }
 
-  @NullableDecl
+  @Nullable
   ImmutableMapEntry<K, V> getNextInKeyBucket() {
     return null;
   }
 
-  @NullableDecl
+  @Nullable
   ImmutableMapEntry<K, V> getNextInValueBucket() {
     return null;
   }
@@ -80,7 +80,7 @@ boolean isReusable() {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     final ImmutableMapEntry<K, V> getNextInKeyBucket() {
       return nextInKeyBucket;
     }
@@ -105,7 +105,7 @@ final boolean isReusable() {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     ImmutableMapEntry<K, V> getNextInValueBucket() {
       return nextInValueBucket;
     }, @@ -23,7 +23,7 @@
 import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@code entrySet()} implementation for {@link ImmutableMap}.
@@ -88,7 +88,7 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     if (object instanceof Entry) {
       Entry<?, ?> entry = (Entry<?, ?>) object;
       V value = map().get(entry.getKey());, @@ -24,7 +24,7 @@
 import java.io.Serializable;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@code keySet()} implementation for {@link ImmutableMap}.
@@ -56,7 +56,7 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return map.containsKey(object);
   }
 , @@ -25,7 +25,7 @@
 import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@code values()} implementation for {@link ImmutableMap}.
@@ -69,7 +69,7 @@ public V next() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return object != null && Iterators.contains(iterator(), object);
   }
 , @@ -37,7 +37,7 @@
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Multimap} whose contents will never change, with many other important properties
@@ -467,12 +467,12 @@ boolean isPartialView() {
   // accessors
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return map.containsKey(key);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return value != null && super.containsValue(value);
   }
 
@@ -623,12 +623,12 @@ public void forEach(BiConsumer<? super K, ? super V> action) {
   @WeakOuter
   class Keys extends ImmutableMultiset<K> {
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       return containsKey(object);
     }
 
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       Collection<V> values = map.get(element);
       return (values == null) ? 0 : values.size();
     }
@@ -717,7 +717,7 @@ public V next() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       return multimap.containsValue(object);
     }
 , @@ -35,7 +35,7 @@
 import java.util.function.ToIntFunction;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Multiset} whose contents will never change, with many other important properties
@@ -268,7 +268,7 @@ public E next() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return count(object) > 0;
   }
 
@@ -335,7 +335,7 @@ int copyIntoArray(Object[] dst, int offset) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     return Multisets.equalsImpl(this, object);
   }
 
@@ -600,7 +600,7 @@ E get(int index) {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       return delegate.contains(object);
     }
 , @@ -31,7 +31,7 @@
 import java.util.NoSuchElementException;
 import java.util.function.Function;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link RangeMap} whose contents will never change, with many other important properties
@@ -169,7 +169,7 @@ public Builder() {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public V get(K key) {
     int index =
         SortedLists.binarySearch(
@@ -187,7 +187,7 @@ public V get(K key) {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<Range<K>, V> getEntry(K key) {
     int index =
         SortedLists.binarySearch(
@@ -361,7 +361,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o instanceof RangeMap) {
       RangeMap<?, ?> rangeMap = (RangeMap<?, ?>) o;
       return asMapOfRanges().equals(rangeMap.asMapOfRanges());, @@ -36,7 +36,7 @@
 import java.util.Set;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link RangeSet} whose contents will never change, with many other important properties
@@ -629,7 +629,7 @@ protected C computeNext() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       if (o == null) {
         return false;
       }, @@ -40,7 +40,7 @@
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Set} whose contents will never change, with many other important properties detailed at
@@ -280,7 +280,7 @@ boolean isHashCodeFast() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     } else if (object instanceof ImmutableSet
@@ -302,7 +302,7 @@ public int hashCode() {
   @Override
   public abstract UnmodifiableIterator<E> iterator();
 
-  @LazyInit @NullableDecl @RetainedWith private transient ImmutableList<E> asList;
+  @LazyInit @Nullable @RetainedWith private transient ImmutableList<E> asList;
 
   @Override
   public ImmutableList<E> asList() {, @@ -41,7 +41,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link SetMultimap} whose contents will never change, with many other important properties
@@ -414,7 +414,7 @@ public Builder() {
   /** Creates an ImmutableSetMultimap from an asMap.entrySet. */
   static <K, V> ImmutableSetMultimap<K, V> fromMapEntries(
       Collection<? extends Map.Entry<? extends K, ? extends Collection<? extends V>>> mapEntries,
-      @NullableDecl Comparator<? super V> valueComparator) {
+      @Nullable Comparator<? super V> valueComparator) {
     if (mapEntries.isEmpty()) {
       return of();
     }
@@ -444,7 +444,7 @@ public Builder() {
   ImmutableSetMultimap(
       ImmutableMap<K, ImmutableSet<V>> map,
       int size,
-      @NullableDecl Comparator<? super V> valueComparator) {
+      @Nullable Comparator<? super V> valueComparator) {
     super(map, size);
     this.emptySet = emptySet(valueComparator);
   }
@@ -457,7 +457,7 @@ public Builder() {
    * parameters used to build this multimap.
    */
   @Override
-  public ImmutableSet<V> get(@NullableDecl K key) {
+  public ImmutableSet<V> get(@Nullable K key) {
     // This cast is safe as its type is known in constructor.
     ImmutableSet<V> set = (ImmutableSet<V>) map.get(key);
     return MoreObjects.firstNonNull(set, emptySet);
@@ -536,7 +536,7 @@ public Builder() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       if (object instanceof Entry) {
         Entry<?, ?> entry = (Entry<?, ?>) object;
         return multimap.containsEntry(entry.getKey(), entry.getValue());
@@ -561,20 +561,20 @@ boolean isPartialView() {
   }
 
   private static <V> ImmutableSet<V> valueSet(
-      @NullableDecl Comparator<? super V> valueComparator, Collection<? extends V> values) {
+      @Nullable Comparator<? super V> valueComparator, Collection<? extends V> values) {
     return (valueComparator == null)
         ? ImmutableSet.copyOf(values)
         : ImmutableSortedSet.copyOf(valueComparator, values);
   }
 
-  private static <V> ImmutableSet<V> emptySet(@NullableDecl Comparator<? super V> valueComparator) {
+  private static <V> ImmutableSet<V> emptySet(@Nullable Comparator<? super V> valueComparator) {
     return (valueComparator == null)
         ? ImmutableSet.<V>of()
         : ImmutableSortedSet.<V>emptySet(valueComparator);
   }
 
   private static <V> ImmutableSet.Builder<V> valuesBuilder(
-      @NullableDecl Comparator<? super V> valueComparator) {
+      @Nullable Comparator<? super V> valueComparator) {
     return (valueComparator == null)
         ? new ImmutableSet.Builder<V>()
         : new ImmutableSortedSet.Builder<V>(valueComparator);
@@ -591,7 +591,7 @@ private void writeObject(ObjectOutputStream stream) throws IOException {
     Serialization.writeMultimap(this, stream);
   }
 
-  @NullableDecl
+  @Nullable
   Comparator<? super V> valueComparator() {
     return emptySet instanceof ImmutableSortedSet
         ? ((ImmutableSortedSet<V>) emptySet).comparator(), @@ -18,7 +18,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Comparator;
 import java.util.Spliterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * List returned by {@code ImmutableSortedSet.asList()} when the set isn't empty.
@@ -49,7 +49,7 @@
   @GwtIncompatible // ImmutableSortedSet.indexOf
   // TODO(cpovirk): consider manual binary search under GWT to preserve O(log N) lookup
   @Override
-  public int indexOf(@NullableDecl Object target) {
+  public int indexOf(@Nullable Object target) {
     int index = delegateCollection().indexOf(target);
 
     // TODO(kevinb): reconsider if it's really worth making feeble attempts at
@@ -62,7 +62,7 @@ public int indexOf(@NullableDecl Object target) {
 
   @GwtIncompatible // ImmutableSortedSet.indexOf
   @Override
-  public int lastIndexOf(@NullableDecl Object target) {
+  public int lastIndexOf(@Nullable Object target) {
     return indexOf(target);
   }
 , @@ -39,7 +39,7 @@
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link NavigableMap} whose contents will never change, with many other important properties
@@ -590,7 +590,7 @@ public void forEach(BiConsumer<? super K, ? super V> action) {
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     int index = keySet.indexOf(key);
     return (index == -1) ? null : valueList.get(index);
   }, @@ -39,7 +39,7 @@
 import java.util.Spliterators;
 import java.util.function.Consumer;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link NavigableSet} whose contents will never change, with many other important properties
@@ -807,7 +807,7 @@ public boolean tryAdvance(Consumer<? super E> action) {
   public abstract UnmodifiableIterator<E> descendingIterator();
 
   /** Returns the position of an element within the set, or -1 if not present. */
-  abstract int indexOf(@NullableDecl Object target);
+  abstract int indexOf(@Nullable Object target);
 
   /*
    * This class is used to serialize all ImmutableSortedSet instances,, @@ -34,7 +34,7 @@
 import java.util.function.Function;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Table} whose contents will never change, with many other important properties detailed
@@ -442,12 +442,12 @@ public Builder() {}
   public abstract ImmutableMap<R, Map<C, V>> rowMap();
 
   @Override
-  public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
     return get(rowKey, columnKey) != null;
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return values().contains(value);
   }
 , @@ -39,7 +39,7 @@
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An assortment of mainly legacy static utility methods that operate on or return objects of type
@@ -132,7 +132,7 @@ public static int size(Iterable<?> iterable) {
    * cases where {@link Collection#contains} might throw {@link NullPointerException} or {@link
    * ClassCastException}.
    */
-  public static boolean contains(Iterable<?> iterable, @NullableDecl Object element) {
+  public static boolean contains(Iterable<?> iterable, @Nullable Object element) {
     if (iterable instanceof Collection) {
       Collection<?> collection = (Collection<?>) iterable;
       return Collections2.safeContains(collection, element);
@@ -199,7 +199,7 @@ public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsTo
   }
 
   /** Removes and returns the first matching element, or returns {@code null} if there is none. */
-  @NullableDecl
+  @Nullable
   static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     Iterator<T> iterator = removeFrom.iterator();
@@ -263,8 +263,8 @@ public static String toString(Iterable<?> iterable) {
    *
    * @throws IllegalArgumentException if the iterator contains multiple elements
    */
-  @NullableDecl
-  public static <T> T getOnlyElement(Iterable<? extends T> iterable, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getOnlyElement(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     return Iterators.getOnlyElement(iterable.iterator(), defaultValue);
   }
 
@@ -331,7 +331,7 @@ public static String toString(Iterable<?> iterable) {
    * @see java.util.Collections#frequency(Collection, Object) Collections.frequency(Collection,
    *     Object)
    */
-  public static int frequency(Iterable<?> iterable, @NullableDecl Object element) {
+  public static int frequency(Iterable<?> iterable, @Nullable Object element) {
     if ((iterable instanceof Multiset)) {
       return ((Multiset<?>) iterable).count(element);
     } else if ((iterable instanceof Set)) {
@@ -641,11 +641,9 @@ public void forEach(Consumer<? super T> action) {
    *
    * @since 7.0
    */
-  @NullableDecl
+  @Nullable
   public static <T> T find(
-      Iterable<? extends T> iterable,
-      Predicate<? super T> predicate,
-      @NullableDecl T defaultValue) {
+      Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue) {
     return Iterators.find(iterable.iterator(), predicate, defaultValue);
   }
 
@@ -747,9 +745,8 @@ public void forEach(Consumer<? super T> action) {
    * @throws IndexOutOfBoundsException if {@code position} is negative
    * @since 4.0
    */
-  @NullableDecl
-  public static <T> T get(
-      Iterable<? extends T> iterable, int position, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T get(Iterable<? extends T> iterable, int position, @Nullable T defaultValue) {
     checkNotNull(iterable);
     Iterators.checkNonnegative(position);
     if (iterable instanceof List) {
@@ -779,8 +776,8 @@ public void forEach(Consumer<? super T> action) {
    * @return the first element of {@code iterable} or the default value
    * @since 7.0
    */
-  @NullableDecl
-  public static <T> T getFirst(Iterable<? extends T> iterable, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getFirst(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     return Iterators.getNext(iterable.iterator(), defaultValue);
   }
 
@@ -817,8 +814,8 @@ public void forEach(Consumer<? super T> action) {
    * @return the last element of {@code iterable} or the default value
    * @since 3.0
    */
-  @NullableDecl
-  public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     if (iterable instanceof Collection) {
       Collection<? extends T> c = Collections2.cast(iterable);
       if (c.isEmpty()) {, @@ -45,7 +45,7 @@
 import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
 import java.util.Queue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class contains static utility methods that operate on or return objects of type {@link
@@ -168,7 +168,7 @@ public static int size(Iterator<?> iterator) {
   }
 
   /** Returns {@code true} if {@code iterator} contains {@code element}. */
-  public static boolean contains(Iterator<?> iterator, @NullableDecl Object element) {
+  public static boolean contains(Iterator<?> iterator, @Nullable Object element) {
     if (element == null) {
       while (iterator.hasNext()) {
         if (iterator.next() == null) {
@@ -324,8 +324,8 @@ public static String toString(Iterator<?> iterator) {
    *     iterator is unspecified.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this?
-  @NullableDecl
-  public static <T> T getOnlyElement(Iterator<? extends T> iterator, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getOnlyElement(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
   }
 
@@ -366,7 +366,7 @@ public static String toString(Iterator<?> iterator) {
    *
    * @see Collections#frequency
    */
-  public static int frequency(Iterator<?> iterator, @NullableDecl Object element) {
+  public static int frequency(Iterator<?> iterator, @Nullable Object element) {
     int count = 0;
     while (contains(iterator, element)) {
       // Since it lives in the same class, we know contains gets to the element and then stops,
@@ -707,11 +707,9 @@ protected T computeNext() {
    *
    * @since 7.0
    */
-  @NullableDecl
+  @Nullable
   public static <T> T find(
-      Iterator<? extends T> iterator,
-      Predicate<? super T> predicate,
-      @NullableDecl T defaultValue) {
+      Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue) {
     checkNotNull(iterator);
     checkNotNull(predicate);
     while (iterator.hasNext()) {
@@ -825,9 +823,8 @@ T transform(F from) {
    * @throws IndexOutOfBoundsException if {@code position} is negative
    * @since 4.0
    */
-  @NullableDecl
-  public static <T> T get(
-      Iterator<? extends T> iterator, int position, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T get(Iterator<? extends T> iterator, int position, @Nullable T defaultValue) {
     checkNonnegative(position);
     advance(iterator, position);
     return getNext(iterator, defaultValue);
@@ -847,8 +844,8 @@ static void checkNonnegative(int position) {
    * @return the next element of {@code iterator} or the default value
    * @since 7.0
    */
-  @NullableDecl
-  public static <T> T getNext(Iterator<? extends T> iterator, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getNext(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? iterator.next() : defaultValue;
   }
 
@@ -875,8 +872,8 @@ static void checkNonnegative(int position) {
    * @return the last element of {@code iterator}
    * @since 3.0
    */
-  @NullableDecl
-  public static <T> T getLast(Iterator<? extends T> iterator, @NullableDecl T defaultValue) {
+  @Nullable
+  public static <T> T getLast(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? getLast(iterator) : defaultValue;
   }
 
@@ -973,7 +970,7 @@ public String toString() {
    * Deletes and returns the next value from the iterator, or returns {@code null} if there is no
    * such value.
    */
-  @NullableDecl
+  @Nullable
   static <T> T pollNext(Iterator<T> iterator) {
     if (iterator.hasNext()) {
       T result = iterator.next();
@@ -1054,7 +1051,7 @@ protected T get(int index) {
    *
    * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.
    */
-  public static <T> UnmodifiableIterator<T> singletonIterator(@NullableDecl final T value) {
+  public static <T> UnmodifiableIterator<T> singletonIterator(@Nullable final T value) {
     return new UnmodifiableIterator<T>() {
       boolean done;
 
@@ -1122,7 +1119,7 @@ public T nextElement() {
 
     private final Iterator<? extends E> iterator;
     private boolean hasPeeked;
-    @NullableDecl private E peekedElement;
+    @Nullable private E peekedElement;
 
     public PeekingImpl(Iterator<? extends E> iterator) {
       this.iterator = checkNotNull(iterator);
@@ -1291,7 +1288,7 @@ public T next() {
 
   private static class ConcatenatedIterator<T> implements Iterator<T> {
     /* The last iterator to return an element.  Calls to remove() go to this iterator. */
-    @NullableDecl private Iterator<? extends T> toRemove;
+    @Nullable private Iterator<? extends T> toRemove;
 
     /* The iterator currently returning elements. */
     private Iterator<? extends T> iterator;
@@ -1306,15 +1303,15 @@ public T next() {
     private Iterator<? extends Iterator<? extends T>> topMetaIterator;
 
     // Only becomes nonnull if we encounter nested concatenations.
-    @NullableDecl private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
+    @Nullable private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
 
     ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {
       iterator = emptyIterator();
       topMetaIterator = checkNotNull(metaIterator);
     }
 
     // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
-    @NullableDecl
+    @Nullable
     private Iterator<? extends Iterator<? extends T>> getTopMetaIterator() {
       while (topMetaIterator == null || !topMetaIterator.hasNext()) {
         if (metaIterators != null && !metaIterators.isEmpty()) {, @@ -21,7 +21,7 @@
 import com.google.j2objc.annotations.RetainedWith;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of ImmutableBiMap backed by a pair of JDK HashMaps, which have smartness
@@ -100,7 +100,7 @@ public int size() {
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return forwardDelegate.get(key);
   }
 , @@ -22,7 +22,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
 import java.util.function.BiConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of ImmutableMap backed by a JDK HashMap, which has smartness protecting against
@@ -61,7 +61,7 @@ public int size() {
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return delegateMap.get(key);
   }
 , @@ -20,7 +20,7 @@
 import com.google.common.primitives.Ints;
 import java.util.Collection;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of ImmutableMultiset backed by a JDK Map and a list of entries. Used to protect
@@ -61,7 +61,7 @@ private JdkBackedImmutableMultiset(
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     return delegateMap.getOrDefault(element, 0);
   }
 , @@ -16,7 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * ImmutableSet implementation backed by a JDK HashSet, used to defend against apparent hash
@@ -41,7 +41,7 @@ E get(int index) {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     return delegate.contains(object);
   }
 , @@ -20,7 +20,7 @@
 import java.io.Serializable;
 import java.util.Comparator;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering which sorts iterables by comparing corresponding elements pairwise. */
 @GwtCompatible(serializable = true)
@@ -51,7 +51,7 @@ public int compare(Iterable<T> leftIterable, Iterable<T> rightIterable) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -40,7 +40,7 @@
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Multimap} that does not allow duplicate key-value entries and that
@@ -153,25 +153,25 @@
   static final class ValueEntry<K, V> extends ImmutableEntry<K, V> implements ValueSetLink<K, V> {
     final int smearedValueHash;
 
-    @NullableDecl ValueEntry<K, V> nextInValueBucket;
+    @Nullable ValueEntry<K, V> nextInValueBucket;
 
-    @NullableDecl ValueSetLink<K, V> predecessorInValueSet;
-    @NullableDecl ValueSetLink<K, V> successorInValueSet;
+    @Nullable ValueSetLink<K, V> predecessorInValueSet;
+    @Nullable ValueSetLink<K, V> successorInValueSet;
 
-    @NullableDecl ValueEntry<K, V> predecessorInMultimap;
-    @NullableDecl ValueEntry<K, V> successorInMultimap;
+    @Nullable ValueEntry<K, V> predecessorInMultimap;
+    @Nullable ValueEntry<K, V> successorInMultimap;
 
     ValueEntry(
-        @NullableDecl K key,
-        @NullableDecl V value,
+        @Nullable K key,
+        @Nullable V value,
         int smearedValueHash,
-        @NullableDecl ValueEntry<K, V> nextInValueBucket) {
+        @Nullable ValueEntry<K, V> nextInValueBucket) {
       super(key, value);
       this.smearedValueHash = smearedValueHash;
       this.nextInValueBucket = nextInValueBucket;
     }
 
-    boolean matchesValue(@NullableDecl Object v, int smearedVHash) {
+    boolean matchesValue(@Nullable Object v, int smearedVHash) {
       return smearedValueHash == smearedVHash && Objects.equal(getValue(), v);
     }
 
@@ -263,7 +263,7 @@ private LinkedHashMultimap(int keyCapacity, int valueSetCapacity) {
    */
   @CanIgnoreReturnValue
   @Override
-  public Set<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public Set<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     return super.replaceValues(key, values);
   }
 
@@ -368,7 +368,7 @@ public void setSuccessorInValueSet(ValueSetLink<K, V> entry) {
     public Iterator<V> iterator() {
       return new Iterator<V>() {
         ValueSetLink<K, V> nextEntry = firstEntry;
-        @NullableDecl ValueEntry<K, V> toRemove;
+        @Nullable ValueEntry<K, V> toRemove;
         int expectedModCount = modCount;
 
         private void checkForComodification() {
@@ -422,7 +422,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       int smearedHash = Hashing.smearedHash(o);
       for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];
           entry != null;
@@ -435,7 +435,7 @@ public boolean contains(@NullableDecl Object o) {
     }
 
     @Override
-    public boolean add(@NullableDecl V value) {
+    public boolean add(@Nullable V value) {
       int smearedHash = Hashing.smearedHash(value);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> rowHead = hashTable[bucket];
@@ -476,7 +476,7 @@ private void rehashIfNecessary() {
 
     @CanIgnoreReturnValue
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       int smearedHash = Hashing.smearedHash(o);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> prev = null;
@@ -519,7 +519,7 @@ public void clear() {
   Iterator<Entry<K, V>> entryIterator() {
     return new Iterator<Entry<K, V>>() {
       ValueEntry<K, V> nextEntry = multimapHeaderEntry.successorInMultimap;
-      @NullableDecl ValueEntry<K, V> toRemove;
+      @Nullable ValueEntry<K, V> toRemove;
 
       @Override
       public boolean hasNext() {, @@ -41,7 +41,7 @@
 import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@code ListMultimap} that supports deterministic iteration order for both
@@ -106,14 +106,14 @@
    */
 
   private static final class Node<K, V> extends AbstractMapEntry<K, V> {
-    @NullableDecl final K key;
-    @NullableDecl V value;
-    @NullableDecl Node<K, V> next; // the next node (with any key)
-    @NullableDecl Node<K, V> previous; // the previous node (with any key)
-    @NullableDecl Node<K, V> nextSibling; // the next node with the same key
-    @NullableDecl Node<K, V> previousSibling; // the previous node with the same key
-
-    Node(@NullableDecl K key, @NullableDecl V value) {
+    @Nullable final K key;
+    @Nullable V value;
+    @Nullable Node<K, V> next; // the next node (with any key)
+    @Nullable Node<K, V> previous; // the previous node (with any key)
+    @Nullable Node<K, V> nextSibling; // the next node with the same key
+    @Nullable Node<K, V> previousSibling; // the previous node with the same key
+
+    Node(@Nullable K key, @Nullable V value) {
       this.key = key;
       this.value = value;
     }
@@ -129,7 +129,7 @@ public V getValue() {
     }
 
     @Override
-    public V setValue(@NullableDecl V newValue) {
+    public V setValue(@Nullable V newValue) {
       V result = value;
       this.value = newValue;
       return result;
@@ -150,8 +150,8 @@ public V setValue(@NullableDecl V newValue) {
     }
   }
 
-  @NullableDecl private transient Node<K, V> head; // the head for all keys
-  @NullableDecl private transient Node<K, V> tail; // the tail for all keys
+  @Nullable private transient Node<K, V> head; // the head for all keys
+  @Nullable private transient Node<K, V> tail; // the tail for all keys
   private transient Map<K, KeyList<K, V>> keyToKeyList;
   private transient int size;
 
@@ -209,8 +209,7 @@ private LinkedListMultimap(Multimap<? extends K, ? extends V> multimap) {
    * is specified, it MUST be for an node for the same {@code key}!
    */
   @CanIgnoreReturnValue
-  private Node<K, V> addNode(
-      @NullableDecl K key, @NullableDecl V value, @NullableDecl Node<K, V> nextSibling) {
+  private Node<K, V> addNode(@Nullable K key, @Nullable V value, @Nullable Node<K, V> nextSibling) {
     Node<K, V> node = new Node<>(key, value);
     if (head == null) { // empty list
       head = tail = node;
@@ -294,12 +293,12 @@ private void removeNode(Node<K, V> node) {
   }
 
   /** Removes all nodes for the specified key. */
-  private void removeAllNodes(@NullableDecl Object key) {
+  private void removeAllNodes(@Nullable Object key) {
     Iterators.clear(new ValueForKeyIterator(key));
   }
 
   /** Helper method for verifying that an iterator element is present. */
-  private static void checkElement(@NullableDecl Object node) {
+  private static void checkElement(@Nullable Object node) {
     if (node == null) {
       throw new NoSuchElementException();
     }
@@ -308,9 +307,9 @@ private static void checkElement(@NullableDecl Object node) {
   /** An {@code Iterator} over all nodes. */
   private class NodeIterator implements ListIterator<Entry<K, V>> {
     int nextIndex;
-    @NullableDecl Node<K, V> next;
-    @NullableDecl Node<K, V> current;
-    @NullableDecl Node<K, V> previous;
+    @Nullable Node<K, V> next;
+    @Nullable Node<K, V> current;
+    @Nullable Node<K, V> previous;
     int expectedModCount = modCount;
 
     NodeIterator(int index) {
@@ -416,7 +415,7 @@ void setValue(V value) {
   private class DistinctKeyIterator implements Iterator<K> {
     final Set<K> seenKeys = Sets.<K>newHashSetWithExpectedSize(keySet().size());
     Node<K, V> next = head;
-    @NullableDecl Node<K, V> current;
+    @Nullable Node<K, V> current;
     int expectedModCount = modCount;
 
     private void checkForConcurrentModification() {
@@ -455,14 +454,14 @@ public void remove() {
 
   /** A {@code ListIterator} over values for a specified key. */
   private class ValueForKeyIterator implements ListIterator<V> {
-    @NullableDecl final Object key;
+    @Nullable final Object key;
     int nextIndex;
-    @NullableDecl Node<K, V> next;
-    @NullableDecl Node<K, V> current;
-    @NullableDecl Node<K, V> previous;
+    @Nullable Node<K, V> next;
+    @Nullable Node<K, V> current;
+    @Nullable Node<K, V> previous;
 
     /** Constructs a new iterator over all values for the specified key. */
-    ValueForKeyIterator(@NullableDecl Object key) {
+    ValueForKeyIterator(@Nullable Object key) {
       this.key = key;
       KeyList<K, V> keyList = keyToKeyList.get(key);
       next = (keyList == null) ? null : keyList.head;
@@ -476,7 +475,7 @@ public void remove() {
      *
      * @throws IndexOutOfBoundsException if index is invalid
      */
-    public ValueForKeyIterator(@NullableDecl Object key, int index) {
+    public ValueForKeyIterator(@Nullable Object key, int index) {
       KeyList<K, V> keyList = keyToKeyList.get(key);
       int size = (keyList == null) ? 0 : keyList.count;
       checkPositionIndex(index, size);
@@ -577,12 +576,12 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return keyToKeyList.containsKey(key);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return values().contains(value);
   }
 
@@ -597,7 +596,7 @@ public boolean containsValue(@NullableDecl Object value) {
    */
   @CanIgnoreReturnValue
   @Override
-  public boolean put(@NullableDecl K key, @NullableDecl V value) {
+  public boolean put(@Nullable K key, @Nullable V value) {
     addNode(key, value, null);
     return true;
   }
@@ -614,7 +613,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    */
   @CanIgnoreReturnValue
   @Override
-  public List<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values) {
+  public List<V> replaceValues(@Nullable K key, Iterable<? extends V> values) {
     List<V> oldValues = getCopy(key);
     ListIterator<V> keyValues = new ValueForKeyIterator(key);
     Iterator<? extends V> newValues = values.iterator();
@@ -639,7 +638,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
     return oldValues;
   }
 
-  private List<V> getCopy(@NullableDecl Object key) {
+  private List<V> getCopy(@Nullable Object key) {
     return unmodifiableList(Lists.newArrayList(new ValueForKeyIterator(key)));
   }
 
@@ -650,7 +649,7 @@ public boolean put(@NullableDecl K key, @NullableDecl V value) {
    */
   @CanIgnoreReturnValue
   @Override
-  public List<V> removeAll(@NullableDecl Object key) {
+  public List<V> removeAll(@Nullable Object key) {
     List<V> oldValues = getCopy(key);
     removeAllNodes(key);
     return oldValues;
@@ -677,7 +676,7 @@ public void clear() {
    * <p>The returned list is not serializable and does not have random access.
    */
   @Override
-  public List<V> get(final @NullableDecl K key) {
+  public List<V> get(final @Nullable K key) {
     return new AbstractSequentialList<V>() {
       @Override
       public int size() {, @@ -21,7 +21,7 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code Multimap} that can hold duplicate key-value pairs and that maintains the insertion
@@ -49,7 +49,7 @@
    * the {@link Multimap} interface.
    */
   @Override
-  List<V> get(@NullableDecl K key);
+  List<V> get(@Nullable K key);
 
   /**
    * {@inheritDoc}
@@ -60,7 +60,7 @@
    */
   @CanIgnoreReturnValue
   @Override
-  List<V> removeAll(@NullableDecl Object key);
+  List<V> removeAll(@Nullable Object key);
 
   /**
    * {@inheritDoc}
@@ -93,5 +93,5 @@
    * empty {@code SetMultimap}.
    */
   @Override
-  boolean equals(@NullableDecl Object obj);
+  boolean equals(@Nullable Object obj);
 }, @@ -50,7 +50,7 @@
 import java.util.RandomAccess;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link List} instances. Also see this class's counterparts
@@ -287,7 +287,7 @@ static int computeArrayListCapacity(int arraySize) {
    * @param rest an array of additional elements, possibly empty
    * @return an unmodifiable list containing the specified elements
    */
-  public static <E> List<E> asList(@NullableDecl E first, E[] rest) {
+  public static <E> List<E> asList(@Nullable E first, E[] rest) {
     return new OnePlusArrayList<>(first, rest);
   }
 
@@ -307,17 +307,17 @@ static int computeArrayListCapacity(int arraySize) {
    * @param rest an array of additional elements, possibly empty
    * @return an unmodifiable list containing the specified elements
    */
-  public static <E> List<E> asList(@NullableDecl E first, @NullableDecl E second, E[] rest) {
+  public static <E> List<E> asList(@Nullable E first, @Nullable E second, E[] rest) {
     return new TwoPlusArrayList<>(first, second, rest);
   }
 
   /** @see Lists#asList(Object, Object[]) */
   private static class OnePlusArrayList<E> extends AbstractList<E>
       implements Serializable, RandomAccess {
-    @NullableDecl final E first;
+    @Nullable final E first;
     final E[] rest;
 
-    OnePlusArrayList(@NullableDecl E first, E[] rest) {
+    OnePlusArrayList(@Nullable E first, E[] rest) {
       this.first = first;
       this.rest = checkNotNull(rest);
     }
@@ -340,11 +340,11 @@ public E get(int index) {
   /** @see Lists#asList(Object, Object, Object[]) */
   private static class TwoPlusArrayList<E> extends AbstractList<E>
       implements Serializable, RandomAccess {
-    @NullableDecl final E first;
-    @NullableDecl final E second;
+    @Nullable final E first;
+    @Nullable final E second;
     final E[] rest;
 
-    TwoPlusArrayList(@NullableDecl E first, @NullableDecl E second, E[] rest) {
+    TwoPlusArrayList(@Nullable E first, @Nullable E second, E[] rest) {
       this.first = first;
       this.second = second;
       this.rest = checkNotNull(rest);
@@ -732,12 +732,12 @@ public boolean isEmpty() {
     }
 
     @Override
-    public int indexOf(@NullableDecl Object object) {
+    public int indexOf(@Nullable Object object) {
       return (object instanceof Character) ? string.indexOf((Character) object) : -1;
     }
 
     @Override
-    public int lastIndexOf(@NullableDecl Object object) {
+    public int lastIndexOf(@Nullable Object object) {
       return (object instanceof Character) ? string.lastIndexOf((Character) object) : -1;
     }
 
@@ -830,7 +830,7 @@ private int reversePosition(int index) {
     }
 
     @Override
-    public void add(int index, @NullableDecl T element) {
+    public void add(int index, @Nullable T element) {
       forwardList.add(reversePosition(index), element);
     }
 
@@ -850,7 +850,7 @@ protected void removeRange(int fromIndex, int toIndex) {
     }
 
     @Override
-    public T set(int index, @NullableDecl T element) {
+    public T set(int index, @Nullable T element) {
       return forwardList.set(reverseIndex(index), element);
     }
 
@@ -964,7 +964,7 @@ static int hashCodeImpl(List<?> list) {
   }
 
   /** An implementation of {@link List#equals(Object)}. */
-  static boolean equalsImpl(List<?> thisList, @NullableDecl Object other) {
+  static boolean equalsImpl(List<?> thisList, @Nullable Object other) {
     if (other == checkNotNull(thisList)) {
       return true;
     }
@@ -1001,7 +1001,7 @@ static boolean equalsImpl(List<?> thisList, @NullableDecl Object other) {
   }
 
   /** An implementation of {@link List#indexOf(Object)}. */
-  static int indexOfImpl(List<?> list, @NullableDecl Object element) {
+  static int indexOfImpl(List<?> list, @Nullable Object element) {
     if (list instanceof RandomAccess) {
       return indexOfRandomAccess(list, element);
     } else {
@@ -1015,7 +1015,7 @@ static int indexOfImpl(List<?> list, @NullableDecl Object element) {
     }
   }
 
-  private static int indexOfRandomAccess(List<?> list, @NullableDecl Object element) {
+  private static int indexOfRandomAccess(List<?> list, @Nullable Object element) {
     int size = list.size();
     if (element == null) {
       for (int i = 0; i < size; i++) {
@@ -1034,7 +1034,7 @@ private static int indexOfRandomAccess(List<?> list, @NullableDecl Object elemen
   }
 
   /** An implementation of {@link List#lastIndexOf(Object)}. */
-  static int lastIndexOfImpl(List<?> list, @NullableDecl Object element) {
+  static int lastIndexOfImpl(List<?> list, @Nullable Object element) {
     if (list instanceof RandomAccess) {
       return lastIndexOfRandomAccess(list, element);
     } else {
@@ -1048,7 +1048,7 @@ static int lastIndexOfImpl(List<?> list, @NullableDecl Object element) {
     }
   }
 
-  private static int lastIndexOfRandomAccess(List<?> list, @NullableDecl Object element) {
+  private static int lastIndexOfRandomAccess(List<?> list, @Nullable Object element) {
     if (element == null) {
       for (int i = list.size() - 1; i >= 0; i--) {
         if (list.get(i) == null) {, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object representing the differences between two maps.
@@ -65,7 +65,7 @@
    * #entriesDiffering()} of the two instances are equal.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   /**
    * Returns the hash code for this instance. This is defined as the hash code of
@@ -96,7 +96,7 @@
      * {@link #rightValue()} values are also equal.
      */
     @Override
-    boolean equals(@NullableDecl Object other);
+    boolean equals(@Nullable Object other);
 
     /**
      * The hash code equals the value {@code Arrays.asList(leftValue(), rightValue()).hashCode()}., @@ -48,7 +48,7 @@
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.concurrent.locks.ReentrantLock;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * The concurrent hash map implementation built by {@link MapMaker}.
@@ -292,13 +292,13 @@ private MapMakerInternalMap(MapMaker builder, InternalEntryHelper<K, V, E, S> en
     /**
      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment}.
      */
-    E newEntry(S segment, K key, int hash, @NullableDecl E next);
+    E newEntry(S segment, K key, int hash, @Nullable E next);
 
     /**
      * Returns a freshly created entry, typed at the {@code E} type, for the given {@code segment},
      * that is a copy of the given {@code entry}.
      */
-    E copy(S segment, E entry, @NullableDecl E newNext);
+    E copy(S segment, E entry, @Nullable E newNext);
 
     /**
      * Sets the value of the given {@code entry} in the given {@code segment} to be the given {@code
@@ -340,9 +340,9 @@ private MapMakerInternalMap(MapMaker builder, InternalEntryHelper<K, V, E, S> en
       implements InternalEntry<K, V, E> {
     final K key;
     final int hash;
-    @NullableDecl final E next;
+    @Nullable final E next;
 
-    AbstractStrongKeyEntry(K key, int hash, @NullableDecl E next) {
+    AbstractStrongKeyEntry(K key, int hash, @Nullable E next) {
       this.key = key;
       this.hash = hash;
       this.next = next;
@@ -390,14 +390,14 @@ public E getNext() {
   static final class StrongKeyStrongValueEntry<K, V>
       extends AbstractStrongKeyEntry<K, V, StrongKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, StrongKeyStrongValueEntry<K, V>> {
-    @NullableDecl private volatile V value = null;
+    @Nullable private volatile V value = null;
 
-    StrongKeyStrongValueEntry(K key, int hash, @NullableDecl StrongKeyStrongValueEntry<K, V> next) {
+    StrongKeyStrongValueEntry(K key, int hash, @Nullable StrongKeyStrongValueEntry<K, V> next) {
       super(key, hash, next);
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public V getValue() {
       return value;
     }
@@ -448,7 +448,7 @@ public Strength valueStrength() {
       public StrongKeyStrongValueEntry<K, V> copy(
           StrongKeyStrongValueSegment<K, V> segment,
           StrongKeyStrongValueEntry<K, V> entry,
-          @NullableDecl StrongKeyStrongValueEntry<K, V> newNext) {
+          @Nullable StrongKeyStrongValueEntry<K, V> newNext) {
         return entry.copy(newNext);
       }
 
@@ -465,7 +465,7 @@ public void setValue(
           StrongKeyStrongValueSegment<K, V> segment,
           K key,
           int hash,
-          @NullableDecl StrongKeyStrongValueEntry<K, V> next) {
+          @Nullable StrongKeyStrongValueEntry<K, V> next) {
         return new StrongKeyStrongValueEntry<>(key, hash, next);
       }
     }
@@ -478,7 +478,7 @@ public void setValue(
     private volatile WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> valueReference =
         unsetWeakValueReference();
 
-    StrongKeyWeakValueEntry(K key, int hash, @NullableDecl StrongKeyWeakValueEntry<K, V> next) {
+    StrongKeyWeakValueEntry(K key, int hash, @Nullable StrongKeyWeakValueEntry<K, V> next) {
       super(key, hash, next);
     }
 
@@ -544,7 +544,7 @@ public Strength valueStrength() {
       public StrongKeyWeakValueEntry<K, V> copy(
           StrongKeyWeakValueSegment<K, V> segment,
           StrongKeyWeakValueEntry<K, V> entry,
-          @NullableDecl StrongKeyWeakValueEntry<K, V> newNext) {
+          @Nullable StrongKeyWeakValueEntry<K, V> newNext) {
         if (Segment.isCollected(entry)) {
           return null;
         }
@@ -562,7 +562,7 @@ public void setValue(
           StrongKeyWeakValueSegment<K, V> segment,
           K key,
           int hash,
-          @NullableDecl StrongKeyWeakValueEntry<K, V> next) {
+          @Nullable StrongKeyWeakValueEntry<K, V> next) {
         return new StrongKeyWeakValueEntry<>(key, hash, next);
       }
     }
@@ -572,7 +572,7 @@ public void setValue(
   static final class StrongKeyDummyValueEntry<K>
       extends AbstractStrongKeyEntry<K, Dummy, StrongKeyDummyValueEntry<K>>
       implements StrongValueEntry<K, Dummy, StrongKeyDummyValueEntry<K>> {
-    StrongKeyDummyValueEntry(K key, int hash, @NullableDecl StrongKeyDummyValueEntry<K> next) {
+    StrongKeyDummyValueEntry(K key, int hash, @Nullable StrongKeyDummyValueEntry<K> next) {
       super(key, hash, next);
     }
 
@@ -624,7 +624,7 @@ public Strength valueStrength() {
       public StrongKeyDummyValueEntry<K> copy(
           StrongKeyDummyValueSegment<K> segment,
           StrongKeyDummyValueEntry<K> entry,
-          @NullableDecl StrongKeyDummyValueEntry<K> newNext) {
+          @Nullable StrongKeyDummyValueEntry<K> newNext) {
         return entry.copy(newNext);
       }
 
@@ -637,7 +637,7 @@ public void setValue(
           StrongKeyDummyValueSegment<K> segment,
           K key,
           int hash,
-          @NullableDecl StrongKeyDummyValueEntry<K> next) {
+          @Nullable StrongKeyDummyValueEntry<K> next) {
         return new StrongKeyDummyValueEntry<K>(key, hash, next);
       }
     }
@@ -647,9 +647,9 @@ public void setValue(
   abstract static class AbstractWeakKeyEntry<K, V, E extends InternalEntry<K, V, E>>
       extends WeakReference<K> implements InternalEntry<K, V, E> {
     final int hash;
-    @NullableDecl final E next;
+    @Nullable final E next;
 
-    AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, @NullableDecl E next) {
+    AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable E next) {
       super(key, queue);
       this.hash = hash;
       this.next = next;
@@ -676,7 +676,7 @@ public E getNext() {
       extends AbstractWeakKeyEntry<K, Dummy, WeakKeyDummyValueEntry<K>>
       implements StrongValueEntry<K, Dummy, WeakKeyDummyValueEntry<K>> {
     WeakKeyDummyValueEntry(
-        ReferenceQueue<K> queue, K key, int hash, @NullableDecl WeakKeyDummyValueEntry<K> next) {
+        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyDummyValueEntry<K> next) {
       super(queue, key, hash, next);
     }
 
@@ -728,7 +728,7 @@ public Strength valueStrength() {
       public WeakKeyDummyValueEntry<K> copy(
           WeakKeyDummyValueSegment<K> segment,
           WeakKeyDummyValueEntry<K> entry,
-          @NullableDecl WeakKeyDummyValueEntry<K> newNext) {
+          @Nullable WeakKeyDummyValueEntry<K> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -745,7 +745,7 @@ public void setValue(
           WeakKeyDummyValueSegment<K> segment,
           K key,
           int hash,
-          @NullableDecl WeakKeyDummyValueEntry<K> next) {
+          @Nullable WeakKeyDummyValueEntry<K> next) {
         return new WeakKeyDummyValueEntry<K>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -755,18 +755,15 @@ public void setValue(
   static final class WeakKeyStrongValueEntry<K, V>
       extends AbstractWeakKeyEntry<K, V, WeakKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, WeakKeyStrongValueEntry<K, V>> {
-    @NullableDecl private volatile V value = null;
+    @Nullable private volatile V value = null;
 
     WeakKeyStrongValueEntry(
-        ReferenceQueue<K> queue,
-        K key,
-        int hash,
-        @NullableDecl WeakKeyStrongValueEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public V getValue() {
       return value;
     }
@@ -817,7 +814,7 @@ public Strength valueStrength() {
       public WeakKeyStrongValueEntry<K, V> copy(
           WeakKeyStrongValueSegment<K, V> segment,
           WeakKeyStrongValueEntry<K, V> entry,
-          @NullableDecl WeakKeyStrongValueEntry<K, V> newNext) {
+          @Nullable WeakKeyStrongValueEntry<K, V> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -836,7 +833,7 @@ public void setValue(
           WeakKeyStrongValueSegment<K, V> segment,
           K key,
           int hash,
-          @NullableDecl WeakKeyStrongValueEntry<K, V> next) {
+          @Nullable WeakKeyStrongValueEntry<K, V> next) {
         return new WeakKeyStrongValueEntry<>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -850,7 +847,7 @@ public void setValue(
         unsetWeakValueReference();
 
     WeakKeyWeakValueEntry(
-        ReferenceQueue<K> queue, K key, int hash, @NullableDecl WeakKeyWeakValueEntry<K, V> next) {
+        ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyWeakValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
@@ -918,7 +915,7 @@ public Strength valueStrength() {
       public WeakKeyWeakValueEntry<K, V> copy(
           WeakKeyWeakValueSegment<K, V> segment,
           WeakKeyWeakValueEntry<K, V> entry,
-          @NullableDecl WeakKeyWeakValueEntry<K, V> newNext) {
+          @Nullable WeakKeyWeakValueEntry<K, V> newNext) {
         if (entry.getKey() == null) {
           // key collected
           return null;
@@ -940,7 +937,7 @@ public void setValue(
           WeakKeyWeakValueSegment<K, V> segment,
           K key,
           int hash,
-          @NullableDecl WeakKeyWeakValueEntry<K, V> next) {
+          @Nullable WeakKeyWeakValueEntry<K, V> next) {
         return new WeakKeyWeakValueEntry<>(segment.queueForKeys, key, hash, next);
       }
     }
@@ -952,7 +949,7 @@ public void setValue(
      * Returns the current value being referenced, or {@code null} if there is none (e.g. because
      * either it got collected, or {@link #clear} was called, or it wasn't set in the first place).
      */
-    @NullableDecl
+    @Nullable
     V get();
 
     /** Returns the entry which contains this {@link WeakValueReference}. */
@@ -1306,7 +1303,7 @@ void setTableEntryForTesting(int i, InternalEntry<K, V, ?> entry) {
     }
 
     /** Unsafely returns a copy of the given entry. */
-    E copyForTesting(InternalEntry<K, V, ?> entry, @NullableDecl InternalEntry<K, V, ?> newNext) {
+    E copyForTesting(InternalEntry<K, V, ?> entry, @Nullable InternalEntry<K, V, ?> newNext) {
       return this.map.entryHelper.copy(self(), castForTesting(entry), castForTesting(newNext));
     }
 
@@ -1316,7 +1313,7 @@ void setValueForTesting(InternalEntry<K, V, ?> entry, V value) {
     }
 
     /** Unsafely returns a fresh entry. */
-    E newEntryForTesting(K key, int hash, @NullableDecl InternalEntry<K, V, ?> next) {
+    E newEntryForTesting(K key, int hash, @Nullable InternalEntry<K, V, ?> next) {
       return this.map.entryHelper.newEntry(self(), key, hash, castForTesting(next));
     }
 
@@ -1334,7 +1331,7 @@ E removeFromChainForTesting(InternalEntry<K, V, ?> first, InternalEntry<K, V, ?>
     /**
      * Unsafely returns the value of the given entry if it's still live, or {@code null} otherwise.
      */
-    @NullableDecl
+    @Nullable
     V getLiveValueForTesting(InternalEntry<K, V, ?> entry) {
       return getLiveValue(castForTesting(entry));
     }
@@ -1949,7 +1946,7 @@ boolean removeEntryForTesting(E entry) {
      * Gets the value from an entry. Returns {@code null} if the entry is invalid or
      * partially-collected.
      */
-    @NullableDecl
+    @Nullable
     V getLiveValue(E entry) {
       if (entry.getKey() == null) {
         tryDrainReferenceQueues();
@@ -2342,7 +2339,7 @@ public int size() {
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -2354,7 +2351,7 @@ public V get(@NullableDecl Object key) {
    * Returns the internal entry for the specified key. The entry may be computing or partially
    * collected. Does not impact recency ordering.
    */
-  E getEntry(@NullableDecl Object key) {
+  E getEntry(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -2363,7 +2360,7 @@ E getEntry(@NullableDecl Object key) {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     if (key == null) {
       return false;
     }
@@ -2372,7 +2369,7 @@ public boolean containsKey(@NullableDecl Object key) {
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     if (value == null) {
       return false;
     }
@@ -2436,7 +2433,7 @@ public void putAll(Map<? extends K, ? extends V> m) {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object key) {
+  public V remove(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -2446,7 +2443,7 @@ public V remove(@NullableDecl Object key) {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
+  public boolean remove(@Nullable Object key, @Nullable Object value) {
     if (key == null || value == null) {
       return false;
     }
@@ -2456,7 +2453,7 @@ public boolean remove(@NullableDecl Object key, @NullableDecl Object value) {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean replace(K key, @NullableDecl V oldValue, V newValue) {
+  public boolean replace(K key, @Nullable V oldValue, V newValue) {
     checkNotNull(key);
     checkNotNull(newValue);
     if (oldValue == null) {
@@ -2514,9 +2511,9 @@ public void clear() {
     int nextTableIndex;
     @MonotonicNonNullDecl Segment<K, V, E, S> currentSegment;
     @MonotonicNonNullDecl AtomicReferenceArray<E> currentTable;
-    @NullableDecl E nextEntry;
-    @NullableDecl WriteThroughEntry nextExternal;
-    @NullableDecl WriteThroughEntry lastReturned;
+    @Nullable E nextEntry;
+    @Nullable WriteThroughEntry nextExternal;
+    @Nullable WriteThroughEntry lastReturned;
 
     HashIterator() {
       nextSegmentIndex = segments.length - 1;
@@ -2656,7 +2653,7 @@ public V getValue() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       // Cannot use key and value equivalence
       if (object instanceof Entry) {
         Entry<?, ?> that = (Entry<?, ?>) object;, @@ -69,7 +69,7 @@
 import java.util.function.Consumer;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Map} instances (including instances of {@link
@@ -92,14 +92,14 @@ private Maps() {}
   private enum EntryFunction implements Function<Entry<?, ?>, Object> {
     KEY {
       @Override
-      @NullableDecl
+      @Nullable
       public Object apply(Entry<?, ?> entry) {
         return entry.getKey();
       }
     },
     VALUE {
       @Override
-      @NullableDecl
+      @Nullable
       public Object apply(Entry<?, ?> entry) {
         return entry.getValue();
       }
@@ -447,8 +447,7 @@ static int capacity(int expectedSize) {
    * @param comparator the comparator to sort the keys with
    * @return a new, empty {@code TreeMap}
    */
-  public static <C, K extends C, V> TreeMap<K, V> newTreeMap(
-      @NullableDecl Comparator<C> comparator) {
+  public static <C, K extends C, V> TreeMap<K, V> newTreeMap(@Nullable Comparator<C> comparator) {
     // Ideally, the extra type parameter ""C"" shouldn't be necessary. It is a
     // work-around of a compiler type inference quirk that prevents the
     // following code from being compiled:
@@ -696,14 +695,14 @@ public String toString() {
   }
 
   static class ValueDifferenceImpl<V> implements MapDifference.ValueDifference<V> {
-    @NullableDecl private final V left;
-    @NullableDecl private final V right;
+    @Nullable private final V left;
+    @Nullable private final V right;
 
-    static <V> ValueDifference<V> create(@NullableDecl V left, @NullableDecl V right) {
+    static <V> ValueDifference<V> create(@Nullable V left, @Nullable V right) {
       return new ValueDifferenceImpl<V>(left, right);
     }
 
-    private ValueDifferenceImpl(@NullableDecl V left, @NullableDecl V right) {
+    private ValueDifferenceImpl(@Nullable V left, @Nullable V right) {
       this.left = left;
       this.right = right;
     }
@@ -719,7 +718,7 @@ public V rightValue() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof MapDifference.ValueDifference) {
         MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;
         return Objects.equal(this.left, that.leftValue())
@@ -776,7 +775,7 @@ public String toString() {
    * ugly type-casting in one place.
    */
   @SuppressWarnings(""unchecked"")
-  static <E> Comparator<? super E> orNaturalOrder(@NullableDecl Comparator<? super E> comparator) {
+  static <E> Comparator<? super E> orNaturalOrder(@Nullable Comparator<? super E> comparator) {
     if (comparator != null) { // can't use ? : because of javac bug 5080917
       return comparator;
     }
@@ -897,17 +896,17 @@ public int size() {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return backingSet().contains(key);
     }
 
     @Override
-    public V get(@NullableDecl Object key) {
+    public V get(@Nullable Object key) {
       return getOrDefault(key, null);
     }
 
     @Override
-    public V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
+    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
       if (Collections2.safeContains(backingSet(), key)) {
         @SuppressWarnings(""unchecked"") // unsafe, but Javadoc warns about it
         K k = (K) key;
@@ -918,7 +917,7 @@ public V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
     }
 
     @Override
-    public V remove(@NullableDecl Object key) {
+    public V remove(@Nullable Object key) {
       if (backingSet().remove(key)) {
         @SuppressWarnings(""unchecked"") // unsafe, but Javadoc warns about it
         K k = (K) key;
@@ -1052,14 +1051,14 @@ public K lastKey() {
     }
 
     @Override
-    @NullableDecl
-    public V get(@NullableDecl Object key) {
+    @Nullable
+    public V get(@Nullable Object key) {
       return getOrDefault(key, null);
     }
 
     @Override
-    @NullableDecl
-    public V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
+    @Nullable
+    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
       if (Collections2.safeContains(set, key)) {
         @SuppressWarnings(""unchecked"") // unsafe, but Javadoc warns about it
         K k = (K) key;
@@ -1380,7 +1379,7 @@ public boolean addAll(Collection<? extends E> es) {
    * @param value the value to be associated with the returned entry
    */
   @GwtCompatible(serializable = true)
-  public static <K, V> Entry<K, V> immutableEntry(@NullableDecl K key, @NullableDecl V value) {
+  public static <K, V> Entry<K, V> immutableEntry(@Nullable K key, @Nullable V value) {
     return new ImmutableEntry<>(key, value);
   }
 
@@ -1476,7 +1475,7 @@ public boolean hasNext() {
     // See java.util.Collections.UnmodifiableEntrySet for details on attacks.
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return Sets.equalsImpl(this, object);
     }
 
@@ -1525,7 +1524,7 @@ protected A doBackward(B b) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof BiMapConverter) {
         BiMapConverter<?, ?> that = (BiMapConverter<?, ?>) object;
         return this.bimap.equals(that.bimap);
@@ -1603,7 +1602,7 @@ public String toString() {
     @MonotonicNonNullDecl @RetainedWith BiMap<V, K> inverse;
     @MonotonicNonNullDecl transient Set<V> values;
 
-    UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @NullableDecl BiMap<V, K> inverse) {
+    UnmodifiableBiMap(BiMap<? extends K, ? extends V> delegate, @Nullable BiMap<V, K> inverse) {
       unmodifiableMap = Collections.unmodifiableMap(delegate);
       this.delegate = delegate;
       this.inverse = inverse;
@@ -1942,7 +1941,7 @@ public V forcePut(K key, V value) {
      * @throws NullPointerException if the key or value is null and this transformer does not accept
      *     null arguments
      */
-    V2 transformEntry(@NullableDecl K key, @NullableDecl V1 value);
+    V2 transformEntry(@Nullable K key, @Nullable V1 value);
   }
 
   /** Views a function as an entry transformer that ignores the entry key. */
@@ -1962,7 +1961,7 @@ public V2 transformEntry(K key, V1 value) {
     checkNotNull(transformer);
     return new Function<V1, V2>() {
       @Override
-      public V2 apply(@NullableDecl V1 v1) {
+      public V2 apply(@Nullable V1 v1) {
         return transformer.transformEntry(key, v1);
       }
     };
@@ -2031,16 +2030,16 @@ public boolean containsKey(Object key) {
     }
 
     @Override
-    @NullableDecl
-    public V2 get(@NullableDecl Object key) {
+    @Nullable
+    public V2 get(@Nullable Object key) {
       return getOrDefault(key, null);
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
     @SuppressWarnings(""unchecked"")
     @Override
-    @NullableDecl
-    public V2 getOrDefault(@NullableDecl Object key, @NullableDecl V2 defaultValue) {
+    @Nullable
+    public V2 getOrDefault(@Nullable Object key, @Nullable V2 defaultValue) {
       V1 value = fromMap.get(key);
       return (value != null || fromMap.containsKey(key))
           ? transformer.transformEntry((K) key, value)
@@ -2250,8 +2249,8 @@ public K lowerKey(K key) {
       return transformEntries(fromMap().tailMap(fromKey, inclusive), transformer);
     }
 
-    @NullableDecl
-    private Entry<K, V2> transformEntry(@NullableDecl Entry<K, V1> entry) {
+    @Nullable
+    private Entry<K, V2> transformEntry(@Nullable Entry<K, V1> entry) {
       return (entry == null) ? null : Maps.transformEntry(transformer, entry);
     }
 
@@ -2709,7 +2708,7 @@ public K lowerKey(K key) {
       this.predicate = predicate;
     }
 
-    boolean apply(@NullableDecl Object key, @NullableDecl V value) {
+    boolean apply(@Nullable Object key, @Nullable V value) {
       // This method is called only when the key is in the map, implying that
       // key is a K.
       @SuppressWarnings(""unchecked"")
@@ -3129,13 +3128,13 @@ public boolean isEmpty() {
     }
 
     @Override
-    @NullableDecl
-    public V get(@NullableDecl Object key) {
+    @Nullable
+    public V get(@Nullable Object key) {
       return filteredDelegate.get(key);
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return filteredDelegate.containsKey(key);
     }
 
@@ -3145,7 +3144,7 @@ public V put(K key, V value) {
     }
 
     @Override
-    public V remove(@NullableDecl Object key) {
+    public V remove(@Nullable Object key) {
       return filteredDelegate.remove(key);
     }
 
@@ -3228,7 +3227,7 @@ private FilteredEntryBiMap(
     }
 
     @Override
-    public V forcePut(@NullableDecl K key, @NullableDecl V value) {
+    public V forcePut(@Nullable K key, @Nullable V value) {
       checkArgument(apply(key, value));
       return unfiltered().forcePut(key, value);
     }
@@ -3285,8 +3284,8 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     }
   }
 
-  @NullableDecl
-  private static <K, V> Entry<K, V> unmodifiableOrNull(@NullableDecl Entry<K, ? extends V> entry) {
+  @Nullable
+  private static <K, V> Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {
     return (entry == null) ? null : Maps.unmodifiableEntry(entry);
   }
 
@@ -3578,7 +3577,7 @@ public void clear() {
    * Delegates to {@link Map#get}. Returns {@code null} on {@code ClassCastException} and {@code
    * NullPointerException}.
    */
-  static <V> V safeGet(Map<?, V> map, @NullableDecl Object key) {
+  static <V> V safeGet(Map<?, V> map, @Nullable Object key) {
     checkNotNull(map);
     try {
       return map.get(key);
@@ -3614,12 +3613,12 @@ static boolean safeContainsKey(Map<?, ?> map, Object key) {
   }
 
   /** An admittedly inefficient implementation of {@link Map#containsKey}. */
-  static boolean containsKeyImpl(Map<?, ?> map, @NullableDecl Object key) {
+  static boolean containsKeyImpl(Map<?, ?> map, @Nullable Object key) {
     return Iterators.contains(keyIterator(map.entrySet().iterator()), key);
   }
 
   /** An implementation of {@link Map#containsValue}. */
-  static boolean containsValueImpl(Map<?, ?> map, @NullableDecl Object value) {
+  static boolean containsValueImpl(Map<?, ?> map, @Nullable Object value) {
     return Iterators.contains(valueIterator(map.entrySet().iterator()), value);
   }
 
@@ -3745,13 +3744,13 @@ public void clear() {
     }
   }
 
-  @NullableDecl
-  static <K> K keyOrNull(@NullableDecl Entry<K, ?> entry) {
+  @Nullable
+  static <K> K keyOrNull(@Nullable Entry<K, ?> entry) {
     return (entry == null) ? null : entry.getKey();
   }
 
-  @NullableDecl
-  static <V> V valueOrNull(@NullableDecl Entry<?, V> entry) {
+  @Nullable
+  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {
     return (entry == null) ? null : entry.getValue();
   }
 
@@ -3958,7 +3957,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       return map().containsValue(o);
     }
 , @@ -42,7 +42,7 @@
 import java.util.PriorityQueue;
 import java.util.Queue;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A double-ended priority queue, which provides constant-time access to both its least element and
@@ -754,7 +754,7 @@ private int getGrandparentIndex(int i) {
     // either of them, up to the same multiplicity as the queue.
     @MonotonicNonNullDecl private Queue<E> forgetMeNot;
     @MonotonicNonNullDecl private List<E> skipMe;
-    @NullableDecl private E lastFromForgetMeNot;
+    @Nullable private E lastFromForgetMeNot;
     private boolean canRemove;
 
     @Override, @@ -25,7 +25,7 @@
 import java.util.NoSuchElementException;
 import java.util.Optional;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Collectors not present in {@code java.util.stream.Collectors} that are not otherwise associated
@@ -91,8 +91,8 @@
   private static final class ToOptionalState {
     static final int MAX_EXTRAS = 4;
 
-    @NullableDecl Object element;
-    @NullableDecl List<Object> extras;
+    @Nullable Object element;
+    @Nullable List<Object> extras;
 
     ToOptionalState() {
       element = null;, @@ -27,7 +27,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.function.BiConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that maps keys to values, similar to {@link Map}, but in which each key may be
@@ -181,21 +181,20 @@
    * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
    * key}.
    */
-  boolean containsKey(@CompatibleWith(""K"") @NullableDecl Object key);
+  boolean containsKey(@CompatibleWith(""K"") @Nullable Object key);
 
   /**
    * Returns {@code true} if this multimap contains at least one key-value pair with the value
    * {@code value}.
    */
-  boolean containsValue(@CompatibleWith(""V"") @NullableDecl Object value);
+  boolean containsValue(@CompatibleWith(""V"") @Nullable Object value);
 
   /**
    * Returns {@code true} if this multimap contains at least one key-value pair with the key {@code
    * key} and the value {@code value}.
    */
   boolean containsEntry(
-      @CompatibleWith(""K"") @NullableDecl Object key,
-      @CompatibleWith(""V"") @NullableDecl Object value);
+      @CompatibleWith(""K"") @Nullable Object key, @CompatibleWith(""V"") @Nullable Object value);
 
   // Modification Operations
 
@@ -210,7 +209,7 @@ boolean containsEntry(
    *     multimap already contained the key-value pair and doesn't allow duplicates
    */
   @CanIgnoreReturnValue
-  boolean put(@NullableDecl K key, @NullableDecl V value);
+  boolean put(@Nullable K key, @Nullable V value);
 
   /**
    * Removes a single key-value pair with the key {@code key} and the value {@code value} from this
@@ -221,8 +220,7 @@ boolean containsEntry(
    */
   @CanIgnoreReturnValue
   boolean remove(
-      @CompatibleWith(""K"") @NullableDecl Object key,
-      @CompatibleWith(""V"") @NullableDecl Object value);
+      @CompatibleWith(""K"") @Nullable Object key, @CompatibleWith(""V"") @Nullable Object value);
 
   // Bulk Operations
 
@@ -241,7 +239,7 @@ boolean remove(
    * @return {@code true} if the multimap changed
    */
   @CanIgnoreReturnValue
-  boolean putAll(@NullableDecl K key, Iterable<? extends V> values);
+  boolean putAll(@Nullable K key, Iterable<? extends V> values);
 
   /**
    * Stores all key-value pairs of {@code multimap} in this multimap, in the order returned by
@@ -262,7 +260,7 @@ boolean remove(
    *     no effect on the multimap.
    */
   @CanIgnoreReturnValue
-  Collection<V> replaceValues(@NullableDecl K key, Iterable<? extends V> values);
+  Collection<V> replaceValues(@Nullable K key, Iterable<? extends V> values);
 
   /**
    * Removes all values associated with the key {@code key}.
@@ -274,7 +272,7 @@ boolean remove(
    *     modifiable, but updating it will have no effect on the multimap.
    */
   @CanIgnoreReturnValue
-  Collection<V> removeAll(@CompatibleWith(""K"") @NullableDecl Object key);
+  Collection<V> removeAll(@CompatibleWith(""K"") @Nullable Object key);
 
   /** Removes all key-value pairs from the multimap, leaving it {@linkplain #isEmpty empty}. */
   void clear();
@@ -288,7 +286,7 @@ boolean remove(
    *
    * <p>Changes to the returned collection will update the underlying multimap, and vice versa.
    */
-  Collection<V> get(@NullableDecl K key);
+  Collection<V> get(@Nullable K key);
 
   /**
    * Returns a view collection of all <i>distinct</i> keys contained in this multimap. Note that the
@@ -370,7 +368,7 @@ default void forEach(BiConsumer<? super K, ? super V> action) {
    * multimaps are equal, because they both have empty {@link #asMap} views.
    */
   @Override
-  boolean equals(@NullableDecl Object obj);
+  boolean equals(@Nullable Object obj);
 
   /**
    * Returns the hash code for this multimap., @@ -53,7 +53,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods acting on or generating a {@code Multimap}.
@@ -1737,7 +1737,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object element) {
+    public boolean contains(@Nullable Object element) {
       return multimap.containsKey(element);
     }
 
@@ -1747,13 +1747,13 @@ public boolean contains(@NullableDecl Object element) {
     }
 
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       Collection<V> values = Maps.safeGet(multimap.asMap(), element);
       return (values == null) ? 0 : values.size();
     }
 
     @Override
-    public int remove(@NullableDecl Object element, int occurrences) {
+    public int remove(@Nullable Object element, int occurrences) {
       checkNonnegative(occurrences, ""occurrences"");
       if (occurrences == 0) {
         return count(element);
@@ -1804,7 +1804,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       if (o instanceof Map.Entry) {
         Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
         return multimap().containsEntry(entry.getKey(), entry.getValue());
@@ -1813,7 +1813,7 @@ public boolean contains(@NullableDecl Object o) {
     }
 
     @Override
-    public boolean remove(@NullableDecl Object o) {
+    public boolean remove(@Nullable Object o) {
       if (o instanceof Map.Entry) {
         Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;
         return multimap().remove(entry.getKey(), entry.getValue());
@@ -2194,7 +2194,7 @@ public void clear() {
     return new FilteredEntrySetMultimap<>(multimap.unfiltered(), predicate);
   }
 
-  static boolean equalsImpl(Multimap<?, ?> multimap, @NullableDecl Object object) {
+  static boolean equalsImpl(Multimap<?, ?> multimap, @Nullable Object object) {
     if (object == multimap) {
       return true;
     }, @@ -30,7 +30,7 @@
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import java.util.function.ObjIntConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that supports order-independent equality, like {@link Set}, but may have duplicate
@@ -107,7 +107,7 @@
    * @return the number of occurrences of the element in this multiset; possibly zero but never
    *     negative
    */
-  int count(@NullableDecl @CompatibleWith(""E"") Object element);
+  int count(@Nullable @CompatibleWith(""E"") Object element);
 
   // Bulk Operations
 
@@ -130,7 +130,7 @@
    *     return normally.
    */
   @CanIgnoreReturnValue
-  int add(@NullableDecl E element, int occurrences);
+  int add(@Nullable E element, int occurrences);
 
   /**
    * Adds a single occurrence of the specified element to this multiset.
@@ -168,7 +168,7 @@
    * @throws IllegalArgumentException if {@code occurrences} is negative
    */
   @CanIgnoreReturnValue
-  int remove(@NullableDecl @CompatibleWith(""E"") Object element, int occurrences);
+  int remove(@Nullable @CompatibleWith(""E"") Object element, int occurrences);
 
   /**
    * Removes a <i>single</i> occurrence of the specified element from this multiset, if present.
@@ -184,7 +184,7 @@
    */
   @CanIgnoreReturnValue
   @Override
-  boolean remove(@NullableDecl Object element);
+  boolean remove(@Nullable Object element);
 
   /**
    * Adds or removes the necessary occurrences of an element such that the element attains the
@@ -348,7 +348,7 @@ default void forEachEntry(ObjIntConsumer<? super E> action) {
    */
   @Override
   // TODO(kevinb): caveats about equivalence-relation?
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   /**
    * Returns the hash code for this multiset. This is defined as the sum of
@@ -394,7 +394,7 @@ default void forEachEntry(ObjIntConsumer<? super E> action) {
    * @return {@code true} if this multiset contains at least one occurrence of the element
    */
   @Override
-  boolean contains(@NullableDecl Object element);
+  boolean contains(@Nullable Object element);
 
   /**
    * Returns {@code true} if this multiset contains at least one occurrence of each element in the, @@ -41,7 +41,7 @@
 import java.util.Spliterator;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static utility methods for creating and working with {@link Multiset} instances.
@@ -241,22 +241,22 @@ public boolean setCount(E element, int oldCount, int newCount) {
    * @param n the count to be associated with the returned entry
    * @throws IllegalArgumentException if {@code n} is negative
    */
-  public static <E> Multiset.Entry<E> immutableEntry(@NullableDecl E e, int n) {
+  public static <E> Multiset.Entry<E> immutableEntry(@Nullable E e, int n) {
     return new ImmutableEntry<E>(e, n);
   }
 
   static class ImmutableEntry<E> extends AbstractEntry<E> implements Serializable {
-    @NullableDecl private final E element;
+    @Nullable private final E element;
     private final int count;
 
-    ImmutableEntry(@NullableDecl E element, int count) {
+    ImmutableEntry(@Nullable E element, int count) {
       this.element = element;
       this.count = count;
       checkNonnegative(count, ""count"");
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public final E getElement() {
       return element;
     }
@@ -352,7 +352,7 @@ public boolean apply(Entry<E> entry) {
     }
 
     @Override
-    public int count(@NullableDecl Object element) {
+    public int count(@Nullable Object element) {
       int count = unfiltered.count(element);
       if (count > 0) {
         @SuppressWarnings(""unchecked"") // element is equal to an E
@@ -363,14 +363,14 @@ public int count(@NullableDecl Object element) {
     }
 
     @Override
-    public int add(@NullableDecl E element, int occurrences) {
+    public int add(@Nullable E element, int occurrences) {
       checkArgument(
           predicate.apply(element), ""Element %s does not match predicate %s"", element, predicate);
       return unfiltered.add(element, occurrences);
     }
 
     @Override
-    public int remove(@NullableDecl Object element, int occurrences) {
+    public int remove(@Nullable Object element, int occurrences) {
       checkNonnegative(occurrences, ""occurrences"");
       if (occurrences == 0) {
         return count(element);
@@ -412,7 +412,7 @@ static int inferDistinctElements(Iterable<?> elements) {
 
     return new ViewMultiset<E>() {
       @Override
-      public boolean contains(@NullableDecl Object element) {
+      public boolean contains(@Nullable Object element) {
         return multiset1.contains(element) || multiset2.contains(element);
       }
 
@@ -541,7 +541,7 @@ public int count(Object element) {
     // TODO(lowasser): consider making the entries live views
     return new ViewMultiset<E>() {
       @Override
-      public boolean contains(@NullableDecl Object element) {
+      public boolean contains(@Nullable Object element) {
         return multiset1.contains(element) || multiset2.contains(element);
       }
 
@@ -618,7 +618,7 @@ public int count(Object element) {
     // TODO(lowasser): consider making the entries live views
     return new ViewMultiset<E>() {
       @Override
-      public int count(@NullableDecl Object element) {
+      public int count(@Nullable Object element) {
         int count1 = multiset1.count(element);
         return (count1 == 0) ? 0 : Math.max(0, count1 - multiset2.count(element));
       }
@@ -828,7 +828,7 @@ public static boolean removeOccurrences(
      * Multiset.Entry#equals}.
      */
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof Multiset.Entry) {
         Multiset.Entry<?> that = (Multiset.Entry<?>) object;
         return this.getCount() == that.getCount()
@@ -862,7 +862,7 @@ public String toString() {
   }
 
   /** An implementation of {@link Multiset#equals}. */
-  static boolean equalsImpl(Multiset<?> multiset, @NullableDecl Object object) {
+  static boolean equalsImpl(Multiset<?> multiset, @Nullable Object object) {
     if (object == multiset) {
       return true;
     }
@@ -1009,7 +1009,7 @@ public int size() {
     abstract Multiset<E> multiset();
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       if (o instanceof Entry) {
         /*
          * The GWT compiler wrongly issues a warning here., @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that treats {@code null} as less than all other values. */
 @GwtCompatible(serializable = true)
@@ -30,7 +30,7 @@
   }
 
   @Override
-  public int compare(@NullableDecl T left, @NullableDecl T right) {
+  public int compare(@Nullable T left, @Nullable T right) {
     if (left == right) {
       return 0;
     }
@@ -61,7 +61,7 @@ public int compare(@NullableDecl T left, @NullableDecl T right) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that treats {@code null} as greater than all other values. */
 @GwtCompatible(serializable = true)
@@ -30,7 +30,7 @@
   }
 
   @Override
-  public int compare(@NullableDecl T left, @NullableDecl T right) {
+  public int compare(@Nullable T left, @Nullable T right) {
     if (left == right) {
       return 0;
     }
@@ -61,7 +61,7 @@ public int compare(@NullableDecl T left, @NullableDecl T right) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -24,7 +24,7 @@
 import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Collection;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to object arrays.
@@ -82,7 +82,7 @@ private ObjectArrays() {}
    * @return an array whose size is one larger than {@code array}, with {@code element} occupying
    *     the first position, and the elements of {@code array} occupying the remaining elements.
    */
-  public static <T> T[] concat(@NullableDecl T element, T[] array) {
+  public static <T> T[] concat(@Nullable T element, T[] array) {
     T[] result = newArray(array, array.length + 1);
     result[0] = element;
     System.arraycopy(array, 0, result, 1, array.length);
@@ -97,7 +97,7 @@ private ObjectArrays() {}
    * @return an array whose size is one larger than {@code array}, with the same contents as {@code
    *     array}, plus {@code element} occupying the last position.
    */
-  public static <T> T[] concat(T[] array, @NullableDecl T element) {
+  public static <T> T[] concat(T[] array, @Nullable T element) {
     T[] result = Arrays.copyOf(array, array.length + 1);
     result[array.length] = element;
     return result;, @@ -35,7 +35,7 @@
 import java.util.SortedMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A comparator, with additional methods to support common operations. This is an ""enriched"" version
@@ -524,10 +524,10 @@ protected Ordering() {}
 
   // Regular instance methods
 
-  // Override to add @NullableDecl
+  // Override to add @Nullable
   @CanIgnoreReturnValue // TODO(kak): Consider removing this
   @Override
-  public abstract int compare(@NullableDecl T left, @NullableDecl T right);
+  public abstract int compare(@Nullable T left, @Nullable T right);
 
   /**
    * Returns the least of the specified values according to this ordering. If there are multiple
@@ -592,7 +592,7 @@ protected Ordering() {}
    *     ordering.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this
-  public <E extends T> E min(@NullableDecl E a, @NullableDecl E b) {
+  public <E extends T> E min(@Nullable E a, @Nullable E b) {
     return (compare(a, b) <= 0) ? a : b;
   }
 
@@ -611,7 +611,7 @@ protected Ordering() {}
    *     ordering.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this
-  public <E extends T> E min(@NullableDecl E a, @NullableDecl E b, @NullableDecl E c, E... rest) {
+  public <E extends T> E min(@Nullable E a, @Nullable E b, @Nullable E c, E... rest) {
     E minSoFar = min(min(a, b), c);
 
     for (E r : rest) {
@@ -684,7 +684,7 @@ protected Ordering() {}
    *     ordering.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this
-  public <E extends T> E max(@NullableDecl E a, @NullableDecl E b) {
+  public <E extends T> E max(@Nullable E a, @Nullable E b) {
     return (compare(a, b) >= 0) ? a : b;
   }
 
@@ -703,7 +703,7 @@ protected Ordering() {}
    *     ordering.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this
-  public <E extends T> E max(@NullableDecl E a, @NullableDecl E b, @NullableDecl E c, E... rest) {
+  public <E extends T> E max(@Nullable E a, @Nullable E b, @Nullable E c, E... rest) {
     E maxSoFar = max(max(a, b), c);
 
     for (E r : rest) {
@@ -931,7 +931,7 @@ public boolean isStrictlyOrdered(Iterable<? extends T> iterable) {
    * @deprecated Use {@link Collections#binarySearch(List, Object, Comparator)} directly.
    */
   @Deprecated
-  public int binarySearch(List<? extends T> sortedList, @NullableDecl T key) {
+  public int binarySearch(List<? extends T> sortedList, @Nullable T key) {
     return Collections.binarySearch(sortedList, key, this);
   }
 , @@ -27,7 +27,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A range (or ""interval"") defines the <i>boundaries</i> around a contiguous span of values of some
@@ -617,7 +617,7 @@ public boolean isConnected(Range<C> other) {
    * {@code [3..3)}, {@code (3..3]}, {@code (4..4]} are all unequal.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Range) {
       Range<?> other = (Range<?>) object;
       return lowerBound.equals(other.lowerBound) && upperBound.equals(other.upperBound);, @@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mapping from disjoint nonempty ranges to non-null values. Queries look up the value associated
@@ -43,14 +43,14 @@
    * <p>Specifically, if any range in this range map contains the specified key, the value
    * associated with that range is returned.
    */
-  @NullableDecl
+  @Nullable
   V get(K key);
 
   /**
    * Returns the range containing this key and its associated value, if such a range is present in
    * the range map, or {@code null} otherwise.
    */
-  @NullableDecl
+  @Nullable
   Entry<Range<K>, V> getEntry(K key);
 
   /**
@@ -151,7 +151,7 @@
    * #asMapOfRanges()}.
    */
   @Override
-  boolean equals(@NullableDecl Object o);
+  boolean equals(@Nullable Object o);
 
   /** Returns {@code asMapOfRanges().hashCode()}. */
   @Override, @@ -18,7 +18,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A set comprising zero or more {@linkplain Range#isEmpty nonempty}, {@linkplain
@@ -260,7 +260,7 @@ default void removeAll(Iterable<Range<C>> ranges) {
    * according to {@link Range#equals(Object)}.
    */
   @Override
-  boolean equals(@NullableDecl Object obj);
+  boolean equals(@Nullable Object obj);
 
   /** Returns {@code asRanges().hashCode()}. */
   @Override, @@ -23,7 +23,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import java.io.Serializable;
 import java.util.Collection;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link ContiguousSet} that contains one or more elements.
@@ -100,7 +100,7 @@ protected C computeNext(C previous) {
     };
   }
 
-  private static boolean equalsOrThrow(Comparable<?> left, @NullableDecl Comparable<?> right) {
+  private static boolean equalsOrThrow(Comparable<?> left, @Nullable Comparable<?> right) {
     return right != null && Range.compareOrThrow(left, right) == 0;
   }
 
@@ -146,7 +146,7 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object object) {
+  public boolean contains(@Nullable Object object) {
     if (object == null) {
       return false;
     }
@@ -195,7 +195,7 @@ public boolean isEmpty() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     } else if (object instanceof RegularContiguousSet) {, @@ -32,7 +32,7 @@
 import java.io.Serializable;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Bimap with zero or more mappings.
@@ -125,7 +125,7 @@ private RegularImmutableBiMap(
    */
   @CanIgnoreReturnValue
   private static int checkNoConflictInValueBucket(
-      Object value, Entry<?, ?> entry, @NullableDecl ImmutableMapEntry<?, ?> valueBucketHead) {
+      Object value, Entry<?, ?> entry, @Nullable ImmutableMapEntry<?, ?> valueBucketHead) {
     int bucketSize = 0;
     for (; valueBucketHead != null; valueBucketHead = valueBucketHead.getNextInValueBucket()) {
       checkNoConflict(!value.equals(valueBucketHead.getValue()), ""value"", entry, valueBucketHead);
@@ -135,8 +135,8 @@ private static int checkNoConflictInValueBucket(
   }
 
   @Override
-  @NullableDecl
-  public V get(@NullableDecl Object key) {
+  @Nullable
+  public V get(@Nullable Object key) {
     return (keyTable == null) ? null : RegularImmutableMap.get(key, keyTable, mask);
   }
 
@@ -210,7 +210,7 @@ public void forEach(BiConsumer<? super V, ? super K> action) {
     }
 
     @Override
-    public K get(@NullableDecl Object value) {
+    public K get(@Nullable Object value) {
       if (value == null || valueTable == null) {
         return null;
       }, @@ -29,7 +29,7 @@
 import com.google.j2objc.annotations.Weak;
 import java.io.Serializable;
 import java.util.function.BiConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMap} with two or more entries.
@@ -99,7 +99,7 @@
       V value = entry.getValue();
       checkEntryNotNull(key, value);
       int tableIndex = Hashing.smear(key.hashCode()) & mask;
-      @NullableDecl ImmutableMapEntry<K, V> existing = table[tableIndex];
+      @Nullable ImmutableMapEntry<K, V> existing = table[tableIndex];
       // prepend, not append, so the entries can be immutable
       ImmutableMapEntry<K, V> newEntry =
           (existing == null)
@@ -141,7 +141,7 @@ private RegularImmutableMap(Entry<K, V>[] entries, ImmutableMapEntry<K, V>[] tab
    */
   @CanIgnoreReturnValue
   static int checkNoConflictInKeyBucket(
-      Object key, Entry<?, ?> entry, @NullableDecl ImmutableMapEntry<?, ?> keyBucketHead) {
+      Object key, Entry<?, ?> entry, @Nullable ImmutableMapEntry<?, ?> keyBucketHead) {
     int bucketSize = 0;
     for (; keyBucketHead != null; keyBucketHead = keyBucketHead.getNextInKeyBucket()) {
       checkNoConflict(!key.equals(keyBucketHead.getKey()), ""key"", entry, keyBucketHead);
@@ -151,13 +151,12 @@ static int checkNoConflictInKeyBucket(
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return get(key, table, mask);
   }
 
-  @NullableDecl
-  static <V> V get(
-      @NullableDecl Object key, @NullableDecl ImmutableMapEntry<?, V>[] keyTable, int mask) {
+  @Nullable
+  static <V> V get(@Nullable Object key, ImmutableMapEntry<?, V> @Nullable [] keyTable, int mask) {
     if (key == null || keyTable == null) {
       return null;
     }, @@ -24,7 +24,7 @@
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.util.Arrays;
 import java.util.Collection;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMultiset} with zero or more elements.
@@ -116,7 +116,7 @@ private static boolean hashFloodingDetected(Multisets.ImmutableEntry<?>[] hashTa
   @VisibleForTesting static final int MAX_HASH_BUCKET_LENGTH = 9;
 
   private final transient Multisets.ImmutableEntry<E>[] entries;
-  @NullableDecl private final transient Multisets.ImmutableEntry<E>[] hashTable;
+  private final transient Multisets.ImmutableEntry<E> @Nullable [] hashTable;
   private final transient int size;
   private final transient int hashCode;
 
@@ -155,7 +155,7 @@ boolean isPartialView() {
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     Multisets.ImmutableEntry<E>[] hashTable = this.hashTable;
     if (element == null || hashTable == null) {
       return 0;, @@ -20,7 +20,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableSet} with two or more elements.
@@ -48,7 +48,7 @@
   }
 
   @Override
-  public boolean contains(@NullableDecl Object target) {
+  public boolean contains(@Nullable Object target) {
     Object[] table = this.table;
     if (target == null || table == null) {
       return false;, @@ -23,7 +23,7 @@
 import com.google.common.primitives.Ints;
 import java.util.Comparator;
 import java.util.function.ObjIntConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable sorted multiset with one or more distinct elements.
@@ -86,7 +86,7 @@ public void forEachEntry(ObjIntConsumer<? super E> action) {
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     int index = elementSet.indexOf(element);
     return (index >= 0) ? getCount(index) : 0;
   }, @@ -28,7 +28,7 @@
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable sorted set with one or more elements. TODO(jlevy): Consider separate class for a
@@ -77,7 +77,7 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object o) {
+  public boolean contains(@Nullable Object o) {
     try {
       return o != null && unsafeBinarySearch(o) >= 0;
     } catch (ClassCastException e) {
@@ -152,7 +152,7 @@ int copyIntoArray(Object[] dst, int offset) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }
@@ -282,7 +282,7 @@ int tailIndex(E fromElement, boolean inclusive) {
   }
 
   @Override
-  int indexOf(@NullableDecl Object target) {
+  int indexOf(@Nullable Object target) {
     if (target == null) {
       return -1;
     }, @@ -23,7 +23,7 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link ImmutableTable} holding an arbitrary number of cells.
@@ -54,7 +54,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object object) {
+    public boolean contains(@Nullable Object object) {
       if (object instanceof Cell) {
         Cell<?, ?, ?> cell = (Cell<?, ?, ?>) object;
         Object value = RegularImmutableTable.this.get(cell.getRowKey(), cell.getColumnKey());
@@ -96,8 +96,8 @@ boolean isPartialView() {
 
   static <R, C, V> RegularImmutableTable<R, C, V> forCells(
       List<Cell<R, C, V>> cells,
-      @NullableDecl final Comparator<? super R> rowComparator,
-      @NullableDecl final Comparator<? super C> columnComparator) {
+      @Nullable final Comparator<? super R> rowComparator,
+      @Nullable final Comparator<? super C> columnComparator) {
     checkNotNull(cells);
     if (rowComparator != null || columnComparator != null) {
       /*
@@ -134,8 +134,8 @@ public int compare(Cell<R, C, V> cell1, Cell<R, C, V> cell2) {
 
   private static <R, C, V> RegularImmutableTable<R, C, V> forCellsInternal(
       Iterable<Cell<R, C, V>> cells,
-      @NullableDecl Comparator<? super R> rowComparator,
-      @NullableDecl Comparator<? super C> columnComparator) {
+      @Nullable Comparator<? super R> rowComparator,
+      @Nullable Comparator<? super C> columnComparator) {
     Set<R> rowSpaceBuilder = new LinkedHashSet<>();
     Set<C> columnSpaceBuilder = new LinkedHashSet<>();
     ImmutableList<Cell<R, C, V>> cellList = ImmutableList.copyOf(cells);, @@ -21,7 +21,7 @@
 import com.google.common.annotations.GwtCompatible;
 import java.io.Serializable;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** An ordering that uses the reverse of a given order. */
 @GwtCompatible(serializable = true)
@@ -91,7 +91,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code Multimap} that cannot hold duplicate key-value pairs. Adding a key-value pair that's
@@ -58,7 +58,7 @@
    * interface.
    */
   @Override
-  Set<V> get(@NullableDecl K key);
+  Set<V> get(@Nullable K key);
 
   /**
    * {@inheritDoc}
@@ -69,7 +69,7 @@
    */
   @CanIgnoreReturnValue
   @Override
-  Set<V> removeAll(@NullableDecl Object key);
+  Set<V> removeAll(@Nullable Object key);
 
   /**
    * {@inheritDoc}
@@ -114,5 +114,5 @@
    * empty {@code ListMultimap}.
    */
   @Override
-  boolean equals(@NullableDecl Object obj);
+  boolean equals(@Nullable Object obj);
 }, @@ -52,7 +52,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@link Set} instances. Also see this class's counterparts
@@ -1141,7 +1141,7 @@ public boolean contains(Object element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       return equalsImpl(this, object);
     }
 
@@ -1208,13 +1208,13 @@ public E last() {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public E lower(E e) {
       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public E floor(E e) {
       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
     }
@@ -1431,7 +1431,7 @@ private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> deleg
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       // Warning: this is broken if size() == 0, so it is critical that we
       // substitute an empty ImmutableSet to the user in place of this
       if (object instanceof CartesianSet) {
@@ -1531,7 +1531,7 @@ public int size() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object o) {
+    public boolean contains(@Nullable Object o) {
       Integer index = inputSet.get(o);
       return index != null && (mask & (1 << index)) != 0;
     }
@@ -1567,7 +1567,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object obj) {
+    public boolean contains(@Nullable Object obj) {
       if (obj instanceof Set) {
         Set<?> set = (Set<?>) obj;
         return inputSet.keySet().containsAll(set);
@@ -1576,7 +1576,7 @@ public boolean contains(@NullableDecl Object obj) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj instanceof PowerSet) {
         PowerSet<?> that = (PowerSet<?>) obj;
         return inputSet.equals(that.inputSet);
@@ -1636,7 +1636,7 @@ public String toString() {
     }
     return new AbstractSet<Set<E>>() {
       @Override
-      public boolean contains(@NullableDecl Object o) {
+      public boolean contains(@Nullable Object o) {
         if (o instanceof Set) {
           Set<?> s = (Set<?>) o;
           return s.size() == size && index.keySet().containsAll(s);
@@ -1681,7 +1681,7 @@ public boolean contains(@NullableDecl Object o) {
             final BitSet copy = (BitSet) bits.clone();
             return new AbstractSet<E>() {
               @Override
-              public boolean contains(@NullableDecl Object o) {
+              public boolean contains(@Nullable Object o) {
                 Integer i = index.get(o);
                 return i != null && copy.get(i);
               }
@@ -1736,7 +1736,7 @@ static int hashCodeImpl(Set<?> s) {
   }
 
   /** An implementation for {@link Set#equals(Object)}. */
-  static boolean equalsImpl(Set<?> s, @NullableDecl Object object) {
+  static boolean equalsImpl(Set<?> s, @Nullable Object object) {
     if (s == object) {
       return true;
     }, @@ -23,7 +23,7 @@
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
 import java.util.function.BiConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@link ImmutableMap} with exactly one entry.
@@ -51,7 +51,7 @@ private SingletonImmutableBiMap(K singleKey, V singleValue, ImmutableBiMap<V, K>
   }
 
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     return singleKey.equals(key) ? singleValue : null;
   }
 
@@ -66,12 +66,12 @@ public void forEach(BiConsumer<? super K, ? super V> action) {
   }
 
   @Override
-  public boolean containsKey(@NullableDecl Object key) {
+  public boolean containsKey(@Nullable Object key) {
     return singleKey.equals(key);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return singleValue.equals(value);
   }
 , @@ -23,7 +23,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static methods pertaining to sorted {@link List} instances.
@@ -196,7 +196,7 @@ public int resultIndex(int higherIndex) {
   public static <E, K extends Comparable> int binarySearch(
       List<E> list,
       Function<? super E, K> keyFunction,
-      @NullableDecl K key,
+      @Nullable K key,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {
     return binarySearch(
@@ -213,7 +213,7 @@ public int resultIndex(int higherIndex) {
   public static <E, K> int binarySearch(
       List<E> list,
       Function<? super E, K> keyFunction,
-      @NullableDecl K key,
+      @Nullable K key,
       Comparator<? super K> keyComparator,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {
@@ -246,7 +246,7 @@ public int resultIndex(int higherIndex) {
    */
   public static <E> int binarySearch(
       List<? extends E> list,
-      @NullableDecl E key,
+      @Nullable E key,
       Comparator<? super E> comparator,
       KeyPresentBehavior presentBehavior,
       KeyAbsentBehavior absentBehavior) {, @@ -28,7 +28,7 @@
 import java.util.NavigableSet;
 import java.util.NoSuchElementException;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static utility methods for creating and working with {@link SortedMultiset} instances.
@@ -165,7 +165,7 @@ public E pollLast() {
     return entry.getElement();
   }
 
-  private static <E> E getElementOrNull(@NullableDecl Entry<E> entry) {
+  private static <E> E getElementOrNull(@Nullable Entry<E> entry) {
     return (entry == null) ? null : entry.getElement();
   }
 }, @@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@code SetMultimap} whose set of values for a given key are kept sorted; that is, they comprise
@@ -58,7 +58,7 @@
    * {@link Multimap} interface.
    */
   @Override
-  SortedSet<V> get(@NullableDecl K key);
+  SortedSet<V> get(@Nullable K key);
 
   /**
    * Removes all values associated with a given key.
@@ -69,7 +69,7 @@
    */
   @CanIgnoreReturnValue
   @Override
-  SortedSet<V> removeAll(@NullableDecl Object key);
+  SortedSet<V> removeAll(@Nullable Object key);
 
   /**
    * Stores a collection of values with the same key, replacing any existing values for that key., @@ -43,7 +43,7 @@
 import java.util.Spliterator;
 import java.util.Spliterators;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@link Table} implementation backed by a map that associates row keys with column key / value
@@ -77,12 +77,12 @@
   // Accessors
 
   @Override
-  public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
     return rowKey != null && columnKey != null && super.contains(rowKey, columnKey);
   }
 
   @Override
-  public boolean containsColumn(@NullableDecl Object columnKey) {
+  public boolean containsColumn(@Nullable Object columnKey) {
     if (columnKey == null) {
       return false;
     }
@@ -95,17 +95,17 @@ public boolean containsColumn(@NullableDecl Object columnKey) {
   }
 
   @Override
-  public boolean containsRow(@NullableDecl Object rowKey) {
+  public boolean containsRow(@Nullable Object rowKey) {
     return rowKey != null && safeContainsKey(backingMap, rowKey);
   }
 
   @Override
-  public boolean containsValue(@NullableDecl Object value) {
+  public boolean containsValue(@Nullable Object value) {
     return value != null && super.containsValue(value);
   }
 
   @Override
-  public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
     return (rowKey == null || columnKey == null) ? null : super.get(rowKey, columnKey);
   }
 
@@ -150,7 +150,7 @@ public V put(R rowKey, C columnKey, V value) {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+  public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
     if ((rowKey == null) || (columnKey == null)) {
       return null;
     }
@@ -235,7 +235,7 @@ public void clear() {
 
   private class CellIterator implements Iterator<Cell<R, C, V>> {
     final Iterator<Entry<R, Map<C, V>>> rowIterator = backingMap.entrySet().iterator();
-    @NullableDecl Entry<R, Map<C, V>> rowEntry;
+    @Nullable Entry<R, Map<C, V>> rowEntry;
     Iterator<Entry<C, V>> columnIterator = Iterators.emptyModifiableIterator();
 
     @Override
@@ -289,7 +289,7 @@ public void remove() {
       this.rowKey = checkNotNull(rowKey);
     }
 
-    @NullableDecl Map<C, V> backingRowMap;
+    @Nullable Map<C, V> backingRowMap;
 
     Map<C, V> backingRowMap() {
       return (backingRowMap == null || (backingRowMap.isEmpty() && backingMap.containsKey(rowKey))), @@ -44,7 +44,7 @@
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods related to {@code Stream} instances.
@@ -373,14 +373,14 @@ public boolean tryAdvance(Consumer<? super R> action) {
           .onClose(stream::close);
     }
     class Splitr extends MapWithIndexSpliterator<Spliterator<T>, R, Splitr> implements Consumer<T> {
-      @NullableDecl T holder;
+      @Nullable T holder;
 
       Splitr(Spliterator<T> splitr, long index) {
         super(splitr, index);
       }
 
       @Override
-      public void accept(@NullableDecl T t) {
+      public void accept(@Nullable T t) {
         this.holder = t;
       }
 
@@ -753,7 +753,7 @@ public int characteristics() {
       boolean set = false;
       T value = null;
 
-      void set(@NullableDecl T value) {
+      void set(@Nullable T value) {
         this.set = true;
         this.value = value;
       }, @@ -49,7 +49,7 @@
 import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Synchronized collection views. The returned synchronized collection views are serializable if the
@@ -71,7 +71,7 @@ private Synchronized() {}
     final Object delegate;
     final Object mutex;
 
-    SynchronizedObject(Object delegate, @NullableDecl Object mutex) {
+    SynchronizedObject(Object delegate, @Nullable Object mutex) {
       this.delegate = checkNotNull(delegate);
       this.mutex = (mutex == null) ? this : mutex;
     }
@@ -105,14 +105,13 @@ private void writeObject(ObjectOutputStream stream) throws IOException {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E> Collection<E> collection(
-      Collection<E> collection, @NullableDecl Object mutex) {
+  private static <E> Collection<E> collection(Collection<E> collection, @Nullable Object mutex) {
     return new SynchronizedCollection<E>(collection, mutex);
   }
 
   @VisibleForTesting
   static class SynchronizedCollection<E> extends SynchronizedObject implements Collection<E> {
-    private SynchronizedCollection(Collection<E> delegate, @NullableDecl Object mutex) {
+    private SynchronizedCollection(Collection<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -250,13 +249,13 @@ public int size() {
   }
 
   @VisibleForTesting
-  static <E> Set<E> set(Set<E> set, @NullableDecl Object mutex) {
+  static <E> Set<E> set(Set<E> set, @Nullable Object mutex) {
     return new SynchronizedSet<E>(set, mutex);
   }
 
   static class SynchronizedSet<E> extends SynchronizedCollection<E> implements Set<E> {
 
-    SynchronizedSet(Set<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedSet(Set<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -285,12 +284,12 @@ public int hashCode() {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @NullableDecl Object mutex) {
+  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @Nullable Object mutex) {
     return new SynchronizedSortedSet<E>(set, mutex);
   }
 
   static class SynchronizedSortedSet<E> extends SynchronizedSet<E> implements SortedSet<E> {
-    SynchronizedSortedSet(SortedSet<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedSortedSet(SortedSet<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -344,14 +343,14 @@ public E last() {
     private static final long serialVersionUID = 0;
   }
 
-  private static <E> List<E> list(List<E> list, @NullableDecl Object mutex) {
+  private static <E> List<E> list(List<E> list, @Nullable Object mutex) {
     return (list instanceof RandomAccess)
         ? new SynchronizedRandomAccessList<E>(list, mutex)
         : new SynchronizedList<E>(list, mutex);
   }
 
   private static class SynchronizedList<E> extends SynchronizedCollection<E> implements List<E> {
-    SynchronizedList(List<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedList(List<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -462,14 +461,14 @@ public int hashCode() {
 
   private static class SynchronizedRandomAccessList<E> extends SynchronizedList<E>
       implements RandomAccess {
-    SynchronizedRandomAccessList(List<E> list, @NullableDecl Object mutex) {
+    SynchronizedRandomAccessList(List<E> list, @Nullable Object mutex) {
       super(list, mutex);
     }
 
     private static final long serialVersionUID = 0;
   }
 
-  static <E> Multiset<E> multiset(Multiset<E> multiset, @NullableDecl Object mutex) {
+  static <E> Multiset<E> multiset(Multiset<E> multiset, @Nullable Object mutex) {
     if (multiset instanceof SynchronizedMultiset || multiset instanceof ImmutableMultiset) {
       return multiset;
     }
@@ -481,7 +480,7 @@ public int hashCode() {
     @MonotonicNonNullDecl transient Set<E> elementSet;
     @MonotonicNonNullDecl transient Set<Entry<E>> entrySet;
 
-    SynchronizedMultiset(Multiset<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedMultiset(Multiset<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -565,7 +564,7 @@ public int hashCode() {
     private static final long serialVersionUID = 0;
   }
 
-  static <K, V> Multimap<K, V> multimap(Multimap<K, V> multimap, @NullableDecl Object mutex) {
+  static <K, V> Multimap<K, V> multimap(Multimap<K, V> multimap, @Nullable Object mutex) {
     if (multimap instanceof SynchronizedMultimap || multimap instanceof ImmutableMultimap) {
       return multimap;
     }
@@ -586,7 +585,7 @@ public int hashCode() {
       return (Multimap<K, V>) super.delegate();
     }
 
-    SynchronizedMultimap(Multimap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedMultimap(Multimap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -759,7 +758,7 @@ public int hashCode() {
   }
 
   static <K, V> ListMultimap<K, V> listMultimap(
-      ListMultimap<K, V> multimap, @NullableDecl Object mutex) {
+      ListMultimap<K, V> multimap, @Nullable Object mutex) {
     if (multimap instanceof SynchronizedListMultimap || multimap instanceof ImmutableListMultimap) {
       return multimap;
     }
@@ -768,7 +767,7 @@ public int hashCode() {
 
   private static class SynchronizedListMultimap<K, V> extends SynchronizedMultimap<K, V>
       implements ListMultimap<K, V> {
-    SynchronizedListMultimap(ListMultimap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedListMultimap(ListMultimap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -801,8 +800,7 @@ public int hashCode() {
     private static final long serialVersionUID = 0;
   }
 
-  static <K, V> SetMultimap<K, V> setMultimap(
-      SetMultimap<K, V> multimap, @NullableDecl Object mutex) {
+  static <K, V> SetMultimap<K, V> setMultimap(SetMultimap<K, V> multimap, @Nullable Object mutex) {
     if (multimap instanceof SynchronizedSetMultimap || multimap instanceof ImmutableSetMultimap) {
       return multimap;
     }
@@ -813,7 +811,7 @@ public int hashCode() {
       implements SetMultimap<K, V> {
     @MonotonicNonNullDecl transient Set<Entry<K, V>> entrySet;
 
-    SynchronizedSetMultimap(SetMultimap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedSetMultimap(SetMultimap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -857,7 +855,7 @@ public int hashCode() {
   }
 
   static <K, V> SortedSetMultimap<K, V> sortedSetMultimap(
-      SortedSetMultimap<K, V> multimap, @NullableDecl Object mutex) {
+      SortedSetMultimap<K, V> multimap, @Nullable Object mutex) {
     if (multimap instanceof SynchronizedSortedSetMultimap) {
       return multimap;
     }
@@ -866,7 +864,7 @@ public int hashCode() {
 
   private static class SynchronizedSortedSetMultimap<K, V> extends SynchronizedSetMultimap<K, V>
       implements SortedSetMultimap<K, V> {
-    SynchronizedSortedSetMultimap(SortedSetMultimap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedSortedSetMultimap(SortedSetMultimap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -907,7 +905,7 @@ public int hashCode() {
   }
 
   private static <E> Collection<E> typePreservingCollection(
-      Collection<E> collection, @NullableDecl Object mutex) {
+      Collection<E> collection, @Nullable Object mutex) {
     if (collection instanceof SortedSet) {
       return sortedSet((SortedSet<E>) collection, mutex);
     }
@@ -920,7 +918,7 @@ public int hashCode() {
     return collection(collection, mutex);
   }
 
-  private static <E> Set<E> typePreservingSet(Set<E> set, @NullableDecl Object mutex) {
+  private static <E> Set<E> typePreservingSet(Set<E> set, @Nullable Object mutex) {
     if (set instanceof SortedSet) {
       return sortedSet((SortedSet<E>) set, mutex);
     } else {
@@ -930,7 +928,7 @@ public int hashCode() {
 
   private static class SynchronizedAsMapEntries<K, V>
       extends SynchronizedSet<Entry<K, Collection<V>>> {
-    SynchronizedAsMapEntries(Set<Entry<K, Collection<V>>> delegate, @NullableDecl Object mutex) {
+    SynchronizedAsMapEntries(Set<Entry<K, Collection<V>>> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1021,7 +1019,7 @@ public boolean retainAll(Collection<?> c) {
   }
 
   @VisibleForTesting
-  static <K, V> Map<K, V> map(Map<K, V> map, @NullableDecl Object mutex) {
+  static <K, V> Map<K, V> map(Map<K, V> map, @Nullable Object mutex) {
     return new SynchronizedMap<>(map, mutex);
   }
 
@@ -1030,7 +1028,7 @@ public boolean retainAll(Collection<?> c) {
     @MonotonicNonNullDecl transient Collection<V> values;
     @MonotonicNonNullDecl transient Set<Entry<K, V>> entrySet;
 
-    SynchronizedMap(Map<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedMap(Map<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1232,14 +1230,14 @@ public int hashCode() {
     private static final long serialVersionUID = 0;
   }
 
-  static <K, V> SortedMap<K, V> sortedMap(SortedMap<K, V> sortedMap, @NullableDecl Object mutex) {
+  static <K, V> SortedMap<K, V> sortedMap(SortedMap<K, V> sortedMap, @Nullable Object mutex) {
     return new SynchronizedSortedMap<>(sortedMap, mutex);
   }
 
   static class SynchronizedSortedMap<K, V> extends SynchronizedMap<K, V>
       implements SortedMap<K, V> {
 
-    SynchronizedSortedMap(SortedMap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedSortedMap(SortedMap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1293,7 +1291,7 @@ public K lastKey() {
     private static final long serialVersionUID = 0;
   }
 
-  static <K, V> BiMap<K, V> biMap(BiMap<K, V> bimap, @NullableDecl Object mutex) {
+  static <K, V> BiMap<K, V> biMap(BiMap<K, V> bimap, @Nullable Object mutex) {
     if (bimap instanceof SynchronizedBiMap || bimap instanceof ImmutableBiMap) {
       return bimap;
     }
@@ -1307,7 +1305,7 @@ public K lastKey() {
     @MonotonicNonNullDecl @RetainedWith private transient BiMap<V, K> inverse;
 
     private SynchronizedBiMap(
-        BiMap<K, V> delegate, @NullableDecl Object mutex, @NullableDecl BiMap<V, K> inverse) {
+        BiMap<K, V> delegate, @Nullable Object mutex, @Nullable BiMap<V, K> inverse) {
       super(delegate, mutex);
       this.inverse = inverse;
     }
@@ -1351,7 +1349,7 @@ public V forcePut(K key, V value) {
     @MonotonicNonNullDecl transient Set<Entry<K, Collection<V>>> asMapEntrySet;
     @MonotonicNonNullDecl transient Collection<Collection<V>> asMapValues;
 
-    SynchronizedAsMap(Map<K, Collection<V>> delegate, @NullableDecl Object mutex) {
+    SynchronizedAsMap(Map<K, Collection<V>> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1393,7 +1391,7 @@ public boolean containsValue(Object o) {
   }
 
   private static class SynchronizedAsMapValues<V> extends SynchronizedCollection<Collection<V>> {
-    SynchronizedAsMapValues(Collection<Collection<V>> delegate, @NullableDecl Object mutex) {
+    SynchronizedAsMapValues(Collection<Collection<V>> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1415,7 +1413,7 @@ public boolean containsValue(Object o) {
   @VisibleForTesting
   static class SynchronizedNavigableSet<E> extends SynchronizedSortedSet<E>
       implements NavigableSet<E> {
-    SynchronizedNavigableSet(NavigableSet<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedNavigableSet(NavigableSet<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1527,8 +1525,7 @@ public E pollLast() {
   }
 
   @GwtIncompatible // NavigableSet
-  static <E> NavigableSet<E> navigableSet(
-      NavigableSet<E> navigableSet, @NullableDecl Object mutex) {
+  static <E> NavigableSet<E> navigableSet(NavigableSet<E> navigableSet, @Nullable Object mutex) {
     return new SynchronizedNavigableSet<E>(navigableSet, mutex);
   }
 
@@ -1544,7 +1541,7 @@ public E pollLast() {
 
   @GwtIncompatible // NavigableMap
   static <K, V> NavigableMap<K, V> navigableMap(
-      NavigableMap<K, V> navigableMap, @NullableDecl Object mutex) {
+      NavigableMap<K, V> navigableMap, @Nullable Object mutex) {
     return new SynchronizedNavigableMap<>(navigableMap, mutex);
   }
 
@@ -1553,7 +1550,7 @@ public E pollLast() {
   static class SynchronizedNavigableMap<K, V> extends SynchronizedSortedMap<K, V>
       implements NavigableMap<K, V> {
 
-    SynchronizedNavigableMap(NavigableMap<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedNavigableMap(NavigableMap<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1729,7 +1726,7 @@ public K lowerKey(K key) {
 
   @GwtIncompatible // works but is needed only for NavigableMap
   private static <K, V> Entry<K, V> nullableSynchronizedEntry(
-      @NullableDecl Entry<K, V> entry, @NullableDecl Object mutex) {
+      @Nullable Entry<K, V> entry, @Nullable Object mutex) {
     if (entry == null) {
       return null;
     }
@@ -1739,7 +1736,7 @@ public K lowerKey(K key) {
   @GwtIncompatible // works but is needed only for NavigableMap
   private static class SynchronizedEntry<K, V> extends SynchronizedObject implements Entry<K, V> {
 
-    SynchronizedEntry(Entry<K, V> delegate, @NullableDecl Object mutex) {
+    SynchronizedEntry(Entry<K, V> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1787,13 +1784,13 @@ public V setValue(V value) {
     private static final long serialVersionUID = 0;
   }
 
-  static <E> Queue<E> queue(Queue<E> queue, @NullableDecl Object mutex) {
+  static <E> Queue<E> queue(Queue<E> queue, @Nullable Object mutex) {
     return (queue instanceof SynchronizedQueue) ? queue : new SynchronizedQueue<E>(queue, mutex);
   }
 
   private static class SynchronizedQueue<E> extends SynchronizedCollection<E> implements Queue<E> {
 
-    SynchronizedQueue(Queue<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedQueue(Queue<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1840,13 +1837,13 @@ public E remove() {
     private static final long serialVersionUID = 0;
   }
 
-  static <E> Deque<E> deque(Deque<E> deque, @NullableDecl Object mutex) {
+  static <E> Deque<E> deque(Deque<E> deque, @Nullable Object mutex) {
     return new SynchronizedDeque<E>(deque, mutex);
   }
 
   private static final class SynchronizedDeque<E> extends SynchronizedQueue<E> implements Deque<E> {
 
-    SynchronizedDeque(Deque<E> delegate, @NullableDecl Object mutex) {
+    SynchronizedDeque(Deque<E> delegate, @Nullable Object mutex) {
       super(delegate, mutex);
     }
 
@@ -1995,35 +1992,35 @@ public E pop() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
       synchronized (mutex) {
         return delegate().contains(rowKey, columnKey);
       }
     }
 
     @Override
-    public boolean containsRow(@NullableDecl Object rowKey) {
+    public boolean containsRow(@Nullable Object rowKey) {
       synchronized (mutex) {
         return delegate().containsRow(rowKey);
       }
     }
 
     @Override
-    public boolean containsColumn(@NullableDecl Object columnKey) {
+    public boolean containsColumn(@Nullable Object columnKey) {
       synchronized (mutex) {
         return delegate().containsColumn(columnKey);
       }
     }
 
     @Override
-    public boolean containsValue(@NullableDecl Object value) {
+    public boolean containsValue(@Nullable Object value) {
       synchronized (mutex) {
         return delegate().containsValue(value);
       }
     }
 
     @Override
-    public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
       synchronized (mutex) {
         return delegate().get(rowKey, columnKey);
       }
@@ -2051,7 +2048,7 @@ public void clear() {
     }
 
     @Override
-    public V put(@NullableDecl R rowKey, @NullableDecl C columnKey, @NullableDecl V value) {
+    public V put(@Nullable R rowKey, @Nullable C columnKey, @Nullable V value) {
       synchronized (mutex) {
         return delegate().put(rowKey, columnKey, value);
       }
@@ -2065,21 +2062,21 @@ public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     }
 
     @Override
-    public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
       synchronized (mutex) {
         return delegate().remove(rowKey, columnKey);
       }
     }
 
     @Override
-    public Map<C, V> row(@NullableDecl R rowKey) {
+    public Map<C, V> row(@Nullable R rowKey) {
       synchronized (mutex) {
         return map(delegate().row(rowKey), mutex);
       }
     }
 
     @Override
-    public Map<R, V> column(@NullableDecl C columnKey) {
+    public Map<R, V> column(@Nullable C columnKey) {
       synchronized (mutex) {
         return map(delegate().column(columnKey), mutex);
       }
@@ -2153,7 +2150,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (this == obj) {
         return true;
       }, @@ -23,7 +23,7 @@
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection that associates an ordered pair of keys, called a row key and a column key, with a
@@ -65,29 +65,29 @@
    * @param columnKey key of column to search for
    */
   boolean contains(
-      @NullableDecl @CompatibleWith(""R"") Object rowKey,
-      @NullableDecl @CompatibleWith(""C"") Object columnKey);
+      @Nullable @CompatibleWith(""R"") Object rowKey,
+      @Nullable @CompatibleWith(""C"") Object columnKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified row key.
    *
    * @param rowKey key of row to search for
    */
-  boolean containsRow(@NullableDecl @CompatibleWith(""R"") Object rowKey);
+  boolean containsRow(@Nullable @CompatibleWith(""R"") Object rowKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified column.
    *
    * @param columnKey key of column to search for
    */
-  boolean containsColumn(@NullableDecl @CompatibleWith(""C"") Object columnKey);
+  boolean containsColumn(@Nullable @CompatibleWith(""C"") Object columnKey);
 
   /**
    * Returns {@code true} if the table contains a mapping with the specified value.
    *
    * @param value value to search for
    */
-  boolean containsValue(@NullableDecl @CompatibleWith(""V"") Object value);
+  boolean containsValue(@Nullable @CompatibleWith(""V"") Object value);
 
   /**
    * Returns the value corresponding to the given row and column keys, or {@code null} if no such
@@ -97,8 +97,8 @@ boolean contains(
    * @param columnKey key of column to search for
    */
   V get(
-      @NullableDecl @CompatibleWith(""R"") Object rowKey,
-      @NullableDecl @CompatibleWith(""C"") Object columnKey);
+      @Nullable @CompatibleWith(""R"") Object rowKey,
+      @Nullable @CompatibleWith(""C"") Object columnKey);
 
   /** Returns {@code true} if the table contains no mappings. */
   boolean isEmpty();
@@ -111,7 +111,7 @@ V get(
    * cell views, as returned by {@link #cellSet}, are equal.
    */
   @Override
-  boolean equals(@NullableDecl Object obj);
+  boolean equals(@Nullable Object obj);
 
   /**
    * Returns the hash code for this table. The hash code of a table is defined as the hash code of
@@ -136,7 +136,7 @@ V get(
    *     for the keys
    */
   @CanIgnoreReturnValue
-  @NullableDecl
+  @Nullable
   V put(R rowKey, C columnKey, V value);
 
   /**
@@ -155,10 +155,10 @@ V get(
    * @return the value previously associated with the keys, or {@code null} if no such value existed
    */
   @CanIgnoreReturnValue
-  @NullableDecl
+  @Nullable
   V remove(
-      @NullableDecl @CompatibleWith(""R"") Object rowKey,
-      @NullableDecl @CompatibleWith(""C"") Object columnKey);
+      @Nullable @CompatibleWith(""R"") Object rowKey,
+      @Nullable @CompatibleWith(""C"") Object columnKey);
 
   // Views
 
@@ -252,23 +252,23 @@ V remove(
    */
   interface Cell<R, C, V> {
     /** Returns the row key of this cell. */
-    @NullableDecl
+    @Nullable
     R getRowKey();
 
     /** Returns the column key of this cell. */
-    @NullableDecl
+    @Nullable
     C getColumnKey();
 
     /** Returns the value of this cell. */
-    @NullableDecl
+    @Nullable
     V getValue();
 
     /**
      * Compares the specified object with this cell for equality. Two cells are equal when they have
      * equal row keys, column keys, and values.
      */
     @Override
-    boolean equals(@NullableDecl Object obj);
+    boolean equals(@Nullable Object obj);
 
     /**
      * Returns the hash code of this cell., @@ -36,7 +36,7 @@
 import java.util.Spliterator;
 import java.util.function.BinaryOperator;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides static methods that involve a {@code Table}.
@@ -146,16 +146,16 @@ private Tables() {}
    * @param value the value to be associated with the returned cell
    */
   public static <R, C, V> Cell<R, C, V> immutableCell(
-      @NullableDecl R rowKey, @NullableDecl C columnKey, @NullableDecl V value) {
+      @Nullable R rowKey, @Nullable C columnKey, @Nullable V value) {
     return new ImmutableCell<>(rowKey, columnKey, value);
   }
 
   static final class ImmutableCell<R, C, V> extends AbstractCell<R, C, V> implements Serializable {
-    @NullableDecl private final R rowKey;
-    @NullableDecl private final C columnKey;
-    @NullableDecl private final V value;
+    @Nullable private final R rowKey;
+    @Nullable private final C columnKey;
+    @Nullable private final V value;
 
-    ImmutableCell(@NullableDecl R rowKey, @NullableDecl C columnKey, @NullableDecl V value) {
+    ImmutableCell(@Nullable R rowKey, @Nullable C columnKey, @Nullable V value) {
       this.rowKey = rowKey;
       this.columnKey = columnKey;
       this.value = value;
@@ -254,27 +254,27 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public boolean contains(@Nullable Object rowKey, @Nullable Object columnKey) {
       return original.contains(columnKey, rowKey);
     }
 
     @Override
-    public boolean containsColumn(@NullableDecl Object columnKey) {
+    public boolean containsColumn(@Nullable Object columnKey) {
       return original.containsRow(columnKey);
     }
 
     @Override
-    public boolean containsRow(@NullableDecl Object rowKey) {
+    public boolean containsRow(@Nullable Object rowKey) {
       return original.containsColumn(rowKey);
     }
 
     @Override
-    public boolean containsValue(@NullableDecl Object value) {
+    public boolean containsValue(@Nullable Object value) {
       return original.containsValue(value);
     }
 
     @Override
-    public V get(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public V get(@Nullable Object rowKey, @Nullable Object columnKey) {
       return original.get(columnKey, rowKey);
     }
 
@@ -289,7 +289,7 @@ public void putAll(Table<? extends C, ? extends R, ? extends V> table) {
     }
 
     @Override
-    public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
       return original.remove(columnKey, rowKey);
     }
 
@@ -574,7 +574,7 @@ public void clear() {
     }
 
     @Override
-    public Map<R, V> column(@NullableDecl C columnKey) {
+    public Map<R, V> column(@Nullable C columnKey) {
       return Collections.unmodifiableMap(super.column(columnKey));
     }
 
@@ -590,7 +590,7 @@ public void clear() {
     }
 
     @Override
-    public V put(@NullableDecl R rowKey, @NullableDecl C columnKey, @NullableDecl V value) {
+    public V put(@Nullable R rowKey, @Nullable C columnKey, @Nullable V value) {
       throw new UnsupportedOperationException();
     }
 
@@ -600,12 +600,12 @@ public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     }
 
     @Override
-    public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {
+    public V remove(@Nullable Object rowKey, @Nullable Object columnKey) {
       throw new UnsupportedOperationException();
     }
 
     @Override
-    public Map<C, V> row(@NullableDecl R rowKey) {
+    public Map<C, V> row(@Nullable R rowKey) {
       return Collections.unmodifiableMap(super.row(rowKey));
     }
 
@@ -723,7 +723,7 @@ public UnmodifiableRowSortedMap(RowSortedTable<R, ? extends C, ? extends V> dele
     return Synchronized.table(table, null);
   }
 
-  static boolean equalsImpl(Table<?, ?, ?> table, @NullableDecl Object obj) {
+  static boolean equalsImpl(Table<?, ?, ?> table, @Nullable Object obj) {
     if (obj == table) {
       return true;
     } else if (obj instanceof Table) {, @@ -28,7 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An accumulator that selects the ""top"" {@code k} elements added to it, relative to a provided
@@ -110,7 +110,7 @@
    * The largest of the lowest k elements we've seen so far relative to this comparator. If
    * bufferSize ≥ k, then we can ignore any elements greater than this value.
    */
-  @NullableDecl private T threshold;
+  @Nullable private T threshold;
 
   private TopKSelector(Comparator<? super T> comparator, int k) {
     this.comparator = checkNotNull(comparator, ""comparator"");
@@ -125,7 +125,7 @@ private TopKSelector(Comparator<? super T> comparator, int k) {
    * Adds {@code elem} as a candidate for the top {@code k} elements. This operation takes amortized
    * O(1) time.
    */
-  public void offer(@NullableDecl T elem) {
+  public void offer(@Nullable T elem) {
     if (k == 0) {
       return;
     } else if (bufferSize == 0) {, @@ -31,7 +31,7 @@
 import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.TreeMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Table} whose row keys and column keys are ordered by their natural
@@ -169,14 +169,14 @@
   }
 
   private class TreeRow extends Row implements SortedMap<C, V> {
-    @NullableDecl final C lowerBound;
-    @NullableDecl final C upperBound;
+    @Nullable final C lowerBound;
+    @Nullable final C upperBound;
 
     TreeRow(R rowKey) {
       this(rowKey, null, null);
     }
 
-    TreeRow(R rowKey, @NullableDecl C lowerBound, @NullableDecl C upperBound) {
+    TreeRow(R rowKey, @Nullable C lowerBound, @Nullable C upperBound) {
       super(rowKey);
       this.lowerBound = lowerBound;
       this.upperBound = upperBound;
@@ -201,7 +201,7 @@ int compare(Object a, Object b) {
       return cmp.compare(a, b);
     }
 
-    boolean rangeContains(@NullableDecl Object o) {
+    boolean rangeContains(@Nullable Object o) {
       return o != null
           && (lowerBound == null || compare(lowerBound, o) <= 0)
           && (upperBound == null || compare(upperBound, o) > 0);
@@ -243,7 +243,7 @@ public C lastKey() {
       return backingRowMap().lastKey();
     }
 
-    @NullableDecl transient SortedMap<C, V> wholeRow;
+    @Nullable transient SortedMap<C, V> wholeRow;
 
     /*
      * If the row was previously empty, we check if there's a new row here every
@@ -327,7 +327,7 @@ public V put(C key, V value) {
             comparator);
 
     return new AbstractIterator<C>() {
-      @NullableDecl C lastValue;
+      @Nullable C lastValue;
 
       @Override
       protected C computeNext() {, @@ -31,7 +31,7 @@
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Implementation of {@code Multimap} whose keys and values are ordered by their natural ordering or
@@ -138,7 +138,7 @@ private TreeMultimap(
   }
 
   @Override
-  Collection<V> createCollection(@NullableDecl K key) {
+  Collection<V> createCollection(@Nullable K key) {
     if (key == null) {
       keyComparator().compare(key, key);
     }
@@ -163,7 +163,7 @@ private TreeMultimap(
   /** @since 14.0 (present with return type {@code SortedSet} since 2.0) */
   @Override
   @GwtIncompatible // NavigableSet
-  public NavigableSet<V> get(@NullableDecl K key) {
+  public NavigableSet<V> get(@Nullable K key) {
     return (NavigableSet<V>) super.get(key);
   }
 , @@ -36,7 +36,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 import java.util.function.ObjIntConsumer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A multiset which maintains the ordering of its elements, according to either their natural order
@@ -87,7 +87,7 @@
    *     indicates that the elements' <i>natural ordering</i> should be used.
    */
   @SuppressWarnings(""unchecked"")
-  public static <E> TreeMultiset<E> create(@NullableDecl Comparator<? super E> comparator) {
+  public static <E> TreeMultiset<E> create(@Nullable Comparator<? super E> comparator) {
     return (comparator == null)
         ? new TreeMultiset<E>((Comparator) Ordering.natural())
         : new TreeMultiset<E>(comparator);
@@ -136,7 +136,7 @@ int nodeAggregate(AvlNode<?> node) {
       }
 
       @Override
-      long treeAggregate(@NullableDecl AvlNode<?> root) {
+      long treeAggregate(@Nullable AvlNode<?> root) {
         return (root == null) ? 0 : root.totalCount;
       }
     },
@@ -147,14 +147,14 @@ int nodeAggregate(AvlNode<?> node) {
       }
 
       @Override
-      long treeAggregate(@NullableDecl AvlNode<?> root) {
+      long treeAggregate(@Nullable AvlNode<?> root) {
         return (root == null) ? 0 : root.distinctElements;
       }
     };
 
     abstract int nodeAggregate(AvlNode<?> node);
 
-    abstract long treeAggregate(@NullableDecl AvlNode<?> root);
+    abstract long treeAggregate(@Nullable AvlNode<?> root);
   }
 
   private long aggregateForEntries(Aggregate aggr) {
@@ -169,7 +169,7 @@ private long aggregateForEntries(Aggregate aggr) {
     return total;
   }
 
-  private long aggregateBelowRange(Aggregate aggr, @NullableDecl AvlNode<E> node) {
+  private long aggregateBelowRange(Aggregate aggr, @Nullable AvlNode<E> node) {
     if (node == null) {
       return 0;
     }
@@ -192,7 +192,7 @@ private long aggregateBelowRange(Aggregate aggr, @NullableDecl AvlNode<E> node)
     }
   }
 
-  private long aggregateAboveRange(Aggregate aggr, @NullableDecl AvlNode<E> node) {
+  private long aggregateAboveRange(Aggregate aggr, @Nullable AvlNode<E> node) {
     if (node == null) {
       return 0;
     }
@@ -225,12 +225,12 @@ int distinctElements() {
     return Ints.saturatedCast(aggregateForEntries(Aggregate.DISTINCT));
   }
 
-  static int distinctElements(@NullableDecl AvlNode<?> node) {
+  static int distinctElements(@Nullable AvlNode<?> node) {
     return (node == null) ? 0 : node.distinctElements;
   }
 
   @Override
-  public int count(@NullableDecl Object element) {
+  public int count(@Nullable Object element) {
     try {
       @SuppressWarnings(""unchecked"")
       E e = (E) element;
@@ -246,7 +246,7 @@ public int count(@NullableDecl Object element) {
 
   @CanIgnoreReturnValue
   @Override
-  public int add(@NullableDecl E element, int occurrences) {
+  public int add(@Nullable E element, int occurrences) {
     checkNonnegative(occurrences, ""occurrences"");
     if (occurrences == 0) {
       return count(element);
@@ -268,7 +268,7 @@ public int add(@NullableDecl E element, int occurrences) {
 
   @CanIgnoreReturnValue
   @Override
-  public int remove(@NullableDecl Object element, int occurrences) {
+  public int remove(@Nullable Object element, int occurrences) {
     checkNonnegative(occurrences, ""occurrences"");
     if (occurrences == 0) {
       return count(element);
@@ -292,7 +292,7 @@ public int remove(@NullableDecl Object element, int occurrences) {
 
   @CanIgnoreReturnValue
   @Override
-  public int setCount(@NullableDecl E element, int count) {
+  public int setCount(@Nullable E element, int count) {
     checkNonnegative(count, ""count"");
     if (!range.contains(element)) {
       checkArgument(count == 0);
@@ -314,7 +314,7 @@ public int setCount(@NullableDecl E element, int count) {
 
   @CanIgnoreReturnValue
   @Override
-  public boolean setCount(@NullableDecl E element, int oldCount, int newCount) {
+  public boolean setCount(@Nullable E element, int oldCount, int newCount) {
     checkNonnegative(newCount, ""newCount"");
     checkNonnegative(oldCount, ""oldCount"");
     checkArgument(range.contains(element));
@@ -380,7 +380,7 @@ public int getCount() {
   }
 
   /** Returns the first node in the tree that is in range. */
-  @NullableDecl
+  @Nullable
   private AvlNode<E> firstNode() {
     AvlNode<E> root = rootReference.get();
     if (root == null) {
@@ -403,7 +403,7 @@ public int getCount() {
     return (node == header || !range.contains(node.getElement())) ? null : node;
   }
 
-  @NullableDecl
+  @Nullable
   private AvlNode<E> lastNode() {
     AvlNode<E> root = rootReference.get();
     if (root == null) {
@@ -435,7 +435,7 @@ public int getCount() {
   Iterator<Entry<E>> entryIterator() {
     return new Iterator<Entry<E>>() {
       AvlNode<E> current = firstNode();
-      @NullableDecl Entry<E> prevEntry;
+      @Nullable Entry<E> prevEntry;
 
       @Override
       public boolean hasNext() {
@@ -531,30 +531,30 @@ public void forEachEntry(ObjIntConsumer<? super E> action) {
   }
 
   @Override
-  public SortedMultiset<E> headMultiset(@NullableDecl E upperBound, BoundType boundType) {
+  public SortedMultiset<E> headMultiset(@Nullable E upperBound, BoundType boundType) {
     return new TreeMultiset<E>(
         rootReference,
         range.intersect(GeneralRange.upTo(comparator(), upperBound, boundType)),
         header);
   }
 
   @Override
-  public SortedMultiset<E> tailMultiset(@NullableDecl E lowerBound, BoundType boundType) {
+  public SortedMultiset<E> tailMultiset(@Nullable E lowerBound, BoundType boundType) {
     return new TreeMultiset<E>(
         rootReference,
         range.intersect(GeneralRange.downTo(comparator(), lowerBound, boundType)),
         header);
   }
 
   private static final class Reference<T> {
-    @NullableDecl private T value;
+    @Nullable private T value;
 
-    @NullableDecl
+    @Nullable
     public T get() {
       return value;
     }
 
-    public void checkAndSet(@NullableDecl T expected, T newValue) {
+    public void checkAndSet(@Nullable T expected, T newValue) {
       if (value != expected) {
         throw new ConcurrentModificationException();
       }
@@ -567,20 +567,20 @@ void clear() {
   }
 
   private static final class AvlNode<E> {
-    @NullableDecl private final E elem;
+    @Nullable private final E elem;
 
     // elemCount is 0 iff this node has been deleted.
     private int elemCount;
 
     private int distinctElements;
     private long totalCount;
     private int height;
-    @NullableDecl private AvlNode<E> left;
-    @NullableDecl private AvlNode<E> right;
-    @NullableDecl private AvlNode<E> pred;
-    @NullableDecl private AvlNode<E> succ;
+    @Nullable private AvlNode<E> left;
+    @Nullable private AvlNode<E> right;
+    @Nullable private AvlNode<E> pred;
+    @Nullable private AvlNode<E> succ;
 
-    AvlNode(@NullableDecl E elem, int elemCount) {
+    AvlNode(@Nullable E elem, int elemCount) {
       checkArgument(elemCount > 0);
       this.elem = elem;
       this.elemCount = elemCount;
@@ -620,7 +620,7 @@ public int count(Comparator<? super E> comparator, E e) {
       return this;
     }
 
-    AvlNode<E> add(Comparator<? super E> comparator, @NullableDecl E e, int count, int[] result) {
+    AvlNode<E> add(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {
       /*
        * It speeds things up considerably to unconditionally add count to totalCount here,
        * but that destroys failure atomicity in the case of count overflow. =(
@@ -665,8 +665,7 @@ public int count(Comparator<? super E> comparator, E e) {
       return this;
     }
 
-    AvlNode<E> remove(
-        Comparator<? super E> comparator, @NullableDecl E e, int count, int[] result) {
+    AvlNode<E> remove(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {
       int cmp = comparator.compare(e, elem);
       if (cmp < 0) {
         AvlNode<E> initLeft = left;
@@ -717,8 +716,7 @@ public int count(Comparator<? super E> comparator, E e) {
       }
     }
 
-    AvlNode<E> setCount(
-        Comparator<? super E> comparator, @NullableDecl E e, int count, int[] result) {
+    AvlNode<E> setCount(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {
       int cmp = comparator.compare(e, elem);
       if (cmp < 0) {
         AvlNode<E> initLeft = left;
@@ -768,7 +766,7 @@ public int count(Comparator<? super E> comparator, E e) {
 
     AvlNode<E> setCount(
         Comparator<? super E> comparator,
-        @NullableDecl E e,
+        @Nullable E e,
         int expectedCount,
         int newCount,
         int[] result) {
@@ -940,15 +938,15 @@ private int balanceFactor() {
       return newTop;
     }
 
-    private static long totalCount(@NullableDecl AvlNode<?> node) {
+    private static long totalCount(@Nullable AvlNode<?> node) {
       return (node == null) ? 0 : node.totalCount;
     }
 
-    private static int height(@NullableDecl AvlNode<?> node) {
+    private static int height(@Nullable AvlNode<?> node) {
       return (node == null) ? 0 : node.height;
     }
 
-    @NullableDecl
+    @Nullable
     private AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {
       int cmp = comparator.compare(e, elem);
       if (cmp < 0) {
@@ -960,7 +958,7 @@ private static int height(@NullableDecl AvlNode<?> node) {
       }
     }
 
-    @NullableDecl
+    @Nullable
     private AvlNode<E> floor(Comparator<? super E> comparator, E e) {
       int cmp = comparator.compare(e, elem);
       if (cmp > 0) {, @@ -37,7 +37,7 @@
 import java.util.NavigableMap;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@code RangeMap} based on a {@code TreeMap}, supporting all optional
@@ -100,14 +100,14 @@ public boolean contains(K value) {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public V get(K key) {
     Entry<Range<K>, V> entry = getEntry(key);
     return (entry == null) ? null : entry.getValue();
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Entry<Range<K>, V> getEntry(K key) {
     Entry<Cut<K>, RangeMapEntry<K, V>> mapEntry =
         entriesByLowerBound.floorEntry(Cut.belowValue(key));
@@ -155,7 +155,7 @@ public void putCoalescing(Range<K> range, V value) {
 
   /** Returns the range that spans the given range and entry, if the entry can be coalesced. */
   private static <K extends Comparable, V> Range<K> coalesce(
-      Range<K> range, V value, @NullableDecl Entry<Cut<K>, RangeMapEntry<K, V>> entry) {
+      Range<K> range, V value, @Nullable Entry<Cut<K>, RangeMapEntry<K, V>> entry) {
     if (entry != null
         && entry.getValue().getKey().isConnected(range)
         && entry.getValue().getValue().equals(value)) {
@@ -261,12 +261,12 @@ public void remove(Range<K> rangeToRemove) {
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return get(key) != null;
     }
 
     @Override
-    public V get(@NullableDecl Object key) {
+    public V get(@Nullable Object key) {
       if (key instanceof Range) {
         Range<?> range = (Range<?>) key;
         RangeMapEntry<K, V> rangeMapEntry = entriesByLowerBound.get(range.lowerBound);
@@ -305,13 +305,13 @@ public int size() {
   private static final RangeMap EMPTY_SUB_RANGE_MAP =
       new RangeMap() {
         @Override
-        @NullableDecl
+        @Nullable
         public Object get(Comparable key) {
           return null;
         }
 
         @Override
-        @NullableDecl
+        @Nullable
         public Entry<Range, Object> getEntry(Comparable key) {
           return null;
         }
@@ -377,13 +377,13 @@ public RangeMap subRangeMap(Range range) {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public V get(K key) {
       return subRange.contains(key) ? TreeRangeMap.this.get(key) : null;
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public Entry<Range<K>, V> getEntry(K key) {
       if (subRange.contains(key)) {
         Entry<Range<K>, V> entry = TreeRangeMap.this.getEntry(key);
@@ -515,7 +515,7 @@ public void remove(Range<K> range) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof RangeMap) {
         RangeMap<?, ?> rangeMap = (RangeMap<?, ?>) o;
         return asMapOfRanges().equals(rangeMap.asMapOfRanges());
@@ -607,7 +607,7 @@ private boolean removeEntryIf(Predicate<? super Entry<Range<K>, V>> predicate) {
       public Set<Range<K>> keySet() {
         return new Maps.KeySet<Range<K>, V>(SubRangeMapAsMap.this) {
           @Override
-          public boolean remove(@NullableDecl Object o) {
+          public boolean remove(@Nullable Object o) {
             return SubRangeMapAsMap.this.remove(o) != null;
           }
 
@@ -693,7 +693,7 @@ public boolean retainAll(Collection<?> c) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o instanceof RangeMap) {
       RangeMap<?, ?> rangeMap = (RangeMap<?, ?>) o;
       return asMapOfRanges().equals(rangeMap.asMapOfRanges());, @@ -31,7 +31,7 @@
 import java.util.Set;
 import java.util.TreeMap;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link RangeSet} backed by a {@link TreeMap}.
@@ -113,13 +113,13 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       return Sets.equalsImpl(this, o);
     }
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public Range<C> rangeContaining(C value) {
     checkNotNull(value);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
@@ -153,7 +153,7 @@ public boolean encloses(Range<C> range) {
     return floorEntry != null && floorEntry.getValue().encloses(range);
   }
 
-  @NullableDecl
+  @Nullable
   private Range<C> rangeEnclosing(Range<C> range) {
     checkNotNull(range);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
@@ -333,12 +333,12 @@ private RangesByUpperBound(
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return get(key) != null;
     }
 
     @Override
-    public Range<C> get(@NullableDecl Object key) {
+    public Range<C> get(@Nullable Object key) {
       if (key instanceof Cut) {
         try {
           @SuppressWarnings(""unchecked"") // we catch CCEs
@@ -625,7 +625,7 @@ public int size() {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public Range<C> get(Object key) {
       if (key instanceof Cut) {
         try {
@@ -738,13 +738,13 @@ private SubRangeSetRangesByLowerBound(
     }
 
     @Override
-    public boolean containsKey(@NullableDecl Object key) {
+    public boolean containsKey(@Nullable Object key) {
       return get(key) != null;
     }
 
     @Override
-    @NullableDecl
-    public Range<C> get(@NullableDecl Object key) {
+    @Nullable
+    public Range<C> get(@Nullable Object key) {
       if (key instanceof Cut) {
         try {
           @SuppressWarnings(""unchecked"") // we catch CCE's
@@ -881,7 +881,7 @@ public boolean encloses(Range<C> range) {
     }
 
     @Override
-    @NullableDecl
+    @Nullable
     public Range<C> rangeContaining(C value) {
       if (!restriction.contains(value)) {
         return null;, @@ -29,7 +29,7 @@
 import com.google.common.primitives.Ints;
 import java.util.AbstractSet;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of {@link BaseGraph}.
@@ -84,7 +84,7 @@ public boolean remove(Object o) {
       // Graph<LinkedList>.
       @SuppressWarnings(""unchecked"")
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         if (!(obj instanceof EndpointPair)) {
           return false;
         }
@@ -186,7 +186,7 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         if (!(obj instanceof EndpointPair)) {
           return false;
         }
@@ -227,7 +227,7 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         if (!(obj instanceof EndpointPair)) {
           return false;
         }, @@ -30,7 +30,7 @@
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A base implementation of {@link NetworkConnections} for directed networks.
@@ -79,7 +79,7 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         return inEdgeMap.containsKey(obj) || outEdgeMap.containsKey(obj);
       }
     };, @@ -17,7 +17,7 @@
 package com.google.common.graph;
 
 import com.google.common.annotations.Beta;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of {@link Graph}. It is recommended to extend this
@@ -31,7 +31,7 @@
 public abstract class AbstractGraph<N> extends AbstractBaseGraph<N> implements Graph<N> {
 
   @Override
-  public final boolean equals(@NullableDecl Object obj) {
+  public final boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     }, @@ -32,7 +32,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of {@link Network}. It is recommended to extend
@@ -87,7 +87,7 @@ public int size() {
           // Network<LinkedList>.
           @SuppressWarnings(""unchecked"")
           @Override
-          public boolean contains(@NullableDecl Object obj) {
+          public boolean contains(@Nullable Object obj) {
             if (!(obj instanceof EndpointPair)) {
               return false;
             }
@@ -192,7 +192,7 @@ public boolean apply(E edge) {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public E edgeConnectingOrNull(N nodeU, N nodeV) {
     return edgeConnecting(nodeU, nodeV).orElse(null);
   }
@@ -203,7 +203,7 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
   }
 
   @Override
-  public final boolean equals(@NullableDecl Object obj) {
+  public final boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     }, @@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of {@link ValueGraph}. It is recommended to extend
@@ -106,7 +106,7 @@ public int outDegree(N node) {
   }
 
   @Override
-  public final boolean equals(@NullableDecl Object obj) {
+  public final boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     }, @@ -27,7 +27,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Configurable implementation of {@link Network} that supports the options supplied by {@link
@@ -192,11 +192,11 @@ protected final N checkedReferenceNode(E edge) {
     return referenceNode;
   }
 
-  protected final boolean containsNode(@NullableDecl N node) {
+  protected final boolean containsNode(@Nullable N node) {
     return nodeConnections.containsKey(node);
   }
 
-  protected final boolean containsEdge(@NullableDecl E edge) {
+  protected final boolean containsEdge(@Nullable E edge) {
     return edgeToReferenceNode.containsKey(edge);
   }
 }, @@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Configurable implementation of {@link ValueGraph} that supports the options supplied by {@link
@@ -123,8 +123,8 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
   }
 
   @Override
-  @NullableDecl
-  public V edgeValueOrDefault(N nodeU, N nodeV, @NullableDecl V defaultValue) {
+  @Nullable
+  public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
     checkNotNull(nodeU);
     checkNotNull(nodeV);
     GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);
@@ -146,7 +146,7 @@ protected long edgeCount() {
     return connections;
   }
 
-  protected final boolean containsNode(@NullableDecl N node) {
+  protected final boolean containsNode(@Nullable N node) {
     return nodeConnections.containsKey(node);
   }
 }, @@ -33,7 +33,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link GraphConnections} for directed graphs.
@@ -126,7 +126,7 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         return isPredecessor(adjacentNodeValues.get(obj));
       }
     };
@@ -158,7 +158,7 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object obj) {
+      public boolean contains(@Nullable Object obj) {
         return isSuccessor(adjacentNodeValues.get(obj));
       }
     };
@@ -241,11 +241,11 @@ public V addSuccessor(N node, V value) {
     }
   }
 
-  private static boolean isPredecessor(@NullableDecl Object value) {
+  private static boolean isPredecessor(@Nullable Object value) {
     return (value == PRED) || (value instanceof PredAndSucc);
   }
 
-  private static boolean isSuccessor(@NullableDecl Object value) {
+  private static boolean isSuccessor(@Nullable Object value) {
     return (value != PRED) && (value != null);
   }
 }, @@ -30,7 +30,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link NetworkConnections} for directed networks with parallel edges.
@@ -139,8 +139,8 @@ public void addOutEdge(E edge, N node) {
     }
   }
 
-  @NullableDecl
-  private static <T> T getReference(@NullableDecl Reference<T> reference) {
+  @Nullable
+  private static <T> T getReference(@Nullable Reference<T> reference) {
     return (reference == null) ? null : reference.get();
   }
 }, @@ -23,7 +23,7 @@
 import com.google.common.collect.UnmodifiableIterator;
 import java.util.AbstractSet;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A class to represent the set of edges connecting an (implicit) origin node to a target node.
@@ -58,12 +58,12 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object edge) {
+  public boolean contains(@Nullable Object edge) {
     E connectingEdge = getConnectingEdge();
     return (connectingEdge != null && connectingEdge.equals(edge));
   }
 
-  @NullableDecl
+  @Nullable
   private E getConnectingEdge() {
     return nodeToOutEdge.get(targetNode);
   }, @@ -28,7 +28,7 @@
 import com.google.errorprone.annotations.Immutable;
 import java.util.Comparator;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Used to represent the order of elements in a data structure that supports different options for
@@ -50,7 +50,7 @@
   private final Type type;
 
   @SuppressWarnings(""Immutable"") // Hopefully the comparator provided is immutable!
-  @NullableDecl
+  @Nullable
   private final Comparator<T> comparator;
 
   /**
@@ -68,7 +68,7 @@
     SORTED
   }
 
-  private ElementOrder(Type type, @NullableDecl Comparator<T> comparator) {
+  private ElementOrder(Type type, @Nullable Comparator<T> comparator) {
     this.type = checkNotNull(type);
     this.comparator = comparator;
     checkState((type == Type.SORTED) == (comparator != null));
@@ -117,7 +117,7 @@ public Type type() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj == this) {
       return true;
     }, @@ -24,7 +24,7 @@
 import com.google.common.collect.Iterators;
 import com.google.common.collect.UnmodifiableIterator;
 import com.google.errorprone.annotations.Immutable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable pair representing the two endpoints of an edge in a graph. The {@link EndpointPair}
@@ -132,7 +132,7 @@ public final N adjacentNode(Object node) {
    * ordered {@link EndpointPair} is never equal to an unordered {@link EndpointPair}.
    */
   @Override
-  public abstract boolean equals(@NullableDecl Object obj);
+  public abstract boolean equals(@Nullable Object obj);
 
   /**
    * The hashcode of an ordered {@link EndpointPair} is equal to {@code Objects.hashCode(source(),
@@ -163,7 +163,7 @@ public boolean isOrdered() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj == this) {
         return true;
       }
@@ -211,7 +211,7 @@ public boolean isOrdered() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object obj) {
+    public boolean equals(@Nullable Object obj) {
       if (obj == this) {
         return true;
       }, @@ -18,7 +18,7 @@
 
 import java.util.Optional;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A class to allow {@link ValueGraph} implementations to be backed by a provided delegate. This is
@@ -101,8 +101,8 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
   }
 
   @Override
-  @NullableDecl
-  public V edgeValueOrDefault(N nodeU, N nodeV, @NullableDecl V defaultValue) {
+  @Nullable
+  public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
     return delegate().edgeValueOrDefault(nodeU, nodeV, defaultValue);
   }
 }, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.Beta;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An interface for <a
@@ -256,7 +256,7 @@
    * <p>A reference implementation of this is provided by {@link AbstractGraph#equals(Object)}.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   /**
    * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of, @@ -18,7 +18,7 @@
 
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An interface for representing and manipulating an origin node's adjacent nodes and edge values in
@@ -40,7 +40,7 @@
    * Returns the value associated with the edge connecting the origin node to {@code node}, or null
    * if there is no such edge.
    */
-  @NullableDecl
+  @Nullable
   V value(N node);
 
   /** Remove {@code node} from the set of predecessors. */, @@ -33,7 +33,7 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods for {@link Graph}, {@link ValueGraph}, and {@link Network} instances.
@@ -99,10 +99,7 @@ public static boolean hasCycle(Network<?, ?> network) {
    * cycle in the graph.
    */
   private static <N> boolean subgraphHasCycle(
-      Graph<N> graph,
-      Map<Object, NodeVisitState> visitedNodes,
-      N node,
-      @NullableDecl N previousNode) {
+      Graph<N> graph, Map<Object, NodeVisitState> visitedNodes, N node, @Nullable N previousNode) {
     NodeVisitState state = visitedNodes.get(node);
     if (state == NodeVisitState.COMPLETE) {
       return false;
@@ -129,7 +126,7 @@ public static boolean hasCycle(Network<?, ?> network) {
    * from B to A).
    */
   private static boolean canTraverseWithoutReusingEdge(
-      Graph<?> graph, Object nextNode, @NullableDecl Object previousNode) {
+      Graph<?> graph, Object nextNode, @Nullable Object previousNode) {
     if (graph.isDirected() || !Objects.equal(previousNode, nextNode)) {
       return true;
     }
@@ -347,8 +344,8 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
     }
 
     @Override
-    @NullableDecl
-    public V edgeValueOrDefault(N nodeU, N nodeV, @NullableDecl V defaultValue) {
+    @Nullable
+    public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
       return delegate().edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose
     }
   }, @@ -25,7 +25,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A map-like data structure that wraps a backing map and caches values while iterating through
@@ -47,20 +47,20 @@
   // Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
   // the entry was returned by the iterator, except through the setValue operation on the map entry""
   // As such, this field must be cleared before every map mutation.
-  @NullableDecl private transient Entry<K, V> entrySetCache;
+  @Nullable private transient Entry<K, V> entrySetCache;
 
   MapIteratorCache(Map<K, V> backingMap) {
     this.backingMap = checkNotNull(backingMap);
   }
 
   @CanIgnoreReturnValue
-  public V put(@NullableDecl K key, @NullableDecl V value) {
+  public V put(@Nullable K key, @Nullable V value) {
     clearCache();
     return backingMap.put(key, value);
   }
 
   @CanIgnoreReturnValue
-  public V remove(@NullableDecl Object key) {
+  public V remove(@Nullable Object key) {
     clearCache();
     return backingMap.remove(key);
   }
@@ -70,16 +70,16 @@ public void clear() {
     backingMap.clear();
   }
 
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     V value = getIfCached(key);
     return (value != null) ? value : getWithoutCaching(key);
   }
 
-  public final V getWithoutCaching(@NullableDecl Object key) {
+  public final V getWithoutCaching(@Nullable Object key) {
     return backingMap.get(key);
   }
 
-  public final boolean containsKey(@NullableDecl Object key) {
+  public final boolean containsKey(@Nullable Object key) {
     return getIfCached(key) != null || backingMap.containsKey(key);
   }
 
@@ -110,15 +110,15 @@ public int size() {
       }
 
       @Override
-      public boolean contains(@NullableDecl Object key) {
+      public boolean contains(@Nullable Object key) {
         return containsKey(key);
       }
     };
   }
 
   // Internal methods ('protected' is still package-visible, but treat as only subclass-visible)
 
-  protected V getIfCached(@NullableDecl Object key) {
+  protected V getIfCached(@Nullable Object key) {
     Entry<K, V> entry = entrySetCache; // store local reference for thread-safety
 
     // Check cache. We use == on purpose because it's cheaper and a cache miss is ok., @@ -17,7 +17,7 @@
 package com.google.common.graph;
 
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link MapIteratorCache} that adds additional caching. In addition to the caching provided by
@@ -26,16 +26,16 @@
  * @author James Sexton
  */
 class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
-  @NullableDecl private transient CacheEntry<K, V> cacheEntry1;
-  @NullableDecl private transient CacheEntry<K, V> cacheEntry2;
+  @Nullable private transient CacheEntry<K, V> cacheEntry1;
+  @Nullable private transient CacheEntry<K, V> cacheEntry2;
 
   MapRetrievalCache(Map<K, V> backingMap) {
     super(backingMap);
   }
 
   @SuppressWarnings(""unchecked"") // Safe because we only cast if key is found in map.
   @Override
-  public V get(@NullableDecl Object key) {
+  public V get(@Nullable Object key) {
     V value = getIfCached(key);
     if (value != null) {
       return value;
@@ -51,7 +51,7 @@ public V get(@NullableDecl Object key) {
   // Internal methods ('protected' is still package-visible, but treat as only subclass-visible)
 
   @Override
-  protected V getIfCached(@NullableDecl Object key) {
+  protected V getIfCached(@Nullable Object key) {
     V value = super.getIfCached(key);
     if (value != null) {
       return value;, @@ -24,7 +24,7 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A class to represent the set of edges connecting an (implicit) origin node to a target node.
@@ -63,7 +63,7 @@ protected E computeNext() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object edge) {
+  public boolean contains(@Nullable Object edge) {
     return targetNode.equals(outEdgeToNode.get(edge));
   }
 }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.Beta;
 import java.util.Optional;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An interface for <a
@@ -311,7 +311,7 @@
    *     network
    * @since 23.0
    */
-  @NullableDecl
+  @Nullable
   E edgeConnectingOrNull(N nodeU, N nodeV);
 
   /**
@@ -350,7 +350,7 @@
    * <p>A reference implementation of this is provided by {@link AbstractNetwork#equals(Object)}.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   /**
    * Returns the hash code for this network. The hash code of a network is defined as the hash code, @@ -30,7 +30,7 @@
 import java.util.Iterator;
 import java.util.Queue;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An object that can traverse the nodes that are reachable from a specified (set of) start node(s)
@@ -471,10 +471,10 @@ NodeAndSuccessors withSuccessors(N node) {
 
       /** A simple tuple of a node and a partially iterated {@link Iterator} of its successors. */
       private final class NodeAndSuccessors {
-        @NullableDecl final N node;
+        @Nullable final N node;
         final Iterator<? extends N> successorIterator;
 
-        NodeAndSuccessors(@NullableDecl N node, Iterable<? extends N> successors) {
+        NodeAndSuccessors(@Nullable N node, Iterable<? extends N> successors) {
           this.node = node;
           this.successorIterator = successors.iterator();
         }
@@ -644,10 +644,10 @@ NodeAndChildren withChildren(N node) {
 
       /** A simple tuple of a node and a partially iterated {@link Iterator} of its children. */
       private final class NodeAndChildren {
-        @NullableDecl final N node;
+        @Nullable final N node;
         final Iterator<? extends N> childIterator;
 
-        NodeAndChildren(@NullableDecl N node, Iterable<? extends N> children) {
+        NodeAndChildren(@Nullable N node, Iterable<? extends N> children) {
           this.node = node;
           this.childIterator = children.iterator();
         }, @@ -30,7 +30,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An implementation of {@link NetworkConnections} for undirected networks with parallel edges.
@@ -115,8 +115,8 @@ public void addOutEdge(E edge, N node) {
     }
   }
 
-  @NullableDecl
-  private static <T> T getReference(@NullableDecl Reference<T> reference) {
+  @Nullable
+  private static <T> T getReference(@Nullable Reference<T> reference) {
     return (reference == null) ? null : reference.get();
   }
 }, @@ -19,7 +19,7 @@
 import com.google.common.annotations.Beta;
 import java.util.Optional;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An interface for <a
@@ -267,8 +267,8 @@
    * @throws IllegalArgumentException if {@code nodeU} or {@code nodeV} is not an element of this
    *     graph
    */
-  @NullableDecl
-  V edgeValueOrDefault(N nodeU, N nodeV, @NullableDecl V defaultValue);
+  @Nullable
+  V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue);
 
   //
   // ValueGraph identity
@@ -295,7 +295,7 @@
    * <p>A reference implementation of this is provided by {@link AbstractValueGraph#equals(Object)}.
    */
   @Override
-  boolean equals(@NullableDecl Object object);
+  boolean equals(@Nullable Object object);
 
   /**
    * Returns the hash code for this graph. The hash code of a graph is defined as the hash code of a, @@ -34,7 +34,7 @@
 import java.io.Serializable;
 import java.math.RoundingMode;
 import java.util.stream.Collector;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test
@@ -269,7 +269,7 @@ public void putAll(BloomFilter<T> that) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -22,7 +22,7 @@
 import java.math.RoundingMode;
 import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLongArray;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Collections of strategies of generating the k * log(M) bits required for an element to be mapped
@@ -266,7 +266,7 @@ void putAll(LockFreeBitArray other) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof LockFreeBitArray) {
         LockFreeBitArray lockFreeBitArray = (LockFreeBitArray) o;
         // TODO(lowasser): avoid allocation here, @@ -19,7 +19,7 @@
 import java.io.OutputStream;
 import java.io.Serializable;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Funnels for common types. All implementations are serializable.
@@ -100,7 +100,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof StringCharsetFunnel) {
         StringCharsetFunnel funnel = (StringCharsetFunnel) o;
         return this.charset.equals(funnel.charset);
@@ -183,7 +183,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o instanceof SequentialFunnel) {
         SequentialFunnel<?> funnel = (SequentialFunnel<?>) o;
         return elementFunnel.equals(funnel.elementFunnel);, @@ -24,7 +24,7 @@
 import com.google.common.primitives.UnsignedInts;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable hash code of arbitrary bit length.
@@ -369,7 +369,7 @@ private static int decode(char ch) {
    * to protect against <a href=""http://en.wikipedia.org/wiki/Timing_attack"">timing attacks</a>.
    */
   @Override
-  public final boolean equals(@NullableDecl Object object) {
+  public final boolean equals(@Nullable Object object) {
     if (object instanceof HashCode) {
       HashCode that = (HashCode) object;
       return bits() == that.bits() && equalsSameBits(that);, @@ -28,7 +28,7 @@
 import java.util.zip.CRC32;
 import java.util.zip.Checksum;
 import javax.crypto.spec.SecretKeySpec;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static methods to obtain {@link HashFunction} instances, and other static hashing-related
@@ -642,7 +642,7 @@ public int bits() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof ConcatenatedHashFunction) {
         ConcatenatedHashFunction other = (ConcatenatedHashFunction) object;
         return Arrays.equals(functions, other.functions);, @@ -31,7 +31,7 @@
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * See MurmurHash3_x64_128 in <a href=""http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp"">the
@@ -70,7 +70,7 @@ public String toString() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Murmur3_128HashFunction) {
       Murmur3_128HashFunction other = (Murmur3_128HashFunction) object;
       return seed == other.seed;, @@ -39,7 +39,7 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.charset.Charset;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * See MurmurHash3_x86_32 in <a
@@ -84,7 +84,7 @@ public String toString() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof Murmur3_32HashFunction) {
       Murmur3_32HashFunction other = (Murmur3_32HashFunction) object;
       return seed == other.seed;, @@ -24,7 +24,7 @@
 import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.nio.ByteBuffer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * {@link HashFunction} implementation of SipHash-c-d.
@@ -81,7 +81,7 @@ public String toString() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object instanceof SipHashFunction) {
       SipHashFunction other = (SipHashFunction) object;
       return (c == other.c) && (d == other.d) && (k0 == other.k0) && (k1 == other.k1);, @@ -13,7 +13,7 @@
 
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Random;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A package-local class holding common representation and mechanics for classes supporting dynamic
@@ -134,7 +134,7 @@ final boolean cas(long cmp, long val) {
   static final int NCPU = Runtime.getRuntime().availableProcessors();
 
   /** Table of cells. When non-null, size is a power of 2. */
-  @NullableDecl transient volatile Cell[] cells;
+  transient volatile Cell @Nullable [] cells;
 
   /**
    * Base value, used mainly when there is no contention, but also as a fallback during table
@@ -177,7 +177,7 @@ final boolean casBusy() {
    * @param hc the hash code holder
    * @param wasUncontended false if CAS failed before call
    */
-  final void retryUpdate(long x, @NullableDecl int[] hc, boolean wasUncontended) {
+  final void retryUpdate(long x, int @Nullable [] hc, boolean wasUncontended) {
     int h;
     if (hc == null) {
       threadHashCode.set(hc = new int[1]); // Initialize randomly, @@ -21,7 +21,7 @@
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Writer that places all output on an {@link Appendable} target. If the target is {@link Flushable}
@@ -68,13 +68,13 @@ public void write(int c) throws IOException {
   }
 
   @Override
-  public void write(@NullableDecl String str) throws IOException {
+  public void write(@Nullable String str) throws IOException {
     checkNotClosed();
     target.append(str);
   }
 
   @Override
-  public void write(@NullableDecl String str, int off, int len) throws IOException {
+  public void write(@Nullable String str, int off, int len) throws IOException {
     checkNotClosed();
     // tricky: append takes start, end pair...
     target.append(str, off, off + len);
@@ -104,14 +104,14 @@ public Writer append(char c) throws IOException {
   }
 
   @Override
-  public Writer append(@NullableDecl CharSequence charSeq) throws IOException {
+  public Writer append(@Nullable CharSequence charSeq) throws IOException {
     checkNotClosed();
     target.append(charSeq);
     return this;
   }
 
   @Override
-  public Writer append(@NullableDecl CharSequence charSeq, int start, int end) throws IOException {
+  public Writer append(@Nullable CharSequence charSeq, int start, int end) throws IOException {
     checkNotClosed();
     target.append(charSeq, start, end);
     return this;, @@ -35,7 +35,7 @@
 import java.io.Writer;
 import java.util.Arrays;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII
@@ -549,7 +549,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       if (other instanceof Alphabet) {
         Alphabet that = (Alphabet) other;
         return Arrays.equals(this.chars, that.chars);
@@ -567,13 +567,13 @@ public int hashCode() {
     // TODO(lowasser): provide a useful toString
     final Alphabet alphabet;
 
-    @NullableDecl final Character paddingChar;
+    @Nullable final Character paddingChar;
 
-    StandardBaseEncoding(String name, String alphabetChars, @NullableDecl Character paddingChar) {
+    StandardBaseEncoding(String name, String alphabetChars, @Nullable Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    StandardBaseEncoding(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    StandardBaseEncoding(Alphabet alphabet, @Nullable Character paddingChar) {
       this.alphabet = checkNotNull(alphabet);
       checkArgument(
           paddingChar == null || !alphabet.matches(paddingChar),
@@ -833,7 +833,7 @@ public BaseEncoding lowerCase() {
       return result;
     }
 
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
       return new StandardBaseEncoding(alphabet, paddingChar);
     }
 
@@ -852,7 +852,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@Nullable Object other) {
       if (other instanceof StandardBaseEncoding) {
         StandardBaseEncoding that = (StandardBaseEncoding) other;
         return this.alphabet.equals(that.alphabet)
@@ -909,17 +909,17 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
       return new Base16Encoding(alphabet);
     }
   }
 
   static final class Base64Encoding extends StandardBaseEncoding {
-    Base64Encoding(String name, String alphabetChars, @NullableDecl Character paddingChar) {
+    Base64Encoding(String name, String alphabetChars, @Nullable Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    private Base64Encoding(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    private Base64Encoding(Alphabet alphabet, @Nullable Character paddingChar) {
       super(alphabet, paddingChar);
       checkArgument(alphabet.chars.length == 64);
     }
@@ -966,7 +966,7 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
       return new Base64Encoding(alphabet, paddingChar);
     }
   }
@@ -1017,13 +1017,12 @@ public Appendable append(char c) throws IOException {
       }
 
       @Override
-      public Appendable append(@NullableDecl CharSequence chars, int off, int len)
-          throws IOException {
+      public Appendable append(@Nullable CharSequence chars, int off, int len) throws IOException {
         throw new UnsupportedOperationException();
       }
 
       @Override
-      public Appendable append(@NullableDecl CharSequence chars) throws IOException {
+      public Appendable append(@Nullable CharSequence chars) throws IOException {
         throw new UnsupportedOperationException();
       }
     };, @@ -39,7 +39,7 @@
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code
@@ -295,7 +295,7 @@ public String read() throws IOException {
    *
    * @throws IOException if an I/O error occurs while reading from this source
    */
-  @NullableDecl
+  @Nullable
   public String readFirstLine() throws IOException {
     Closer closer = Closer.create();
     try {, @@ -23,7 +23,7 @@
 import java.io.Reader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utility methods for working with {@link Closeable} objects.
@@ -69,7 +69,7 @@ private Closeables() {}
    * @throws IOException if {@code swallowIOException} is false and {@code close} throws an {@code
    *     IOException}.
    */
-  public static void close(@NullableDecl Closeable closeable, boolean swallowIOException)
+  public static void close(@Nullable Closeable closeable, boolean swallowIOException)
       throws IOException {
     if (closeable == null) {
       return;
@@ -99,7 +99,7 @@ public static void close(@NullableDecl Closeable closeable, boolean swallowIOExc
    *     does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@NullableDecl InputStream inputStream) {
+  public static void closeQuietly(@Nullable InputStream inputStream) {
     try {
       close(inputStream, true);
     } catch (IOException impossible) {
@@ -120,7 +120,7 @@ public static void closeQuietly(@NullableDecl InputStream inputStream) {
    * @param reader the reader to be closed, or {@code null} in which case this method does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@NullableDecl Reader reader) {
+  public static void closeQuietly(@Nullable Reader reader) {
     try {
       close(reader, true);
     } catch (IOException impossible) {, @@ -28,7 +28,7 @@
 import java.util.Deque;
 import java.util.logging.Level;
 import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Closeable} that collects {@code Closeable} resources and closes them all when it is
@@ -121,7 +121,7 @@ public static Closer create() {
    */
   // close. this word no longer has any meaning to me.
   @CanIgnoreReturnValue
-  public <C extends Closeable> C register(@NullableDecl C closeable) {
+  public <C extends Closeable> C register(@Nullable C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }, @@ -25,7 +25,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
@@ -46,7 +46,7 @@
 
   private OutputStream out;
   private MemoryOutput memory;
-  @NullableDecl private File file;
+  @Nullable private File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
   private static class MemoryOutput extends ByteArrayOutputStream {, @@ -21,7 +21,7 @@
 import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.nio.file.FileSystemException;
 import java.nio.file.SecureDirectoryStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Exception indicating that a recursive delete can't be performed because the file system does not
@@ -40,7 +40,7 @@
 @J2ObjCIncompatible // java.nio.file
 public final class InsecureRecursiveDeleteException extends FileSystemException {
 
-  public InsecureRecursiveDeleteException(@NullableDecl String file) {
+  public InsecureRecursiveDeleteException(@Nullable String file) {
     super(file, null, ""unable to guarantee security of recursive delete"");
   }
 }, @@ -25,7 +25,7 @@
 import java.nio.CharBuffer;
 import java.util.LinkedList;
 import java.util.Queue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A class for reading lines of text. Provides the same functionality as {@link
@@ -39,7 +39,7 @@
 @GwtIncompatible
 public final class LineReader {
   private final Readable readable;
-  @NullableDecl private final Reader reader;
+  @Nullable private final Reader reader;
   private final CharBuffer cbuf = createBuffer();
   private final char[] buf = cbuf.array();
 , @@ -54,7 +54,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utilities for use with {@link Path} instances, intended to complement {@link Files}.
@@ -611,7 +611,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of exceptions
    * that occurred or null if no exceptions were thrown.
    */
-  @NullableDecl
+  @Nullable
   private static Collection<IOException> deleteRecursivelySecure(
       SecureDirectoryStream<Path> dir, Path path) {
     Collection<IOException> exceptions = null;
@@ -640,7 +640,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  @NullableDecl
+  @Nullable
   private static Collection<IOException> deleteDirectoryContentsSecure(
       SecureDirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
@@ -659,7 +659,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  @NullableDecl
+  @Nullable
   private static Collection<IOException> deleteRecursivelyInsecure(Path path) {
     Collection<IOException> exceptions = null;
     try {
@@ -686,7 +686,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or null
    * if no exceptions were thrown.
    */
-  @NullableDecl
+  @Nullable
   private static Collection<IOException> deleteDirectoryContentsInsecure(
       DirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
@@ -706,7 +706,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path
    * is a root or is the empty path.
    */
-  @NullableDecl
+  @Nullable
   private static Path getParentPath(Path path) {
     Path parent = path.getParent();
 
@@ -753,7 +753,7 @@ private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] optio
    * the collection.
    */
   private static Collection<IOException> addException(
-      @NullableDecl Collection<IOException> exceptions, IOException e) {
+      @Nullable Collection<IOException> exceptions, IOException e) {
     if (exceptions == null) {
       exceptions = new ArrayList<>(); // don't need Set semantics
     }
@@ -766,10 +766,9 @@ private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] optio
    * null, the other collection is returned. Otherwise, the elements of {@code other} are added to
    * {@code exceptions} and {@code exceptions} is returned.
    */
-  @NullableDecl
+  @Nullable
   private static Collection<IOException> concat(
-      @NullableDecl Collection<IOException> exceptions,
-      @NullableDecl Collection<IOException> other) {
+      @Nullable Collection<IOException> exceptions, @Nullable Collection<IOException> other) {
     if (exceptions == null) {
       return other;
     } else if (other != null) {, @@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An {@link InputStream} that concatenates multiple substreams. At most one stream will be open at
@@ -33,7 +33,7 @@
 final class MultiInputStream extends InputStream {
 
   private Iterator<? extends ByteSource> it;
-  @NullableDecl private InputStream in;
+  @Nullable private InputStream in;
 
   /**
    * Creates a new instance.
@@ -90,7 +90,7 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl byte[] b, int off, int len) throws IOException {
+  public int read(byte @Nullable [] b, int off, int len) throws IOException {
     while (in != null) {
       int result = in.read(b, off, len);
       if (result != -1) {, @@ -19,7 +19,7 @@
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Reader} that concatenates multiple readers.
@@ -30,7 +30,7 @@
 @GwtIncompatible
 class MultiReader extends Reader {
   private final Iterator<? extends CharSource> it;
-  @NullableDecl private Reader current;
+  @Nullable private Reader current;
 
   MultiReader(Iterator<? extends CharSource> readers) throws IOException {
     this.it = readers;
@@ -46,7 +46,7 @@ private void advance() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl char[] cbuf, int off, int len) throws IOException {
+  public int read(char @Nullable [] cbuf, int off, int len) throws IOException {
     if (current == null) {
       return -1;
     }, @@ -21,7 +21,7 @@
 import java.io.FilenameFilter;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * File name filter that only accepts files matching a regular expression. This class is thread-safe
@@ -56,7 +56,7 @@ public PatternFilenameFilter(Pattern pattern) {
   }
 
   @Override
-  public boolean accept(@NullableDecl File dir, String fileName) {
+  public boolean accept(@Nullable File dir, String fileName) {
     return pattern.matcher(fileName).matches();
   }
 }, @@ -17,7 +17,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection of preconditions for math functions.
@@ -27,49 +27,49 @@
 @GwtCompatible
 @CanIgnoreReturnValue
 final class MathPreconditions {
-  static int checkPositive(@NullableDecl String role, int x) {
+  static int checkPositive(@Nullable String role, int x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static long checkPositive(@NullableDecl String role, long x) {
+  static long checkPositive(@Nullable String role, long x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static BigInteger checkPositive(@NullableDecl String role, BigInteger x) {
+  static BigInteger checkPositive(@Nullable String role, BigInteger x) {
     if (x.signum() <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static int checkNonNegative(@NullableDecl String role, int x) {
+  static int checkNonNegative(@Nullable String role, int x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static long checkNonNegative(@NullableDecl String role, long x) {
+  static long checkNonNegative(@Nullable String role, long x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static BigInteger checkNonNegative(@NullableDecl String role, BigInteger x) {
+  static BigInteger checkNonNegative(@Nullable String role, BigInteger x) {
     if (x.signum() < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static double checkNonNegative(@NullableDecl String role, double x) {
+  static double checkNonNegative(@Nullable String role, double x) {
     if (!(x >= 0)) { // not x < 0, to work with NaN.
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }, @@ -28,7 +28,7 @@
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable value object capturing some basic statistics about a collection of paired double
@@ -213,7 +213,7 @@ public LinearTransformation leastSquaresFit() {
    * guarantees {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj == null) {
       return false;
     }, @@ -32,7 +32,7 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A bundle of statistical summary values -- sum, count, mean/average, min and max, and several
@@ -339,7 +339,7 @@ public double max() {
    * {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj == null) {
       return false;
     }, @@ -29,7 +29,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code boolean} primitives, that are not already found in
@@ -458,7 +458,7 @@ public Boolean set(int index, Boolean element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }, @@ -27,7 +27,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code byte} primitives, that are not already found in
@@ -319,7 +319,7 @@ public Byte set(int index, Byte element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }, @@ -30,7 +30,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code char} primitives, that are not already found in
@@ -589,7 +589,7 @@ public Character set(int index, Character element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }, @@ -36,7 +36,7 @@
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.regex.Pattern;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code double} primitives, that are not already found in
@@ -601,7 +601,7 @@ public Double set(int index, Double element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }
@@ -682,7 +682,7 @@ private static Pattern fpPattern() {
    * @since 14.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   @GwtIncompatible // regular expressions
   public static Double tryParse(String string) {
     if (FLOATING_POINT_PATTERN.matcher(string).matches()) {, @@ -33,7 +33,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code float} primitives, that are not already found in
@@ -586,7 +586,7 @@ public Float set(int index, Float element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }
@@ -649,7 +649,7 @@ public String toString() {
    * @since 14.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   @GwtIncompatible // regular expressions
   public static Float tryParse(String string) {
     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {, @@ -33,7 +33,7 @@
 import java.util.Spliterators;
 import java.util.function.DoubleConsumer;
 import java.util.stream.DoubleStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable array of {@code double} values, with an API resembling {@link List}.
@@ -512,7 +512,7 @@ public int lastIndexOf(Object target) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof AsList) {
         AsList that = (AsList) object;
         return this.parent.equals(that.parent);
@@ -552,7 +552,7 @@ public String toString() {
    * values as this one, in the same order. Values are compared as if by {@link Double#equals}.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -33,7 +33,7 @@
 import java.util.Spliterators;
 import java.util.function.IntConsumer;
 import java.util.stream.IntStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable array of {@code int} values, with an API resembling {@link List}.
@@ -507,7 +507,7 @@ public int lastIndexOf(Object target) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof AsList) {
         AsList that = (AsList) object;
         return this.parent.equals(that.parent);
@@ -547,7 +547,7 @@ public String toString() {
    * values as this one, in the same order.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -33,7 +33,7 @@
 import java.util.Spliterators;
 import java.util.function.LongConsumer;
 import java.util.stream.LongStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * An immutable array of {@code long} values, with an API resembling {@link List}.
@@ -509,7 +509,7 @@ public int lastIndexOf(Object target) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object instanceof AsList) {
         AsList that = (AsList) object;
         return this.parent.equals(that.parent);
@@ -549,7 +549,7 @@ public String toString() {
    * values as this one, in the same order.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
     }, @@ -32,7 +32,7 @@
 import java.util.RandomAccess;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code int} primitives, that are not already found in either
@@ -644,7 +644,7 @@ public Integer set(int index, Integer element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }
@@ -707,7 +707,7 @@ public String toString() {
    * @since 11.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   public static Integer tryParse(String string) {
     return tryParse(string, 10);
   }
@@ -732,7 +732,7 @@ public static Integer tryParse(String string) {
    * @since 19.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   public static Integer tryParse(String string, int radix) {
     Long result = Longs.tryParse(string, radix);
     if (result == null || result.longValue() != result.intValue()) {, @@ -32,7 +32,7 @@
 import java.util.RandomAccess;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code long} primitives, that are not already found in
@@ -362,7 +362,7 @@ static int digit(char c) {
    * @since 14.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   public static Long tryParse(String string) {
     return tryParse(string, 10);
   }
@@ -387,7 +387,7 @@ public static Long tryParse(String string) {
    * @since 19.0
    */
   @Beta
-  @NullableDecl
+  @Nullable
   public static Long tryParse(String string, int radix) {
     if (checkNotNull(string).isEmpty()) {
       return null;
@@ -743,7 +743,7 @@ public Long set(int index, Long element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }, @@ -31,7 +31,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods pertaining to {@code short} primitives, that are not already found in
@@ -588,13 +588,13 @@ public Short get(int index) {
     }
 
     @Override
-    public boolean contains(@NullableDecl Object target) {
+    public boolean contains(@Nullable Object target) {
       // Overridden to prevent a ton of boxing
       return (target instanceof Short) && Shorts.indexOf(array, (Short) target, start, end) != -1;
     }
 
     @Override
-    public int indexOf(@NullableDecl Object target) {
+    public int indexOf(@Nullable Object target) {
       // Overridden to prevent a ton of boxing
       if (target instanceof Short) {
         int i = Shorts.indexOf(array, (Short) target, start, end);
@@ -606,7 +606,7 @@ public int indexOf(@NullableDecl Object target) {
     }
 
     @Override
-    public int lastIndexOf(@NullableDecl Object target) {
+    public int lastIndexOf(@Nullable Object target) {
       // Overridden to prevent a ton of boxing
       if (target instanceof Short) {
         int i = Shorts.lastIndexOf(array, (Short) target, start, end);
@@ -637,7 +637,7 @@ public Short set(int index, Short element) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@Nullable Object object) {
       if (object == this) {
         return true;
       }, @@ -23,7 +23,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import java.math.BigInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A wrapper class for unsigned {@code int} values, supporting arithmetic operations.
@@ -226,7 +226,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj instanceof UnsignedInteger) {
       UnsignedInteger other = (UnsignedInteger) obj;
       return value == other.value;, @@ -21,7 +21,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.Serializable;
 import java.math.BigInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A wrapper class for unsigned {@code long} values, supporting arithmetic operations.
@@ -238,7 +238,7 @@ public int hashCode() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj instanceof UnsignedLong) {
       UnsignedLong other = (UnsignedLong) obj;
       return value == other.value;, @@ -19,7 +19,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Abstract implementation of {@link InvocationHandler} that handles {@link Object#equals}, {@link
@@ -59,7 +59,7 @@
    * </ul>
    */
   @Override
-  public final Object invoke(Object proxy, Method method, @NullableDecl Object[] args)
+  public final Object invoke(Object proxy, Method method, Object @Nullable [] args)
       throws Throwable {
     if (args == null) {
       args = NO_ARGS;, @@ -54,7 +54,7 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Scans the source of a {@link ClassLoader} and finds all loadable classes and resources.
@@ -414,8 +414,7 @@ private void scanJar(File file, ClassLoader classloader) throws IOException {
      * and an empty set will be returned.
      */
     @VisibleForTesting
-    static ImmutableSet<File> getClassPathFromManifest(
-        File jarFile, @NullableDecl Manifest manifest) {
+    static ImmutableSet<File> getClassPathFromManifest(File jarFile, @Nullable Manifest manifest) {
       if (manifest == null) {
         return ImmutableSet.of();
       }, @@ -23,7 +23,7 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Represents either a {@link Field}, a {@link Method} or a {@link Constructor}. Provides
@@ -158,7 +158,7 @@ final boolean isTransient() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj instanceof Element) {
       Element that = (Element) obj;
       return getOwnerType().equals(that.getOwnerType()) && member.equals(that.member);, @@ -31,7 +31,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Wrapper around either a {@link Method} or a {@link Constructor}. Convenience API is provided to
@@ -97,7 +97,7 @@
   // All subclasses are owned by us and we'll make sure to get the R type right.
   @SuppressWarnings(""unchecked"")
   @CanIgnoreReturnValue
-  public final R invoke(@NullableDecl T receiver, Object... args)
+  public final R invoke(@Nullable T receiver, Object... args)
       throws InvocationTargetException, IllegalAccessException {
     return (R) invokeInternal(receiver, checkNotNull(args));
   }
@@ -177,7 +177,7 @@ public final R invoke(@NullableDecl T receiver, Object... args)
     return (TypeToken<T>) TypeToken.of(getDeclaringClass());
   }
 
-  abstract Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+  abstract Object invokeInternal(@Nullable Object receiver, Object[] args)
       throws InvocationTargetException, IllegalAccessException;
 
   abstract Type[] getGenericParameterTypes();
@@ -203,7 +203,7 @@ abstract Object invokeInternal(@NullableDecl Object receiver, Object[] args)
     }
 
     @Override
-    final Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+    final Object invokeInternal(@Nullable Object receiver, Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       return method.invoke(receiver, args);
     }
@@ -267,7 +267,7 @@ public final boolean isVarArgs() {
     }
 
     @Override
-    final Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+    final Object invokeInternal(@Nullable Object receiver, Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       try {
         return constructor.newInstance(args);, @@ -27,7 +27,7 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A mutable type-to-instance map. See also {@link ImmutableTypeToInstanceMap}.
@@ -41,29 +41,29 @@
 
   private final Map<TypeToken<? extends B>, B> backingMap = Maps.newHashMap();
 
-  @NullableDecl
+  @Nullable
   @Override
   public <T extends B> T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
 
-  @NullableDecl
+  @Nullable
   @Override
   public <T extends B> T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
-  @NullableDecl
+  @Nullable
   @Override
   @CanIgnoreReturnValue
-  public <T extends B> T putInstance(Class<T> type, @NullableDecl T value) {
+  public <T extends B> T putInstance(Class<T> type, @Nullable T value) {
     return trustedPut(TypeToken.of(type), value);
   }
 
-  @NullableDecl
+  @Nullable
   @Override
   @CanIgnoreReturnValue
-  public <T extends B> T putInstance(TypeToken<T> type, @NullableDecl T value) {
+  public <T extends B> T putInstance(TypeToken<T> type, @Nullable T value) {
     return trustedPut(type.rejectTypeVariables(), value);
   }
 
@@ -103,13 +103,13 @@ public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
   }
 
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @NullableDecl
-  private <T extends B> T trustedPut(TypeToken<T> type, @NullableDecl T value) {
+  @Nullable
+  private <T extends B> T trustedPut(TypeToken<T> type, @Nullable T value) {
     return (T) backingMap.put(type, value);
   }
 
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @NullableDecl
+  @Nullable
   private <T extends B> T trustedGet(TypeToken<T> type) {
     return (T) backingMap.get(type);
   }, @@ -22,7 +22,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.AnnotatedType;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Represents a method or constructor parameter.
@@ -68,7 +68,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   }
 
   @Override
-  @NullableDecl
+  @Nullable
   public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     for (Annotation annotation : annotations) {
@@ -99,7 +99,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
 
   /** @since 18.0 */
   // @Override on JDK8
-  @NullableDecl
+  @Nullable
   public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     return FluentIterable.from(annotations).filter(annotationType).first().orNull();
@@ -118,7 +118,7 @@ public AnnotatedType getAnnotatedType() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@Nullable Object obj) {
     if (obj instanceof Parameter) {
       Parameter that = (Parameter) obj;
       return position == that.position && declaration.equals(that.declaration);, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Support type annotations in NullPointerTester

RELNOTES=N/A

feefa807349f68c90589aca91d121ba2991fe7f5

-------

<p> Continue type annotation preparations in NullPointerTester

9f4014505d9d368f4fbd607586b7349081e3b021

-------

<p> Add Token Binding HTTP header names to header libraries.

5406f50eb39519a00062ab1e0cf5b1ac0ef76e80

-------

<p> Use the type annotation version of @Nullable in the Java 8 branch

RELNOTES=Use the type annotation version of @Nullable in the Java 8 branch

daa53ccf373aedee90abbceb3a33c2355d189e5c",Moe Sync
3142,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/FluentFuture.java', 'guava/src/com/google/common/util/concurrent/FluentFuture.java']","@@ -150,7 +150,6 @@
    * // TimeoutException.
    * ListenableFuture<Integer> faultTolerantFuture =
    *     fetchCounters().catchingAsync(
-   *         fetchCounterFuture,
    *         FetchException.class,
    *         e -> {
    *           if (omitDataOnFetchFailure) {, @@ -150,7 +150,6 @@
    * // TimeoutException.
    * ListenableFuture<Integer> faultTolerantFuture =
    *     fetchCounters().catchingAsync(
-   *         fetchCounterFuture,
    *         FetchException.class,
    *         e -> {
    *           if (omitDataOnFetchFailure) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix a documentation error.

FluentFuture.catchingAsync does not take a future as an argument.

bf25a56ef0d350b2a631536809e4f9b958abf9e3",Moe Sync
3144,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Public Suffix data.

The copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

16cb0383e37d26e1da4b6f7cfb7a9d21078d0912",Moe Sync
3146,Ron Shapiro,"['android/guava/src/com/google/common/base/AbstractIterator.java', 'android/guava/src/com/google/common/base/Converter.java', 'android/guava/src/com/google/common/base/Defaults.java', 'android/guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'android/guava/src/com/google/common/collect/ImmutableEntry.java', 'android/guava/src/com/google/common/collect/ImmutableSet.java', 'android/guava/src/com/google/common/primitives/Doubles.java', 'android/guava/src/com/google/common/primitives/Floats.java', 'android/guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java', 'android/guava/src/com/google/common/reflect/TypeToInstanceMap.java', 'android/guava/src/com/google/common/reflect/TypeToken.java', 'android/guava/src/com/google/common/reflect/Types.java', 'guava/src/com/google/common/base/Absent.java', 'guava/src/com/google/common/base/AbstractIterator.java', 'guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/Defaults.java', 'guava/src/com/google/common/base/Equivalence.java', 'guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'guava/src/com/google/common/base/Functions.java', 'guava/src/com/google/common/base/Optional.java', 'guava/src/com/google/common/base/StandardSystemProperty.java', 'guava/src/com/google/common/base/Strings.java', 'guava/src/com/google/common/base/Suppliers.java', 'guava/src/com/google/common/base/Throwables.java', 'guava/src/com/google/common/base/internal/Finalizer.java', 'guava/src/com/google/common/cache/CacheBuilderSpec.java', 'guava/src/com/google/common/cache/ForwardingCache.java', 'guava/src/com/google/common/cache/LocalCache.java', 'guava/src/com/google/common/collect/AbstractIterator.java', 'guava/src/com/google/common/collect/AbstractMapBasedMultimap.java', 'guava/src/com/google/common/collect/AbstractNavigableMap.java', 'guava/src/com/google/common/collect/AbstractSequentialIterator.java', 'guava/src/com/google/common/collect/ArrayTable.java', 'guava/src/com/google/common/collect/CollectSpliterators.java', 'guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/ConcurrentHashMultiset.java', 'guava/src/com/google/common/collect/Cut.java', 'guava/src/com/google/common/collect/DenseImmutableTable.java', 'guava/src/com/google/common/collect/GeneralRange.java', 'guava/src/com/google/common/collect/HashBiMap.java', 'guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java', 'guava/src/com/google/common/collect/ImmutableEntry.java', 'guava/src/com/google/common/collect/ImmutableMapEntry.java', 'guava/src/com/google/common/collect/ImmutableRangeMap.java', 'guava/src/com/google/common/collect/ImmutableSet.java', 'guava/src/com/google/common/collect/Iterables.java', 'guava/src/com/google/common/collect/Iterators.java', 'guava/src/com/google/common/collect/LinkedListMultimap.java', 'guava/src/com/google/common/collect/Lists.java', 'guava/src/com/google/common/collect/MapMakerInternalMap.java', 'guava/src/com/google/common/collect/Maps.java', 'guava/src/com/google/common/collect/MinMaxPriorityQueue.java', 'guava/src/com/google/common/collect/Multisets.java', 'guava/src/com/google/common/collect/RegularImmutableBiMap.java', 'guava/src/com/google/common/collect/RegularImmutableMap.java', 'guava/src/com/google/common/collect/RegularImmutableTable.java', 'guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/Tables.java', 'guava/src/com/google/common/collect/TopKSelector.java', 'guava/src/com/google/common/collect/TreeBasedTable.java', 'guava/src/com/google/common/collect/TreeMultiset.java', 'guava/src/com/google/common/collect/TreeRangeMap.java', 'guava/src/com/google/common/collect/TreeRangeSet.java', 'guava/src/com/google/common/graph/AbstractNetwork.java', 'guava/src/com/google/common/graph/ConfigurableValueGraph.java', 'guava/src/com/google/common/graph/DirectedMultiNetworkConnections.java', 'guava/src/com/google/common/graph/EdgesConnecting.java', 'guava/src/com/google/common/graph/ElementOrder.java', 'guava/src/com/google/common/graph/ForwardingValueGraph.java', 'guava/src/com/google/common/graph/Graphs.java', 'guava/src/com/google/common/graph/MapIteratorCache.java', 'guava/src/com/google/common/graph/MapRetrievalCache.java', 'guava/src/com/google/common/graph/Traverser.java', 'guava/src/com/google/common/graph/UndirectedMultiNetworkConnections.java', 'guava/src/com/google/common/io/BaseEncoding.java', 'guava/src/com/google/common/io/CharSource.java', 'guava/src/com/google/common/io/FileBackedOutputStream.java', 'guava/src/com/google/common/io/LineReader.java', 'guava/src/com/google/common/io/MoreFiles.java', 'guava/src/com/google/common/io/MultiInputStream.java', 'guava/src/com/google/common/io/MultiReader.java', 'guava/src/com/google/common/primitives/Doubles.java', 'guava/src/com/google/common/primitives/Floats.java', 'guava/src/com/google/common/primitives/Ints.java', 'guava/src/com/google/common/primitives/Longs.java', 'guava/src/com/google/common/reflect/MutableTypeToInstanceMap.java', 'guava/src/com/google/common/reflect/Parameter.java', 'guava/src/com/google/common/reflect/TypeToInstanceMap.java', 'guava/src/com/google/common/reflect/TypeToken.java', 'guava/src/com/google/common/reflect/Types.java', 'guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'guava/src/com/google/common/util/concurrent/AbstractService.java', 'guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'guava/src/com/google/common/util/concurrent/Callables.java', 'guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java', 'guava/src/com/google/common/util/concurrent/ExecutionList.java', 'guava/src/com/google/common/util/concurrent/FuturesGetChecked.java', 'guava/src/com/google/common/util/concurrent/ImmediateFuture.java', 'guava/src/com/google/common/util/concurrent/TimeoutFuture.java']","@@ -43,8 +43,8 @@ protected AbstractIterator() {}
 
   protected abstract T computeNext();
 
-  @NullableDecl
   @CanIgnoreReturnValue
+  @NullableDecl
   protected final T endOfData() {
     state = State.DONE;
     return null;, @@ -164,8 +164,8 @@ protected Converter() {
    *
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
-  @NullableDecl
   @CanIgnoreReturnValue
+  @NullableDecl
   public final B convert(@NullableDecl A a) {
     return correctedDoForward(a);
   }
@@ -386,8 +386,8 @@ public String toString() {
    */
   @Deprecated
   @Override
-  @NullableDecl
   @CanIgnoreReturnValue
+  @NullableDecl
   public final B apply(@NullableDecl A a) {
     return convert(a);
   }, @@ -37,8 +37,8 @@ private Defaults() {}
    * false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
    * {@code void}, {@code null} is returned.
    */
-  @NullableDecl
   @SuppressWarnings(""unchecked"")
+  @NullableDecl
   public static <T> T defaultValue(Class<T> type) {
     checkNotNull(type);
     if (type == boolean.class) {, @@ -241,8 +241,8 @@ void cleanUp() {
     // finding Finalizer on the system class path even if it is there.
     @VisibleForTesting static boolean disabled;
 
-    @NullableDecl
     @Override
+    @NullableDecl
     public Class<?> loadFinalizer() {
       if (disabled) {
         return null;
@@ -279,8 +279,8 @@ void cleanUp() {
             + ""loader. To support reclaiming this class loader, either resolve the underlying ""
             + ""issue, or move Guava to your system class path."";
 
-    @NullableDecl
     @Override
+    @NullableDecl
     public Class<?> loadFinalizer() {
       try {
         /*, @@ -31,14 +31,14 @@
     this.value = value;
   }
 
-  @NullableDecl
   @Override
+  @NullableDecl
   public final K getKey() {
     return key;
   }
 
-  @NullableDecl
   @Override
+  @NullableDecl
   public final V getValue() {
     return value;
   }, @@ -338,7 +338,7 @@ public int hashCode() {
   @Override
   public abstract UnmodifiableIterator<E> iterator();
 
-  @LazyInit @NullableDecl @RetainedWith private transient ImmutableList<E> asList;
+  @LazyInit @RetainedWith @NullableDecl private transient ImmutableList<E> asList;
 
   @Override
   public ImmutableList<E> asList() {, @@ -675,8 +675,8 @@ private static Pattern fpPattern() {
    * @since 14.0
    */
   @Beta
-  @NullableDecl
   @GwtIncompatible // regular expressions
+  @NullableDecl
   public static Double tryParse(String string) {
     if (FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with, @@ -649,8 +649,8 @@ public String toString() {
    * @since 14.0
    */
   @Beta
-  @NullableDecl
   @GwtIncompatible // regular expressions
+  @NullableDecl
   public static Float tryParse(String string) {
     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with, @@ -41,28 +41,28 @@
 
   private final Map<TypeToken<? extends B>, B> backingMap = Maps.newHashMap();
 
-  @NullableDecl
   @Override
+  @NullableDecl
   public <T extends B> T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
 
-  @NullableDecl
   @Override
+  @NullableDecl
   public <T extends B> T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
-  @NullableDecl
   @Override
   @CanIgnoreReturnValue
+  @NullableDecl
   public <T extends B> T putInstance(Class<T> type, @NullableDecl T value) {
     return trustedPut(TypeToken.of(type), value);
   }
 
-  @NullableDecl
   @Override
   @CanIgnoreReturnValue
+  @NullableDecl
   public <T extends B> T putInstance(TypeToken<T> type, @NullableDecl T value) {
     return trustedPut(type.rejectTypeVariables(), value);
   }, @@ -70,8 +70,8 @@
    * @return the value previously associated with this class (possibly {@code null}), or {@code
    *     null} if there was no previous entry.
    */
-  @NullableDecl
   @CanIgnoreReturnValue
+  @NullableDecl
   <T extends B> T putInstance(Class<T> type, @NullableDecl T value);
 
   /**
@@ -81,7 +81,7 @@
    * @return the value previously associated with this type (possibly {@code null}), or {@code null}
    *     if there was no previous entry.
    */
-  @NullableDecl
   @CanIgnoreReturnValue
+  @NullableDecl
   <T extends B> T putInstance(TypeToken<T> type, @NullableDecl T value);
 }, @@ -1310,8 +1310,8 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
             return type.getGenericInterfaces();
           }
 
-          @NullableDecl
           @Override
+          @NullableDecl
           TypeToken<?> getSuperclass(TypeToken<?> type) {
             return type.getGenericSuperclass();
           }
@@ -1329,8 +1329,8 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
             return Arrays.asList(type.getInterfaces());
           }
 
-          @NullableDecl
           @Override
+          @NullableDecl
           Class<?> getSuperclass(Class<?> type) {
             return type.getSuperclass();
           }, @@ -105,15 +105,15 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
   /** Decides what owner type to use for constructing {@link ParameterizedType} from a raw class. */
   private enum ClassOwnership {
     OWNED_BY_ENCLOSING_CLASS {
-      @NullableDecl
       @Override
+      @NullableDecl
       Class<?> getOwnerType(Class<?> rawType) {
         return rawType.getEnclosingClass();
       }
     },
     LOCAL_CLASS_HAS_NO_OWNER {
-      @NullableDecl
       @Override
+      @NullableDecl
       Class<?> getOwnerType(Class<?> rawType) {
         if (rawType.isLocalClass()) {
           return null;, @@ -61,8 +61,7 @@ public T or(Supplier<? extends T> supplier) {
   }
 
   @Override
-  @Nullable
-  public T orNull() {
+  public @Nullable T orNull() {
     return null;
   }
 , @@ -39,13 +39,12 @@ protected AbstractIterator() {}
     FAILED,
   }
 
-  @Nullable private T next;
+  private @Nullable T next;
 
   protected abstract T computeNext();
 
-  @Nullable
   @CanIgnoreReturnValue
-  protected final T endOfData() {
+  protected final @Nullable T endOfData() {
     state = State.DONE;
     return null;
   }, @@ -164,9 +164,8 @@ protected Converter() {
    *
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
-  @Nullable
   @CanIgnoreReturnValue
-  public final B convert(@Nullable A a) {
+  public final @Nullable B convert(@Nullable A a) {
     return correctedDoForward(a);
   }
 
@@ -386,9 +385,8 @@ public String toString() {
    */
   @Deprecated
   @Override
-  @Nullable
   @CanIgnoreReturnValue
-  public final B apply(@Nullable A a) {
+  public final @Nullable B apply(@Nullable A a) {
     return convert(a);
   }
 , @@ -37,9 +37,8 @@ private Defaults() {}
    * false} for {@code boolean} and {@code '\0'} for {@code char}. For non-primitive types and
    * {@code void}, {@code null} is returned.
    */
-  @Nullable
   @SuppressWarnings(""unchecked"")
-  public static <T> T defaultValue(Class<T> type) {
+  public static <T> @Nullable T defaultValue(Class<T> type) {
     checkNotNull(type);
     if (type == boolean.class) {
       return (T) Boolean.FALSE;, @@ -184,16 +184,15 @@ public final int hash(@Nullable T t) {
    */
   public static final class Wrapper<T> implements Serializable {
     private final Equivalence<? super T> equivalence;
-    @Nullable private final T reference;
+    private final @Nullable T reference;
 
     private Wrapper(Equivalence<? super T> equivalence, @Nullable T reference) {
       this.equivalence = checkNotNull(equivalence);
       this.reference = reference;
     }
 
     /** Returns the (possibly null) reference wrapped by this instance. */
-    @Nullable
-    public T get() {
+    public @Nullable T get() {
       return reference;
     }
 
@@ -272,7 +271,7 @@ public String toString() {
   private static final class EquivalentToPredicate<T> implements Predicate<T>, Serializable {
 
     private final Equivalence<T> equivalence;
-    @Nullable private final T target;
+    private final @Nullable T target;
 
     EquivalentToPredicate(Equivalence<T> equivalence, @Nullable T target) {
       this.equivalence = checkNotNull(equivalence);, @@ -241,9 +241,8 @@ void cleanUp() {
     // finding Finalizer on the system class path even if it is there.
     @VisibleForTesting static boolean disabled;
 
-    @Nullable
     @Override
-    public Class<?> loadFinalizer() {
+    public @Nullable Class<?> loadFinalizer() {
       if (disabled) {
         return null;
       }
@@ -279,9 +278,8 @@ void cleanUp() {
             + ""loader. To support reclaiming this class loader, either resolve the underlying ""
             + ""issue, or move Guava to your system class path."";
 
-    @Nullable
     @Override
-    public Class<?> loadFinalizer() {
+    public @Nullable Class<?> loadFinalizer() {
       try {
         /*
          * We use URLClassLoader because it's the only concrete class loader implementation in the, @@ -88,8 +88,7 @@ public String toString() {
     INSTANCE;
 
     @Override
-    @Nullable
-    public Object apply(@Nullable Object o) {
+    public @Nullable Object apply(@Nullable Object o) {
       return o;
     }
 
@@ -171,7 +170,7 @@ public String toString() {
 
   private static class ForMapWithDefault<K, V> implements Function<K, V>, Serializable {
     final Map<K, ? extends V> map;
-    @Nullable final V defaultValue;
+    final @Nullable V defaultValue;
 
     ForMapWithDefault(Map<K, ? extends V> map, @Nullable V defaultValue) {
       this.map = checkNotNull(map);
@@ -320,7 +319,7 @@ public String toString() {
   }
 
   private static class ConstantFunction<E> implements Function<Object, E>, Serializable {
-    @Nullable private final E value;
+    private final @Nullable E value;
 
     public ConstantFunction(@Nullable E value) {
       this.value = value;, @@ -120,8 +120,8 @@
    *
    * @since 21.0
    */
-  @Nullable
-  public static <T> Optional<T> fromJavaUtil(java.util.@Nullable Optional<T> javaUtilOptional) {
+  public static <T> @Nullable Optional<T> fromJavaUtil(
+      java.util.@Nullable Optional<T> javaUtilOptional) {
     return (javaUtilOptional == null) ? null : fromNullable(javaUtilOptional.orElse(null));
   }
 
@@ -246,8 +246,7 @@
    * <p><b>Comparison to {@code java.util.Optional}:</b> this method is equivalent to Java 8's
    * {@code Optional.orElse(null)}.
    */
-  @Nullable
-  public abstract T orNull();
+  public abstract @Nullable T orNull();
 
   /**
    * Returns an immutable singleton {@link Set} whose only element is the contained instance if it, @@ -125,8 +125,7 @@ public String key() {
    * Returns the current value for this system property by delegating to {@link
    * System#getProperty(String)}.
    */
-  @Nullable
-  public String value() {
+  public @Nullable String value() {
     return System.getProperty(key);
   }
 , @@ -47,8 +47,7 @@ public static String nullToEmpty(@Nullable String string) {
    * @param string the string to test and possibly return
    * @return {@code string} itself if it is nonempty; {@code null} if it is empty or null
    */
-  @Nullable
-  public static String emptyToNull(@Nullable String string) {
+  public static @Nullable String emptyToNull(@Nullable String string) {
     return Platform.emptyToNull(string);
   }
 , @@ -113,7 +113,7 @@ public String toString() {
     transient volatile boolean initialized;
     // ""value"" does not need to be volatile; visibility piggy-backs
     // on volatile read of ""initialized"".
-    @Nullable transient T value;
+    transient @Nullable T value;
 
     MemoizingSupplier(Supplier<T> delegate) {
       this.delegate = Preconditions.checkNotNull(delegate);
@@ -214,7 +214,7 @@ public String toString() {
   static class ExpiringMemoizingSupplier<T> implements Supplier<T>, Serializable {
     final Supplier<T> delegate;
     final long durationNanos;
-    @Nullable transient volatile T value;
+    transient volatile @Nullable T value;
     // The special value 0 means ""not yet initialized"".
     transient volatile long expirationNanos;
 
@@ -266,7 +266,7 @@ public String toString() {
   }
 
   private static class SupplierOfInstance<T> implements Supplier<T>, Serializable {
-    @Nullable final T instance;
+    final @Nullable T instance;
 
     SupplierOfInstance(@Nullable T instance) {
       this.instance = instance;, @@ -448,32 +448,30 @@ private static Object invokeAccessibleNonThrowingMethod(
 
   /** Access to some fancy internal JVM internals. */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static final Object jla = getJLA();
+  private static final @Nullable Object jla = getJLA();
 
   /**
    * The ""getStackTraceElementMethod"" method, only available on some JDKs so we use reflection to
    * find it when available. When this is null, use the slow way.
    */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static final Method getStackTraceElementMethod = (jla == null) ? null : getGetMethod();
+  private static final @Nullable Method getStackTraceElementMethod =
+      (jla == null) ? null : getGetMethod();
 
   /**
    * The ""getStackTraceDepth"" method, only available on some JDKs so we use reflection to find it
    * when available. When this is null, use the slow way.
    */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod();
+  private static final @Nullable Method getStackTraceDepthMethod =
+      (jla == null) ? null : getSizeMethod();
 
   /**
    * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for
    * AppEngine, and not present in non-Sun JDKs.
    */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static Object getJLA() {
+  private static @Nullable Object getJLA() {
     try {
       /*
        * We load sun.misc.* classes using reflection since Android doesn't support these classes and
@@ -498,8 +496,7 @@ private static Object getJLA() {
    * method cannot be found (it is only to be found in fairly recent JDKs).
    */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static Method getGetMethod() {
+  private static @Nullable Method getGetMethod() {
     return getJlaMethod(""getStackTraceElement"", Throwable.class, int.class);
   }
 
@@ -513,8 +510,7 @@ private static Method getGetMethod() {
    * UnsupportedOperationException</a>.
    */
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static Method getSizeMethod() {
+  private static @Nullable Method getSizeMethod() {
     try {
       Method getStackTraceDepth = getJlaMethod(""getStackTraceDepth"", Throwable.class);
       if (getStackTraceDepth == null) {
@@ -528,8 +524,8 @@ private static Method getSizeMethod() {
   }
 
   @GwtIncompatible // java.lang.reflect
-  @Nullable
-  private static Method getJlaMethod(String name, Class<?>... parameterTypes) throws ThreadDeath {
+  private static @Nullable Method getJlaMethod(String name, Class<?>... parameterTypes)
+      throws ThreadDeath {
     try {
       return Class.forName(JAVA_LANG_ACCESS_CLASSNAME, false, null).getMethod(name, parameterTypes);
     } catch (ThreadDeath death) {, @@ -116,11 +116,10 @@ public static void startFinalizer(
   // By preference, we will use the Thread constructor that has an `inheritThreadLocals` parameter.
   // But before Java 9, our only way not to inherit ThreadLocals is to zap them after the thread
   // is created, by accessing a private field.
-  @Nullable
-  private static final Constructor<Thread> bigThreadConstructor = getBigThreadConstructor();
+  private static final @Nullable Constructor<Thread> bigThreadConstructor =
+      getBigThreadConstructor();
 
-  @Nullable
-  private static final Field inheritableThreadLocals =
+  private static final @Nullable Field inheritableThreadLocals =
       (bigThreadConstructor == null) ? getInheritableThreadLocalsField() : null;
 
   /** Constructs a new finalizer thread. */
@@ -192,8 +191,7 @@ private boolean cleanUp(Reference<?> reference) {
   }
 
   /** Looks up FinalizableReference.finalizeReferent() method. */
-  @Nullable
-  private Method getFinalizeReferentMethod() {
+  private @Nullable Method getFinalizeReferentMethod() {
     Class<?> finalizableReferenceClass = finalizableReferenceClassReference.get();
     if (finalizableReferenceClass == null) {
       /*
@@ -211,8 +209,7 @@ private Method getFinalizeReferentMethod() {
     }
   }
 
-  @Nullable
-  private static Field getInheritableThreadLocalsField() {
+  private static @Nullable Field getInheritableThreadLocalsField() {
     try {
       Field inheritableThreadLocals = Thread.class.getDeclaredField(""inheritableThreadLocals"");
       inheritableThreadLocals.setAccessible(true);
@@ -226,8 +223,7 @@ private static Field getInheritableThreadLocalsField() {
     }
   }
 
-  @Nullable
-  private static Constructor<Thread> getBigThreadConstructor() {
+  private static @Nullable Constructor<Thread> getBigThreadConstructor() {
     try {
       return Thread.class.getConstructor(
           ThreadGroup.class, Runnable.class, String.class, long.class, boolean.class);, @@ -278,8 +278,7 @@ public boolean equals(@Nullable Object obj) {
    * Converts an expiration duration/unit pair into a single Long for hashing and equality. Uses
    * nanos to match CacheBuilder implementation.
    */
-  @Nullable
-  private static Long durationInNanos(long duration, @Nullable TimeUnit unit) {
+  private static @Nullable Long durationInNanos(long duration, @Nullable TimeUnit unit) {
     return (unit == null) ? null : unit.toNanos(duration);
   }
 , @@ -43,8 +43,7 @@ protected ForwardingCache() {}
 
   /** @since 11.0 */
   @Override
-  @Nullable
-  public V getIfPresent(Object key) {
+  public @Nullable V getIfPresent(Object key) {
     return delegate().getIfPresent(key);
   }
 , @@ -230,7 +230,7 @@
   final StatsCounter globalStatsCounter;
 
   /** The default cache loader to use on loading operations. */
-  @Nullable final CacheLoader<? super K, V> defaultLoader;
+  final @Nullable CacheLoader<? super K, V> defaultLoader;
 
   /**
    * Creates a new, empty map with the specified strategy, initial capacity and concurrency level.
@@ -953,7 +953,7 @@ public K getKey() {
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    @Nullable final ReferenceEntry<K, V> next;
+    final @Nullable ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -1240,7 +1240,7 @@ public void setPreviousInWriteQueue(ReferenceEntry<K, V> previous) {
     // The code below is exactly the same for each entry type.
 
     final int hash;
-    @Nullable final ReferenceEntry<K, V> next;
+    final @Nullable ReferenceEntry<K, V> next;
     volatile ValueReference<K, V> valueReference = unset();
 
     @Override
@@ -1893,13 +1893,13 @@ void processPendingNotifications() {
      * The key reference queue contains entries whose keys have been garbage collected, and which
      * need to be cleaned up internally.
      */
-    @Nullable final ReferenceQueue<K> keyReferenceQueue;
+    final @Nullable ReferenceQueue<K> keyReferenceQueue;
 
     /**
      * The value reference queue contains value references whose values have been garbage collected,
      * and which need to be cleaned up internally.
      */
-    @Nullable final ReferenceQueue<V> valueReferenceQueue;
+    final @Nullable ReferenceQueue<V> valueReferenceQueue;
 
     /**
      * The recency queue is used to record which entries were accessed for updating the access
@@ -3932,8 +3932,7 @@ public int size() {
   }
 
   @Override
-  @Nullable
-  public V get(@Nullable Object key) {
+  public @Nullable V get(@Nullable Object key) {
     if (key == null) {
       return null;
     }
@@ -3946,8 +3945,7 @@ V get(K key, CacheLoader<? super K, V> loader) throws ExecutionException {
     return segmentFor(hash).get(key, hash, loader);
   }
 
-  @Nullable
-  public V getIfPresent(Object key) {
+  public @Nullable V getIfPresent(Object key) {
     int hash = hash(checkNotNull(key));
     V value = segmentFor(hash).get(key, hash);
     if (value == null) {
@@ -3960,8 +3958,7 @@ public V getIfPresent(Object key) {
 
   // Only becomes available in Java 8 when it's on the interface.
   // @Override
-  @Nullable
-  public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
+  public @Nullable V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
     V result = get(key);
     return (result != null) ? result : defaultValue;
   }
@@ -4693,7 +4690,7 @@ public boolean remove(Object o) {
     final Weigher<K, V> weigher;
     final int concurrencyLevel;
     final RemovalListener<? super K, ? super V> removalListener;
-    @Nullable final Ticker ticker;
+    final @Nullable Ticker ticker;
     final CacheLoader<? super K, V> loader;
 
     @MonotonicNonNullDecl transient Cache<K, V> delegate;
@@ -4857,8 +4854,7 @@ private LocalManualCache(LocalCache<K, V> localCache) {
     // Cache methods
 
     @Override
-    @Nullable
-    public V getIfPresent(Object key) {
+    public @Nullable V getIfPresent(Object key) {
       return localCache.getIfPresent(key);
     }
 , @@ -81,7 +81,7 @@ protected AbstractIterator() {}
     FAILED,
   }
 
-  @Nullable private T next;
+  private @Nullable T next;
 
   /**
    * Returns the next element. <b>Note:</b> the implementation must call {@link #endOfData()} when, @@ -324,10 +324,10 @@ public void clear() {
    */
   @WeakOuter
   class WrappedCollection extends AbstractCollection<V> {
-    @Nullable final K key;
+    final @Nullable K key;
     Collection<V> delegate;
-    @Nullable final WrappedCollection ancestor;
-    @Nullable final Collection<V> ancestorDelegate;
+    final @Nullable WrappedCollection ancestor;
+    final @Nullable Collection<V> ancestorDelegate;
 
     WrappedCollection(
         @Nullable K key, Collection<V> delegate, @Nullable WrappedCollection ancestor) {, @@ -36,30 +36,25 @@
     implements NavigableMap<K, V> {
 
   @Override
-  @Nullable
-  public abstract V get(@Nullable Object key);
+  public abstract @Nullable V get(@Nullable Object key);
 
   @Override
-  @Nullable
-  public Entry<K, V> firstEntry() {
+  public @Nullable Entry<K, V> firstEntry() {
     return Iterators.getNext(entryIterator(), null);
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> lastEntry() {
+  public @Nullable Entry<K, V> lastEntry() {
     return Iterators.getNext(descendingEntryIterator(), null);
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> pollFirstEntry() {
+  public @Nullable Entry<K, V> pollFirstEntry() {
     return Iterators.pollNext(entryIterator());
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> pollLastEntry() {
+  public @Nullable Entry<K, V> pollLastEntry() {
     return Iterators.pollNext(descendingEntryIterator());
   }
 
@@ -84,26 +79,22 @@ public K lastKey() {
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> lowerEntry(K key) {
+  public @Nullable Entry<K, V> lowerEntry(K key) {
     return headMap(key, false).lastEntry();
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> floorEntry(K key) {
+  public @Nullable Entry<K, V> floorEntry(K key) {
     return headMap(key, true).lastEntry();
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> ceilingEntry(K key) {
+  public @Nullable Entry<K, V> ceilingEntry(K key) {
     return tailMap(key, true).firstEntry();
   }
 
   @Override
-  @Nullable
-  public Entry<K, V> higherEntry(K key) {
+  public @Nullable Entry<K, V> higherEntry(K key) {
     return tailMap(key, false).firstEntry();
   }
 , @@ -41,7 +41,7 @@
  */
 @GwtCompatible
 public abstract class AbstractSequentialIterator<T> extends UnmodifiableIterator<T> {
-  @Nullable private T nextOrNull;
+  private @Nullable T nextOrNull;
 
   /**
    * Creates a new iterator with the given first element, or, if {@code firstOrNull} is null,, @@ -190,11 +190,9 @@ K getKey(int index) {
 
     abstract String getKeyRole();
 
-    @Nullable
-    abstract V getValue(int index);
+    abstract @Nullable V getValue(int index);
 
-    @Nullable
-    abstract V setValue(int index, V newValue);
+    abstract @Nullable V setValue(int index, V newValue);
 
     @Override
     public int size() {, @@ -65,8 +65,7 @@ public void forEachRemaining(Consumer<? super T> action) {
       }
 
       @Override
-      @Nullable
-      public Spliterator<T> trySplit() {
+      public @Nullable Spliterator<T> trySplit() {
         Spliterator.OfInt split = delegate.trySplit();
         return (split == null) ? null : new WithCharacteristics(split);
       }, @@ -236,8 +236,7 @@ void accessEntry(int index) {
 
   @CanIgnoreReturnValue
   @Override
-  @Nullable
-  public V put(@Nullable K key, @Nullable V value) {
+  public @Nullable V put(@Nullable K key, @Nullable V value) {
     long[] entries = this.entries;
     Object[] keys = this.keys;
     Object[] values = this.values;
@@ -373,13 +372,11 @@ public V get(@Nullable Object key) {
 
   @CanIgnoreReturnValue
   @Override
-  @Nullable
-  public V remove(@Nullable Object key) {
+  public @Nullable V remove(@Nullable Object key) {
     return remove(key, smearedHash(key));
   }
 
-  @Nullable
-  private V remove(@Nullable Object key, int hash) {
+  private @Nullable V remove(@Nullable Object key, int hash) {
     int tableIndex = hash & hashTableMask();
     int next = table[tableIndex];
     if (next == UNSET) { // empty bucket
@@ -664,7 +661,7 @@ public boolean remove(@Nullable Object o) {
   }
 
   final class MapEntry extends AbstractMapEntry<K, V> {
-    @Nullable private final K key;
+    private final @Nullable K key;
 
     private int lastKnownIndex;
 , @@ -522,7 +522,7 @@ public boolean isEmpty() {
         };
 
     return new ForwardingIterator<Entry<E>>() {
-      @Nullable private Entry<E> last;
+      private @Nullable Entry<E> last;
 
       @Override
       protected Iterator<Entry<E>> delegate() {, @@ -33,7 +33,7 @@
  */
 @GwtCompatible
 abstract class Cut<C extends Comparable> implements Comparable<Cut<C>>, Serializable {
-  @Nullable final C endpoint;
+  final @Nullable C endpoint;
 
   Cut(@Nullable C endpoint) {
     this.endpoint = endpoint;, @@ -101,8 +101,7 @@ K getKey(int index) {
       return keyToIndex().keySet().asList().get(index);
     }
 
-    @Nullable
-    abstract V getValue(int keyIndex);
+    abstract @Nullable V getValue(int keyIndex);
 
     @Override
     ImmutableSet<K> createKeySet() {, @@ -92,10 +92,10 @@
 
   private final Comparator<? super T> comparator;
   private final boolean hasLowerBound;
-  @Nullable private final T lowerEndpoint;
+  private final @Nullable T lowerEndpoint;
   private final BoundType lowerBoundType;
   private final boolean hasUpperBound;
-  @Nullable private final T upperEndpoint;
+  private final @Nullable T upperEndpoint;
   private final BoundType upperBoundType;
 
   private GeneralRange(, @@ -105,8 +105,8 @@
 
   private transient BiEntry<K, V>[] hashTableKToV;
   private transient BiEntry<K, V>[] hashTableVToK;
-  @Nullable private transient BiEntry<K, V> firstInKeyInsertionOrder;
-  @Nullable private transient BiEntry<K, V> lastInKeyInsertionOrder;
+  private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
+  private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -249,9 +249,8 @@ public boolean containsValue(@Nullable Object value) {
     return seekByValue(value, smearedHash(value)) != null;
   }
 
-  @Nullable
   @Override
-  public V get(@Nullable Object key) {
+  public @Nullable V get(@Nullable Object key) {
     return Maps.valueOrNull(seekByKey(key, smearedHash(key)));
   }
 
@@ -301,8 +300,7 @@ public V forcePut(@Nullable K key, @Nullable V value) {
     return put(key, value, true);
   }
 
-  @Nullable
-  private K putInverse(@Nullable V value, @Nullable K key, boolean force) {
+  private @Nullable K putInverse(@Nullable V value, @Nullable K key, boolean force) {
     int valueHash = smearedHash(value);
     int keyHash = smearedHash(key);
 , @@ -169,8 +169,7 @@ private ImmutableClassToInstanceMap(ImmutableMap<Class<? extends B>, B> delegate
 
   @Override
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @Nullable
-  public <T extends B> T getInstance(Class<T> type) {
+  public <T extends B> @Nullable T getInstance(Class<T> type) {
     return (T) delegate.get(checkNotNull(type));
   }
 , @@ -23,23 +23,21 @@
 /** @see com.google.common.collect.Maps#immutableEntry(Object, Object) */
 @GwtCompatible(serializable = true)
 class ImmutableEntry<K, V> extends AbstractMapEntry<K, V> implements Serializable {
-  @Nullable final K key;
-  @Nullable final V value;
+  final @Nullable K key;
+  final @Nullable V value;
 
   ImmutableEntry(@Nullable K key, @Nullable V value) {
     this.key = key;
     this.value = value;
   }
 
-  @Nullable
   @Override
-  public final K getKey() {
+  public final @Nullable K getKey() {
     return key;
   }
 
-  @Nullable
   @Override
-  public final V getValue() {
+  public final @Nullable V getValue() {
     return value;
   }
 , @@ -80,8 +80,7 @@ boolean isReusable() {
     }
 
     @Override
-    @Nullable
-    final ImmutableMapEntry<K, V> getNextInKeyBucket() {
+    final @Nullable ImmutableMapEntry<K, V> getNextInKeyBucket() {
       return nextInKeyBucket;
     }
 , @@ -169,8 +169,7 @@ public Builder() {
   }
 
   @Override
-  @Nullable
-  public V get(K key) {
+  public @Nullable V get(K key) {
     int index =
         SortedLists.binarySearch(
             ranges,
@@ -187,8 +186,7 @@ public V get(K key) {
   }
 
   @Override
-  @Nullable
-  public Entry<Range<K>, V> getEntry(K key) {
+  public @Nullable Entry<Range<K>, V> getEntry(K key) {
     int index =
         SortedLists.binarySearch(
             ranges,, @@ -302,7 +302,7 @@ public int hashCode() {
   @Override
   public abstract UnmodifiableIterator<E> iterator();
 
-  @LazyInit @Nullable @RetainedWith private transient ImmutableList<E> asList;
+  @LazyInit @RetainedWith private transient @Nullable ImmutableList<E> asList;
 
   @Override
   public ImmutableList<E> asList() {, @@ -199,8 +199,8 @@ public static boolean retainAll(Iterable<?> removeFrom, Collection<?> elementsTo
   }
 
   /** Removes and returns the first matching element, or returns {@code null} if there is none. */
-  @Nullable
-  static <T> T removeFirstMatching(Iterable<T> removeFrom, Predicate<? super T> predicate) {
+  static <T> @Nullable T removeFirstMatching(
+      Iterable<T> removeFrom, Predicate<? super T> predicate) {
     checkNotNull(predicate);
     Iterator<T> iterator = removeFrom.iterator();
     while (iterator.hasNext()) {
@@ -263,8 +263,8 @@ public static String toString(Iterable<?> iterable) {
    *
    * @throws IllegalArgumentException if the iterator contains multiple elements
    */
-  @Nullable
-  public static <T> T getOnlyElement(Iterable<? extends T> iterable, @Nullable T defaultValue) {
+  public static <T> @Nullable T getOnlyElement(
+      Iterable<? extends T> iterable, @Nullable T defaultValue) {
     return Iterators.getOnlyElement(iterable.iterator(), defaultValue);
   }
 
@@ -641,8 +641,7 @@ public void forEach(Consumer<? super T> action) {
    *
    * @since 7.0
    */
-  @Nullable
-  public static <T> T find(
+  public static <T> @Nullable T find(
       Iterable<? extends T> iterable, Predicate<? super T> predicate, @Nullable T defaultValue) {
     return Iterators.find(iterable.iterator(), predicate, defaultValue);
   }
@@ -745,8 +744,8 @@ public void forEach(Consumer<? super T> action) {
    * @throws IndexOutOfBoundsException if {@code position} is negative
    * @since 4.0
    */
-  @Nullable
-  public static <T> T get(Iterable<? extends T> iterable, int position, @Nullable T defaultValue) {
+  public static <T> @Nullable T get(
+      Iterable<? extends T> iterable, int position, @Nullable T defaultValue) {
     checkNotNull(iterable);
     Iterators.checkNonnegative(position);
     if (iterable instanceof List) {
@@ -776,8 +775,7 @@ public void forEach(Consumer<? super T> action) {
    * @return the first element of {@code iterable} or the default value
    * @since 7.0
    */
-  @Nullable
-  public static <T> T getFirst(Iterable<? extends T> iterable, @Nullable T defaultValue) {
+  public static <T> @Nullable T getFirst(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     return Iterators.getNext(iterable.iterator(), defaultValue);
   }
 
@@ -814,8 +812,7 @@ public void forEach(Consumer<? super T> action) {
    * @return the last element of {@code iterable} or the default value
    * @since 3.0
    */
-  @Nullable
-  public static <T> T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {
+  public static <T> @Nullable T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     if (iterable instanceof Collection) {
       Collection<? extends T> c = Collections2.cast(iterable);
       if (c.isEmpty()) {, @@ -324,8 +324,8 @@ public static String toString(Iterator<?> iterator) {
    *     iterator is unspecified.
    */
   @CanIgnoreReturnValue // TODO(kak): Consider removing this?
-  @Nullable
-  public static <T> T getOnlyElement(Iterator<? extends T> iterator, @Nullable T defaultValue) {
+  public static <T> @Nullable T getOnlyElement(
+      Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? getOnlyElement(iterator) : defaultValue;
   }
 
@@ -707,8 +707,7 @@ protected T computeNext() {
    *
    * @since 7.0
    */
-  @Nullable
-  public static <T> T find(
+  public static <T> @Nullable T find(
       Iterator<? extends T> iterator, Predicate<? super T> predicate, @Nullable T defaultValue) {
     checkNotNull(iterator);
     checkNotNull(predicate);
@@ -823,8 +822,8 @@ T transform(F from) {
    * @throws IndexOutOfBoundsException if {@code position} is negative
    * @since 4.0
    */
-  @Nullable
-  public static <T> T get(Iterator<? extends T> iterator, int position, @Nullable T defaultValue) {
+  public static <T> @Nullable T get(
+      Iterator<? extends T> iterator, int position, @Nullable T defaultValue) {
     checkNonnegative(position);
     advance(iterator, position);
     return getNext(iterator, defaultValue);
@@ -844,8 +843,7 @@ static void checkNonnegative(int position) {
    * @return the next element of {@code iterator} or the default value
    * @since 7.0
    */
-  @Nullable
-  public static <T> T getNext(Iterator<? extends T> iterator, @Nullable T defaultValue) {
+  public static <T> @Nullable T getNext(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? iterator.next() : defaultValue;
   }
 
@@ -872,8 +870,7 @@ static void checkNonnegative(int position) {
    * @return the last element of {@code iterator}
    * @since 3.0
    */
-  @Nullable
-  public static <T> T getLast(Iterator<? extends T> iterator, @Nullable T defaultValue) {
+  public static <T> @Nullable T getLast(Iterator<? extends T> iterator, @Nullable T defaultValue) {
     return iterator.hasNext() ? getLast(iterator) : defaultValue;
   }
 
@@ -970,8 +967,7 @@ public String toString() {
    * Deletes and returns the next value from the iterator, or returns {@code null} if there is no
    * such value.
    */
-  @Nullable
-  static <T> T pollNext(Iterator<T> iterator) {
+  static <T> @Nullable T pollNext(Iterator<T> iterator) {
     if (iterator.hasNext()) {
       T result = iterator.next();
       iterator.remove();
@@ -1051,7 +1047,7 @@ protected T get(int index) {
    *
    * <p>The {@link Iterable} equivalent of this method is {@link Collections#singleton}.
    */
-  public static <T> UnmodifiableIterator<T> singletonIterator(@Nullable final T value) {
+  public static <T> UnmodifiableIterator<T> singletonIterator(final @Nullable T value) {
     return new UnmodifiableIterator<T>() {
       boolean done;
 
@@ -1119,7 +1115,7 @@ public T nextElement() {
 
     private final Iterator<? extends E> iterator;
     private boolean hasPeeked;
-    @Nullable private E peekedElement;
+    private @Nullable E peekedElement;
 
     public PeekingImpl(Iterator<? extends E> iterator) {
       this.iterator = checkNotNull(iterator);
@@ -1288,7 +1284,7 @@ public T next() {
 
   private static class ConcatenatedIterator<T> implements Iterator<T> {
     /* The last iterator to return an element.  Calls to remove() go to this iterator. */
-    @Nullable private Iterator<? extends T> toRemove;
+    private @Nullable Iterator<? extends T> toRemove;
 
     /* The iterator currently returning elements. */
     private Iterator<? extends T> iterator;
@@ -1303,16 +1299,15 @@ public T next() {
     private Iterator<? extends Iterator<? extends T>> topMetaIterator;
 
     // Only becomes nonnull if we encounter nested concatenations.
-    @Nullable private Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
+    private @Nullable Deque<Iterator<? extends Iterator<? extends T>>> metaIterators;
 
     ConcatenatedIterator(Iterator<? extends Iterator<? extends T>> metaIterator) {
       iterator = emptyIterator();
       topMetaIterator = checkNotNull(metaIterator);
     }
 
     // Returns a nonempty meta-iterator or, if all meta-iterators are empty, null.
-    @Nullable
-    private Iterator<? extends Iterator<? extends T>> getTopMetaIterator() {
+    private @Nullable Iterator<? extends Iterator<? extends T>> getTopMetaIterator() {
       while (topMetaIterator == null || !topMetaIterator.hasNext()) {
         if (metaIterators != null && !metaIterators.isEmpty()) {
           topMetaIterator = metaIterators.removeFirst();, @@ -106,7 +106,7 @@
    */
 
   private static final class Node<K, V> extends AbstractMapEntry<K, V> {
-    @Nullable final K key;
+    final @Nullable K key;
     @Nullable V value;
     @Nullable Node<K, V> next; // the next node (with any key)
     @Nullable Node<K, V> previous; // the previous node (with any key)
@@ -150,8 +150,8 @@ public V setValue(@Nullable V newValue) {
     }
   }
 
-  @Nullable private transient Node<K, V> head; // the head for all keys
-  @Nullable private transient Node<K, V> tail; // the tail for all keys
+  private transient @Nullable Node<K, V> head; // the head for all keys
+  private transient @Nullable Node<K, V> tail; // the tail for all keys
   private transient Map<K, KeyList<K, V>> keyToKeyList;
   private transient int size;
 
@@ -454,7 +454,7 @@ public void remove() {
 
   /** A {@code ListIterator} over values for a specified key. */
   private class ValueForKeyIterator implements ListIterator<V> {
-    @Nullable final Object key;
+    final @Nullable Object key;
     int nextIndex;
     @Nullable Node<K, V> next;
     @Nullable Node<K, V> current;, @@ -314,7 +314,7 @@ static int computeArrayListCapacity(int arraySize) {
   /** @see Lists#asList(Object, Object[]) */
   private static class OnePlusArrayList<E> extends AbstractList<E>
       implements Serializable, RandomAccess {
-    @Nullable final E first;
+    final @Nullable E first;
     final E[] rest;
 
     OnePlusArrayList(@Nullable E first, E[] rest) {
@@ -340,8 +340,8 @@ public E get(int index) {
   /** @see Lists#asList(Object, Object, Object[]) */
   private static class TwoPlusArrayList<E> extends AbstractList<E>
       implements Serializable, RandomAccess {
-    @Nullable final E first;
-    @Nullable final E second;
+    final @Nullable E first;
+    final @Nullable E second;
     final E[] rest;
 
     TwoPlusArrayList(@Nullable E first, @Nullable E second, E[] rest) {, @@ -340,7 +340,7 @@ private MapMakerInternalMap(MapMaker builder, InternalEntryHelper<K, V, E, S> en
       implements InternalEntry<K, V, E> {
     final K key;
     final int hash;
-    @Nullable final E next;
+    final @Nullable E next;
 
     AbstractStrongKeyEntry(K key, int hash, @Nullable E next) {
       this.key = key;
@@ -390,15 +390,14 @@ public E getNext() {
   static final class StrongKeyStrongValueEntry<K, V>
       extends AbstractStrongKeyEntry<K, V, StrongKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, StrongKeyStrongValueEntry<K, V>> {
-    @Nullable private volatile V value = null;
+    private volatile @Nullable V value = null;
 
     StrongKeyStrongValueEntry(K key, int hash, @Nullable StrongKeyStrongValueEntry<K, V> next) {
       super(key, hash, next);
     }
 
     @Override
-    @Nullable
-    public V getValue() {
+    public @Nullable V getValue() {
       return value;
     }
 
@@ -647,7 +646,7 @@ public void setValue(
   abstract static class AbstractWeakKeyEntry<K, V, E extends InternalEntry<K, V, E>>
       extends WeakReference<K> implements InternalEntry<K, V, E> {
     final int hash;
-    @Nullable final E next;
+    final @Nullable E next;
 
     AbstractWeakKeyEntry(ReferenceQueue<K> queue, K key, int hash, @Nullable E next) {
       super(key, queue);
@@ -755,16 +754,15 @@ public void setValue(
   static final class WeakKeyStrongValueEntry<K, V>
       extends AbstractWeakKeyEntry<K, V, WeakKeyStrongValueEntry<K, V>>
       implements StrongValueEntry<K, V, WeakKeyStrongValueEntry<K, V>> {
-    @Nullable private volatile V value = null;
+    private volatile @Nullable V value = null;
 
     WeakKeyStrongValueEntry(
         ReferenceQueue<K> queue, K key, int hash, @Nullable WeakKeyStrongValueEntry<K, V> next) {
       super(queue, key, hash, next);
     }
 
     @Override
-    @Nullable
-    public V getValue() {
+    public @Nullable V getValue() {
       return value;
     }
 , @@ -92,15 +92,13 @@ private Maps() {}
   private enum EntryFunction implements Function<Entry<?, ?>, Object> {
     KEY {
       @Override
-      @Nullable
-      public Object apply(Entry<?, ?> entry) {
+      public @Nullable Object apply(Entry<?, ?> entry) {
         return entry.getKey();
       }
     },
     VALUE {
       @Override
-      @Nullable
-      public Object apply(Entry<?, ?> entry) {
+      public @Nullable Object apply(Entry<?, ?> entry) {
         return entry.getValue();
       }
     };
@@ -695,8 +693,8 @@ public String toString() {
   }
 
   static class ValueDifferenceImpl<V> implements MapDifference.ValueDifference<V> {
-    @Nullable private final V left;
-    @Nullable private final V right;
+    private final @Nullable V left;
+    private final @Nullable V right;
 
     static <V> ValueDifference<V> create(@Nullable V left, @Nullable V right) {
       return new ValueDifferenceImpl<V>(left, right);
@@ -1051,14 +1049,12 @@ public K lastKey() {
     }
 
     @Override
-    @Nullable
-    public V get(@Nullable Object key) {
+    public @Nullable V get(@Nullable Object key) {
       return getOrDefault(key, null);
     }
 
     @Override
-    @Nullable
-    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
+    public @Nullable V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
       if (Collections2.safeContains(set, key)) {
         @SuppressWarnings(""unchecked"") // unsafe, but Javadoc warns about it
         K k = (K) key;
@@ -2030,16 +2026,14 @@ public boolean containsKey(Object key) {
     }
 
     @Override
-    @Nullable
-    public V2 get(@Nullable Object key) {
+    public @Nullable V2 get(@Nullable Object key) {
       return getOrDefault(key, null);
     }
 
     // safe as long as the user followed the <b>Warning</b> in the javadoc
     @SuppressWarnings(""unchecked"")
     @Override
-    @Nullable
-    public V2 getOrDefault(@Nullable Object key, @Nullable V2 defaultValue) {
+    public @Nullable V2 getOrDefault(@Nullable Object key, @Nullable V2 defaultValue) {
       V1 value = fromMap.get(key);
       return (value != null || fromMap.containsKey(key))
           ? transformer.transformEntry((K) key, value)
@@ -2249,8 +2243,7 @@ public K lowerKey(K key) {
       return transformEntries(fromMap().tailMap(fromKey, inclusive), transformer);
     }
 
-    @Nullable
-    private Entry<K, V2> transformEntry(@Nullable Entry<K, V1> entry) {
+    private @Nullable Entry<K, V2> transformEntry(@Nullable Entry<K, V1> entry) {
       return (entry == null) ? null : Maps.transformEntry(transformer, entry);
     }
 
@@ -3128,8 +3121,7 @@ public boolean isEmpty() {
     }
 
     @Override
-    @Nullable
-    public V get(@Nullable Object key) {
+    public @Nullable V get(@Nullable Object key) {
       return filteredDelegate.get(key);
     }
 
@@ -3284,8 +3276,8 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     }
   }
 
-  @Nullable
-  private static <K, V> Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {
+  private static <K, V> @Nullable Entry<K, V> unmodifiableOrNull(
+      @Nullable Entry<K, ? extends V> entry) {
     return (entry == null) ? null : Maps.unmodifiableEntry(entry);
   }
 
@@ -3744,13 +3736,11 @@ public void clear() {
     }
   }
 
-  @Nullable
-  static <K> K keyOrNull(@Nullable Entry<K, ?> entry) {
+  static <K> @Nullable K keyOrNull(@Nullable Entry<K, ?> entry) {
     return (entry == null) ? null : entry.getKey();
   }
 
-  @Nullable
-  static <V> V valueOrNull(@Nullable Entry<?, V> entry) {
+  static <V> @Nullable V valueOrNull(@Nullable Entry<?, V> entry) {
     return (entry == null) ? null : entry.getValue();
   }
 , @@ -754,7 +754,7 @@ private int getGrandparentIndex(int i) {
     // either of them, up to the same multiplicity as the queue.
     @MonotonicNonNullDecl private Queue<E> forgetMeNot;
     @MonotonicNonNullDecl private List<E> skipMe;
-    @Nullable private E lastFromForgetMeNot;
+    private @Nullable E lastFromForgetMeNot;
     private boolean canRemove;
 
     @Override, @@ -246,7 +246,7 @@ public boolean setCount(E element, int oldCount, int newCount) {
   }
 
   static class ImmutableEntry<E> extends AbstractEntry<E> implements Serializable {
-    @Nullable private final E element;
+    private final @Nullable E element;
     private final int count;
 
     ImmutableEntry(@Nullable E element, int count) {
@@ -256,8 +256,7 @@ public boolean setCount(E element, int oldCount, int newCount) {
     }
 
     @Override
-    @Nullable
-    public final E getElement() {
+    public final @Nullable E getElement() {
       return element;
     }
 , @@ -135,8 +135,7 @@ private static int checkNoConflictInValueBucket(
   }
 
   @Override
-  @Nullable
-  public V get(@Nullable Object key) {
+  public @Nullable V get(@Nullable Object key) {
     return (keyTable == null) ? null : RegularImmutableMap.get(key, keyTable, mask);
   }
 , @@ -155,8 +155,8 @@ public V get(@Nullable Object key) {
     return get(key, table, mask);
   }
 
-  @Nullable
-  static <V> V get(@Nullable Object key, ImmutableMapEntry<?, V> @Nullable [] keyTable, int mask) {
+  static <V> @Nullable V get(
+      @Nullable Object key, ImmutableMapEntry<?, V> @Nullable [] keyTable, int mask) {
     if (key == null || keyTable == null) {
       return null;
     }, @@ -96,8 +96,8 @@ boolean isPartialView() {
 
   static <R, C, V> RegularImmutableTable<R, C, V> forCells(
       List<Cell<R, C, V>> cells,
-      @Nullable final Comparator<? super R> rowComparator,
-      @Nullable final Comparator<? super C> columnComparator) {
+      final @Nullable Comparator<? super R> rowComparator,
+      final @Nullable Comparator<? super C> columnComparator) {
     checkNotNull(cells);
     if (rowComparator != null || columnComparator != null) {
       /*, @@ -1208,14 +1208,12 @@ public E last() {
     }
 
     @Override
-    @Nullable
-    public E lower(E e) {
+    public @Nullable E lower(E e) {
       return Iterators.find(unfiltered().headSet(e, false).descendingIterator(), predicate, null);
     }
 
     @Override
-    @Nullable
-    public E floor(E e) {
+    public @Nullable E floor(E e) {
       return Iterators.find(unfiltered().headSet(e, true).descendingIterator(), predicate, null);
     }
 , @@ -151,9 +151,9 @@ private Tables() {}
   }
 
   static final class ImmutableCell<R, C, V> extends AbstractCell<R, C, V> implements Serializable {
-    @Nullable private final R rowKey;
-    @Nullable private final C columnKey;
-    @Nullable private final V value;
+    private final @Nullable R rowKey;
+    private final @Nullable C columnKey;
+    private final @Nullable V value;
 
     ImmutableCell(@Nullable R rowKey, @Nullable C columnKey, @Nullable V value) {
       this.rowKey = rowKey;, @@ -110,7 +110,7 @@
    * The largest of the lowest k elements we've seen so far relative to this comparator. If
    * bufferSize ≥ k, then we can ignore any elements greater than this value.
    */
-  @Nullable private T threshold;
+  private @Nullable T threshold;
 
   private TopKSelector(Comparator<? super T> comparator, int k) {
     this.comparator = checkNotNull(comparator, ""comparator"");, @@ -169,8 +169,8 @@
   }
 
   private class TreeRow extends Row implements SortedMap<C, V> {
-    @Nullable final C lowerBound;
-    @Nullable final C upperBound;
+    final @Nullable C lowerBound;
+    final @Nullable C upperBound;
 
     TreeRow(R rowKey) {
       this(rowKey, null, null);
@@ -243,7 +243,7 @@ public C lastKey() {
       return backingRowMap().lastKey();
     }
 
-    @Nullable transient SortedMap<C, V> wholeRow;
+    transient @Nullable SortedMap<C, V> wholeRow;
 
     /*
      * If the row was previously empty, we check if there's a new row here every, @@ -380,8 +380,7 @@ public int getCount() {
   }
 
   /** Returns the first node in the tree that is in range. */
-  @Nullable
-  private AvlNode<E> firstNode() {
+  private @Nullable AvlNode<E> firstNode() {
     AvlNode<E> root = rootReference.get();
     if (root == null) {
       return null;
@@ -403,8 +402,7 @@ public int getCount() {
     return (node == header || !range.contains(node.getElement())) ? null : node;
   }
 
-  @Nullable
-  private AvlNode<E> lastNode() {
+  private @Nullable AvlNode<E> lastNode() {
     AvlNode<E> root = rootReference.get();
     if (root == null) {
       return null;
@@ -547,10 +545,9 @@ public void forEachEntry(ObjIntConsumer<? super E> action) {
   }
 
   private static final class Reference<T> {
-    @Nullable private T value;
+    private @Nullable T value;
 
-    @Nullable
-    public T get() {
+    public @Nullable T get() {
       return value;
     }
 
@@ -567,18 +564,18 @@ void clear() {
   }
 
   private static final class AvlNode<E> {
-    @Nullable private final E elem;
+    private final @Nullable E elem;
 
     // elemCount is 0 iff this node has been deleted.
     private int elemCount;
 
     private int distinctElements;
     private long totalCount;
     private int height;
-    @Nullable private AvlNode<E> left;
-    @Nullable private AvlNode<E> right;
-    @Nullable private AvlNode<E> pred;
-    @Nullable private AvlNode<E> succ;
+    private @Nullable AvlNode<E> left;
+    private @Nullable AvlNode<E> right;
+    private @Nullable AvlNode<E> pred;
+    private @Nullable AvlNode<E> succ;
 
     AvlNode(@Nullable E elem, int elemCount) {
       checkArgument(elemCount > 0);
@@ -946,8 +943,7 @@ private static int height(@Nullable AvlNode<?> node) {
       return (node == null) ? 0 : node.height;
     }
 
-    @Nullable
-    private AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {
+    private @Nullable AvlNode<E> ceiling(Comparator<? super E> comparator, E e) {
       int cmp = comparator.compare(e, elem);
       if (cmp < 0) {
         return (left == null) ? this : MoreObjects.firstNonNull(left.ceiling(comparator, e), this);
@@ -958,8 +954,7 @@ private static int height(@Nullable AvlNode<?> node) {
       }
     }
 
-    @Nullable
-    private AvlNode<E> floor(Comparator<? super E> comparator, E e) {
+    private @Nullable AvlNode<E> floor(Comparator<? super E> comparator, E e) {
       int cmp = comparator.compare(e, elem);
       if (cmp > 0) {
         return (right == null) ? this : MoreObjects.firstNonNull(right.floor(comparator, e), this);, @@ -100,15 +100,13 @@ public boolean contains(K value) {
   }
 
   @Override
-  @Nullable
-  public V get(K key) {
+  public @Nullable V get(K key) {
     Entry<Range<K>, V> entry = getEntry(key);
     return (entry == null) ? null : entry.getValue();
   }
 
   @Override
-  @Nullable
-  public Entry<Range<K>, V> getEntry(K key) {
+  public @Nullable Entry<Range<K>, V> getEntry(K key) {
     Entry<Cut<K>, RangeMapEntry<K, V>> mapEntry =
         entriesByLowerBound.floorEntry(Cut.belowValue(key));
     if (mapEntry != null && mapEntry.getValue().contains(key)) {
@@ -305,14 +303,12 @@ public int size() {
   private static final RangeMap EMPTY_SUB_RANGE_MAP =
       new RangeMap() {
         @Override
-        @Nullable
-        public Object get(Comparable key) {
+        public @Nullable Object get(Comparable key) {
           return null;
         }
 
         @Override
-        @Nullable
-        public Entry<Range, Object> getEntry(Comparable key) {
+        public @Nullable Entry<Range, Object> getEntry(Comparable key) {
           return null;
         }
 
@@ -377,14 +373,12 @@ public RangeMap subRangeMap(Range range) {
     }
 
     @Override
-    @Nullable
-    public V get(K key) {
+    public @Nullable V get(K key) {
       return subRange.contains(key) ? TreeRangeMap.this.get(key) : null;
     }
 
     @Override
-    @Nullable
-    public Entry<Range<K>, V> getEntry(K key) {
+    public @Nullable Entry<Range<K>, V> getEntry(K key) {
       if (subRange.contains(key)) {
         Entry<Range<K>, V> entry = TreeRangeMap.this.getEntry(key);
         if (entry != null) {, @@ -119,8 +119,7 @@ public boolean equals(@Nullable Object o) {
   }
 
   @Override
-  @Nullable
-  public Range<C> rangeContaining(C value) {
+  public @Nullable Range<C> rangeContaining(C value) {
     checkNotNull(value);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(Cut.belowValue(value));
     if (floorEntry != null && floorEntry.getValue().contains(value)) {
@@ -153,8 +152,7 @@ public boolean encloses(Range<C> range) {
     return floorEntry != null && floorEntry.getValue().encloses(range);
   }
 
-  @Nullable
-  private Range<C> rangeEnclosing(Range<C> range) {
+  private @Nullable Range<C> rangeEnclosing(Range<C> range) {
     checkNotNull(range);
     Entry<Cut<C>, Range<C>> floorEntry = rangesByLowerBound.floorEntry(range.lowerBound);
     return (floorEntry != null && floorEntry.getValue().encloses(range))
@@ -625,8 +623,7 @@ public int size() {
     }
 
     @Override
-    @Nullable
-    public Range<C> get(Object key) {
+    public @Nullable Range<C> get(Object key) {
       if (key instanceof Cut) {
         try {
           @SuppressWarnings(""unchecked"")
@@ -743,8 +740,7 @@ public boolean containsKey(@Nullable Object key) {
     }
 
     @Override
-    @Nullable
-    public Range<C> get(@Nullable Object key) {
+    public @Nullable Range<C> get(@Nullable Object key) {
       if (key instanceof Cut) {
         try {
           @SuppressWarnings(""unchecked"") // we catch CCE's
@@ -881,8 +877,7 @@ public boolean encloses(Range<C> range) {
     }
 
     @Override
-    @Nullable
-    public Range<C> rangeContaining(C value) {
+    public @Nullable Range<C> rangeContaining(C value) {
       if (!restriction.contains(value)) {
         return null;
       }, @@ -192,8 +192,7 @@ public boolean apply(E edge) {
   }
 
   @Override
-  @Nullable
-  public E edgeConnectingOrNull(N nodeU, N nodeV) {
+  public @Nullable E edgeConnectingOrNull(N nodeU, N nodeV) {
     return edgeConnecting(nodeU, nodeV).orElse(null);
   }
 , @@ -123,8 +123,7 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
   }
 
   @Override
-  @Nullable
-  public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
+  public @Nullable V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
     checkNotNull(nodeU);
     checkNotNull(nodeV);
     GraphConnections<N, V> connectionsU = nodeConnections.get(nodeU);, @@ -139,8 +139,7 @@ public void addOutEdge(E edge, N node) {
     }
   }
 
-  @Nullable
-  private static <T> T getReference(@Nullable Reference<T> reference) {
+  private static <T> @Nullable T getReference(@Nullable Reference<T> reference) {
     return (reference == null) ? null : reference.get();
   }
 }, @@ -63,8 +63,7 @@ public boolean contains(@Nullable Object edge) {
     return (connectingEdge != null && connectingEdge.equals(edge));
   }
 
-  @Nullable
-  private E getConnectingEdge() {
+  private @Nullable E getConnectingEdge() {
     return nodeToOutEdge.get(targetNode);
   }
 }, @@ -50,8 +50,7 @@
   private final Type type;
 
   @SuppressWarnings(""Immutable"") // Hopefully the comparator provided is immutable!
-  @Nullable
-  private final Comparator<T> comparator;
+  private final @Nullable Comparator<T> comparator;
 
   /**
    * The type of ordering that this object specifies., @@ -101,8 +101,7 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
   }
 
   @Override
-  @Nullable
-  public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
+  public @Nullable V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
     return delegate().edgeValueOrDefault(nodeU, nodeV, defaultValue);
   }
 }, @@ -344,8 +344,7 @@ public boolean hasEdgeConnecting(N nodeU, N nodeV) {
     }
 
     @Override
-    @Nullable
-    public V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
+    public @Nullable V edgeValueOrDefault(N nodeU, N nodeV, @Nullable V defaultValue) {
       return delegate().edgeValueOrDefault(nodeV, nodeU, defaultValue); // transpose
     }
   }, @@ -47,7 +47,7 @@
   // Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
   // the entry was returned by the iterator, except through the setValue operation on the map entry""
   // As such, this field must be cleared before every map mutation.
-  @Nullable private transient Entry<K, V> entrySetCache;
+  private transient @Nullable Entry<K, V> entrySetCache;
 
   MapIteratorCache(Map<K, V> backingMap) {
     this.backingMap = checkNotNull(backingMap);, @@ -26,8 +26,8 @@
  * @author James Sexton
  */
 class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
-  @Nullable private transient CacheEntry<K, V> cacheEntry1;
-  @Nullable private transient CacheEntry<K, V> cacheEntry2;
+  private transient @Nullable CacheEntry<K, V> cacheEntry1;
+  private transient @Nullable CacheEntry<K, V> cacheEntry2;
 
   MapRetrievalCache(Map<K, V> backingMap) {
     super(backingMap);, @@ -471,7 +471,7 @@ NodeAndSuccessors withSuccessors(N node) {
 
       /** A simple tuple of a node and a partially iterated {@link Iterator} of its successors. */
       private final class NodeAndSuccessors {
-        @Nullable final N node;
+        final @Nullable N node;
         final Iterator<? extends N> successorIterator;
 
         NodeAndSuccessors(@Nullable N node, Iterable<? extends N> successors) {
@@ -644,7 +644,7 @@ NodeAndChildren withChildren(N node) {
 
       /** A simple tuple of a node and a partially iterated {@link Iterator} of its children. */
       private final class NodeAndChildren {
-        @Nullable final N node;
+        final @Nullable N node;
         final Iterator<? extends N> childIterator;
 
         NodeAndChildren(@Nullable N node, Iterable<? extends N> children) {, @@ -115,8 +115,7 @@ public void addOutEdge(E edge, N node) {
     }
   }
 
-  @Nullable
-  private static <T> T getReference(@Nullable Reference<T> reference) {
+  private static <T> @Nullable T getReference(@Nullable Reference<T> reference) {
     return (reference == null) ? null : reference.get();
   }
 }, @@ -567,7 +567,7 @@ public int hashCode() {
     // TODO(lowasser): provide a useful toString
     final Alphabet alphabet;
 
-    @Nullable final Character paddingChar;
+    final @Nullable Character paddingChar;
 
     StandardBaseEncoding(String name, String alphabetChars, @Nullable Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);, @@ -295,8 +295,7 @@ public String read() throws IOException {
    *
    * @throws IOException if an I/O error occurs while reading from this source
    */
-  @Nullable
-  public String readFirstLine() throws IOException {
+  public @Nullable String readFirstLine() throws IOException {
     Closer closer = Closer.create();
     try {
       BufferedReader reader = closer.register(openBufferedStream());, @@ -46,7 +46,7 @@
 
   private OutputStream out;
   private MemoryOutput memory;
-  @Nullable private File file;
+  private @Nullable File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
   private static class MemoryOutput extends ByteArrayOutputStream {, @@ -39,7 +39,7 @@
 @GwtIncompatible
 public final class LineReader {
   private final Readable readable;
-  @Nullable private final Reader reader;
+  private final @Nullable Reader reader;
   private final CharBuffer cbuf = createBuffer();
   private final char[] buf = cbuf.array();
 , @@ -611,8 +611,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of exceptions
    * that occurred or null if no exceptions were thrown.
    */
-  @Nullable
-  private static Collection<IOException> deleteRecursivelySecure(
+  private static @Nullable Collection<IOException> deleteRecursivelySecure(
       SecureDirectoryStream<Path> dir, Path path) {
     Collection<IOException> exceptions = null;
     try {
@@ -640,8 +639,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  @Nullable
-  private static Collection<IOException> deleteDirectoryContentsSecure(
+  private static @Nullable Collection<IOException> deleteDirectoryContentsSecure(
       SecureDirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
     try {
@@ -659,8 +657,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  @Nullable
-  private static Collection<IOException> deleteRecursivelyInsecure(Path path) {
+  private static @Nullable Collection<IOException> deleteRecursivelyInsecure(Path path) {
     Collection<IOException> exceptions = null;
     try {
       if (Files.isDirectory(path, NOFOLLOW_LINKS)) {
@@ -686,8 +683,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or null
    * if no exceptions were thrown.
    */
-  @Nullable
-  private static Collection<IOException> deleteDirectoryContentsInsecure(
+  private static @Nullable Collection<IOException> deleteDirectoryContentsInsecure(
       DirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
     try {
@@ -706,8 +702,7 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path
    * is a root or is the empty path.
    */
-  @Nullable
-  private static Path getParentPath(Path path) {
+  private static @Nullable Path getParentPath(Path path) {
     Path parent = path.getParent();
 
     // Paths that have a parent:
@@ -766,8 +761,7 @@ private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] optio
    * null, the other collection is returned. Otherwise, the elements of {@code other} are added to
    * {@code exceptions} and {@code exceptions} is returned.
    */
-  @Nullable
-  private static Collection<IOException> concat(
+  private static @Nullable Collection<IOException> concat(
       @Nullable Collection<IOException> exceptions, @Nullable Collection<IOException> other) {
     if (exceptions == null) {
       return other;, @@ -33,7 +33,7 @@
 final class MultiInputStream extends InputStream {
 
   private Iterator<? extends ByteSource> it;
-  @Nullable private InputStream in;
+  private @Nullable InputStream in;
 
   /**
    * Creates a new instance., @@ -30,7 +30,7 @@
 @GwtIncompatible
 class MultiReader extends Reader {
   private final Iterator<? extends CharSource> it;
-  @Nullable private Reader current;
+  private @Nullable Reader current;
 
   MultiReader(Iterator<? extends CharSource> readers) throws IOException {
     this.it = readers;, @@ -682,9 +682,8 @@ private static Pattern fpPattern() {
    * @since 14.0
    */
   @Beta
-  @Nullable
   @GwtIncompatible // regular expressions
-  public static Double tryParse(String string) {
+  public static @Nullable Double tryParse(String string) {
     if (FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with
       // extensive testing, @@ -649,9 +649,8 @@ public String toString() {
    * @since 14.0
    */
   @Beta
-  @Nullable
   @GwtIncompatible // regular expressions
-  public static Float tryParse(String string) {
+  public static @Nullable Float tryParse(String string) {
     if (Doubles.FLOATING_POINT_PATTERN.matcher(string).matches()) {
       // TODO(lowasser): could be potentially optimized, but only with
       // extensive testing, @@ -707,8 +707,7 @@ public String toString() {
    * @since 11.0
    */
   @Beta
-  @Nullable
-  public static Integer tryParse(String string) {
+  public static @Nullable Integer tryParse(String string) {
     return tryParse(string, 10);
   }
 
@@ -732,8 +731,7 @@ public static Integer tryParse(String string) {
    * @since 19.0
    */
   @Beta
-  @Nullable
-  public static Integer tryParse(String string, int radix) {
+  public static @Nullable Integer tryParse(String string, int radix) {
     Long result = Longs.tryParse(string, radix);
     if (result == null || result.longValue() != result.intValue()) {
       return null;, @@ -362,8 +362,7 @@ static int digit(char c) {
    * @since 14.0
    */
   @Beta
-  @Nullable
-  public static Long tryParse(String string) {
+  public static @Nullable Long tryParse(String string) {
     return tryParse(string, 10);
   }
 
@@ -387,8 +386,7 @@ public static Long tryParse(String string) {
    * @since 19.0
    */
   @Beta
-  @Nullable
-  public static Long tryParse(String string, int radix) {
+  public static @Nullable Long tryParse(String string, int radix) {
     if (checkNotNull(string).isEmpty()) {
       return null;
     }, @@ -41,29 +41,25 @@
 
   private final Map<TypeToken<? extends B>, B> backingMap = Maps.newHashMap();
 
-  @Nullable
   @Override
-  public <T extends B> T getInstance(Class<T> type) {
+  public <T extends B> @Nullable T getInstance(Class<T> type) {
     return trustedGet(TypeToken.of(type));
   }
 
-  @Nullable
   @Override
-  public <T extends B> T getInstance(TypeToken<T> type) {
+  public <T extends B> @Nullable T getInstance(TypeToken<T> type) {
     return trustedGet(type.rejectTypeVariables());
   }
 
-  @Nullable
   @Override
   @CanIgnoreReturnValue
-  public <T extends B> T putInstance(Class<T> type, @Nullable T value) {
+  public <T extends B> @Nullable T putInstance(Class<T> type, @Nullable T value) {
     return trustedPut(TypeToken.of(type), value);
   }
 
-  @Nullable
   @Override
   @CanIgnoreReturnValue
-  public <T extends B> T putInstance(TypeToken<T> type, @Nullable T value) {
+  public <T extends B> @Nullable T putInstance(TypeToken<T> type, @Nullable T value) {
     return trustedPut(type.rejectTypeVariables(), value);
   }
 
@@ -103,14 +99,12 @@ public void putAll(Map<? extends TypeToken<? extends B>, ? extends B> map) {
   }
 
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @Nullable
-  private <T extends B> T trustedPut(TypeToken<T> type, @Nullable T value) {
+  private <T extends B> @Nullable T trustedPut(TypeToken<T> type, @Nullable T value) {
     return (T) backingMap.put(type, value);
   }
 
   @SuppressWarnings(""unchecked"") // value could not get in if not a T
-  @Nullable
-  private <T extends B> T trustedGet(TypeToken<T> type) {
+  private <T extends B> @Nullable T trustedGet(TypeToken<T> type) {
     return (T) backingMap.get(type);
   }
 , @@ -68,8 +68,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   }
 
   @Override
-  @Nullable
-  public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+  public <A extends Annotation> @Nullable A getAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     for (Annotation annotation : annotations) {
       if (annotationType.isInstance(annotation)) {
@@ -99,8 +98,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
 
   /** @since 18.0 */
   // @Override on JDK8
-  @Nullable
-  public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationType) {
+  public <A extends Annotation> @Nullable A getDeclaredAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     return FluentIterable.from(annotations).filter(annotationType).first().orNull();
   }, @@ -49,16 +49,14 @@
    * <p>{@code getInstance(Foo.class)} is equivalent to {@code
    * getInstance(TypeToken.of(Foo.class))}.
    */
-  @Nullable
-  <T extends B> T getInstance(Class<T> type);
+  <T extends B> @Nullable T getInstance(Class<T> type);
 
   /**
    * Returns the value the specified type is mapped to, or {@code null} if no entry for this type is
    * present. This will only return a value that was bound to this specific type, not a value that
    * may have been bound to a subtype.
    */
-  @Nullable
-  <T extends B> T getInstance(TypeToken<T> type);
+  <T extends B> @Nullable T getInstance(TypeToken<T> type);
 
   /**
    * Maps the specified class to the specified value. Does <i>not</i> associate this value with any
@@ -70,9 +68,8 @@
    * @return the value previously associated with this class (possibly {@code null}), or {@code
    *     null} if there was no previous entry.
    */
-  @Nullable
   @CanIgnoreReturnValue
-  <T extends B> T putInstance(Class<T> type, @Nullable T value);
+  <T extends B> @Nullable T putInstance(Class<T> type, @Nullable T value);
 
   /**
    * Maps the specified type to the specified value. Does <i>not</i> associate this value with any
@@ -81,7 +78,6 @@
    * @return the value previously associated with this type (possibly {@code null}), or {@code null}
    *     if there was no previous entry.
    */
-  @Nullable
   @CanIgnoreReturnValue
-  <T extends B> T putInstance(TypeToken<T> type, @Nullable T value);
+  <T extends B> @Nullable T putInstance(TypeToken<T> type, @Nullable T value);
 }, @@ -289,8 +289,7 @@ public final Type getType() {
    * if the bound is a class or extends from a class. This means that the returned type could be a
    * type variable too.
    */
-  @Nullable
-  final TypeToken<? super T> getGenericSuperclass() {
+  final @Nullable TypeToken<? super T> getGenericSuperclass() {
     if (runtimeType instanceof TypeVariable) {
       // First bound is always the super class, if one exists.
       return boundAsSuperclass(((TypeVariable<?>) runtimeType).getBounds()[0]);
@@ -308,8 +307,7 @@ public final Type getType() {
     return superToken;
   }
 
-  @Nullable
-  private TypeToken<? super T> boundAsSuperclass(Type bound) {
+  private @Nullable TypeToken<? super T> boundAsSuperclass(Type bound) {
     TypeToken<?> token = of(bound);
     if (token.getRawType().isInterface()) {
       return null;
@@ -561,8 +559,7 @@ private boolean isWrapper() {
    * Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},
    * {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.
    */
-  @Nullable
-  public final TypeToken<?> getComponentType() {
+  public final @Nullable TypeToken<?> getComponentType() {
     Type componentType = Types.getComponentType(runtimeType);
     if (componentType == null) {
       return null;
@@ -1133,8 +1130,7 @@ private boolean isOwnedBySubtypeOf(Type supertype) {
    * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class}, or
    * null otherwise.
    */
-  @Nullable
-  private Type getOwnerTypeIfPresent() {
+  private @Nullable Type getOwnerTypeIfPresent() {
     if (runtimeType instanceof ParameterizedType) {
       return ((ParameterizedType) runtimeType).getOwnerType();
     } else if (runtimeType instanceof Class<?>) {
@@ -1310,8 +1306,8 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
             return type.getGenericInterfaces();
           }
 
-          @Nullable
           @Override
+          @Nullable
           TypeToken<?> getSuperclass(TypeToken<?> type) {
             return type.getGenericSuperclass();
           }
@@ -1329,8 +1325,8 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
             return Arrays.asList(type.getInterfaces());
           }
 
-          @Nullable
           @Override
+          @Nullable
           Class<?> getSuperclass(Class<?> type) {
             return type.getSuperclass();
           }
@@ -1412,8 +1408,7 @@ public int compare(K left, K right) {
 
     abstract Iterable<? extends K> getInterfaces(K type);
 
-    @Nullable
-    abstract K getSuperclass(K type);
+    abstract @Nullable K getSuperclass(K type);
 
     private static class ForwardingTypeCollector<K> extends TypeCollector<K> {
 , @@ -105,15 +105,15 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
   /** Decides what owner type to use for constructing {@link ParameterizedType} from a raw class. */
   private enum ClassOwnership {
     OWNED_BY_ENCLOSING_CLASS {
-      @Nullable
       @Override
+      @Nullable
       Class<?> getOwnerType(Class<?> rawType) {
         return rawType.getEnclosingClass();
       }
     },
     LOCAL_CLASS_HAS_NO_OWNER {
-      @Nullable
       @Override
+      @Nullable
       Class<?> getOwnerType(Class<?> rawType) {
         if (rawType.isLocalClass()) {
           return null;
@@ -123,8 +123,7 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
       }
     };
 
-    @Nullable
-    abstract Class<?> getOwnerType(Class<?> rawType);
+    abstract @Nullable Class<?> getOwnerType(Class<?> rawType);
 
     static final ClassOwnership JVM_BEHAVIOR = detectJvmBehavior();
 
@@ -172,8 +171,7 @@ static String toString(Type type) {
     return (type instanceof Class) ? ((Class<?>) type).getName() : type.toString();
   }
 
-  @Nullable
-  static Type getComponentType(Type type) {
+  static @Nullable Type getComponentType(Type type) {
     checkNotNull(type);
     final AtomicReference<Type> result = new AtomicReference<>();
     new TypeVisitor() {
@@ -204,8 +202,7 @@ void visitClass(Class<?> t) {
    * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null
    * otherwise.
    */
-  @Nullable
-  private static Type subtypeOfComponentType(Type[] bounds) {
+  private static @Nullable Type subtypeOfComponentType(Type[] bounds) {
     for (Type bound : bounds) {
       Type componentType = getComponentType(bound);
       if (componentType != null) {
@@ -260,7 +257,7 @@ public boolean equals(Object obj) {
 
   private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
 
-    @Nullable private final Type ownerType;
+    private final @Nullable Type ownerType;
     private final ImmutableList<Type> argumentsList;
     private final Class<?> rawType;
 , @@ -141,8 +141,7 @@ protected String pendingToString() {
 
   /** Template method for subtypes to actually run the fallback. */
   @ForOverride
-  @Nullable
-  abstract T doFallback(F fallback, X throwable) throws Exception;
+  abstract @Nullable T doFallback(F fallback, X throwable) throws Exception;
 
   /** Template method for subtypes to actually set the result. */
   @ForOverride, @@ -170,8 +170,8 @@ public final boolean cancel(boolean mayInterruptIfRunning) {
   private static final class Waiter {
     static final Waiter TOMBSTONE = new Waiter(false /* ignored param */);
 
-    @Nullable volatile Thread thread;
-    @Nullable volatile Waiter next;
+    volatile @Nullable Thread thread;
+    volatile @Nullable Waiter next;
 
     /**
      * Constructor for the TOMBSTONE, avoids use of ATOMIC_HELPER in case this class is loaded
@@ -293,7 +293,7 @@ public synchronized Throwable fillInStackTrace() {
     }
 
     final boolean wasInterrupted;
-    @Nullable final Throwable cause;
+    final @Nullable Throwable cause;
 
     Cancellation(boolean wasInterrupted, @Nullable Throwable cause) {
       this.wasInterrupted = wasInterrupted;
@@ -341,13 +341,13 @@ public void run() {
    *       argument.
    * </ul>
    */
-  @Nullable private volatile Object value;
+  private volatile @Nullable Object value;
 
   /** All listeners. */
-  @Nullable private volatile Listener listeners;
+  private volatile @Nullable Listener listeners;
 
   /** All waiting threads. */
-  @Nullable private volatile Waiter waiters;
+  private volatile @Nullable Waiter waiters;
 
   /** Constructor for use by subclasses. */
   protected AbstractFuture() {}
@@ -978,8 +978,7 @@ public String toString() {
    * @return null if an explanation cannot be provided because the future is done.
    * @since 23.0
    */
-  @Nullable
-  protected String pendingToString() {
+  protected @Nullable String pendingToString() {
     Object localValue = value;
     if (localValue instanceof SetFuture) {
       return ""setFuture=["" + userObjectToString(((SetFuture) localValue).future) + ""]"";, @@ -466,8 +466,7 @@ public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutExc
 
       /** The future that represents the next execution of this task. */
       @GuardedBy(""lock"")
-      @Nullable
-      private Future<Void> currentFuture;
+      private @Nullable Future<Void> currentFuture;
 
       ReschedulableCallable(
           AbstractService service, ScheduledExecutorService executor, Runnable runnable) {, @@ -551,7 +551,7 @@ public String toString() {
      * The exception that caused this service to fail. This will be {@code null} unless the service
      * has failed.
      */
-    @Nullable final Throwable failure;
+    final @Nullable Throwable failure;
 
     StateSnapshot(State internalState) {
       this(internalState, false, null);, @@ -162,8 +162,7 @@ public final void run() {
 
   /** Template method for subtypes to actually run the transform. */
   @ForOverride
-  @Nullable
-  abstract T doTransform(F function, @Nullable I result) throws Exception;
+  abstract @Nullable T doTransform(F function, @Nullable I result) throws Exception;
 
   /** Template method for subtypes to actually set the result. */
   @ForOverride, @@ -44,7 +44,7 @@
    * In certain circumstances, this field might theoretically not be visible to an afterDone() call
    * triggered by cancel(). For details, see the comments on the fields of TimeoutFuture.
    */
-  @Nullable private RunningState runningState;
+  private @Nullable RunningState runningState;
 
   @Override
   protected final void afterDone() {, @@ -34,7 +34,7 @@
   private Callables() {}
 
   /** Creates a {@code Callable} which immediately returns a preset value each time it is called. */
-  public static <T> Callable<T> returning(@Nullable final T value) {
+  public static <T> Callable<T> returning(final @Nullable T value) {
     return new Callable<T>() {
       @Override
       public T call() {, @@ -674,8 +674,7 @@ void checkAcquiredLock(Policy policy, LockGraphNode acquiredLock) {
      * @return If a path was found, a chained {@link ExampleStackTrace} illustrating the path to the
      *     {@code lock}, or {@code null} if no path was found.
      */
-    @Nullable
-    private ExampleStackTrace findPathTo(LockGraphNode node, Set<LockGraphNode> seen) {
+    private @Nullable ExampleStackTrace findPathTo(LockGraphNode node, Set<LockGraphNode> seen) {
       if (!seen.add(this)) {
         return null; // Already traversed this node.
       }, @@ -49,8 +49,7 @@
    * RunnableExecutorPair#next} field.
    */
   @GuardedBy(""this"")
-  @Nullable
-  private RunnableExecutorPair runnables;
+  private @Nullable RunnableExecutorPair runnables;
 
   @GuardedBy(""this"")
   private boolean executed;, @@ -257,8 +257,7 @@ public Boolean apply(Constructor<?> input) {
               })
           .reverse();
 
-  @Nullable
-  private static <X> X newFromConstructor(Constructor<X> constructor, Throwable cause) {
+  private static <X> @Nullable X newFromConstructor(Constructor<X> constructor, Throwable cause) {
     Class<?>[] paramTypes = constructor.getParameterTypes();
     Object[] params = new Object[paramTypes.length];
     for (int i = 0; i < paramTypes.length; i++) {, @@ -73,7 +73,7 @@ public boolean isDone() {
 
   static class ImmediateSuccessfulFuture<V> extends ImmediateFuture<V> {
     static final ImmediateSuccessfulFuture<Object> NULL = new ImmediateSuccessfulFuture<>(null);
-    @Nullable private final V value;
+    private final @Nullable V value;
 
     ImmediateSuccessfulFuture(@Nullable V value) {
       this.value = value;
@@ -95,7 +95,7 @@ public String toString() {
   @GwtIncompatible // TODO
   static class ImmediateSuccessfulCheckedFuture<V, X extends Exception> extends ImmediateFuture<V>
       implements CheckedFuture<V, X> {
-    @Nullable private final V value;
+    private final @Nullable V value;
 
     ImmediateSuccessfulCheckedFuture(@Nullable V value) {
       this.value = value;, @@ -70,8 +70,8 @@
    * write-barriers).
    */
 
-  @Nullable private ListenableFuture<V> delegateRef;
-  @Nullable private Future<?> timer;
+  private @Nullable ListenableFuture<V> delegateRef;
+  private @Nullable Future<?> timer;
 
   private TimeoutFuture(ListenableFuture<V> delegate) {
     this.delegateRef = Preconditions.checkNotNull(delegate);, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Move type annotations immediately before the type they apply
to

Fixes #3145

RELNOTES=N/A

4270efbda891a947c1bfdb3e5707741a63b40551",Moe Sync
3148,Ron Shapiro,"['android/guava-tests/test/com/google/common/base/PreconditionsTest.java', 'android/guava/src/com/google/common/base/Preconditions.java', 'android/guava/src/com/google/common/base/Verify.java', 'guava-gwt/test/com/google/common/base/PreconditionsTest_gwt.java', 'guava-tests/test/com/google/common/base/PreconditionsTest.java', 'guava/src/com/google/common/base/Preconditions.java', 'guava/src/com/google/common/base/Verify.java']","@@ -16,7 +16,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -379,25 +378,6 @@ public void testCheckPositionIndexes_reversed() {
     }
   }
 
-  public void testFormat() {
-    assertEquals(""%s"", Preconditions.format(""%s""));
-    assertEquals(""5"", Preconditions.format(""%s"", 5));
-    assertEquals(""foo [5]"", Preconditions.format(""foo"", 5));
-    assertEquals(""foo [5, 6, 7]"", Preconditions.format(""foo"", 5, 6, 7));
-    assertEquals(""%s 1 2"", Preconditions.format(""%s %s %s"", ""%s"", 1, 2));
-    assertEquals("" [5, 6]"", Preconditions.format("""", 5, 6));
-    assertEquals(""123"", Preconditions.format(""%s%s%s"", 1, 2, 3));
-    assertEquals(""1%s%s"", Preconditions.format(""%s%s%s"", 1));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""%s + 6 = 11"", 5));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""5 + %s = 11"", 6));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""5 + 6 = %s"", 11));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""%s + %s = %s"", 5, 6, 11));
-    assertEquals(""null [null, null]"", Preconditions.format(""%s"", null, null, null));
-    assertEquals(""null [5, 6]"", Preconditions.format(null, 5, 6));
-    assertEquals(""null"", Preconditions.format(""%s"", (Object) null));
-    assertEquals(""(Object[])null"", Preconditions.format(""%s"", (Object[]) null));
-  }
-
   @GwtIncompatible(""Reflection"")
   public void testAllOverloads_checkArgument() throws Exception {
     for (ImmutableList<Class<?>> sig : allSignatures(boolean.class)) {
@@ -463,7 +443,7 @@ private void assertFailureCause(
       assertThat(throwable).hasMessage("""");
     } else {
       assertThat(throwable)
-          .hasMessage(Preconditions.format("""", Arrays.copyOfRange(params, 2, params.length)));
+          .hasMessage(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
     }
   }
 
@@ -534,20 +514,20 @@ public void overloadSelection() {
     int anInt = 1;
     // With a boxed predicate, no overloads can be selected in phase 1
     // ambiguous without the call to .booleanValue to unbox the Boolean
-    checkState(boxedBoolean.booleanValue(), """", 1);
+    Preconditions.checkState(boxedBoolean.booleanValue(), """", 1);
     // ambiguous without the cast to Object because the boxed predicate prevents any overload from
     // being selected in phase 1
-    checkState(boxedBoolean, """", (Object) boxedLong);
+    Preconditions.checkState(boxedBoolean, """", (Object) boxedLong);
 
     // ternaries introduce their own problems. because of the ternary (which requires a boxing
     // operation) no overload can be selected in phase 1.  and in phase 2 it is ambiguous since it
     // matches with the second parameter being boxed and without it being boxed.  The cast to Object
     // avoids this.
-    checkState(aBoolean, """", aBoolean ? """" : anInt, (Object) anInt);
+    Preconditions.checkState(aBoolean, """", aBoolean ? """" : anInt, (Object) anInt);
 
     // ambiguous without the .booleanValue() call since the boxing forces us into phase 2 resolution
     short s = 2;
-    checkState(boxedBoolean.booleanValue(), """", s);
+    Preconditions.checkState(boxedBoolean.booleanValue(), """", s);
   }
 
   @GwtIncompatible // NullPointerTester, @@ -14,6 +14,8 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Strings.lenientFormat;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
@@ -94,8 +96,12 @@
  *
  * <h3>Only {@code %s} is supported</h3>
  *
- * <p>In {@code Preconditions} error message template strings, only the {@code ""%s""} specifier is
- * supported, not the full range of {@link java.util.Formatter} specifiers.
+ * <p>{@code Preconditions} uses {@link Strings#lenientFormat} to format error message template
+ * strings. This only supports the {@code ""%s""} specifier, not the full range of {@link
+ * java.util.Formatter} specifiers. However, note that if the number of arguments does not match the
+ * number of occurrences of {@code ""%s""} in the format string, {@code Preconditions} will still
+ * behave as expected, and will still include all argument values in the error message; the message
+ * will simply not be formatted exactly as intended.
  *
  * <h3>More information</h3>
  *
@@ -154,7 +160,7 @@ public static void checkArgument(
       @NullableDecl String errorMessageTemplate,
       @NullableDecl Object... errorMessageArgs) {
     if (!expression) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -167,7 +173,7 @@ public static void checkArgument(
    */
   public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, char p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -180,7 +186,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
    */
   public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, int p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -193,7 +199,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
    */
   public static void checkArgument(boolean b, @NullableDecl String errorMessageTemplate, long p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -207,7 +213,7 @@ public static void checkArgument(boolean b, @NullableDecl String errorMessageTem
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -221,7 +227,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -235,7 +241,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -249,7 +255,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -263,7 +269,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -277,7 +283,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -291,7 +297,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -305,7 +311,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -319,7 +325,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -333,7 +339,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -347,7 +353,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -361,7 +367,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -375,7 +381,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -389,7 +395,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -403,7 +409,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -417,7 +423,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -434,7 +440,7 @@ public static void checkArgument(
       @NullableDecl Object p1,
       @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -452,7 +458,7 @@ public static void checkArgument(
       @NullableDecl Object p2,
       @NullableDecl Object p3) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -471,7 +477,7 @@ public static void checkArgument(
       @NullableDecl Object p3,
       @NullableDecl Object p4) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 
@@ -525,7 +531,7 @@ public static void checkState(
       @NullableDecl String errorMessageTemplate,
       @NullableDecl Object... errorMessageArgs) {
     if (!expression) {
-      throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -539,7 +545,7 @@ public static void checkState(
    */
   public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, char p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -553,7 +559,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
    */
   public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, int p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -567,7 +573,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
    */
   public static void checkState(boolean b, @NullableDecl String errorMessageTemplate, long p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -582,7 +588,7 @@ public static void checkState(boolean b, @NullableDecl String errorMessageTempla
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -597,7 +603,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -612,7 +618,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -627,7 +633,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -642,7 +648,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -657,7 +663,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -672,7 +678,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -687,7 +693,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -702,7 +708,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -717,7 +723,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -732,7 +738,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -747,7 +753,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -762,7 +768,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -777,7 +783,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -792,7 +798,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -807,7 +813,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -825,7 +831,7 @@ public static void checkState(
       @NullableDecl Object p1,
       @NullableDecl Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -844,7 +850,7 @@ public static void checkState(
       @NullableDecl Object p2,
       @NullableDecl Object p3) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -864,7 +870,7 @@ public static void checkState(
       @NullableDecl Object p3,
       @NullableDecl Object p4) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 
@@ -923,7 +929,7 @@ public static void checkState(
       @NullableDecl String errorMessageTemplate,
       @NullableDecl Object... errorMessageArgs) {
     if (reference == null) {
-      throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
     return reference;
   }
@@ -938,7 +944,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, char p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -953,7 +959,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, int p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -968,7 +974,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @NullableDecl String errorMessageTemplate, long p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -984,7 +990,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -1000,7 +1006,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, char p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1016,7 +1022,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, char p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1032,7 +1038,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, char p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1048,7 +1054,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, char p1, @NullableDecl Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1064,7 +1070,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, int p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1080,7 +1086,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, int p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1096,7 +1102,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, int p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1112,7 +1118,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, int p1, @NullableDecl Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1128,7 +1134,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, long p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1144,7 +1150,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, long p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1160,7 +1166,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, long p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1176,7 +1182,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, long p1, @NullableDecl Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1192,7 +1198,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1208,7 +1214,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1224,7 +1230,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1243,7 +1249,7 @@ public static void checkState(
       @NullableDecl Object p1,
       @NullableDecl Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1263,7 +1269,7 @@ public static void checkState(
       @NullableDecl Object p2,
       @NullableDecl Object p3) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
     return obj;
   }
@@ -1284,7 +1290,7 @@ public static void checkState(
       @NullableDecl Object p3,
       @NullableDecl Object p4) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
     return obj;
   }
@@ -1352,11 +1358,11 @@ public static int checkElementIndex(int index, int size, @NullableDecl String de
 
   private static String badElementIndex(int index, int size, @NullableDecl String desc) {
     if (index < 0) {
-      return format(""%s (%s) must not be negative"", desc, index);
+      return lenientFormat(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
       throw new IllegalArgumentException(""negative size: "" + size);
     } else { // index >= size
-      return format(""%s (%s) must be less than size (%s)"", desc, index, size);
+      return lenientFormat(""%s (%s) must be less than size (%s)"", desc, index, size);
     }
   }
 
@@ -1397,11 +1403,11 @@ public static int checkPositionIndex(int index, int size, @NullableDecl String d
 
   private static String badPositionIndex(int index, int size, @NullableDecl String desc) {
     if (index < 0) {
-      return format(""%s (%s) must not be negative"", desc, index);
+      return lenientFormat(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
       throw new IllegalArgumentException(""negative size: "" + size);
     } else { // index > size
-      return format(""%s (%s) must not be greater than size (%s)"", desc, index, size);
+      return lenientFormat(""%s (%s) must not be greater than size (%s)"", desc, index, size);
     }
   }
 
@@ -1432,52 +1438,6 @@ private static String badPositionIndexes(int start, int end, int size) {
       return badPositionIndex(end, size, ""end index"");
     }
     // end < start
-    return format(""end index (%s) must not be less than start index (%s)"", end, start);
-  }
-
-  /**
-   * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
-   * position: the first {@code %s} gets {@code args[0]}, etc. If there are more arguments than
-   * placeholders, the unmatched arguments will be appended to the end of the formatted message in
-   * square braces.
-   *
-   * @param template a string containing 0 or more {@code %s} placeholders. null is treated as
-   *     ""null"".
-   * @param args the arguments to be substituted into the message template. Arguments are converted
-   *     to strings using {@link String#valueOf(Object)}. Arguments can be null.
-   */
-  // Note that this is somewhat-improperly used from Verify.java as well.
-  static String format(@NullableDecl String template, @NullableDecl Object... args) {
-    template = String.valueOf(template); // null -> ""null""
-
-    args = args == null ? new Object[] {""(Object[])null""} : args;
-
-    // start substituting the arguments into the '%s' placeholders
-    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
-    int templateStart = 0;
-    int i = 0;
-    while (i < args.length) {
-      int placeholderStart = template.indexOf(""%s"", templateStart);
-      if (placeholderStart == -1) {
-        break;
-      }
-      builder.append(template, templateStart, placeholderStart);
-      builder.append(args[i++]);
-      templateStart = placeholderStart + 2;
-    }
-    builder.append(template, templateStart, template.length());
-
-    // if we run out of placeholders, append the extra args in square braces
-    if (i < args.length) {
-      builder.append("" ["");
-      builder.append(args[i++]);
-      while (i < args.length) {
-        builder.append("", "");
-        builder.append(args[i++]);
-      }
-      builder.append(']');
-    }
-
-    return builder.toString();
+    return lenientFormat(""end index (%s) must not be less than start index (%s)"", end, start);
   }
 }, @@ -14,15 +14,15 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.format;
+import static com.google.common.base.Strings.lenientFormat;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Static convenience methods that serve the same purpose as Java language <a
- * href=""http://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html"">assertions</a>,
+ * href=""https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html"">assertions</a>,
  * except that they are always enabled. These methods should be used instead of Java assertions
  * whenever there is a chance the check may fail ""in real life"". Example:
  *
@@ -72,11 +72,12 @@
  *
  * <h3>Only {@code %s} is supported</h3>
  *
- * <p>As with {@link Preconditions} error message template strings, only the {@code ""%s""} specifier
- * is supported, not the full range of {@link java.util.Formatter} specifiers. However, note that if
- * the number of arguments does not match the number of occurrences of {@code ""%s""} in the format
- * string, {@code Verify} will still behave as expected, and will still include all argument values
- * in the error message; the message will simply not be formatted exactly as intended.
+ * <p>As with {@link Preconditions}, {@code Verify} uses {@link Strings#lenientFormat} to format
+ * error message template strings. This only supports the {@code ""%s""} specifier, not the full range
+ * of {@link java.util.Formatter} specifiers. However, note that if the number of arguments does not
+ * match the number of occurrences of {@code ""%s""} in the format string, {@code Verify} will still
+ * behave as expected, and will still include all argument values in the error message; the message
+ * will simply not be formatted exactly as intended.
  *
  * <h3>More information</h3>
  *
@@ -120,7 +121,7 @@ public static void verify(
       @NullableDecl String errorMessageTemplate,
       @NullableDecl Object... errorMessageArgs) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, errorMessageArgs));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -135,7 +136,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, char p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -149,7 +150,7 @@ public static void verify(
    */
   public static void verify(boolean expression, @NullableDecl String errorMessageTemplate, int p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -164,7 +165,7 @@ public static void verify(boolean expression, @NullableDecl String errorMessageT
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, long p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -179,7 +180,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, @NullableDecl Object p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -194,7 +195,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, char p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -209,7 +210,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, int p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -224,7 +225,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, long p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -242,7 +243,7 @@ public static void verify(
       @NullableDecl Object p1,
       char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -257,7 +258,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, char p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -272,7 +273,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, int p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -287,7 +288,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, long p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -305,7 +306,7 @@ public static void verify(
       @NullableDecl Object p1,
       int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -320,7 +321,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, char p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -335,7 +336,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, int p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -350,7 +351,7 @@ public static void verify(
   public static void verify(
       boolean expression, @NullableDecl String errorMessageTemplate, long p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -368,7 +369,7 @@ public static void verify(
       @NullableDecl Object p1,
       long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -386,7 +387,7 @@ public static void verify(
       char p1,
       @NullableDecl Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -404,7 +405,7 @@ public static void verify(
       int p1,
       @NullableDecl Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -422,7 +423,7 @@ public static void verify(
       long p1,
       @NullableDecl Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -440,7 +441,7 @@ public static void verify(
       @NullableDecl Object p1,
       @NullableDecl Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -459,7 +460,7 @@ public static void verify(
       @NullableDecl Object p2,
       @NullableDecl Object p3) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2, p3));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -479,7 +480,7 @@ public static void verify(
       @NullableDecl Object p3,
       @NullableDecl Object p4) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 , @@ -232,9 +232,4 @@ public void testCheckState_simple_success() throws Exception {
   com.google.common.base.PreconditionsTest testCase = new com.google.common.base.PreconditionsTest();
   testCase.testCheckState_simple_success();
 }
-
-public void testFormat() throws Exception {
-  com.google.common.base.PreconditionsTest testCase = new com.google.common.base.PreconditionsTest();
-  testCase.testFormat();
-}
 }, @@ -16,7 +16,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -379,25 +378,6 @@ public void testCheckPositionIndexes_reversed() {
     }
   }
 
-  public void testFormat() {
-    assertEquals(""%s"", Preconditions.format(""%s""));
-    assertEquals(""5"", Preconditions.format(""%s"", 5));
-    assertEquals(""foo [5]"", Preconditions.format(""foo"", 5));
-    assertEquals(""foo [5, 6, 7]"", Preconditions.format(""foo"", 5, 6, 7));
-    assertEquals(""%s 1 2"", Preconditions.format(""%s %s %s"", ""%s"", 1, 2));
-    assertEquals("" [5, 6]"", Preconditions.format("""", 5, 6));
-    assertEquals(""123"", Preconditions.format(""%s%s%s"", 1, 2, 3));
-    assertEquals(""1%s%s"", Preconditions.format(""%s%s%s"", 1));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""%s + 6 = 11"", 5));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""5 + %s = 11"", 6));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""5 + 6 = %s"", 11));
-    assertEquals(""5 + 6 = 11"", Preconditions.format(""%s + %s = %s"", 5, 6, 11));
-    assertEquals(""null [null, null]"", Preconditions.format(""%s"", null, null, null));
-    assertEquals(""null [5, 6]"", Preconditions.format(null, 5, 6));
-    assertEquals(""null"", Preconditions.format(""%s"", (Object) null));
-    assertEquals(""(Object[])null"", Preconditions.format(""%s"", (Object[]) null));
-  }
-
   @GwtIncompatible(""Reflection"")
   public void testAllOverloads_checkArgument() throws Exception {
     for (ImmutableList<Class<?>> sig : allSignatures(boolean.class)) {
@@ -463,7 +443,7 @@ private void assertFailureCause(
       assertThat(throwable).hasMessage("""");
     } else {
       assertThat(throwable)
-          .hasMessage(Preconditions.format("""", Arrays.copyOfRange(params, 2, params.length)));
+          .hasMessage(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
     }
   }
 
@@ -534,20 +514,20 @@ public void overloadSelection() {
     int anInt = 1;
     // With a boxed predicate, no overloads can be selected in phase 1
     // ambiguous without the call to .booleanValue to unbox the Boolean
-    checkState(boxedBoolean.booleanValue(), """", 1);
+    Preconditions.checkState(boxedBoolean.booleanValue(), """", 1);
     // ambiguous without the cast to Object because the boxed predicate prevents any overload from
     // being selected in phase 1
-    checkState(boxedBoolean, """", (Object) boxedLong);
+    Preconditions.checkState(boxedBoolean, """", (Object) boxedLong);
 
     // ternaries introduce their own problems. because of the ternary (which requires a boxing
     // operation) no overload can be selected in phase 1.  and in phase 2 it is ambiguous since it
     // matches with the second parameter being boxed and without it being boxed.  The cast to Object
     // avoids this.
-    checkState(aBoolean, """", aBoolean ? """" : anInt, (Object) anInt);
+    Preconditions.checkState(aBoolean, """", aBoolean ? """" : anInt, (Object) anInt);
 
     // ambiguous without the .booleanValue() call since the boxing forces us into phase 2 resolution
     short s = 2;
-    checkState(boxedBoolean.booleanValue(), """", s);
+    Preconditions.checkState(boxedBoolean.booleanValue(), """", s);
   }
 
   @GwtIncompatible // NullPointerTester, @@ -14,6 +14,8 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Strings.lenientFormat;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -94,8 +96,12 @@
  *
  * <h3>Only {@code %s} is supported</h3>
  *
- * <p>In {@code Preconditions} error message template strings, only the {@code ""%s""} specifier is
- * supported, not the full range of {@link java.util.Formatter} specifiers.
+ * <p>{@code Preconditions} uses {@link Strings#lenientFormat} to format error message template
+ * strings. This only supports the {@code ""%s""} specifier, not the full range of {@link
+ * java.util.Formatter} specifiers. However, note that if the number of arguments does not match the
+ * number of occurrences of {@code ""%s""} in the format string, {@code Preconditions} will still
+ * behave as expected, and will still include all argument values in the error message; the message
+ * will simply not be formatted exactly as intended.
  *
  * <h3>More information</h3>
  *
@@ -154,7 +160,7 @@ public static void checkArgument(
       @Nullable String errorMessageTemplate,
       Object @Nullable... errorMessageArgs) {
     if (!expression) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, errorMessageArgs));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -167,7 +173,7 @@ public static void checkArgument(
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -180,7 +186,7 @@ public static void checkArgument(boolean b, @Nullable String errorMessageTemplat
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -193,7 +199,7 @@ public static void checkArgument(boolean b, @Nullable String errorMessageTemplat
    */
   public static void checkArgument(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -207,7 +213,7 @@ public static void checkArgument(boolean b, @Nullable String errorMessageTemplat
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -221,7 +227,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -235,7 +241,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -249,7 +255,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -263,7 +269,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -277,7 +283,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -291,7 +297,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -305,7 +311,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -319,7 +325,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -333,7 +339,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -347,7 +353,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -361,7 +367,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -375,7 +381,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -389,7 +395,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -403,7 +409,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -417,7 +423,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -431,7 +437,7 @@ public static void checkArgument(
   public static void checkArgument(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -449,7 +455,7 @@ public static void checkArgument(
       @Nullable Object p2,
       @Nullable Object p3) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -468,7 +474,7 @@ public static void checkArgument(
       @Nullable Object p3,
       @Nullable Object p4) {
     if (!b) {
-      throw new IllegalArgumentException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new IllegalArgumentException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 
@@ -522,7 +528,7 @@ public static void checkState(
       @Nullable String errorMessageTemplate,
       @Nullable Object @Nullable... errorMessageArgs) {
     if (!expression) {
-      throw new IllegalStateException(format(errorMessageTemplate, errorMessageArgs));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -536,7 +542,7 @@ public static void checkState(
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, char p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -550,7 +556,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -564,7 +570,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, long p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -579,7 +585,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -594,7 +600,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -608,7 +614,7 @@ public static void checkState(
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -623,7 +629,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -638,7 +644,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -652,7 +658,7 @@ public static void checkState(
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -666,7 +672,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -680,7 +686,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -695,7 +701,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -710,7 +716,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -724,7 +730,7 @@ public static void checkState(
    */
   public static void checkState(boolean b, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -739,7 +745,7 @@ public static void checkState(boolean b, @Nullable String errorMessageTemplate,
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -754,7 +760,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -769,7 +775,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -784,7 +790,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -799,7 +805,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -814,7 +820,7 @@ public static void checkState(
   public static void checkState(
       boolean b, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -833,7 +839,7 @@ public static void checkState(
       @Nullable Object p2,
       @Nullable Object p3) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -853,7 +859,7 @@ public static void checkState(
       @Nullable Object p3,
       @Nullable Object p4) {
     if (!b) {
-      throw new IllegalStateException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new IllegalStateException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 
@@ -910,7 +916,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T reference, @Nullable String errorMessageTemplate, Object @Nullable... errorMessageArgs) {
     if (reference == null) {
-      throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
     return reference;
   }
@@ -925,7 +931,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -940,7 +946,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -955,7 +961,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -971,7 +977,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1));
     }
     return obj;
   }
@@ -986,7 +992,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1001,7 +1007,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1016,7 +1022,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1032,7 +1038,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1047,7 +1053,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1062,7 +1068,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1077,7 +1083,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1093,7 +1099,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1108,7 +1114,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1123,7 +1129,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1138,7 +1144,7 @@ public static void checkState(
   @CanIgnoreReturnValue
   public static <T> T checkNotNull(T obj, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1154,7 +1160,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1170,7 +1176,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1186,7 +1192,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1202,7 +1208,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1218,7 +1224,7 @@ public static void checkState(
   public static <T> T checkNotNull(
       T obj, @Nullable String errorMessageTemplate, @Nullable Object p1, @Nullable Object p2) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2));
     }
     return obj;
   }
@@ -1238,7 +1244,7 @@ public static void checkState(
       @Nullable Object p2,
       @Nullable Object p3) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
     return obj;
   }
@@ -1259,7 +1265,7 @@ public static void checkState(
       @Nullable Object p3,
       @Nullable Object p4) {
     if (obj == null) {
-      throw new NullPointerException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new NullPointerException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
     return obj;
   }
@@ -1327,11 +1333,11 @@ public static int checkElementIndex(int index, int size, @Nullable String desc)
 
   private static String badElementIndex(int index, int size, @Nullable String desc) {
     if (index < 0) {
-      return format(""%s (%s) must not be negative"", desc, index);
+      return lenientFormat(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
       throw new IllegalArgumentException(""negative size: "" + size);
     } else { // index >= size
-      return format(""%s (%s) must be less than size (%s)"", desc, index, size);
+      return lenientFormat(""%s (%s) must be less than size (%s)"", desc, index, size);
     }
   }
 
@@ -1372,11 +1378,11 @@ public static int checkPositionIndex(int index, int size, @Nullable String desc)
 
   private static String badPositionIndex(int index, int size, @Nullable String desc) {
     if (index < 0) {
-      return format(""%s (%s) must not be negative"", desc, index);
+      return lenientFormat(""%s (%s) must not be negative"", desc, index);
     } else if (size < 0) {
       throw new IllegalArgumentException(""negative size: "" + size);
     } else { // index > size
-      return format(""%s (%s) must not be greater than size (%s)"", desc, index, size);
+      return lenientFormat(""%s (%s) must not be greater than size (%s)"", desc, index, size);
     }
   }
 
@@ -1407,52 +1413,6 @@ private static String badPositionIndexes(int start, int end, int size) {
       return badPositionIndex(end, size, ""end index"");
     }
     // end < start
-    return format(""end index (%s) must not be less than start index (%s)"", end, start);
-  }
-
-  /**
-   * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
-   * position: the first {@code %s} gets {@code args[0]}, etc. If there are more arguments than
-   * placeholders, the unmatched arguments will be appended to the end of the formatted message in
-   * square braces.
-   *
-   * @param template a string containing 0 or more {@code %s} placeholders. null is treated as
-   *     ""null"".
-   * @param args the arguments to be substituted into the message template. Arguments are converted
-   *     to strings using {@link String#valueOf(Object)}. Arguments can be null.
-   */
-  // Note that this is somewhat-improperly used from Verify.java as well.
-  static String format(@Nullable String template, @Nullable Object @Nullable... args) {
-    template = String.valueOf(template); // null -> ""null""
-
-    args = args == null ? new Object[] {""(Object[])null""} : args;
-
-    // start substituting the arguments into the '%s' placeholders
-    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
-    int templateStart = 0;
-    int i = 0;
-    while (i < args.length) {
-      int placeholderStart = template.indexOf(""%s"", templateStart);
-      if (placeholderStart == -1) {
-        break;
-      }
-      builder.append(template, templateStart, placeholderStart);
-      builder.append(args[i++]);
-      templateStart = placeholderStart + 2;
-    }
-    builder.append(template, templateStart, template.length());
-
-    // if we run out of placeholders, append the extra args in square braces
-    if (i < args.length) {
-      builder.append("" ["");
-      builder.append(args[i++]);
-      while (i < args.length) {
-        builder.append("", "");
-        builder.append(args[i++]);
-      }
-      builder.append(']');
-    }
-
-    return builder.toString();
+    return lenientFormat(""end index (%s) must not be less than start index (%s)"", end, start);
   }
 }, @@ -14,15 +14,15 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Preconditions.format;
+import static com.google.common.base.Strings.lenientFormat;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static convenience methods that serve the same purpose as Java language <a
- * href=""http://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html"">assertions</a>,
+ * href=""https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html"">assertions</a>,
  * except that they are always enabled. These methods should be used instead of Java assertions
  * whenever there is a chance the check may fail ""in real life"". Example:
  *
@@ -72,11 +72,12 @@
  *
  * <h3>Only {@code %s} is supported</h3>
  *
- * <p>As with {@link Preconditions} error message template strings, only the {@code ""%s""} specifier
- * is supported, not the full range of {@link java.util.Formatter} specifiers. However, note that if
- * the number of arguments does not match the number of occurrences of {@code ""%s""} in the format
- * string, {@code Verify} will still behave as expected, and will still include all argument values
- * in the error message; the message will simply not be formatted exactly as intended.
+ * <p>As with {@link Preconditions}, {@code Verify} uses {@link Strings#lenientFormat} to format
+ * error message template strings. This only supports the {@code ""%s""} specifier, not the full range
+ * of {@link java.util.Formatter} specifiers. However, note that if the number of arguments does not
+ * match the number of occurrences of {@code ""%s""} in the format string, {@code Verify} will still
+ * behave as expected, and will still include all argument values in the error message; the message
+ * will simply not be formatted exactly as intended.
  *
  * <h3>More information</h3>
  *
@@ -120,7 +121,7 @@ public static void verify(
       @Nullable String errorMessageTemplate,
       @Nullable Object @Nullable... errorMessageArgs) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, errorMessageArgs));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, errorMessageArgs));
     }
   }
 
@@ -134,7 +135,7 @@ public static void verify(
    */
   public static void verify(boolean expression, @Nullable String errorMessageTemplate, char p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -148,7 +149,7 @@ public static void verify(boolean expression, @Nullable String errorMessageTempl
    */
   public static void verify(boolean expression, @Nullable String errorMessageTemplate, int p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -162,7 +163,7 @@ public static void verify(boolean expression, @Nullable String errorMessageTempl
    */
   public static void verify(boolean expression, @Nullable String errorMessageTemplate, long p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -177,7 +178,7 @@ public static void verify(boolean expression, @Nullable String errorMessageTempl
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1));
     }
   }
 
@@ -192,7 +193,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, char p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -207,7 +208,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, int p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -222,7 +223,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, long p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -237,7 +238,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, char p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -252,7 +253,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, char p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -267,7 +268,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, int p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -282,7 +283,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, long p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -297,7 +298,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, int p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -312,7 +313,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, char p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -327,7 +328,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, int p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -342,7 +343,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, long p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -357,7 +358,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, @Nullable Object p1, long p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -372,7 +373,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, char p1, @Nullable Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -387,7 +388,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, int p1, @Nullable Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -402,7 +403,7 @@ public static void verify(
   public static void verify(
       boolean expression, @Nullable String errorMessageTemplate, long p1, @Nullable Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -420,7 +421,7 @@ public static void verify(
       @Nullable Object p1,
       @Nullable Object p2) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2));
     }
   }
 
@@ -439,7 +440,7 @@ public static void verify(
       @Nullable Object p2,
       @Nullable Object p3) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2, p3));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3));
     }
   }
 
@@ -459,7 +460,7 @@ public static void verify(
       @Nullable Object p3,
       @Nullable Object p4) {
     if (!expression) {
-      throw new VerifyException(format(errorMessageTemplate, p1, p2, p3, p4));
+      throw new VerifyException(lenientFormat(errorMessageTemplate, p1, p2, p3, p4));
     }
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Introduce Strings.lenientFormat(), copied from Preconditions.format(). Rewrote documentation but the method body remains unchanged.

RELNOTES=Introduce `Strings.lenientFormat()`, copied from `Preconditions.format()`.

a728cdc8f254ad9ff5049199e4cf9cee9a573270

-------

<p> Branch eventbus, net, and escape for Java 7

RELNOTES=N/A

eeee4ba1b814f540dcb4516bf1079c3a83bc3e68

-------

<p> Swap Preconditions and Verify over to Strings.lenientFormat.

2299ad25a041dbc7d5ffbdd86d2c4ce1b56c3935",Moe Sync
3149,Ron Shapiro,"['android/guava-tests/benchmark/com/google/common/base/WhitespaceMatcherBenchmark.java', 'guava-tests/benchmark/com/google/common/base/WhitespaceMatcherBenchmark.java']","@@ -19,7 +19,6 @@
 import com.google.caliper.BeforeExperiment;
 import com.google.caliper.Benchmark;
 import com.google.caliper.Param;
-import com.google.caliper.runner.CaliperMain;
 import java.util.BitSet;
 import java.util.Random;
 
@@ -51,10 +50,6 @@ public boolean matches(char c) {
   private String teststring;
   private CharMatcher matcher;
 
-  public static void main(String[] args) throws Exception {
-    CaliperMain.main(WhitespaceMatcherBenchmark.class, new String[] {});
-  }
-
   @BeforeExperiment
   protected void setUp() {
     BitSet bitSet = new BitSet();, @@ -19,7 +19,6 @@
 import com.google.caliper.BeforeExperiment;
 import com.google.caliper.Benchmark;
 import com.google.caliper.Param;
-import com.google.caliper.runner.CaliperMain;
 import java.util.BitSet;
 import java.util.Random;
 
@@ -51,10 +50,6 @@ public boolean matches(char c) {
   private String teststring;
   private CharMatcher matcher;
 
-  public static void main(String[] args) throws Exception {
-    CaliperMain.main(WhitespaceMatcherBenchmark.class, new String[] {});
-  }
-
   @BeforeExperiment
   protected void setUp() {
     BitSet bitSet = new BitSet();, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Continue migrating to type annotations for @Nullable

RELNOTES=N/A

f642763e15c2814c2ed6208fb7302235d6518829

-------

<p> Remove usages of CaliperMain from java_benchmarks targets since the deps for java_benchmarks don't need to (and shouldn't) include CaliperMain anymore.

Such benchmarks should be run via the java_benchmarks generated binary directly.

GITHUB_BREAKING_CHANGES=n/a

84d45bc4e1a9b2a87256e30374c517fed329dcae",Moe Sync
3158,Ron Shapiro,['README.md'],"@@ -41,7 +41,7 @@ To add a dependency using Gradle:
 dependencies {
   compile 'com.google.guava:guava:25.1-jre'
   // or, for Android:
-  compile 'com.google.guava:guava:25.1-android'
+  api 'com.google.guava:guava:25.1-android'
 }
 ```
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use api instead of compile for Android

Fixes #3154

03d7fd7e53382bc05795dc34632c4c81caf73b46",Moe Sync
3163,Ron Shapiro,"['guava-gwt/test/com/google/common/collect/StreamsTest_gwt.java', 'guava-tests/test/com/google/common/collect/StreamsTest.java', 'guava/src/com/google/common/collect/CollectSpliterators.java', 'guava/src/com/google/common/collect/Streams.java']","@@ -18,26 +18,6 @@
 @Override public String getModuleName() {
   return ""com.google.common.collect.testModule"";
 }
-public void testConcatInfiniteStream() throws Exception {
-  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
-  testCase.testConcatInfiniteStream();
-}
-
-public void testConcatInfiniteStream_double() throws Exception {
-  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
-  testCase.testConcatInfiniteStream_double();
-}
-
-public void testConcatInfiniteStream_int() throws Exception {
-  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
-  testCase.testConcatInfiniteStream_int();
-}
-
-public void testConcatInfiniteStream_long() throws Exception {
-  com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
-  testCase.testConcatInfiniteStream_long();
-}
-
 public void testConcat_doubleStream() throws Exception {
   com.google.common.collect.StreamsTest testCase = new com.google.common.collect.StreamsTest();
   testCase.testConcat_doubleStream();, @@ -172,30 +172,6 @@ public void testStream_optionalDouble() {
     assertThat(stream(OptionalDouble.of(5.0))).containsExactly(5.0);
   }
 
-  public void testConcatInfiniteStream() {
-    assertThat(Streams.concat(Stream.of(1, 2, 3), Stream.generate(() -> 5)).limit(5))
-        .containsExactly(1, 2, 3, 5, 5)
-        .inOrder();
-  }
-
-  public void testConcatInfiniteStream_int() {
-    assertThat(Streams.concat(IntStream.of(1, 2, 3), IntStream.generate(() -> 5)).limit(5))
-        .containsExactly(1, 2, 3, 5, 5)
-        .inOrder();
-  }
-
-  public void testConcatInfiniteStream_long() {
-    assertThat(Streams.concat(LongStream.of(1, 2, 3), LongStream.generate(() -> 5)).limit(5))
-        .containsExactly(1L, 2L, 3L, 5L, 5L)
-        .inOrder();
-  }
-
-  public void testConcatInfiniteStream_double() {
-    assertThat(Streams.concat(DoubleStream.of(1, 2, 3), DoubleStream.generate(() -> 5)).limit(5))
-        .containsExactly(1., 2., 3., 5., 5.)
-        .inOrder();
-  }
-
   private void testMapWithIndex(Function<Collection<String>, Stream<String>> collectionImpl) {
     SpliteratorTester.of(
             () ->, @@ -20,15 +20,12 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
-import com.google.j2objc.annotations.Weak;
 import java.util.Comparator;
 import java.util.Spliterator;
 import java.util.function.Consumer;
-import java.util.function.DoubleConsumer;
 import java.util.function.Function;
 import java.util.function.IntConsumer;
 import java.util.function.IntFunction;
-import java.util.function.LongConsumer;
 import java.util.function.Predicate;
 import java.util.stream.IntStream;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -210,270 +207,84 @@ public int characteristics() {
         ""flatMap does not support SORTED characteristic"");
     checkNotNull(fromSpliterator);
     checkNotNull(function);
-    return new FlatMapSpliterator<F, T, Spliterator<T>>(
-        null, fromSpliterator, function, topCharacteristics, topSize);
-  }
-
-  /**
-   * Returns a {@code Spliterator.OfInt} that iterates over the elements of the spliterators
-   * generated by applying {@code function} to the elements of {@code fromSpliterator}.
-   */
-  static <F> Spliterator.OfInt flatMapToInt(
-      Spliterator<F> fromSpliterator,
-      Function<? super F, Spliterator.OfInt> function,
-      int topCharacteristics,
-      long topSize) {
-    checkArgument(
-        (topCharacteristics & Spliterator.SUBSIZED) == 0,
-        ""flatMap does not support SUBSIZED characteristic"");
-    checkArgument(
-        (topCharacteristics & Spliterator.SORTED) == 0,
-        ""flatMap does not support SORTED characteristic"");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
-    return new FlatMapSpliteratorOfInt<F>(
-        null, fromSpliterator, function, topCharacteristics, topSize);
-  }
-
-  /**
-   * Returns a {@code Spliterator.OfLong} that iterates over the elements of the spliterators
-   * generated by applying {@code function} to the elements of {@code fromSpliterator}.
-   */
-  static <F> Spliterator.OfLong flatMapToLong(
-      Spliterator<F> fromSpliterator,
-      Function<? super F, Spliterator.OfLong> function,
-      int topCharacteristics,
-      long topSize) {
-    checkArgument(
-        (topCharacteristics & Spliterator.SUBSIZED) == 0,
-        ""flatMap does not support SUBSIZED characteristic"");
-    checkArgument(
-        (topCharacteristics & Spliterator.SORTED) == 0,
-        ""flatMap does not support SORTED characteristic"");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
-    return new FlatMapSpliteratorOfLong<F>(
-        null, fromSpliterator, function, topCharacteristics, topSize);
-  }
-
-  /**
-   * Returns a {@code Spliterator.OfDouble} that iterates over the elements of the spliterators
-   * generated by applying {@code function} to the elements of {@code fromSpliterator}.
-   */
-  static <F> Spliterator.OfDouble flatMapToDouble(
-      Spliterator<F> fromSpliterator,
-      Function<? super F, Spliterator.OfDouble> function,
-      int topCharacteristics,
-      long topSize) {
-    checkArgument(
-        (topCharacteristics & Spliterator.SUBSIZED) == 0,
-        ""flatMap does not support SUBSIZED characteristic"");
-    checkArgument(
-        (topCharacteristics & Spliterator.SORTED) == 0,
-        ""flatMap does not support SORTED characteristic"");
-    checkNotNull(fromSpliterator);
-    checkNotNull(function);
-    return new FlatMapSpliteratorOfDouble<F>(
-        null, fromSpliterator, function, topCharacteristics, topSize);
-  }
-
-  /**
-   * Implements the {@link Stream#flatMap} operation on spliterators.
-   *
-   * @param <F> the element type of the input spliterator
-   * @param <T> the element type of the output spliterators
-   * @param <S> the type of the output spliterators
-   */
-  static class FlatMapSpliterator<F, T, S extends Spliterator<T>> implements Spliterator<T> {
-    @Nullable @Weak S prefix;
-    final Spliterator<F> from;
-    final Function<? super F, S> function;
-    int characteristics;
-    long estimatedSize;
-
-    FlatMapSpliterator(
-        S prefix,
-        Spliterator<F> from,
-        Function<? super F, S> function,
-        int characteristics,
-        long estimatedSize) {
-      this.prefix = prefix;
-      this.from = from;
-      this.function = function;
-      this.characteristics = characteristics;
-      this.estimatedSize = estimatedSize;
-    }
+    class FlatMapSpliterator implements Spliterator<T> {
+      @Nullable Spliterator<T> prefix;
+      final Spliterator<F> from;
+      int characteristics;
+      long estimatedSize;
+
+      FlatMapSpliterator(
+          Spliterator<T> prefix, Spliterator<F> from, int characteristics, long estimatedSize) {
+        this.prefix = prefix;
+        this.from = from;
+        this.characteristics = characteristics;
+        this.estimatedSize = estimatedSize;
+      }
 
-    @Override
-    public boolean tryAdvance(Consumer<? super T> action) {
-      while (true) {
-        if (prefix != null && prefix.tryAdvance(action)) {
-          if (estimatedSize != Long.MAX_VALUE) {
-            estimatedSize--;
+      @Override
+      public boolean tryAdvance(Consumer<? super T> action) {
+        while (true) {
+          if (prefix != null && prefix.tryAdvance(action)) {
+            if (estimatedSize != Long.MAX_VALUE) {
+              estimatedSize--;
+            }
+            return true;
+          } else {
+            prefix = null;
+          }
+          if (!from.tryAdvance(fromElement -> prefix = function.apply(fromElement))) {
+            return false;
           }
-          return true;
-        } else {
-          prefix = null;
-        }
-        if (!from.tryAdvance(fromElement -> prefix = function.apply(fromElement))) {
-          return false;
         }
       }
-    }
-
-    @Override
-    public void forEachRemaining(Consumer<? super T> action) {
-      if (prefix != null) {
-        prefix.forEachRemaining(action);
-        prefix = null;
-      }
-      from.forEachRemaining(fromElement -> function.apply(fromElement).forEachRemaining(action));
-      estimatedSize = 0;
-    }
 
-    @Override
-    public Spliterator<T> trySplit() {
-      Spliterator<F> fromSplit = from.trySplit();
-      if (fromSplit != null) {
-        int splitCharacteristics = characteristics & ~Spliterator.SIZED;
-        long estSplitSize = estimateSize();
-        if (estSplitSize < Long.MAX_VALUE) {
-          estSplitSize /= 2;
-          this.estimatedSize -= estSplitSize;
-          this.characteristics = splitCharacteristics;
+      @Override
+      public void forEachRemaining(Consumer<? super T> action) {
+        if (prefix != null) {
+          prefix.forEachRemaining(action);
+          prefix = null;
         }
-        Spliterator<T> result = buildSplit(fromSplit, splitCharacteristics, estSplitSize);
-        this.prefix = null;
-        return result;
-      } else if (prefix != null) {
-        Spliterator<T> result = prefix;
-        this.prefix = null;
-        return result;
-      } else {
-        return null;
-      }
-    }
-
-    FlatMapSpliterator<F, T, S> buildSplit(
-        Spliterator<F> fromSplit, int splitCharacteristics, long estSplitSize) {
-      return new FlatMapSpliterator<>(
-          this.prefix, fromSplit, function, splitCharacteristics, estSplitSize);
-    }
-
-    @Override
-    public long estimateSize() {
-      if (prefix != null) {
-        estimatedSize = Math.max(estimatedSize, prefix.estimateSize());
+        from.forEachRemaining(fromElement -> function.apply(fromElement).forEachRemaining(action));
+        estimatedSize = 0;
       }
-      return Math.max(estimatedSize, 0);
-    }
-
-    @Override
-    public int characteristics() {
-      return characteristics;
-    }
-  }
-
-  /**
-   * Implementation of {@link Stream#flatMap} with a primitive spliterator output type.
-   *
-   * @param <F> the element type of the input spliterator
-   * @param <T> the (boxed) element type of the output spliterators
-   * @param <T_CONS> the specialized consumer type for the primitive output type
-   * @param <S> the primitive spliterator type associated with {@code T}
-   */
-  static class FlatMapSpliteratorOfPrimitive<
-          F, T, T_CONS, S extends Spliterator.OfPrimitive<T, T_CONS, S>>
-      extends FlatMapSpliterator<F, T, S> implements Spliterator.OfPrimitive<T, T_CONS, S> {
-
-    public FlatMapSpliteratorOfPrimitive(
-        S prefix,
-        Spliterator<F> from,
-        Function<? super F, S> function,
-        int characteristics,
-        long estimatedSize) {
-      super(prefix, from, function, characteristics, estimatedSize);
-    }
 
-    @Override
-    public boolean tryAdvance(T_CONS action) {
-      while (true) {
-        if (prefix != null && prefix.tryAdvance(action)) {
-          if (estimatedSize != Long.MAX_VALUE) {
-            estimatedSize--;
+      @Override
+      public Spliterator<T> trySplit() {
+        Spliterator<F> fromSplit = from.trySplit();
+        if (fromSplit != null) {
+          int splitCharacteristics = characteristics & ~Spliterator.SIZED;
+          long estSplitSize = estimateSize();
+          if (estSplitSize < Long.MAX_VALUE) {
+            estSplitSize /= 2;
+            this.estimatedSize -= estSplitSize;
+            this.characteristics = splitCharacteristics;
           }
-          return true;
+          Spliterator<T> result =
+              new FlatMapSpliterator(this.prefix, fromSplit, splitCharacteristics, estSplitSize);
+          this.prefix = null;
+          return result;
+        } else if (prefix != null) {
+          Spliterator<T> result = prefix;
+          this.prefix = null;
+          return result;
         } else {
-          prefix = null;
-        }
-        if (!from.tryAdvance(fromElement -> prefix = function.apply(fromElement))) {
-          return false;
+          return null;
         }
       }
-    }
 
-    @Override
-    public S trySplit() {
-      return (S) super.trySplit();
-    }
-
-    @Override
-    public void forEachRemaining(T_CONS action) {
-      if (prefix != null) {
-        prefix.forEachRemaining(action);
-        prefix = null;
+      @Override
+      public long estimateSize() {
+        if (prefix != null) {
+          estimatedSize = Math.max(estimatedSize, prefix.estimateSize());
+        }
+        return Math.max(estimatedSize, 0);
       }
-      from.forEachRemaining(fromElement -> function.apply(fromElement).forEachRemaining(action));
-      estimatedSize = 0;
-    }
 
-    @Override
-    FlatMapSpliteratorOfPrimitive<F, T, T_CONS, S> buildSplit(
-        Spliterator<F> fromSplit, int splitCharacteristics, long estSplitSize) {
-      return new FlatMapSpliteratorOfPrimitive<>(
-          this.prefix, fromSplit, function, splitCharacteristics, estSplitSize);
-    }
-  }
-
-  /** Implementation of {@link #flatMapToInt}. */
-  static class FlatMapSpliteratorOfInt<F>
-      extends FlatMapSpliteratorOfPrimitive<F, Integer, IntConsumer, Spliterator.OfInt>
-      implements Spliterator.OfInt {
-    FlatMapSpliteratorOfInt(
-        Spliterator.OfInt prefix,
-        Spliterator<F> from,
-        Function<? super F, Spliterator.OfInt> function,
-        int characteristics,
-        long estimatedSize) {
-      super(prefix, from, function, characteristics, estimatedSize);
-    }
-  }
-
-  /** Implementation of {@link #flatMapToLong}. */
-  static class FlatMapSpliteratorOfLong<F>
-      extends FlatMapSpliteratorOfPrimitive<F, Long, LongConsumer, Spliterator.OfLong>
-      implements Spliterator.OfLong {
-    FlatMapSpliteratorOfLong(
-        Spliterator.OfLong prefix,
-        Spliterator<F> from,
-        Function<? super F, Spliterator.OfLong> function,
-        int characteristics,
-        long estimatedSize) {
-      super(prefix, from, function, characteristics, estimatedSize);
-    }
-  }
-
-  /** Implementation of {@link #flatMapToDouble}. */
-  static class FlatMapSpliteratorOfDouble<F>
-      extends FlatMapSpliteratorOfPrimitive<F, Double, DoubleConsumer, Spliterator.OfDouble>
-      implements Spliterator.OfDouble {
-    FlatMapSpliteratorOfDouble(
-        Spliterator.OfDouble prefix,
-        Spliterator<F> from,
-        Function<? super F, Spliterator.OfDouble> function,
-        int characteristics,
-        long estimatedSize) {
-      super(prefix, from, function, characteristics, estimatedSize);
+      @Override
+      public int characteristics() {
+        return characteristics;
+      }
     }
+    return new FlatMapSpliterator(null, fromSpliterator, topCharacteristics, topSize);
   }
 }, @@ -39,7 +39,6 @@
 import java.util.function.DoubleConsumer;
 import java.util.function.IntConsumer;
 import java.util.function.LongConsumer;
-import java.util.stream.BaseStream;
 import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
@@ -131,12 +130,6 @@ public static DoubleStream stream(OptionalDouble optional) {
     return optional.isPresent() ? DoubleStream.of(optional.getAsDouble()) : DoubleStream.empty();
   }
 
-  private static void closeAll(BaseStream<?, ?>[] toClose) {
-    for (BaseStream<?, ?> stream : toClose) {
-      stream.close();
-    }
-  }
-
   /**
    * Returns a {@link Stream} containing the elements of the first stream, followed by the elements
    * of the second stream, and so on.
@@ -168,7 +161,12 @@ private static void closeAll(BaseStream<?, ?>[] toClose) {
                 characteristics,
                 estimatedSize),
             isParallel)
-        .onClose(() -> closeAll(streams));
+        .onClose(
+            () -> {
+              for (Stream<? extends T> stream : streams) {
+                stream.close();
+              }
+            });
   }
 
   /**
@@ -181,26 +179,8 @@ private static void closeAll(BaseStream<?, ?>[] toClose) {
    * @see IntStream#concat(IntStream, IntStream)
    */
   public static IntStream concat(IntStream... streams) {
-    boolean isParallel = false;
-    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;
-    long estimatedSize = 0L;
-    ImmutableList.Builder<Spliterator.OfInt> splitrsBuilder =
-        new ImmutableList.Builder<>(streams.length);
-    for (IntStream stream : streams) {
-      isParallel |= stream.isParallel();
-      Spliterator.OfInt splitr = stream.spliterator();
-      splitrsBuilder.add(splitr);
-      characteristics &= splitr.characteristics();
-      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
-    }
-    return StreamSupport.intStream(
-            CollectSpliterators.flatMapToInt(
-                splitrsBuilder.build().spliterator(),
-                splitr -> splitr,
-                characteristics,
-                estimatedSize),
-            isParallel)
-        .onClose(() -> closeAll(streams));
+    // TODO(lowasser): optimize this later
+    return Stream.of(streams).flatMapToInt(stream -> stream);
   }
 
   /**
@@ -213,26 +193,8 @@ public static IntStream concat(IntStream... streams) {
    * @see LongStream#concat(LongStream, LongStream)
    */
   public static LongStream concat(LongStream... streams) {
-    boolean isParallel = false;
-    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;
-    long estimatedSize = 0L;
-    ImmutableList.Builder<Spliterator.OfLong> splitrsBuilder =
-        new ImmutableList.Builder<>(streams.length);
-    for (LongStream stream : streams) {
-      isParallel |= stream.isParallel();
-      Spliterator.OfLong splitr = stream.spliterator();
-      splitrsBuilder.add(splitr);
-      characteristics &= splitr.characteristics();
-      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
-    }
-    return StreamSupport.longStream(
-            CollectSpliterators.flatMapToLong(
-                splitrsBuilder.build().spliterator(),
-                splitr -> splitr,
-                characteristics,
-                estimatedSize),
-            isParallel)
-        .onClose(() -> closeAll(streams));
+    // TODO(lowasser): optimize this later
+    return Stream.of(streams).flatMapToLong(stream -> stream);
   }
 
   /**
@@ -245,26 +207,8 @@ public static LongStream concat(LongStream... streams) {
    * @see DoubleStream#concat(DoubleStream, DoubleStream)
    */
   public static DoubleStream concat(DoubleStream... streams) {
-    boolean isParallel = false;
-    int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL;
-    long estimatedSize = 0L;
-    ImmutableList.Builder<Spliterator.OfDouble> splitrsBuilder =
-        new ImmutableList.Builder<>(streams.length);
-    for (DoubleStream stream : streams) {
-      isParallel |= stream.isParallel();
-      Spliterator.OfDouble splitr = stream.spliterator();
-      splitrsBuilder.add(splitr);
-      characteristics &= splitr.characteristics();
-      estimatedSize = LongMath.saturatedAdd(estimatedSize, splitr.estimateSize());
-    }
-    return StreamSupport.doubleStream(
-            CollectSpliterators.flatMapToDouble(
-                splitrsBuilder.build().spliterator(),
-                splitr -> splitr,
-                characteristics,
-                estimatedSize),
-            isParallel)
-        .onClose(() -> closeAll(streams));
+    // TODO(lowasser): optimize this later
+    return Stream.of(streams).flatMapToDouble(stream -> stream);
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add duration info to checkArugment() call in Suppliers.memoizeWithExpiration()

RELNOTES=Add duration info to checkArugment() call in Suppliers.memoizeWithExpiration()

3eadb52dcb210704fefa547853b17e7bfa57e06c

-------

<p> Some changes to the Guava README.

Move most information about the latest release to the release badge at the top, which now links to the GitHub release page for the latest release and automatically displays the latest release version number.

Note: I probably would have removed explicit references to the latest version number entirely (meaning no changes to it need to be made when a new release is created) except for the fact that the release process currently relies on there being *some* change made when prepare_release is run so that the release script knows what commit to create the release from. There are ways we could deal with that, but I didn't want to deal with that yet.

0f364779d314470c8855a6c0c805f858ed418c65

-------

<p> Fix https://github.com/google/guava/issues/3156 by implementing a proper CollectSpliterators.flatMapTo{Int,Long,Double}.

9e6e1d02faa4ff07f2c5746a1902ae36cd54335b

-------

<p> Automated rollback of 9e6e1d02faa4ff07f2c5746a1902ae36cd54335b

*** Reason for rollback ***

Appears to tickle a J2CL bug.

*** Original change description ***

Fix https://github.com/google/guava/issues/3156 by implementing a proper CollectSpliterators.flatMapTo{Int,Long,Double}.

***

15db5b7f84531a19e7e0ab6f7932208e35b8b068",Moe Sync
3170,Ron Shapiro,"['guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java', 'guava/src/com/google/common/cache/LocalCache.java']","@@ -55,6 +55,30 @@ public void testComputeIfAbsent() {
     assertEquals(1, cache.size());
   }
 
+  public void testComputeIfAbsentEviction() {
+    // b/80241237
+
+    Cache<String, String> c = CacheBuilder.newBuilder().maximumSize(1).build();
+
+    assertThat(c.asMap().computeIfAbsent(""hash-1"", k -> """")).isEqualTo("""");
+    assertThat(c.asMap().computeIfAbsent(""hash-1"", k -> """")).isEqualTo("""");
+    assertThat(c.asMap().computeIfAbsent(""hash-1"", k -> """")).isEqualTo("""");
+    assertThat(c.size()).isEqualTo(1);
+    assertThat(c.asMap().computeIfAbsent(""hash-2"", k -> """")).isEqualTo("""");
+  }
+
+  public void testComputeEviction() {
+    // b/80241237
+
+    Cache<String, String> c = CacheBuilder.newBuilder().maximumSize(1).build();
+
+    assertThat(c.asMap().compute(""hash-1"", (k, v) -> ""a"")).isEqualTo(""a"");
+    assertThat(c.asMap().compute(""hash-1"", (k, v) -> ""b"")).isEqualTo(""b"");
+    assertThat(c.asMap().compute(""hash-1"", (k, v) -> ""c"")).isEqualTo(""c"");
+    assertThat(c.size()).isEqualTo(1);
+    assertThat(c.asMap().computeIfAbsent(""hash-2"", k -> """")).isEqualTo("""");
+  }
+
   public void testComputeIfPresent() {
     cache.put(key, ""1"");
     // simultaneous update for same key, expect count successful updates, @@ -2243,7 +2243,8 @@ V compute(K key, int hash, BiFunction<? super K, ? super V, ? extends V> functio
         if (newValue != null) {
           if (valueReference != null && newValue == valueReference.get()) {
             loadingValueReference.set(newValue);
-            setValue(e, key, newValue, now);
+            e.setValueReference(valueReference);
+            recordWrite(e, 0, now); // no change in weight
             return newValue;
           }
           try {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> fix a grammar mistake

Fixes #3161

d60f7f352c7ce8ae031c916b045eb30a6f1a8ab8

-------

<p> In open-source Guava, completely skip trying to discover pluggable PatternCompiler implementations.

It's never been possible to create such implementations externally, anyway, and users are now seeing problems running the useless discovery code under the module system.

Fixes https://github.com/google/guava/issues/3147

RELNOTES=`base`: Fixed the `ServiceConfigurationError` that some users encountered when using Guava as a JPMS module.

0954b82dc4e3fe400550fcba78ae2878a8604c3b

-------

<p> Suppress exceptions raised from argument's toString methods during lenient formatting - take 2.

60c6e22c0ba9c7b305c787bd72e0fd4f1f005afc

-------

<p> Create an htmlescapers target for people who want to avoid the bulk of i18n identifiers and ICU4J.

e0eae79a5ba94850ca447116cd033447240d489e

-------

<p> Fix b/80241237 to correctly *not* change segment weight, nor report an eviction, when a compute() call does not change the present value.

RELNOTES=Fix a bug where Cache.asMap.compute* methods could cause nonsensical weights to be stored, breaking cache eviction.

21b52f64ceda0119daec68f6be2712bee55f02af",Moe Sync
3171,Ron Shapiro,"['android/guava/src/com/google/common/base/Strings.java', 'guava/src/com/google/common/base/Strings.java']","@@ -212,16 +212,30 @@ public static String commonSuffix(CharSequence a, CharSequence b) {
     return a.subSequence(a.length() - s, a.length()).toString();
   }
 
+  /**
+   * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.
+   * Out-of-range indexes return false.
+   */
+  @VisibleForTesting
+  static boolean validSurrogatePairAt(CharSequence string, int index) {
+    return index >= 0
+        && index <= (string.length() - 2)
+        && Character.isHighSurrogate(string.charAt(index))
+        && Character.isLowSurrogate(string.charAt(index + 1));
+  }
+
   /**
    * Returns the given {@code template} string with each occurrence of {@code ""%s""} replaced with
    * the corresponding argument value from {@code args}; or, if the placeholder and argument counts
    * do not match, returns a best-effort form of that string. Will not throw an exception under
    * normal conditions.
    *
-   * <p><b>Note:</b> For most string-formatting needs, use {@link String#format}, {@link
-   * PrintWriter#format}, and related methods. These support the full range of {@linkplain
-   * Formatter#syntax format specifiers}, and alert you to usage errors by throwing {@link
-   * InvalidFormatException}.
+   * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
+   * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
+   * full range of <a
+   * href=""https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax"">format
+   * specifiers</a>, and alert you to usage errors by throwing {@link
+   * java.util.IllegalFormatException}.
    *
    * <p>In certain cases, such as outputting debugging information or constructing a message to be
    * used for another unchecked exception, an exception during string formatting would serve little
@@ -296,16 +310,4 @@ private static String lenientToString(@NullableDecl Object o) {
       return ""<"" + objectToString + "" threw "" + e.getClass().getName() + "">"";
     }
   }
-
-  /**
-   * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.
-   * Out-of-range indexes return false.
-   */
-  @VisibleForTesting
-  static boolean validSurrogatePairAt(CharSequence string, int index) {
-    return index >= 0
-        && index <= (string.length() - 2)
-        && Character.isHighSurrogate(string.charAt(index))
-        && Character.isLowSurrogate(string.charAt(index + 1));
-  }
 }, @@ -211,16 +211,30 @@ public static String commonSuffix(CharSequence a, CharSequence b) {
     return a.subSequence(a.length() - s, a.length()).toString();
   }
 
+  /**
+   * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.
+   * Out-of-range indexes return false.
+   */
+  @VisibleForTesting
+  static boolean validSurrogatePairAt(CharSequence string, int index) {
+    return index >= 0
+        && index <= (string.length() - 2)
+        && Character.isHighSurrogate(string.charAt(index))
+        && Character.isLowSurrogate(string.charAt(index + 1));
+  }
+
   /**
    * Returns the given {@code template} string with each occurrence of {@code ""%s""} replaced with
    * the corresponding argument value from {@code args}; or, if the placeholder and argument counts
    * do not match, returns a best-effort form of that string. Will not throw an exception under
    * normal conditions.
    *
-   * <p><b>Note:</b> For most string-formatting needs, use {@link String#format}, {@link
-   * PrintWriter#format}, and related methods. These support the full range of {@linkplain
-   * Formatter#syntax format specifiers}, and alert you to usage errors by throwing {@link
-   * InvalidFormatException}.
+   * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
+   * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
+   * full range of <a
+   * href=""https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax"">format
+   * specifiers</a>, and alert you to usage errors by throwing {@link
+   * java.util.IllegalFormatException}.
    *
    * <p>In certain cases, such as outputting debugging information or constructing a message to be
    * used for another unchecked exception, an exception during string formatting would serve little
@@ -296,16 +310,4 @@ private static String lenientToString(@Nullable Object o) {
       return ""<"" + objectToString + "" threw "" + e.getClass().getName() + "">"";
     }
   }
-
-  /**
-   * True when a valid surrogate pair starts at the given {@code index} in the given {@code string}.
-   * Out-of-range indexes return false.
-   */
-  @VisibleForTesting
-  static boolean validSurrogatePairAt(CharSequence string, int index) {
-    return index >= 0
-        && index <= (string.length() - 2)
-        && Character.isHighSurrogate(string.charAt(index))
-        && Character.isLowSurrogate(string.charAt(index + 1));
-  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add a direct dependency from guava-gwt to checker-qual.

The GWT sources (specifically, GwtSerializationDependencies) use @Nullable directly, so we shouldn't rely on relying on it indirectly through guava-jre.

However, what actually prompted this is a strange behavior in Compile-Testing, which Truth uses. This CL should help, though it might not be a fully solution.
https://github.com/google/compile-testing/issues/149

5cb6f0a87d75c6b3cd6c79c31d66e3a28620101d

-------

<p> Fix mangled Javadocs.

5928882017809a1d0e57bd1b55dd6abdcf5604d0",Moe Sync
3179,Ron Shapiro,"['android/guava-tests/test/com/google/common/base/AndroidIncompatible.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureFallbackAtomicHelperTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AggregateFutureStateFallbackAtomicHelperTest.java', 'android/guava/src/com/google/common/base/Throwables.java', 'cycle_whitelist.txt', 'guava-tests/test/com/google/common/base/AndroidIncompatible.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureFallbackAtomicHelperTest.java', 'guava-tests/test/com/google/common/util/concurrent/AggregateFutureStateFallbackAtomicHelperTest.java', 'guava/src/com/google/common/base/Throwables.java']","@@ -57,7 +57,7 @@
  *       would no longer have the problematic test. But why bother when we can instead strip it with
  *       a more precisely named annotation?
  *   <li>While a dependency on Android ought to be easy if it's for annotations only, it will
- *       probably require adding the dep to various whitelists, license files, and Proguard
+ *       probably require adding the dep to various ACLs, license files, and Proguard
  *       configurations, and there's always the potential that something will go wrong. It
  *       <i>probably</i> won't, since the deps are needed only in tests (and maybe someday in
  *       testlib), but why bother?, @@ -50,15 +50,15 @@
   // execution significantly)
 
   /**
-   * This classloader blacklists sun.misc.Unsafe which will prevent us from selecting our preferred
-   * strategy {@code UnsafeAtomicHelper}.
+   * This classloader disallows {@link sun.misc.Unsafe}, which will prevent us from selecting our
+   * preferred strategy {@code UnsafeAtomicHelper}.
    */
   private static final ClassLoader NO_UNSAFE =
       getClassLoader(ImmutableSet.of(sun.misc.Unsafe.class.getName()));
 
   /**
-   * This classloader blacklists sun.misc.Unsafe and AtomicReferenceFieldUpdater which will prevent
-   * us from selecting our {@code SafeAtomicHelper} strategy.
+   * This classloader disallows {@link sun.misc.Unsafe} and {@link AtomicReferenceFieldUpdater},
+   * which will prevent us from selecting our {@code SafeAtomicHelper} strategy.
    */
   private static final ClassLoader NO_ATOMIC_REFERENCE_FIELD_UPDATER =
       getClassLoader(
@@ -86,7 +86,7 @@ public void runTest() throws Exception {
     checkHelperVersion(NO_UNSAFE, ""SafeAtomicHelper"");
     checkHelperVersion(NO_ATOMIC_REFERENCE_FIELD_UPDATER, ""SynchronizedHelper"");
 
-    // Run the corresponding AbstractFutureTest test method in a new classloader that blacklists
+    // Run the corresponding AbstractFutureTest test method in a new classloader that disallows
     // certain core jdk classes.
     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
     Thread.currentThread().setContextClassLoader(NO_UNSAFE);
@@ -119,14 +119,14 @@ private void checkHelperVersion(ClassLoader classLoader, String expectedHelperCl
     assertEquals(expectedHelperClassName, helperField.get(null).getClass().getSimpleName());
   }
 
-  private static ClassLoader getClassLoader(final Set<String> blacklist) {
+  private static ClassLoader getClassLoader(final Set<String> disallowedClassNames) {
     final String concurrentPackage = SettableFuture.class.getPackage().getName();
     ClassLoader classLoader = AbstractFutureFallbackAtomicHelperTest.class.getClassLoader();
     // we delegate to the current classloader so both loaders agree on classes like TestCase
     return new URLClassLoader(ClassPathUtil.getClassPathUrls(), classLoader) {
       @Override
       public Class<?> loadClass(String name) throws ClassNotFoundException {
-        if (blacklist.contains(name)) {
+        if (disallowedClassNames.contains(name)) {
           throw new ClassNotFoundException(""I'm sorry Dave, I'm afraid I can't do that."");
         }
         if (name.startsWith(concurrentPackage)) {, @@ -48,7 +48,7 @@
 public class AggregateFutureStateFallbackAtomicHelperTest extends TestCase {
 
   /**
-   * This classloader blacklists AtomicReferenceFieldUpdater and AtomicIntegerFieldUpdate which will
+   * This classloader disallows AtomicReferenceFieldUpdater and AtomicIntegerFieldUpdate which will
    * prevent us from selecting our {@code SafeAtomicHelper} strategy.
    *
    * <p>Stashing this in a static field avoids loading it over and over again and speeds up test
@@ -81,7 +81,7 @@ public void runTest() throws Exception {
     checkHelperVersion(getClass().getClassLoader(), ""SafeAtomicHelper"");
     checkHelperVersion(NO_ATOMIC_FIELD_UPDATER, ""SynchronizedAtomicHelper"");
 
-    // Run the corresponding FuturesTest test method in a new classloader that blacklists
+    // Run the corresponding FuturesTest test method in a new classloader that disallows
     // certain core jdk classes.
     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
     Thread.currentThread().setContextClassLoader(NO_ATOMIC_FIELD_UPDATER);
@@ -110,14 +110,14 @@ private void checkHelperVersion(ClassLoader classLoader, String expectedHelperCl
     assertEquals(expectedHelperClassName, helperField.get(null).getClass().getSimpleName());
   }
 
-  private static ClassLoader getClassLoader(final Set<String> blacklist) {
+  private static ClassLoader getClassLoader(final Set<String> blocklist) {
     final String concurrentPackage = SettableFuture.class.getPackage().getName();
     ClassLoader classLoader = AggregateFutureStateFallbackAtomicHelperTest.class.getClassLoader();
     // we delegate to the current classloader so both loaders agree on classes like TestCase
     return new URLClassLoader(ClassPathUtil.getClassPathUrls(), classLoader) {
       @Override
       public Class<?> loadClass(String name) throws ClassNotFoundException {
-        if (blacklist.contains(name)) {
+        if (blocklist.contains(name)) {
           throw new ClassNotFoundException(""I'm sorry Dave, I'm afraid I can't do that."");
         }
         if (name.startsWith(concurrentPackage)) {, @@ -468,7 +468,7 @@ private static Object invokeAccessibleNonThrowingMethod(
   private static final Method getStackTraceDepthMethod = (jla == null) ? null : getSizeMethod();
 
   /**
-   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for
+   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not allowed in
    * AppEngine, and not present in non-Sun JDKs.
    */
   @GwtIncompatible // java.lang.reflect
@@ -486,7 +486,7 @@ private static Object getJLA() {
       throw death;
     } catch (Throwable t) {
       /*
-       * This is not one of AppEngine's whitelisted classes, so even in Sun JDKs, this can fail with
+       * This is not one of AppEngine's allowed classes, so even in Sun JDKs, this can fail with
        * a NoClassDefFoundError. Other apps might deny access to sun.misc packages.
        */
       return null;, @@ -8,7 +8,7 @@ NAMESPACE com.google.common.io
 NAMESPACE com.google.common.net
 NAMESPACE com.google.common.testing
 
-# Whitelist our dependencies for now.
+# Allow our dependencies for now.
 NAMESPACE junit.framework
 NAMESPACE org.junit
 , @@ -57,7 +57,7 @@
  *       would no longer have the problematic test. But why bother when we can instead strip it with
  *       a more precisely named annotation?
  *   <li>While a dependency on Android ought to be easy if it's for annotations only, it will
- *       probably require adding the dep to various whitelists, license files, and Proguard
+ *       probably require adding the dep to various ACLs, license files, and Proguard
  *       configurations, and there's always the potential that something will go wrong. It
  *       <i>probably</i> won't, since the deps are needed only in tests (and maybe someday in
  *       testlib), but why bother?, @@ -50,15 +50,15 @@
   // execution significantly)
 
   /**
-   * This classloader blacklists sun.misc.Unsafe which will prevent us from selecting our preferred
-   * strategy {@code UnsafeAtomicHelper}.
+   * This classloader disallows {@link sun.misc.Unsafe}, which will prevent us from selecting our
+   * preferred strategy {@code UnsafeAtomicHelper}.
    */
   private static final ClassLoader NO_UNSAFE =
       getClassLoader(ImmutableSet.of(sun.misc.Unsafe.class.getName()));
 
   /**
-   * This classloader blacklists sun.misc.Unsafe and AtomicReferenceFieldUpdater which will prevent
-   * us from selecting our {@code SafeAtomicHelper} strategy.
+   * This classloader disallows {@link sun.misc.Unsafe} and {@link AtomicReferenceFieldUpdater},
+   * which will prevent us from selecting our {@code SafeAtomicHelper} strategy.
    */
   private static final ClassLoader NO_ATOMIC_REFERENCE_FIELD_UPDATER =
       getClassLoader(
@@ -86,7 +86,7 @@ public void runTest() throws Exception {
     checkHelperVersion(NO_UNSAFE, ""SafeAtomicHelper"");
     checkHelperVersion(NO_ATOMIC_REFERENCE_FIELD_UPDATER, ""SynchronizedHelper"");
 
-    // Run the corresponding AbstractFutureTest test method in a new classloader that blacklists
+    // Run the corresponding AbstractFutureTest test method in a new classloader that disallows
     // certain core jdk classes.
     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
     Thread.currentThread().setContextClassLoader(NO_UNSAFE);
@@ -119,14 +119,14 @@ private void checkHelperVersion(ClassLoader classLoader, String expectedHelperCl
     assertEquals(expectedHelperClassName, helperField.get(null).getClass().getSimpleName());
   }
 
-  private static ClassLoader getClassLoader(final Set<String> blacklist) {
+  private static ClassLoader getClassLoader(final Set<String> disallowedClassNames) {
     final String concurrentPackage = SettableFuture.class.getPackage().getName();
     ClassLoader classLoader = AbstractFutureFallbackAtomicHelperTest.class.getClassLoader();
     // we delegate to the current classloader so both loaders agree on classes like TestCase
     return new URLClassLoader(ClassPathUtil.getClassPathUrls(), classLoader) {
       @Override
       public Class<?> loadClass(String name) throws ClassNotFoundException {
-        if (blacklist.contains(name)) {
+        if (disallowedClassNames.contains(name)) {
           throw new ClassNotFoundException(""I'm sorry Dave, I'm afraid I can't do that."");
         }
         if (name.startsWith(concurrentPackage)) {, @@ -48,7 +48,7 @@
 public class AggregateFutureStateFallbackAtomicHelperTest extends TestCase {
 
   /**
-   * This classloader blacklists AtomicReferenceFieldUpdater and AtomicIntegerFieldUpdate which will
+   * This classloader disallows AtomicReferenceFieldUpdater and AtomicIntegerFieldUpdate which will
    * prevent us from selecting our {@code SafeAtomicHelper} strategy.
    *
    * <p>Stashing this in a static field avoids loading it over and over again and speeds up test
@@ -81,7 +81,7 @@ public void runTest() throws Exception {
     checkHelperVersion(getClass().getClassLoader(), ""SafeAtomicHelper"");
     checkHelperVersion(NO_ATOMIC_FIELD_UPDATER, ""SynchronizedAtomicHelper"");
 
-    // Run the corresponding FuturesTest test method in a new classloader that blacklists
+    // Run the corresponding FuturesTest test method in a new classloader that disallows
     // certain core jdk classes.
     ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();
     Thread.currentThread().setContextClassLoader(NO_ATOMIC_FIELD_UPDATER);
@@ -110,14 +110,14 @@ private void checkHelperVersion(ClassLoader classLoader, String expectedHelperCl
     assertEquals(expectedHelperClassName, helperField.get(null).getClass().getSimpleName());
   }
 
-  private static ClassLoader getClassLoader(final Set<String> blacklist) {
+  private static ClassLoader getClassLoader(final Set<String> blocklist) {
     final String concurrentPackage = SettableFuture.class.getPackage().getName();
     ClassLoader classLoader = AggregateFutureStateFallbackAtomicHelperTest.class.getClassLoader();
     // we delegate to the current classloader so both loaders agree on classes like TestCase
     return new URLClassLoader(ClassPathUtil.getClassPathUrls(), classLoader) {
       @Override
       public Class<?> loadClass(String name) throws ClassNotFoundException {
-        if (blacklist.contains(name)) {
+        if (blocklist.contains(name)) {
           throw new ClassNotFoundException(""I'm sorry Dave, I'm afraid I can't do that."");
         }
         if (name.startsWith(concurrentPackage)) {, @@ -467,7 +467,7 @@ private static Object invokeAccessibleNonThrowingMethod(
       (jla == null) ? null : getSizeMethod();
 
   /**
-   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not whitelisted for
+   * Returns the JavaLangAccess class that is present in all Sun JDKs. It is not allowed in
    * AppEngine, and not present in non-Sun JDKs.
    */
   @GwtIncompatible // java.lang.reflect
@@ -484,7 +484,7 @@ private static Object invokeAccessibleNonThrowingMethod(
       throw death;
     } catch (Throwable t) {
       /*
-       * This is not one of AppEngine's whitelisted classes, so even in Sun JDKs, this can fail with
+       * This is not one of AppEngine's allowed classes, so even in Sun JDKs, this can fail with
        * a NoClassDefFoundError. Other apps might deny access to sun.misc packages.
        */
       return null;, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix nonpublic identifiers and documentation that use ""whitelist"" or ""blacklist"" to use less problematic terms.

8a21b1c960067ef89e729eeeaeeb3e224692ee37",Moe Sync
3191,Colin Decker,"['android/guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java', 'android/guava-testlib/src/com/google/common/testing/TearDownStack.java', 'android/guava/src/com/google/common/base/CaseFormat.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'android/guava/src/com/google/common/collect/MapMakerInternalMap.java', 'android/guava/src/com/google/common/collect/RegularContiguousSet.java', 'android/guava/src/com/google/common/hash/BloomFilter.java', 'android/guava/src/com/google/common/hash/Hashing.java', 'android/guava/src/com/google/common/math/DoubleUtils.java', 'android/guava/src/com/google/common/math/PairedStats.java', 'guava-testlib/src/com/google/common/collect/testing/google/SetGenerators.java', 'guava-testlib/src/com/google/common/collect/testing/testers/ListReplaceAllTester.java', 'guava-testlib/src/com/google/common/testing/TearDownStack.java', 'guava/src/com/google/common/base/CaseFormat.java', 'guava/src/com/google/common/collect/CollectSpliterators.java', 'guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'guava/src/com/google/common/collect/MapMakerInternalMap.java', 'guava/src/com/google/common/collect/RegularContiguousSet.java', 'guava/src/com/google/common/hash/BloomFilter.java', 'guava/src/com/google/common/hash/Hashing.java', 'guava/src/com/google/common/math/DoubleUtils.java', 'guava/src/com/google/common/math/PairedStats.java']","@@ -355,7 +355,7 @@
     @Override
     protected SortedSet<Integer> create(Integer[] elements) {
       SortedSet<Integer> set = nullCheckedTreeSet(elements);
-      int tooHigh = (set.isEmpty()) ? 0 : set.last() + 1;
+      int tooHigh = set.isEmpty() ? 0 : set.last() + 1;
       set.add(tooHigh);
       return checkedCreate(set).headSet(tooHigh);
     }
@@ -365,7 +365,7 @@
     @Override
     protected SortedSet<Integer> create(Integer[] elements) {
       SortedSet<Integer> set = nullCheckedTreeSet(elements);
-      int tooLow = (set.isEmpty()) ? 0 : set.first() - 1;
+      int tooLow = set.isEmpty() ? 0 : set.first() - 1;
       set.add(tooLow);
       return checkedCreate(set).tailSet(tooLow + 1);
     }
@@ -417,7 +417,7 @@
         assertEquals(elements.get(i) + 1, (int) elements.get(i + 1));
       }
       Range<Integer> range =
-          (elements.isEmpty()) ? Range.closedOpen(0, 0) : Range.encloseAll(elements);
+          elements.isEmpty() ? Range.closedOpen(0, 0) : Range.encloseAll(elements);
       return ContiguousSet.create(range, DiscreteDomain.integers());
     }
   }, @@ -80,7 +80,7 @@ public final void runTearDown() {
         }
       }
     }
-    if ((!suppressThrows) && (exceptions.size() > 0)) {
+    if (!suppressThrows && (exceptions.size() > 0)) {
       throw ClusterException.create(exceptions);
     }
   }, @@ -202,7 +202,7 @@ private String normalizeFirstWord(String word) {
   }
 
   private static String firstCharOnlyToUpper(String word) {
-    return (word.isEmpty())
+    return word.isEmpty()
         ? word
         : Ascii.toUpperCase(word.charAt(0)) + Ascii.toLowerCase(word.substring(1));
   }, @@ -124,7 +124,7 @@ private void setSuccessor(int entry, int succ) {
   }
 
   private void setPredecessor(int entry, int pred) {
-    long predMask = (~0L) << 32;
+    long predMask = ~0L << 32;
     links[entry] = (links[entry] & ~predMask) | ((long) pred << 32);
   }
 , @@ -2189,7 +2189,7 @@ void maybeClearReferenceQueues() {
     @Override
     public WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> getWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e) {
-      return (castForTesting(e)).getValueReference();
+      return castForTesting(e).getValueReference();
     }
 
     @Override, @@ -41,7 +41,7 @@
   }
 
   private ContiguousSet<C> intersectionInCurrentDomain(Range<C> other) {
-    return (range.isConnected(other))
+    return range.isConnected(other)
         ? ContiguousSet.create(range.intersection(other), domain)
         : new EmptyContiguousSet<C>(domain);
   }, @@ -225,11 +225,11 @@ long bitSize() {
    */
   public boolean isCompatible(BloomFilter<T> that) {
     checkNotNull(that);
-    return (this != that)
-        && (this.numHashFunctions == that.numHashFunctions)
-        && (this.bitSize() == that.bitSize())
-        && (this.strategy.equals(that.strategy))
-        && (this.funnel.equals(that.funnel));
+    return this != that
+        && this.numHashFunctions == that.numHashFunctions
+        && this.bitSize() == that.bitSize()
+        && this.strategy.equals(that.strategy)
+        && this.funnel.equals(that.funnel);
   }
 
   /**, @@ -669,7 +669,7 @@ public LinearCongruentialGenerator(long seed) {
 
     public double nextDouble() {
       state = 2862933555777941757L * state + 1;
-      return ((double) ((int) (state >>> 33) + 1)) / (0x1.0p31);
+      return ((double) ((int) (state >>> 33) + 1)) / 0x1.0p31;
     }
   }
 , @@ -116,7 +116,7 @@ static double bigToDouble(BigInteger x) {
     boolean increment =
         (twiceSignifFloor & 1) != 0 && ((signifFloor & 1) != 0 || absX.getLowestSetBit() < shift);
     long signifRounded = increment ? signifFloor + 1 : signifFloor;
-    long bits = (long) ((exponent + EXPONENT_BIAS)) << SIGNIFICAND_BITS;
+    long bits = (long) (exponent + EXPONENT_BIAS) << SIGNIFICAND_BITS;
     bits += signifRounded;
     /*
      * If signifRounded == 2^53, we'd need to set all of the significand bits to zero and add 1 to, @@ -221,10 +221,10 @@ public boolean equals(@NullableDecl Object obj) {
       return false;
     }
     PairedStats other = (PairedStats) obj;
-    return (xStats.equals(other.xStats))
-        && (yStats.equals(other.yStats))
-        && (doubleToLongBits(sumOfProductsOfDeltas)
-            == doubleToLongBits(other.sumOfProductsOfDeltas));
+    return xStats.equals(other.xStats)
+        && yStats.equals(other.yStats)
+        && doubleToLongBits(sumOfProductsOfDeltas)
+            == doubleToLongBits(other.sumOfProductsOfDeltas);
   }
 
   /**, @@ -355,7 +355,7 @@
     @Override
     protected SortedSet<Integer> create(Integer[] elements) {
       SortedSet<Integer> set = nullCheckedTreeSet(elements);
-      int tooHigh = (set.isEmpty()) ? 0 : set.last() + 1;
+      int tooHigh = set.isEmpty() ? 0 : set.last() + 1;
       set.add(tooHigh);
       return checkedCreate(set).headSet(tooHigh);
     }
@@ -365,7 +365,7 @@
     @Override
     protected SortedSet<Integer> create(Integer[] elements) {
       SortedSet<Integer> set = nullCheckedTreeSet(elements);
-      int tooLow = (set.isEmpty()) ? 0 : set.first() - 1;
+      int tooLow = set.isEmpty() ? 0 : set.first() - 1;
       set.add(tooLow);
       return checkedCreate(set).tailSet(tooLow + 1);
     }
@@ -417,7 +417,7 @@
         assertEquals(elements.get(i) + 1, (int) elements.get(i + 1));
       }
       Range<Integer> range =
-          (elements.isEmpty()) ? Range.closedOpen(0, 0) : Range.encloseAll(elements);
+          elements.isEmpty() ? Range.closedOpen(0, 0) : Range.encloseAll(elements);
       return ContiguousSet.create(range, DiscreteDomain.integers());
     }
   }, @@ -43,7 +43,7 @@ public void testReplaceAll() {
 
   @ListFeature.Require(SUPPORTS_SET)
   public void testReplaceAll_changesSome() {
-    getList().replaceAll(e -> (e.equals(samples.e0())) ? samples.e3() : e);
+    getList().replaceAll(e -> e.equals(samples.e0()) ? samples.e3() : e);
     E[] expected = createSamplesArray();
     for (int i = 0; i < expected.length; i++) {
       if (expected[i].equals(samples.e0())) {, @@ -80,7 +80,7 @@ public final void runTearDown() {
         }
       }
     }
-    if ((!suppressThrows) && (exceptions.size() > 0)) {
+    if (!suppressThrows && (exceptions.size() > 0)) {
       throw ClusterException.create(exceptions);
     }
   }, @@ -202,7 +202,7 @@ private String normalizeFirstWord(String word) {
   }
 
   private static String firstCharOnlyToUpper(String word) {
-    return (word.isEmpty())
+    return word.isEmpty()
         ? word
         : Ascii.toUpperCase(word.charAt(0)) + Ascii.toLowerCase(word.substring(1));
   }, @@ -45,7 +45,7 @@ private CollectSpliterators() {}
       IntFunction<T> function,
       Comparator<? super T> comparator) {
     if (comparator != null) {
-      checkArgument((extraCharacteristics & (Spliterator.SORTED)) != 0);
+      checkArgument((extraCharacteristics & Spliterator.SORTED) != 0);
     }
     class WithCharacteristics implements Spliterator<T> {
       private final Spliterator.OfInt delegate;, @@ -135,7 +135,7 @@ private void setSuccessor(int entry, int succ) {
   }
 
   private void setPredecessor(int entry, int pred) {
-    long predMask = (~0L) << 32;
+    long predMask = ~0L << 32;
     links[entry] = (links[entry] & ~predMask) | ((long) pred << 32);
   }
 , @@ -2184,7 +2184,7 @@ void maybeClearReferenceQueues() {
     @Override
     public WeakValueReference<K, V, WeakKeyWeakValueEntry<K, V>> getWeakValueReferenceForTesting(
         InternalEntry<K, V, ?> e) {
-      return (castForTesting(e)).getValueReference();
+      return castForTesting(e).getValueReference();
     }
 
     @Override, @@ -41,7 +41,7 @@
   }
 
   private ContiguousSet<C> intersectionInCurrentDomain(Range<C> other) {
-    return (range.isConnected(other))
+    return range.isConnected(other)
         ? ContiguousSet.create(range.intersection(other), domain)
         : new EmptyContiguousSet<C>(domain);
   }, @@ -226,11 +226,11 @@ long bitSize() {
    */
   public boolean isCompatible(BloomFilter<T> that) {
     checkNotNull(that);
-    return (this != that)
-        && (this.numHashFunctions == that.numHashFunctions)
-        && (this.bitSize() == that.bitSize())
-        && (this.strategy.equals(that.strategy))
-        && (this.funnel.equals(that.funnel));
+    return this != that
+        && this.numHashFunctions == that.numHashFunctions
+        && this.bitSize() == that.bitSize()
+        && this.strategy.equals(that.strategy)
+        && this.funnel.equals(that.funnel);
   }
 
   /**, @@ -669,7 +669,7 @@ public LinearCongruentialGenerator(long seed) {
 
     public double nextDouble() {
       state = 2862933555777941757L * state + 1;
-      return ((double) ((int) (state >>> 33) + 1)) / (0x1.0p31);
+      return ((double) ((int) (state >>> 33) + 1)) / 0x1.0p31;
     }
   }
 , @@ -116,7 +116,7 @@ static double bigToDouble(BigInteger x) {
     boolean increment =
         (twiceSignifFloor & 1) != 0 && ((signifFloor & 1) != 0 || absX.getLowestSetBit() < shift);
     long signifRounded = increment ? signifFloor + 1 : signifFloor;
-    long bits = (long) ((exponent + EXPONENT_BIAS)) << SIGNIFICAND_BITS;
+    long bits = (long) (exponent + EXPONENT_BIAS) << SIGNIFICAND_BITS;
     bits += signifRounded;
     /*
      * If signifRounded == 2^53, we'd need to set all of the significand bits to zero and add 1 to, @@ -221,10 +221,10 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     PairedStats other = (PairedStats) obj;
-    return (xStats.equals(other.xStats))
-        && (yStats.equals(other.yStats))
-        && (doubleToLongBits(sumOfProductsOfDeltas)
-            == doubleToLongBits(other.sumOfProductsOfDeltas));
+    return xStats.equals(other.xStats)
+        && yStats.equals(other.yStats)
+        && doubleToLongBits(sumOfProductsOfDeltas)
+            == doubleToLongBits(other.sumOfProductsOfDeltas);
   }
 
   /**, ",This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.,Moe Sync
3197,Colin Decker,"['android/guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Files.java']","@@ -631,12 +631,7 @@ public static MappedByteBuffer map(File file) throws IOException {
    * @since 2.0
    */
   public static MappedByteBuffer map(File file, MapMode mode) throws IOException {
-    checkNotNull(file);
-    checkNotNull(mode);
-    if (!file.exists()) {
-      throw new FileNotFoundException(file.toString());
-    }
-    return map(file, mode, file.length());
+    return mapInternal(file, mode, -1);
   }
 
   /**
@@ -658,29 +653,22 @@ public static MappedByteBuffer map(File file, MapMode mode) throws IOException {
    * @see FileChannel#map(MapMode, long, long)
    * @since 2.0
    */
-  public static MappedByteBuffer map(File file, MapMode mode, long size)
-      throws FileNotFoundException, IOException {
+  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {
+    checkArgument(size >= 0, ""size (%s) may not be negative"", size);
+    return mapInternal(file, mode, size);
+  }
+
+  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)
+      throws IOException {
     checkNotNull(file);
     checkNotNull(mode);
 
     Closer closer = Closer.create();
     try {
       RandomAccessFile raf =
           closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? ""r"" : ""rw""));
-      return map(raf, mode, size);
-    } catch (Throwable e) {
-      throw closer.rethrow(e);
-    } finally {
-      closer.close();
-    }
-  }
-
-  private static MappedByteBuffer map(RandomAccessFile raf, MapMode mode, long size)
-      throws IOException {
-    Closer closer = Closer.create();
-    try {
       FileChannel channel = closer.register(raf.getChannel());
-      return channel.map(mode, 0, size);
+      return channel.map(mode, 0, size == -1 ? channel.size() : size);
     } catch (Throwable e) {
       throw closer.rethrow(e);
     } finally {, @@ -631,12 +631,7 @@ public static MappedByteBuffer map(File file) throws IOException {
    * @since 2.0
    */
   public static MappedByteBuffer map(File file, MapMode mode) throws IOException {
-    checkNotNull(file);
-    checkNotNull(mode);
-    if (!file.exists()) {
-      throw new FileNotFoundException(file.toString());
-    }
-    return map(file, mode, file.length());
+    return mapInternal(file, mode, -1);
   }
 
   /**
@@ -658,29 +653,22 @@ public static MappedByteBuffer map(File file, MapMode mode) throws IOException {
    * @see FileChannel#map(MapMode, long, long)
    * @since 2.0
    */
-  public static MappedByteBuffer map(File file, MapMode mode, long size)
-      throws FileNotFoundException, IOException {
+  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {
+    checkArgument(size >= 0, ""size (%s) may not be negative"", size);
+    return mapInternal(file, mode, size);
+  }
+
+  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)
+      throws IOException {
     checkNotNull(file);
     checkNotNull(mode);
 
     Closer closer = Closer.create();
     try {
       RandomAccessFile raf =
           closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? ""r"" : ""rw""));
-      return map(raf, mode, size);
-    } catch (Throwable e) {
-      throw closer.rethrow(e);
-    } finally {
-      closer.close();
-    }
-  }
-
-  private static MappedByteBuffer map(RandomAccessFile raf, MapMode mode, long size)
-      throws IOException {
-    Closer closer = Closer.create();
-    try {
       FileChannel channel = closer.register(raf.getChannel());
-      return channel.map(mode, 0, size);
+      return channel.map(mode, 0, size == -1 ? channel.size() : size);
     } catch (Throwable e) {
       throw closer.rethrow(e);
     } finally {, ",This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.,Moe Sync
3204,Ron Shapiro,"['android/guava-tests/test/com/google/common/base/SplitterTest.java', 'android/guava/src/com/google/common/base/CommonPattern.java', 'android/guava/src/com/google/common/base/PatternCompiler.java', 'android/guava/src/com/google/common/base/Platform.java', 'android/guava/src/com/google/common/primitives/Doubles.java', 'guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java', 'guava-tests/test/com/google/common/base/SplitterTest.java', 'guava/src/com/google/common/base/CommonPattern.java', 'guava/src/com/google/common/base/PatternCompiler.java', 'guava/src/com/google/common/base/Platform.java', 'guava/src/com/google/common/primitives/Doubles.java']","@@ -354,7 +354,7 @@ public void testPatternSplitWithDoubleDelimiterOmitEmptyStrings() {
   @GwtIncompatible // java.util.regex.Pattern
   @AndroidIncompatible // Bug in older versions of Android we test against, since fixed.
   public void testPatternSplitLookBehind() {
-    if (!Platform.usingJdkPatternCompiler()) {
+    if (!CommonPattern.isPcreLike()) {
       return;
     }
     String toSplit = "":foo::barbaz:"";
@@ -491,7 +491,7 @@ public void testSplitterIterableIsLazy_string() {
   @GwtIncompatible // java.util.regex.Pattern
   @AndroidIncompatible // not clear that j.u.r.Matcher promises to handle mutations during use
   public void testSplitterIterableIsLazy_pattern() {
-    if (!Platform.usingJdkPatternCompiler()) {
+    if (!CommonPattern.isPcreLike()) {
       return;
     }
     assertSplitterIterableIsLazy(Splitter.onPattern("",""));, @@ -33,7 +33,11 @@
   @Override
   public abstract String toString();
 
-  static CommonPattern compile(String pattern) {
+  public static CommonPattern compile(String pattern) {
     return Platform.compilePattern(pattern);
   }
+
+  public static boolean isPcreLike() {
+    return Platform.patternCompilerIsPcreLike();
+  }
 }, @@ -29,4 +29,10 @@
    * @throws IllegalArgumentException if the pattern is invalid
    */
   CommonPattern compile(String pattern);
+
+  /**
+   * Returns {@code true} if the regex implementation behaves like Perl -- notably, by supporting
+   * possessive quantifiers but also being susceptible to catastrophic backtracking.
+   */
+  boolean isPcreLike();
 }, @@ -70,8 +70,8 @@ static CommonPattern compilePattern(String pattern) {
     return patternCompiler.compile(pattern);
   }
 
-  static boolean usingJdkPatternCompiler() {
-    return patternCompiler instanceof JdkPatternCompiler;
+  static boolean patternCompilerIsPcreLike() {
+    return patternCompiler.isPcreLike();
   }
 
   private static PatternCompiler loadPatternCompiler() {
@@ -92,5 +92,10 @@ private static void logPatternCompilerError(ServiceConfigurationError e) {
     public CommonPattern compile(String pattern) {
       return new JdkPattern(Pattern.compile(pattern));
     }
+
+    @Override
+    public boolean isPcreLike() {
+      return true;
+    }
   }
 }, @@ -33,7 +33,6 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.RandomAccess;
-import java.util.regex.Pattern;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
@@ -646,16 +645,32 @@ public String toString() {
    * that pass this regex are valid -- only a performance hit is incurred, not a semantics bug.
    */
   @GwtIncompatible // regular expressions
-  static final Pattern FLOATING_POINT_PATTERN = fpPattern();
+  static final
+  java.util.regex.Pattern
+      FLOATING_POINT_PATTERN = fpPattern();
 
   @GwtIncompatible // regular expressions
-  private static Pattern fpPattern() {
-    String decimal = ""(?:\\d++(?:\\.\\d*+)?|\\.\\d++)"";
-    String completeDec = decimal + ""(?:[eE][+-]?\\d++)?[fFdD]?"";
-    String hex = ""(?:\\p{XDigit}++(?:\\.\\p{XDigit}*+)?|\\.\\p{XDigit}++)"";
-    String completeHex = ""0[xX]"" + hex + ""[pP][+-]?\\d++[fFdD]?"";
+  private static
+  java.util.regex.Pattern
+      fpPattern() {
+    /*
+     * We use # instead of * for possessive quantifiers. This lets us strip them out when building
+     * the regex for RE2 (which doesn't support them) but leave them in when building it for
+     * java.util.regex (where we want them in order to avoid catastrophic backtracking).
+     */
+    String decimal = ""(?:\\d+#(?:\\.\\d*#)?|\\.\\d+#)"";
+    String completeDec = decimal + ""(?:[eE][+-]?\\d+#)?[fFdD]?"";
+    String hex = ""(?:[0-9a-fA-F]+#(?:\\.[0-9a-fA-F]*#)?|\\.[0-9a-fA-F]+#)"";
+    String completeHex = ""0[xX]"" + hex + ""[pP][+-]?\\d+#[fFdD]?"";
     String fpPattern = ""[+-]?(?:NaN|Infinity|"" + completeDec + ""|"" + completeHex + "")"";
-    return Pattern.compile(fpPattern);
+    fpPattern =
+        fpPattern.replace(
+            ""#"",
+            ""+""
+            );
+    return
+    java.util.regex.Pattern
+        .compile(fpPattern);
   }
 
   /**, @@ -75,8 +75,8 @@ static CommonPattern compilePattern(String pattern) {
     throw new UnsupportedOperationException();
   }
 
-  static boolean usingJdkPatternCompiler() {
-    return false;
+  static boolean patternCompilerIsPcreLike() {
+    throw new UnsupportedOperationException();
   }
 
   private Platform() {}, @@ -354,7 +354,7 @@ public void testPatternSplitWithDoubleDelimiterOmitEmptyStrings() {
   @GwtIncompatible // java.util.regex.Pattern
   @AndroidIncompatible // Bug in older versions of Android we test against, since fixed.
   public void testPatternSplitLookBehind() {
-    if (!Platform.usingJdkPatternCompiler()) {
+    if (!CommonPattern.isPcreLike()) {
       return;
     }
     String toSplit = "":foo::barbaz:"";
@@ -491,7 +491,7 @@ public void testSplitterIterableIsLazy_string() {
   @GwtIncompatible // java.util.regex.Pattern
   @AndroidIncompatible // not clear that j.u.r.Matcher promises to handle mutations during use
   public void testSplitterIterableIsLazy_pattern() {
-    if (!Platform.usingJdkPatternCompiler()) {
+    if (!CommonPattern.isPcreLike()) {
       return;
     }
     assertSplitterIterableIsLazy(Splitter.onPattern("",""));, @@ -33,7 +33,11 @@
   @Override
   public abstract String toString();
 
-  static CommonPattern compile(String pattern) {
+  public static CommonPattern compile(String pattern) {
     return Platform.compilePattern(pattern);
   }
+
+  public static boolean isPcreLike() {
+    return Platform.patternCompilerIsPcreLike();
+  }
 }, @@ -29,4 +29,10 @@
    * @throws IllegalArgumentException if the pattern is invalid
    */
   CommonPattern compile(String pattern);
+
+  /**
+   * Returns {@code true} if the regex implementation behaves like Perl -- notably, by supporting
+   * possessive quantifiers but also being susceptible to catastrophic backtracking.
+   */
+  boolean isPcreLike();
 }, @@ -70,8 +70,8 @@ static CommonPattern compilePattern(String pattern) {
     return patternCompiler.compile(pattern);
   }
 
-  static boolean usingJdkPatternCompiler() {
-    return patternCompiler instanceof JdkPatternCompiler;
+  static boolean patternCompilerIsPcreLike() {
+    return patternCompiler.isPcreLike();
   }
 
   private static PatternCompiler loadPatternCompiler() {
@@ -87,5 +87,10 @@ private static void logPatternCompilerError(ServiceConfigurationError e) {
     public CommonPattern compile(String pattern) {
       return new JdkPattern(Pattern.compile(pattern));
     }
+
+    @Override
+    public boolean isPcreLike() {
+      return true;
+    }
   }
 }, @@ -35,7 +35,6 @@
 import java.util.RandomAccess;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.regex.Pattern;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -653,16 +652,32 @@ public String toString() {
    * that pass this regex are valid -- only a performance hit is incurred, not a semantics bug.
    */
   @GwtIncompatible // regular expressions
-  static final Pattern FLOATING_POINT_PATTERN = fpPattern();
+  static final
+  java.util.regex.Pattern
+      FLOATING_POINT_PATTERN = fpPattern();
 
   @GwtIncompatible // regular expressions
-  private static Pattern fpPattern() {
-    String decimal = ""(?:\\d++(?:\\.\\d*+)?|\\.\\d++)"";
-    String completeDec = decimal + ""(?:[eE][+-]?\\d++)?[fFdD]?"";
-    String hex = ""(?:\\p{XDigit}++(?:\\.\\p{XDigit}*+)?|\\.\\p{XDigit}++)"";
-    String completeHex = ""0[xX]"" + hex + ""[pP][+-]?\\d++[fFdD]?"";
+  private static
+  java.util.regex.Pattern
+      fpPattern() {
+    /*
+     * We use # instead of * for possessive quantifiers. This lets us strip them out when building
+     * the regex for RE2 (which doesn't support them) but leave them in when building it for
+     * java.util.regex (where we want them in order to avoid catastrophic backtracking).
+     */
+    String decimal = ""(?:\\d+#(?:\\.\\d*#)?|\\.\\d+#)"";
+    String completeDec = decimal + ""(?:[eE][+-]?\\d+#)?[fFdD]?"";
+    String hex = ""(?:[0-9a-fA-F]+#(?:\\.[0-9a-fA-F]*#)?|\\.[0-9a-fA-F]+#)"";
+    String completeHex = ""0[xX]"" + hex + ""[pP][+-]?\\d+#[fFdD]?"";
     String fpPattern = ""[+-]?(?:NaN|Infinity|"" + completeDec + ""|"" + completeHex + "")"";
-    return Pattern.compile(fpPattern);
+    fpPattern =
+        fpPattern.replace(
+            ""#"",
+            ""+""
+            );
+    return
+    java.util.regex.Pattern
+        .compile(fpPattern);
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adds constants for Sec-Metadata header.

https://github.com/mikewest/sec-metadata

RELNOTES=Adds constants for Sec-Metadata header.

2035a276dcecb354dcf68b41f11480786cdeb109

-------

<p> Update Public Suffix data.

This copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

0dc71528308c0ff43961b4869df55b0f582c963b

-------

<p> Add @Nullable to AbstractSequentialIterator's computeNext() method return value so that [] doesn't complain

e59ed3d738accabf895ede47ae07b9cf320b6c8a

-------

<p> Internally, use PatternCompiler from Doubles.tryParse.

(Redo of CL 202132002, which was partially rolled back in CL 202139691.)

This time including tests to cover the RE2J approach.
To avoid the errors of last time, I had to remove the possessive quantifiers under RE2J and replace \p{XDigit} with [0-9a-fA-F] (which is equivalent; see the Pattern Javadoc).

e51afe5a60f68c169e1aec6d30112bb77e423fdd",Moe Sync
3205,Ron Shapiro,"['android/guava-tests/test/com/google/common/net/HostAndPortTest.java', 'android/guava/src/com/google/common/net/HostAndPort.java', 'guava-tests/test/com/google/common/net/HostAndPortTest.java', 'guava/src/com/google/common/net/HostAndPort.java']","@@ -193,15 +193,19 @@ public void testGetPortOrDefault() {
   }
 
   public void testHashCodeAndEquals() {
-    HostAndPort hp1 = HostAndPort.fromString(""foo::123"");
-    HostAndPort hp2 = HostAndPort.fromString(""foo::123"");
-    HostAndPort hp3 = HostAndPort.fromString(""[foo::123]"");
-    HostAndPort hp4 = HostAndPort.fromParts(""[foo::123]"", 80);
-    HostAndPort hp5 = HostAndPort.fromString(""[foo::123]:80"");
+    HostAndPort hpNoPort1 = HostAndPort.fromString(""foo::123"");
+    HostAndPort hpNoPort2 = HostAndPort.fromString(""foo::123"");
+    HostAndPort hpNoPort3 = HostAndPort.fromString(""[foo::123]"");
+    HostAndPort hpNoPort4 = HostAndPort.fromHost(""[foo::123]"");
+    HostAndPort hpNoPort5 = HostAndPort.fromHost(""foo::123"");
+
+    HostAndPort hpWithPort1 = HostAndPort.fromParts(""[foo::123]"", 80);
+    HostAndPort hpWithPort2 = HostAndPort.fromParts(""foo::123"", 80);
+    HostAndPort hpWithPort3 = HostAndPort.fromString(""[foo::123]:80"");
+
     new EqualsTester()
-        .addEqualityGroup(hp1, hp2)
-        .addEqualityGroup(hp3)
-        .addEqualityGroup(hp4, hp5)
+        .addEqualityGroup(hpNoPort1, hpNoPort2, hpNoPort3, hpNoPort4, hpNoPort5)
+        .addEqualityGroup(hpWithPort1, hpWithPort2, hpWithPort3)
         .testEquals();
   }
 , @@ -283,16 +283,14 @@ public boolean equals(@NullableDecl Object other) {
     }
     if (other instanceof HostAndPort) {
       HostAndPort that = (HostAndPort) other;
-      return Objects.equal(this.host, that.host)
-          && this.port == that.port
-          && this.hasBracketlessColons == that.hasBracketlessColons;
+      return Objects.equal(this.host, that.host) && this.port == that.port;
     }
     return false;
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(host, port, hasBracketlessColons);
+    return Objects.hashCode(host, port);
   }
 
   /** Rebuild the host:port string, including brackets if necessary. */, @@ -193,15 +193,19 @@ public void testGetPortOrDefault() {
   }
 
   public void testHashCodeAndEquals() {
-    HostAndPort hp1 = HostAndPort.fromString(""foo::123"");
-    HostAndPort hp2 = HostAndPort.fromString(""foo::123"");
-    HostAndPort hp3 = HostAndPort.fromString(""[foo::123]"");
-    HostAndPort hp4 = HostAndPort.fromParts(""[foo::123]"", 80);
-    HostAndPort hp5 = HostAndPort.fromString(""[foo::123]:80"");
+    HostAndPort hpNoPort1 = HostAndPort.fromString(""foo::123"");
+    HostAndPort hpNoPort2 = HostAndPort.fromString(""foo::123"");
+    HostAndPort hpNoPort3 = HostAndPort.fromString(""[foo::123]"");
+    HostAndPort hpNoPort4 = HostAndPort.fromHost(""[foo::123]"");
+    HostAndPort hpNoPort5 = HostAndPort.fromHost(""foo::123"");
+
+    HostAndPort hpWithPort1 = HostAndPort.fromParts(""[foo::123]"", 80);
+    HostAndPort hpWithPort2 = HostAndPort.fromParts(""foo::123"", 80);
+    HostAndPort hpWithPort3 = HostAndPort.fromString(""[foo::123]:80"");
+
     new EqualsTester()
-        .addEqualityGroup(hp1, hp2)
-        .addEqualityGroup(hp3)
-        .addEqualityGroup(hp4, hp5)
+        .addEqualityGroup(hpNoPort1, hpNoPort2, hpNoPort3, hpNoPort4, hpNoPort5)
+        .addEqualityGroup(hpWithPort1, hpWithPort2, hpWithPort3)
         .testEquals();
   }
 , @@ -283,16 +283,14 @@ public boolean equals(@Nullable Object other) {
     }
     if (other instanceof HostAndPort) {
       HostAndPort that = (HostAndPort) other;
-      return Objects.equal(this.host, that.host)
-          && this.port == that.port
-          && this.hasBracketlessColons == that.hasBracketlessColons;
+      return Objects.equal(this.host, that.host) && this.port == that.port;
     }
     return false;
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(host, port, hasBracketlessColons);
+    return Objects.hashCode(host, port);
   }
 
   /** Rebuild the host:port string, including brackets if necessary. */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Change HostAndPort equals() and hashCode() to stop depending on whether brackets were included

Now they depend only on host and port.

Useful for storing IPv6 addresses in Set and Map

RELNOTES=`net.HostAndPort`: Changed equals() and hashCode() to stop depending on whether brackets were included. Now they depend only on host and port.

6684d0f68ae91d41eac67873d87e13e2ae2b1db0",Moe Sync
3218,Ron Shapiro,"['android/guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'android/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java', 'guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'guava/src/com/google/common/util/concurrent/ExecutionSequencer.java']","@@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2018 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.util.concurrent;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.util.concurrent.Futures.getDone;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link ExecutionSequencer} */
-@RunWith(JUnit4.class)
-public class ExecutionSequencerTest {
-
-  ExecutorService executor;
-
-  private ExecutionSequencer serializer;
-  private SettableFuture<Void> firstFuture;
-  private TestCallable firstCallable;
-
-  @Before
-  public void setUp() throws Exception {
-    executor = Executors.newCachedThreadPool();
-    serializer = ExecutionSequencer.create();
-    firstFuture = SettableFuture.create();
-    firstCallable = new TestCallable(firstFuture);
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    executor.shutdown();
-  }
-
-  @Test
-  public void testCallableStartsAfterFirstFutureCompletes() {
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
-    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError1 = serializer.submitAsync(secondCallable, directExecutor());
-    assertThat(firstCallable.called).isTrue();
-    assertThat(secondCallable.called).isFalse();
-    firstFuture.set(null);
-    assertThat(secondCallable.called).isTrue();
-  }
-
-  @Test
-  public void testCancellationNotPropagatedIfAlreadyStarted() {
-    serializer.submitAsync(firstCallable, directExecutor()).cancel(true);
-    assertThat(firstFuture.isCancelled()).isFalse();
-  }
-
-  @Test
-  public void testCancellationDoesNotViolateSerialization() {
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
-    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    ListenableFuture<Void> secondFuture = serializer.submitAsync(secondCallable, directExecutor());
-    TestCallable thirdCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
-    secondFuture.cancel(true);
-    assertThat(secondCallable.called).isFalse();
-    assertThat(thirdCallable.called).isFalse();
-    firstFuture.set(null);
-    assertThat(secondCallable.called).isFalse();
-    assertThat(thirdCallable.called).isTrue();
-  }
-
-  @Test
-  public void testCancellationMultipleThreads() throws Exception {
-    final BlockingCallable blockingCallable = new BlockingCallable();
-    ListenableFuture<Void> unused = serializer.submit(blockingCallable, executor);
-    ListenableFuture<Boolean> future2 =
-        serializer.submit(
-            new Callable<Boolean>() {
-              @Override
-              public Boolean call() {
-                return blockingCallable.isRunning();
-              }
-            },
-            directExecutor());
-
-    // Wait for the first task to be started in the background. It will block until we explicitly
-    // stop it.
-    blockingCallable.waitForStart();
-
-    // Give the second task a chance to (incorrectly) start up while the first task is running.
-    assertThat(future2.isDone()).isFalse();
-
-    // Stop the first task. The second task should then run.
-    blockingCallable.stop();
-    executor.shutdown();
-    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
-    assertThat(getDone(future2)).isFalse();
-  }
-
-  @Test
-  public void secondTaskWaitsForFirstEvenIfCancelled() throws Exception {
-    final BlockingCallable blockingCallable = new BlockingCallable();
-    ListenableFuture<Void> future1 = serializer.submit(blockingCallable, executor);
-    ListenableFuture<Boolean> future2 =
-        serializer.submit(
-            new Callable<Boolean>() {
-              @Override
-              public Boolean call() {
-                return blockingCallable.isRunning();
-              }
-            },
-            directExecutor());
-
-    // Wait for the first task to be started in the background. It will block until we explicitly
-    // stop it.
-    blockingCallable.waitForStart();
-
-    // This time, cancel the future for the first task. The task remains running, only the future
-    // is cancelled.
-    future1.cancel(false);
-
-    // Give the second task a chance to (incorrectly) start up while the first task is running.
-    // (This is the assertion that fails.)
-    assertThat(future2.isDone()).isFalse();
-
-    // Stop the first task. The second task should then run.
-    blockingCallable.stop();
-    executor.shutdown();
-    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
-    assertThat(getDone(future2)).isFalse();
-  }
-
-  private static class BlockingCallable implements Callable<Void> {
-    private final CountDownLatch startLatch = new CountDownLatch(1);
-    private final CountDownLatch stopLatch = new CountDownLatch(1);
-
-    private volatile boolean running = false;
-
-    @Override
-    public Void call() throws InterruptedException {
-      running = true;
-      startLatch.countDown();
-      stopLatch.await();
-      running = false;
-      return null;
-    }
-
-    public void waitForStart() throws InterruptedException {
-      startLatch.await();
-    }
-
-    public void stop() {
-      stopLatch.countDown();
-    }
-
-    public boolean isRunning() {
-      return running;
-    }
-  }
-
-  private static final class TestCallable implements AsyncCallable<Void> {
-
-    private final ListenableFuture<Void> future;
-    private boolean called = false;
-
-    private TestCallable(ListenableFuture<Void> future) {
-      this.future = future;
-    }
-
-    @Override
-    public ListenableFuture<Void> call() throws Exception {
-      called = true;
-      return future;
-    }
-  }
-}, @@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2018 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.util.concurrent;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
-import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
-import static com.google.common.util.concurrent.Futures.immediateFuture;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-
-import com.google.common.annotations.Beta;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * Serializes execution of a set of operations. This class guarantees that a submitted callable will
- * not be called before previously submitted callables (and any {@code Future}s returned from them)
- * have completed.
- *
- * <p>This class implements a superset of the behavior of {@link
- * MoreExecutors#newSequentialExecutor}. If your tasks all run on the same underlying executor and
- * don't need to wait for {@code Future}s returned from {@code AsyncCallable}s, use it instead.
- *
- * @since NEXT
- */
-@Beta
-public final class ExecutionSequencer {
-
-  private ExecutionSequencer() {}
-
-  /** Creates a new instance. */
-  public static ExecutionSequencer create() {
-    return new ExecutionSequencer();
-  }
-
-  enum RunningState {
-    NOT_RUN,
-    CANCELLED,
-    STARTED,
-  }
-
-  /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
-  private final AtomicReference<ListenableFuture<Object>> ref =
-      new AtomicReference<>(immediateFuture(null));
-
-  /**
-   * Enqueues a task to run when the previous task (if any) completes.
-   *
-   * <p>Cancellation does not propagate from the output future to a callable that has begun to
-   * execute, but if the output future is cancelled before {@link Callable#call()} is invoked,
-   * {@link Callable#call()} will not be invoked.
-   */
-  public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
-    checkNotNull(callable);
-    return submitAsync(
-        new AsyncCallable<T>() {
-          @Override
-          public ListenableFuture<T> call() throws Exception {
-            return immediateFuture(callable.call());
-          }
-        },
-        executor);
-  }
-
-  /**
-   * Enqueues a task to run when the previous task (if any) completes.
-   *
-   * <p>Cancellation does not propagate from the output future to the future returned from {@code
-   * callable} or a callable that has begun to execute, but if the output future is cancelled before
-   * {@link AsyncCallable#call()} is invoked, {@link AsyncCallable#call()} will not be invoked.
-   */
-  public <T> ListenableFuture<T> submitAsync(
-      final AsyncCallable<T> callable, final Executor executor) {
-    checkNotNull(callable);
-    final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
-    final AsyncCallable<T> task =
-        new AsyncCallable<T>() {
-          @Override
-          public ListenableFuture<T> call() throws Exception {
-            if (!runningState.compareAndSet(NOT_RUN, STARTED)) {
-              return immediateCancelledFuture();
-            }
-            return callable.call();
-          }
-        };
-    /*
-     * Four futures are at play here:
-     * taskFuture is the future tracking the result of the callable.
-     * newFuture is a future that completes after this and all prior tasks are done.
-     * oldFuture is the previous task's newFuture.
-     * outputFuture is the future we return to the caller, a nonCancellationPropagating taskFuture.
-     *
-     * newFuture is guaranteed to only complete once all tasks previously submitted to this instance
-     * have completed - namely after oldFuture is done, and taskFuture has either completed or been
-     * cancelled before the callable started execution.
-     */
-    final SettableFuture<Object> newFuture = SettableFuture.create();
-
-    final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
-
-    // Invoke our task once the previous future completes.
-    final ListenableFuture<T> taskFuture =
-        Futures.submitAsync(
-            task,
-            new Executor() {
-              @Override
-              public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, executor);
-              }
-            });
-
-    final ListenableFuture<T> outputFuture = Futures.nonCancellationPropagating(taskFuture);
-
-    // newFuture's lifetime is determined by taskFuture, which can't complete before oldFuture
-    // unless taskFuture is cancelled, in which case it falls back to oldFuture. This ensures that
-    // if the future we return is cancelled, we don't begin execution of the next task until after
-    // oldFuture completes.
-    Runnable listener =
-        new Runnable() {
-          @Override
-          public void run() {
-            if (taskFuture.isDone()
-                // If this CAS succeeds, we know that the provided callable will never be invoked,
-                // so when oldFuture completes it is safe to allow the next submitted task to
-                // proceed.
-                || (outputFuture.isCancelled() && runningState.compareAndSet(NOT_RUN, CANCELLED))) {
-              // Since the value of oldFuture can only ever be immediateFuture(null) or setFuture of
-              // a future that eventually came from immediateFuture(null), this doesn't leak
-              // throwables or completion values.
-              newFuture.setFuture(oldFuture);
-            }
-          }
-        };
-    // Adding the listener to both futures guarantees that newFuture will aways be set. Adding to
-    // taskFuture guarantees completion if the callable is invoked, and adding to outputFuture
-    // propagates cancellation if the callable has not yet been invoked.
-    outputFuture.addListener(listener, directExecutor());
-    taskFuture.addListener(listener, directExecutor());
-
-    return outputFuture;
-  }
-}, @@ -1,196 +0,0 @@
-/*
- * Copyright (C) 2018 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.util.concurrent;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.util.concurrent.Futures.getDone;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link ExecutionSequencer} */
-@RunWith(JUnit4.class)
-public class ExecutionSequencerTest {
-
-  ExecutorService executor;
-
-  private ExecutionSequencer serializer;
-  private SettableFuture<Void> firstFuture;
-  private TestCallable firstCallable;
-
-  @Before
-  public void setUp() throws Exception {
-    executor = Executors.newCachedThreadPool();
-    serializer = ExecutionSequencer.create();
-    firstFuture = SettableFuture.create();
-    firstCallable = new TestCallable(firstFuture);
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    executor.shutdown();
-  }
-
-  @Test
-  public void testCallableStartsAfterFirstFutureCompletes() {
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
-    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError1 = serializer.submitAsync(secondCallable, directExecutor());
-    assertThat(firstCallable.called).isTrue();
-    assertThat(secondCallable.called).isFalse();
-    firstFuture.set(null);
-    assertThat(secondCallable.called).isTrue();
-  }
-
-  @Test
-  public void testCancellationNotPropagatedIfAlreadyStarted() {
-    serializer.submitAsync(firstCallable, directExecutor()).cancel(true);
-    assertThat(firstFuture.isCancelled()).isFalse();
-  }
-
-  @Test
-  public void testCancellationDoesNotViolateSerialization() {
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
-    TestCallable secondCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    ListenableFuture<Void> secondFuture = serializer.submitAsync(secondCallable, directExecutor());
-    TestCallable thirdCallable = new TestCallable(Futures.<Void>immediateFuture(null));
-    @SuppressWarnings({""unused"", ""nullness""})
-    Future<?> possiblyIgnoredError1 = serializer.submitAsync(thirdCallable, directExecutor());
-    secondFuture.cancel(true);
-    assertThat(secondCallable.called).isFalse();
-    assertThat(thirdCallable.called).isFalse();
-    firstFuture.set(null);
-    assertThat(secondCallable.called).isFalse();
-    assertThat(thirdCallable.called).isTrue();
-  }
-
-  @Test
-  public void testCancellationMultipleThreads() throws Exception {
-    final BlockingCallable blockingCallable = new BlockingCallable();
-    ListenableFuture<Void> unused = serializer.submit(blockingCallable, executor);
-    ListenableFuture<Boolean> future2 =
-        serializer.submit(
-            new Callable<Boolean>() {
-              @Override
-              public Boolean call() {
-                return blockingCallable.isRunning();
-              }
-            },
-            directExecutor());
-
-    // Wait for the first task to be started in the background. It will block until we explicitly
-    // stop it.
-    blockingCallable.waitForStart();
-
-    // Give the second task a chance to (incorrectly) start up while the first task is running.
-    assertThat(future2.isDone()).isFalse();
-
-    // Stop the first task. The second task should then run.
-    blockingCallable.stop();
-    executor.shutdown();
-    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
-    assertThat(getDone(future2)).isFalse();
-  }
-
-  @Test
-  public void secondTaskWaitsForFirstEvenIfCancelled() throws Exception {
-    final BlockingCallable blockingCallable = new BlockingCallable();
-    ListenableFuture<Void> future1 = serializer.submit(blockingCallable, executor);
-    ListenableFuture<Boolean> future2 =
-        serializer.submit(
-            new Callable<Boolean>() {
-              @Override
-              public Boolean call() {
-                return blockingCallable.isRunning();
-              }
-            },
-            directExecutor());
-
-    // Wait for the first task to be started in the background. It will block until we explicitly
-    // stop it.
-    blockingCallable.waitForStart();
-
-    // This time, cancel the future for the first task. The task remains running, only the future
-    // is cancelled.
-    future1.cancel(false);
-
-    // Give the second task a chance to (incorrectly) start up while the first task is running.
-    // (This is the assertion that fails.)
-    assertThat(future2.isDone()).isFalse();
-
-    // Stop the first task. The second task should then run.
-    blockingCallable.stop();
-    executor.shutdown();
-    assertThat(executor.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
-    assertThat(getDone(future2)).isFalse();
-  }
-
-  private static class BlockingCallable implements Callable<Void> {
-    private final CountDownLatch startLatch = new CountDownLatch(1);
-    private final CountDownLatch stopLatch = new CountDownLatch(1);
-
-    private volatile boolean running = false;
-
-    @Override
-    public Void call() throws InterruptedException {
-      running = true;
-      startLatch.countDown();
-      stopLatch.await();
-      running = false;
-      return null;
-    }
-
-    public void waitForStart() throws InterruptedException {
-      startLatch.await();
-    }
-
-    public void stop() {
-      stopLatch.countDown();
-    }
-
-    public boolean isRunning() {
-      return running;
-    }
-  }
-
-  private static final class TestCallable implements AsyncCallable<Void> {
-
-    private final ListenableFuture<Void> future;
-    private boolean called = false;
-
-    private TestCallable(ListenableFuture<Void> future) {
-      this.future = future;
-    }
-
-    @Override
-    public ListenableFuture<Void> call() throws Exception {
-      called = true;
-      return future;
-    }
-  }
-}, @@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2018 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.util.concurrent;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
-import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
-import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
-import static com.google.common.util.concurrent.Futures.immediateFuture;
-import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
-
-import com.google.common.annotations.Beta;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicReference;
-
-/**
- * Serializes execution of a set of operations. This class guarantees that a submitted callable will
- * not be called before previously submitted callables (and any {@code Future}s returned from them)
- * have completed.
- *
- * <p>This class implements a superset of the behavior of {@link
- * MoreExecutors#newSequentialExecutor}. If your tasks all run on the same underlying executor and
- * don't need to wait for {@code Future}s returned from {@code AsyncCallable}s, use it instead.
- *
- * @since NEXT
- */
-@Beta
-public final class ExecutionSequencer {
-
-  private ExecutionSequencer() {}
-
-  /** Creates a new instance. */
-  public static ExecutionSequencer create() {
-    return new ExecutionSequencer();
-  }
-
-  enum RunningState {
-    NOT_RUN,
-    CANCELLED,
-    STARTED,
-  }
-
-  /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
-  private final AtomicReference<ListenableFuture<Object>> ref =
-      new AtomicReference<>(immediateFuture(null));
-
-  /**
-   * Enqueues a task to run when the previous task (if any) completes.
-   *
-   * <p>Cancellation does not propagate from the output future to a callable that has begun to
-   * execute, but if the output future is cancelled before {@link Callable#call()} is invoked,
-   * {@link Callable#call()} will not be invoked.
-   */
-  public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
-    checkNotNull(callable);
-    return submitAsync(
-        new AsyncCallable<T>() {
-          @Override
-          public ListenableFuture<T> call() throws Exception {
-            return immediateFuture(callable.call());
-          }
-        },
-        executor);
-  }
-
-  /**
-   * Enqueues a task to run when the previous task (if any) completes.
-   *
-   * <p>Cancellation does not propagate from the output future to the future returned from {@code
-   * callable} or a callable that has begun to execute, but if the output future is cancelled before
-   * {@link AsyncCallable#call()} is invoked, {@link AsyncCallable#call()} will not be invoked.
-   */
-  public <T> ListenableFuture<T> submitAsync(
-      final AsyncCallable<T> callable, final Executor executor) {
-    checkNotNull(callable);
-    final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
-    final AsyncCallable<T> task =
-        new AsyncCallable<T>() {
-          @Override
-          public ListenableFuture<T> call() throws Exception {
-            if (!runningState.compareAndSet(NOT_RUN, STARTED)) {
-              return immediateCancelledFuture();
-            }
-            return callable.call();
-          }
-        };
-    /*
-     * Four futures are at play here:
-     * taskFuture is the future tracking the result of the callable.
-     * newFuture is a future that completes after this and all prior tasks are done.
-     * oldFuture is the previous task's newFuture.
-     * outputFuture is the future we return to the caller, a nonCancellationPropagating taskFuture.
-     *
-     * newFuture is guaranteed to only complete once all tasks previously submitted to this instance
-     * have completed - namely after oldFuture is done, and taskFuture has either completed or been
-     * cancelled before the callable started execution.
-     */
-    final SettableFuture<Object> newFuture = SettableFuture.create();
-
-    final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
-
-    // Invoke our task once the previous future completes.
-    final ListenableFuture<T> taskFuture =
-        Futures.submitAsync(
-            task,
-            new Executor() {
-              @Override
-              public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, executor);
-              }
-            });
-
-    final ListenableFuture<T> outputFuture = Futures.nonCancellationPropagating(taskFuture);
-
-    // newFuture's lifetime is determined by taskFuture, which can't complete before oldFuture
-    // unless taskFuture is cancelled, in which case it falls back to oldFuture. This ensures that
-    // if the future we return is cancelled, we don't begin execution of the next task until after
-    // oldFuture completes.
-    Runnable listener =
-        new Runnable() {
-          @Override
-          public void run() {
-            if (taskFuture.isDone()
-                // If this CAS succeeds, we know that the provided callable will never be invoked,
-                // so when oldFuture completes it is safe to allow the next submitted task to
-                // proceed.
-                || (outputFuture.isCancelled() && runningState.compareAndSet(NOT_RUN, CANCELLED))) {
-              // Since the value of oldFuture can only ever be immediateFuture(null) or setFuture of
-              // a future that eventually came from immediateFuture(null), this doesn't leak
-              // throwables or completion values.
-              newFuture.setFuture(oldFuture);
-            }
-          }
-        };
-    // Adding the listener to both futures guarantees that newFuture will aways be set. Adding to
-    // taskFuture guarantees completion if the callable is invoked, and adding to outputFuture
-    // propagates cancellation if the callable has not yet been invoked.
-    outputFuture.addListener(listener, directExecutor());
-    taskFuture.addListener(listener, directExecutor());
-
-    return outputFuture;
-  }
-}, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix initialCapacity calculation for a maximum size over Integer.MAX_VALUE.

Noticed during discussion of https://github.com/google/guava/issues/3202

813ebd6909096797c6587487a1c67931e73b2bc5

-------

<p> Remove Futures methods that implicitly use directExecutor().

RELNOTES=Removed the `Futures` methods that implicitly use `directExecutor()`.

52fa8683024d7093bb90df2789ac0a8ebf5aea04

-------

<p> Reduce ProGuard retained code from usages of Multimaps.synchronizedXYZMultimap.

Effects on MultimapSynchronizedProGuard:
JAR bytes: 148295 bytes => 50236 bytes (-66%)
Classes: 67 classes => 28 classes (-58%)
Methods: 458 methods => 155 methods (-66%)

b42b6d20bb20ff239a361d990fc3f42048a4d217

-------

<p> Remove deprecated CharMatcher constants.

RELNOTES=Removed deprecated `public static` fields from `CharMatcher`. Use the equivalent `public static` methods instead.

2786afac3ef177232a2e543703c97d42a277c2d8

-------

<p> Move ExecutionSequencer into guava as @Beta.

RELNOTES=Added `ExecutionSequencer`, a new utility to run a series of asynchronous operations serially.

3b25fe7882459991f2336c5021c46f0c374a152b

-------

<p> Automated rollback of c7aa4671cd70853515171333c823e3cdece92918.

*** Original change description ***

Move ExecutionSequencer into guava as @Beta.

***

35aa102cfe256bdf8a23aa89d259ba4916f50c62",Moe Sync
3226,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java']","@@ -70,18 +70,11 @@
       Boolean.parseBoolean(
           System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
 
-  /**
-   * Tag interface marking trusted subclasses. This enables some optimizations.
-   * The implementation of this interface must also be an AbstractureFuture and
-   * must not override or expose for overriding all the public methods of ListenableFuture.
-   * */
-  interface Trusted<V> extends ListenableFuture<V> {}
-
   /**
    * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
    */
-  abstract static class TrustedFuture<V> extends AbstractFuture<V> implements Trusted<V> {
+  abstract static class TrustedFuture<V> extends AbstractFuture<V> {
     @CanIgnoreReturnValue
     @Override
     public final V get() throws InterruptedException, ExecutionException {
@@ -597,7 +590,7 @@ public boolean cancel(boolean mayInterruptIfRunning) {
             // propagate cancellation to the future set in setfuture, this is racy, and we don't
             // care if we are successful or not.
             ListenableFuture<?> futureToPropagateTo = ((SetFuture) localValue).future;
-            if (futureToPropagateTo instanceof Trusted) {
+            if (futureToPropagateTo instanceof TrustedFuture) {
               // If the future is a TrustedFuture then we specifically avoid calling cancel()
               // this has 2 benefits
               // 1. for long chains of futures strung together with setFuture we consume less stack
@@ -804,7 +797,7 @@ protected boolean setFuture(ListenableFuture<? extends V> future) {
    */
   private static Object getFutureValue(ListenableFuture<?> future) {
     Object valueToSet;
-    if (future instanceof Trusted) {
+    if (future instanceof TrustedFuture) {
       // Break encapsulation for TrustedFuture instances since we know that subclasses cannot
       // override .get() (since it is final) and therefore this is equivalent to calling .get()
       // and unpacking the exceptions like we do below (just much faster because it is a single, @@ -21,6 +21,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.util.concurrent.DirectExecutor;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.ForOverride;
 import com.google.j2objc.annotations.ReflectionSupport;
@@ -70,18 +71,11 @@
       Boolean.parseBoolean(
           System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
 
-  /**
-   * Tag interface marking trusted subclasses. This enables some optimizations.
-   * The implementation of this interface must also be an AbstractureFuture and
-   * must not override or expose for overriding all the public methods of ListenableFuture.
-   * */
-  interface Trusted<V> extends ListenableFuture<V> {}
-
   /**
    * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
    * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
    */
-  abstract static class TrustedFuture<V> extends AbstractFuture<V> implements Trusted<V> {
+  abstract static class TrustedFuture<V> extends AbstractFuture<V> {
     @CanIgnoreReturnValue
     @Override
     public final V get() throws InterruptedException, ExecutionException {
@@ -597,7 +591,7 @@ public boolean cancel(boolean mayInterruptIfRunning) {
             // propagate cancellation to the future set in setfuture, this is racy, and we don't
             // care if we are successful or not.
             ListenableFuture<?> futureToPropagateTo = ((SetFuture) localValue).future;
-            if (futureToPropagateTo instanceof Trusted) {
+            if (futureToPropagateTo instanceof TrustedFuture) {
               // If the future is a TrustedFuture then we specifically avoid calling cancel()
               // this has 2 benefits
               // 1. for long chains of futures strung together with setFuture we consume less stack
@@ -804,7 +798,7 @@ protected boolean setFuture(ListenableFuture<? extends V> future) {
    */
   private static Object getFutureValue(ListenableFuture<?> future) {
     Object valueToSet;
-    if (future instanceof Trusted) {
+    if (future instanceof TrustedFuture) {
       // Break encapsulation for TrustedFuture instances since we know that subclasses cannot
       // override .get() (since it is final) and therefore this is equivalent to calling .get()
       // and unpacking the exceptions like we do below (just much faster because it is a single, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add a note about the relative ordering of afterDone and listener execution

25ab9de6336c2040a36aff7bed96b20fc5c30111

-------

<p> Insulate AbstractFuture from Futures.java/MoreExecutors.java dependency

Made DirectExecutor package-private so that we can refer to it directly in AbstractFuture.

660d9154e553b97df367979ccfe19971c9154bff

-------

<p> Remove reference to Strings.isNullOrEmpty from AbstractFuture.

c72e9c73cf468c2c55092912a0178a668f975e2e

-------

<p> Introduce Trusted interface.

So we can create FluentFuture.Trusted without introduction of a dependency on FluentFuture in AbstractFuture.

227d67fc6600a6041a3a3881f1e1b6652d3cf75c

-------

<p> Automated rollback of 227d67fc6600a6041a3a3881f1e1b6652d3cf75c

*** Original change description ***

Introduce Trusted interface.

So we can create FluentFuture.Trusted without introduction of a dependency on FluentFuture in AbstractFuture.

***

e058d91f7d676a8791cba1bdda6b745ccc44f8b8",Moe Sync
3229,Ron Shapiro,"['android/guava/src/com/google/common/primitives/Primitives.java', 'guava/src/com/google/common/primitives/Primitives.java']","@@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 
@@ -42,8 +42,8 @@ private Primitives() {}
   // Sad that we can't use a BiMap. :(
 
   static {
-    Map<Class<?>, Class<?>> primToWrap = new HashMap<>(16);
-    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<>(16);
+    Map<Class<?>, Class<?>> primToWrap = new LinkedHashMap<>(16);
+    Map<Class<?>, Class<?>> wrapToPrim = new LinkedHashMap<>(16);
 
     add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
     add(primToWrap, wrapToPrim, byte.class, Byte.class);, @@ -18,7 +18,7 @@
 
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 
@@ -42,8 +42,8 @@ private Primitives() {}
   // Sad that we can't use a BiMap. :(
 
   static {
-    Map<Class<?>, Class<?>> primToWrap = new HashMap<>(16);
-    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<>(16);
+    Map<Class<?>, Class<?>> primToWrap = new LinkedHashMap<>(16);
+    Map<Class<?>, Class<?>> wrapToPrim = new LinkedHashMap<>(16);
 
     add(primToWrap, wrapToPrim, boolean.class, Boolean.class);
     add(primToWrap, wrapToPrim, byte.class, Byte.class);, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Automated rollback of 45ca38358cac4368877650e591daf9650f5eaae1

*** Reason for rollback ***

The test that caused the inital rollback is buggy

*** Original change description ***

Introduce Trusted interface.

So we can create FluentFuture.Trusted without introduction of a dependency on FluentFuture in AbstractFuture.

***

683eb054a0c9846e73aa9a4f1a47d4821ea5ef60

-------

<p> Optimize ImmutableCollection.toArray(T[]) as per https://shipilev.net/blog/2016/arrays-wisdom-ancients/, the key goal being to avoid the necessity of zeroing a newly created array where possible.

Addresses https://github.com/google/guava/issues/3209.

f5a3541fd118d370488b9f9c15facd408e180b17

-------

<p> Adds WASM as a supported Media type to Google Java utilities.
Adds WASM support to the StaticFileAction in devserver (so that it is served
with the correct Content Type).

RELNOTES=Adds WASM as a supported Media type to Google Java utilities.

67bb79e4ea2e0f6da956c29dd700ad7d756948b7

-------

<p> Allow Service to transition from STARTING to TERMINATED. Add a new ""doCancelStart"" method that is called when a service is stopped while still starting. This gives implementations a chance to abort code which may be preventing the service from starting.

RELNOTES=Added `doCancelStart` protected method to `AbstractService`

6cdea3a7b0fe3953e181cb9660df5834550ba498

-------

<p> Fix javadoc typo in LinkedListMultimap

Fixes https://github.com/google/guava/issues/3228

1d0eeee14d09912362695e6e1c847fc50bc96ebf

-------

<p> Add callable's toString to null failure message.

I find this happens in mock-heavy tests, and this makes it easier to identify the source of the bad mock call.

9c03abcca29fb267ed55fc80e668327e5d46e230

-------

<p> Enhance toString() for futures returned from ExecutionSequencer.

Also make tests for ExecutionSequencer actually run, by porting them to junit3 :-(

0c2b6fb916214ffe092edc8577bd7818d58fe664

-------

<p> Make ordering of Primitives#all{Wrapper,Primitive}Types deterministic

RELNOTES=N/A

c8ad64d04071f0fc20cbcba0bb9ee944746b5ef2",Moe Sync
3238,Ron Shapiro,"['android/guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java', 'android/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java', 'android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java', 'android/guava/src/com/google/common/util/concurrent/FluentFuture.java', 'android/guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java', 'android/guava/src/com/google/common/util/concurrent/ImmediateFuture.java', 'android/guava/src/com/google/common/util/concurrent/TimeoutFuture.java', 'android/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AbstractFuture.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java', 'guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java', 'guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java', 'guava/src/com/google/common/util/concurrent/FluentFuture.java', 'guava/src/com/google/common/util/concurrent/GwtFluentFutureCatchingSpecialization.java', 'guava/src/com/google/common/util/concurrent/ImmediateFuture.java', 'guava/src/com/google/common/util/concurrent/TimeoutFuture.java', 'guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java']","@@ -40,7 +40,7 @@
 @GwtCompatible(emulated = true)
 public class FluentFutureTest extends TestCase {
   public void testFromFluentFuture() {
-    FluentFuture<String> f = SettableFuture.create();
+    FluentFuture<String> f = FluentFuture.from(SettableFuture.<String>create());
     assertThat(FluentFuture.from(f)).isSameAs(f);
   }
 
@@ -131,7 +131,8 @@ public void testTransformAsync() throws Exception {
   public void testWithTimeout() throws Exception {
     ScheduledExecutorService executor = newScheduledThreadPool(1);
     try {
-      FluentFuture<?> f = SettableFuture.create().withTimeout(0, SECONDS, executor);
+      FluentFuture<?> f =
+          FluentFuture.from(SettableFuture.create()).withTimeout(0, SECONDS, executor);
       try {
         f.get();
         fail();, @@ -29,7 +29,7 @@
 /** Implementations of {@code Futures.catching*}. */
 @GwtCompatible
 abstract class AbstractCatchingFuture<V, X extends Throwable, F, T>
-    extends AbstractFuture.TrustedFuture<V> implements Runnable {
+    extends FluentFuture.TrustedFuture<V> implements Runnable {
   static <V, X extends Throwable> ListenableFuture<V> create(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,, @@ -63,18 +63,18 @@
 @SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
-public abstract class AbstractFuture<V> extends FluentFuture<V> {
+public abstract class AbstractFuture<V> implements ListenableFuture<V> {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
   private static final boolean GENERATE_CANCELLATION_CAUSES =
       Boolean.parseBoolean(
           System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
 
   /**
-   * Tag interface marking trusted subclasses. This enables some optimizations.
-   * The implementation of this interface must also be an AbstractureFuture and
-   * must not override or expose for overriding all the public methods of ListenableFuture.
-   * */
+   * Tag interface marking trusted subclasses. This enables some optimizations. The implementation
+   * of this interface must also be an AbstractFuture and must not override or expose for overriding
+   * any of the public methods of ListenableFuture.
+   */
   interface Trusted<V> extends ListenableFuture<V> {}
 
   /**
@@ -965,7 +965,7 @@ private Listener clearListeners(Listener onto) {
     return reversedList;
   }
 
-  // TODO(user) move this up into FluentFuture, or parts as a default method on ListenableFuture?
+  // TODO(user): move parts into a default method on ListenableFuture?
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder().append(super.toString()).append(""[status="");, @@ -28,7 +28,7 @@
 
 /** Implementations of {@code Futures.transform*}. */
 @GwtCompatible
-abstract class AbstractTransformFuture<I, O, F, T> extends AbstractFuture.TrustedFuture<O>
+abstract class AbstractTransformFuture<I, O, F, T> extends FluentFuture.TrustedFuture<O>
     implements Runnable {
   static <I, O> ListenableFuture<O> create(
       ListenableFuture<I> input,, @@ -18,6 +18,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
@@ -68,6 +69,48 @@
 @Beta
 @GwtCompatible(emulated = true)
 public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {
+
+  /**
+   * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
+   * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
+   */
+  abstract static class TrustedFuture<V> extends FluentFuture<V>
+      implements AbstractFuture.Trusted<V> {
+    @CanIgnoreReturnValue
+    @Override
+    public final V get() throws InterruptedException, ExecutionException {
+      return super.get();
+    }
+
+    @CanIgnoreReturnValue
+    @Override
+    public final V get(long timeout, TimeUnit unit)
+        throws InterruptedException, ExecutionException, TimeoutException {
+      return super.get(timeout, unit);
+    }
+
+    @Override
+    public final boolean isDone() {
+      return super.isDone();
+    }
+
+    @Override
+    public final boolean isCancelled() {
+      return super.isCancelled();
+    }
+
+    @Override
+    public final void addListener(Runnable listener, Executor executor) {
+      super.addListener(listener, executor);
+    }
+
+    @CanIgnoreReturnValue
+    @Override
+    public final boolean cancel(boolean mayInterruptIfRunning) {
+      return super.cancel(mayInterruptIfRunning);
+    }
+  }
+
   FluentFuture() {}
 
   /**, @@ -22,7 +22,7 @@
  * FluentFuture.catching} family of methods. Those versions have slightly different signatures.
  */
 @GwtCompatible(emulated = true)
-abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {
+abstract class GwtFluentFutureCatchingSpecialization<V> extends AbstractFuture<V> {
   /*
    * This server copy of the class is empty. The corresponding GWT copy contains alternative
    * versions of catching() and catchingAsync() with slightly different signatures from the ones, @@ -28,7 +28,7 @@
 
 /** Implementations of {@code Futures.immediate*}. */
 @GwtCompatible(emulated = true)
-abstract class ImmediateFuture<V> extends FluentFuture<V> {
+abstract class ImmediateFuture<V> implements ListenableFuture<V> {
   private static final Logger log = Logger.getLogger(ImmediateFuture.class.getName());
 
   @Override, @@ -34,7 +34,7 @@
  * interrupted and cancelled if it times out.
  */
 @GwtIncompatible
-final class TimeoutFuture<V> extends AbstractFuture.TrustedFuture<V> {
+final class TimeoutFuture<V> extends FluentFuture.TrustedFuture<V> {
   static <V> ListenableFuture<V> create(
       ListenableFuture<V> delegate,
       long time,, @@ -30,7 +30,7 @@
  * performance reasons.
  */
 @GwtCompatible
-class TrustedListenableFutureTask<V> extends AbstractFuture.TrustedFuture<V>
+class TrustedListenableFutureTask<V> extends FluentFuture.TrustedFuture<V>
     implements RunnableFuture<V> {
 
   static <V> TrustedListenableFutureTask<V> create(AsyncCallable<V> callable) {, @@ -35,13 +35,42 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Emulation for AbstractFuture in GWT. */
-public abstract class AbstractFuture<V> extends FluentFuture<V> {
+public abstract class AbstractFuture<V> implements ListenableFuture<V> {
+
+  /**
+   * Tag interface marking trusted subclasses. This enables some optimizations. The implementation
+   * of this interface must also be an AbstractFuture and must not override or expose for overriding
+   * any of the public methods of ListenableFuture.
+   */
+  interface Trusted<V> extends ListenableFuture<V> {}
+
+  abstract static class TrustedFuture<V> extends AbstractFuture<V> implements Trusted<V> {
+    @Override
+    public final V get() throws InterruptedException, ExecutionException {
+      return super.get();
+    }
+
+    @Override
+    public final V get(long timeout, TimeUnit unit)
+        throws InterruptedException, ExecutionException, TimeoutException {
+      return super.get(timeout, unit);
+    }
+
+    @Override
+    public final boolean isDone() {
+      return super.isDone();
+    }
+
+    @Override
+    public final boolean isCancelled() {
+      return super.isCancelled();
+    }
+
+    @Override
+    public final void addListener(Runnable listener, Executor executor) {
+      super.addListener(listener, executor);
+    }
 
-  abstract static class TrustedFuture<V> extends AbstractFuture<V> {
-    /*
-     * We don't need to override most of methods that we override in the prod version (and in fact
-     * we can't) because they are already final in AbstractFuture itself under GWT.
-     */
     @Override
     public final boolean cancel(boolean mayInterruptIfRunning) {
       return super.cancel(mayInterruptIfRunning);
@@ -83,34 +112,33 @@ public boolean cancel(boolean mayInterruptIfRunning) {
   protected void interruptTask() {}
 
   @Override
-  public final boolean isCancelled() {
+  public boolean isCancelled() {
     return state.isCancelled();
   }
 
   @Override
-  public final boolean isDone() {
+  public boolean isDone() {
     return state.isDone();
   }
 
   /*
-   * We let people override {@code get()} in the server version (though perhaps we shouldn't). Here,
-   * we don't want that, and anyway, users can't, thanks to the package-private parameter.
+   * ForwardingFluentFuture needs to override those methods, so they are not final.
    */
   @Override
-  public final V get() throws InterruptedException, ExecutionException {
+  public V get() throws InterruptedException, ExecutionException {
     state.maybeThrowOnGet(throwable);
     return value;
   }
 
   @Override
-  public final V get(long timeout, TimeUnit unit)
+  public V get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     checkNotNull(unit);
     return get();
   }
 
   @Override
-  public final void addListener(Runnable runnable, Executor executor) {
+  public void addListener(Runnable runnable, Executor executor) {
     Listener listener = new Listener(runnable, executor);
     if (isDone()) {
       listener.execute();, @@ -22,7 +22,7 @@
  * versions of the {@link FluentFuture#catching(Class, com.google.common.base.Function)
  * FluentFuture.catching} family of methods. Those versions have slightly different signatures.
  */
-abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {
+abstract class GwtFluentFutureCatchingSpecialization<V> extends AbstractFuture<V> {
   /*
    * In the GWT versions of the methods (below), every exceptionType parameter is required to be
    * Class<Throwable>. To handle only certain kinds of exceptions under GWT, you'll need to write, @@ -40,7 +40,7 @@
 @GwtCompatible(emulated = true)
 public class FluentFutureTest extends TestCase {
   public void testFromFluentFuture() {
-    FluentFuture<String> f = SettableFuture.create();
+    FluentFuture<String> f = FluentFuture.from(SettableFuture.<String>create());
     assertThat(FluentFuture.from(f)).isSameAs(f);
   }
 
@@ -131,7 +131,8 @@ public void testTransformAsync() throws Exception {
   public void testWithTimeout() throws Exception {
     ScheduledExecutorService executor = newScheduledThreadPool(1);
     try {
-      FluentFuture<?> f = SettableFuture.create().withTimeout(0, SECONDS, executor);
+      FluentFuture<?> f =
+          FluentFuture.from(SettableFuture.create()).withTimeout(0, SECONDS, executor);
       try {
         f.get();
         fail();, @@ -29,7 +29,7 @@
 /** Implementations of {@code Futures.catching*}. */
 @GwtCompatible
 abstract class AbstractCatchingFuture<V, X extends Throwable, F, T>
-    extends AbstractFuture.TrustedFuture<V> implements Runnable {
+    extends FluentFuture.TrustedFuture<V> implements Runnable {
   static <V, X extends Throwable> ListenableFuture<V> create(
       ListenableFuture<? extends V> input,
       Class<X> exceptionType,, @@ -63,18 +63,18 @@
 @SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
-public abstract class AbstractFuture<V> extends FluentFuture<V> {
+public abstract class AbstractFuture<V> implements ListenableFuture<V> {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
   private static final boolean GENERATE_CANCELLATION_CAUSES =
       Boolean.parseBoolean(
           System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
 
   /**
-   * Tag interface marking trusted subclasses. This enables some optimizations.
-   * The implementation of this interface must also be an AbstractureFuture and
-   * must not override or expose for overriding all the public methods of ListenableFuture.
-   * */
+   * Tag interface marking trusted subclasses. This enables some optimizations. The implementation
+   * of this interface must also be an AbstractFuture and must not override or expose for overriding
+   * any of the public methods of ListenableFuture.
+   */
   interface Trusted<V> extends ListenableFuture<V> {}
 
   /**
@@ -965,7 +965,7 @@ private Listener clearListeners(Listener onto) {
     return reversedList;
   }
 
-  // TODO(user) move this up into FluentFuture, or parts as a default method on ListenableFuture?
+  // TODO(user): move parts into a default method on ListenableFuture?
   @Override
   public String toString() {
     StringBuilder builder = new StringBuilder().append(super.toString()).append(""[status="");, @@ -28,7 +28,7 @@
 
 /** Implementations of {@code Futures.transform*}. */
 @GwtCompatible
-abstract class AbstractTransformFuture<I, O, F, T> extends AbstractFuture.TrustedFuture<O>
+abstract class AbstractTransformFuture<I, O, F, T> extends FluentFuture.TrustedFuture<O>
     implements Runnable {
   static <I, O> ListenableFuture<O> create(
       ListenableFuture<I> input,, @@ -18,6 +18,7 @@
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Function;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
@@ -68,6 +69,48 @@
 @Beta
 @GwtCompatible(emulated = true)
 public abstract class FluentFuture<V> extends GwtFluentFutureCatchingSpecialization<V> {
+
+  /**
+   * A less abstract subclass of AbstractFuture. This can be used to optimize setFuture by ensuring
+   * that {@link #get} calls exactly the implementation of {@link AbstractFuture#get}.
+   */
+  abstract static class TrustedFuture<V> extends FluentFuture<V>
+      implements AbstractFuture.Trusted<V> {
+    @CanIgnoreReturnValue
+    @Override
+    public final V get() throws InterruptedException, ExecutionException {
+      return super.get();
+    }
+
+    @CanIgnoreReturnValue
+    @Override
+    public final V get(long timeout, TimeUnit unit)
+        throws InterruptedException, ExecutionException, TimeoutException {
+      return super.get(timeout, unit);
+    }
+
+    @Override
+    public final boolean isDone() {
+      return super.isDone();
+    }
+
+    @Override
+    public final boolean isCancelled() {
+      return super.isCancelled();
+    }
+
+    @Override
+    public final void addListener(Runnable listener, Executor executor) {
+      super.addListener(listener, executor);
+    }
+
+    @CanIgnoreReturnValue
+    @Override
+    public final boolean cancel(boolean mayInterruptIfRunning) {
+      return super.cancel(mayInterruptIfRunning);
+    }
+  }
+
   FluentFuture() {}
 
   /**, @@ -22,7 +22,7 @@
  * FluentFuture.catching} family of methods. Those versions have slightly different signatures.
  */
 @GwtCompatible(emulated = true)
-abstract class GwtFluentFutureCatchingSpecialization<V> implements ListenableFuture<V> {
+abstract class GwtFluentFutureCatchingSpecialization<V> extends AbstractFuture<V> {
   /*
    * This server copy of the class is empty. The corresponding GWT copy contains alternative
    * versions of catching() and catchingAsync() with slightly different signatures from the ones, @@ -28,7 +28,7 @@
 
 /** Implementations of {@code Futures.immediate*}. */
 @GwtCompatible(emulated = true)
-abstract class ImmediateFuture<V> extends FluentFuture<V> {
+abstract class ImmediateFuture<V> implements ListenableFuture<V> {
   private static final Logger log = Logger.getLogger(ImmediateFuture.class.getName());
 
   @Override, @@ -34,7 +34,7 @@
  * interrupted and cancelled if it times out.
  */
 @GwtIncompatible
-final class TimeoutFuture<V> extends AbstractFuture.TrustedFuture<V> {
+final class TimeoutFuture<V> extends FluentFuture.TrustedFuture<V> {
   static <V> ListenableFuture<V> create(
       ListenableFuture<V> delegate,
       long time,, @@ -30,7 +30,7 @@
  * performance reasons.
  */
 @GwtCompatible
-class TrustedListenableFutureTask<V> extends AbstractFuture.TrustedFuture<V>
+class TrustedListenableFutureTask<V> extends FluentFuture.TrustedFuture<V>
     implements RunnableFuture<V> {
 
   static <V> TrustedListenableFutureTask<V> create(AsyncCallable<V> callable) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add a gap method to Range which computes the range that lies between two ranges. This operation is particularly useful as a replacement for Joda Time's Interval.gap when migrating to Java Time which has no Interval class.

Joda Time:
Interval interval = ...;
Interval gap = interval.gap(interval);

Java Time (after this CL):
Range<Instant> interval = ...;
Range<Instant> gap = interval.gap(otherInterval);

RELNOTES=Adds a gap() method to Range that computes the Range that lies between them.

856f3bc431f7f145f35c6a42a07e1f7158964467

-------

<p> Use gradle formatting

Fixes https://github.com/google/guava/pull/3216

44abd86cf18afa64d1776b19a7bedabda395877f

-------

<p> Add missing @since tag.

https://google.github.io/guava/releases/21.0/api/diffs/changes/com.google.common.util.concurrent.Monitor.html#com.google.common.util.concurrent.Monitor.newGuard_added(java.util.function.BooleanSupplier)

Noticed because of https://github.com/google/guava/issues/2853#issuecomment-412360793

2e93145e51699a3e533c72db2633456f65542ad7

-------

<p> Add information about thread wakeup or scheduling delays to TimeoutExceptions thrown from guava futures.

b155e35606632c756e8db2c414145237a02ef9ca

-------

<p> Remove unnecessary local.

It is a holdover from when we used the value locally, rather than just returned it: 353ae349a24fb6c9b3e233ca03e4012761c7f3d8

94134ff0559baefa9ecc8df2a7c61945b6dfc523

-------

<p> Make delayed get() test more resilient to thread scheduling delays.

cc18f991f9934b4cd06d8d7fc0dbd1cc7ea1b83f

-------

<p> Switch FluentFuture and AbstractFuture in inheritance chain

RELNOTES=AbstractFuture doesn't expose FluentFuture APIs anymore.

4d8e0a81d78cea279441625adc96467a5b7d0879",Moe Sync
3245,Ron Shapiro,"['android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java']","@@ -781,6 +781,46 @@ public void testSetFuture_stackOverflow() {
     assertTrue(orig.isDone());
   }
 
+  public void testSetFuture_misbehavingFuture() throws Exception {
+    SettableFuture<String> future = SettableFuture.create();
+    ListenableFuture<String> badFuture =
+        new ListenableFuture<String>() {
+          @Override
+          public boolean cancel(boolean interrupt) {
+            return false;
+          }
+
+          @Override
+          public boolean isDone() {
+            return true;
+          }
+
+          @Override
+          public boolean isCancelled() {
+            return false; // BAD!!
+          }
+
+          @Override
+          public String get() {
+            throw new CancellationException(); // BAD!!
+          }
+
+          @Override
+          public String get(long time, TimeUnit unit) {
+            throw new CancellationException(); // BAD!!
+          }
+
+          @Override
+          public void addListener(Runnable runnable, Executor executor) {
+            executor.execute(runnable);
+          }
+        };
+    future.setFuture(badFuture);
+    ExecutionException expected = getExpectingExecutionException(future);
+    assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
+    assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
+  }
+
   public void testCancel_stackOverflow() {
     SettableFuture<String> orig = SettableFuture.create();
     SettableFuture<String> prev = orig;, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 import static com.google.common.util.concurrent.Futures.getDone;
+import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
 import com.google.common.annotations.Beta;
@@ -836,18 +837,29 @@ private static Object getFutureValue(ListenableFuture<?> future) {
         }
       }
       return v;
-    } else {
-      // Otherwise calculate the value by calling .get()
-      try {
-        Object v = getDone(future);
-        return v == null ? NULL : v;
-      } catch (ExecutionException exception) {
-        return new Failure(exception.getCause());
-      } catch (CancellationException cancellation) {
-        return new Cancellation(false, cancellation);
-      } catch (Throwable t) {
-        return new Failure(t);
+    }
+    boolean wasCancelled = future.isCancelled();
+    // Don't allocate a CancellationException if it's not necessary
+    if (!GENERATE_CANCELLATION_CAUSES & wasCancelled) {
+      return Cancellation.CAUSELESS_CANCELLED;
+    }
+    // Otherwise calculate the value by calling .get()
+    try {
+      Object v = getUninterruptibly(future);
+      return v == null ? NULL : v;
+    } catch (ExecutionException exception) {
+      return new Failure(exception.getCause());
+    } catch (CancellationException cancellation) {
+      if (!wasCancelled) {
+        return new Failure(
+            new IllegalArgumentException(
+                ""get() threw CancellationException, despite reporting isCancelled() == false: ""
+                    + future,
+                cancellation));
       }
+      return new Cancellation(false, cancellation);
+    } catch (Throwable t) {
+      return new Failure(t);
     }
   }
 , @@ -781,6 +781,46 @@ public void testSetFuture_stackOverflow() {
     assertTrue(orig.isDone());
   }
 
+  public void testSetFuture_misbehavingFuture() throws Exception {
+    SettableFuture<String> future = SettableFuture.create();
+    ListenableFuture<String> badFuture =
+        new ListenableFuture<String>() {
+          @Override
+          public boolean cancel(boolean interrupt) {
+            return false;
+          }
+
+          @Override
+          public boolean isDone() {
+            return true;
+          }
+
+          @Override
+          public boolean isCancelled() {
+            return false; // BAD!!
+          }
+
+          @Override
+          public String get() {
+            throw new CancellationException(); // BAD!!
+          }
+
+          @Override
+          public String get(long time, TimeUnit unit) {
+            throw new CancellationException(); // BAD!!
+          }
+
+          @Override
+          public void addListener(Runnable runnable, Executor executor) {
+            executor.execute(runnable);
+          }
+        };
+    future.setFuture(badFuture);
+    ExecutionException expected = getExpectingExecutionException(future);
+    assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
+    assertThat(expected).hasCauseThat().hasMessageThat().contains(badFuture.toString());
+  }
+
   public void testCancel_stackOverflow() {
     SettableFuture<String> orig = SettableFuture.create();
     SettableFuture<String> prev = orig;, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
 import static com.google.common.util.concurrent.Futures.getDone;
+import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
 import com.google.common.annotations.Beta;
@@ -836,18 +837,29 @@ private static Object getFutureValue(ListenableFuture<?> future) {
         }
       }
       return v;
-    } else {
-      // Otherwise calculate the value by calling .get()
-      try {
-        Object v = getDone(future);
-        return v == null ? NULL : v;
-      } catch (ExecutionException exception) {
-        return new Failure(exception.getCause());
-      } catch (CancellationException cancellation) {
-        return new Cancellation(false, cancellation);
-      } catch (Throwable t) {
-        return new Failure(t);
+    }
+    boolean wasCancelled = future.isCancelled();
+    // Don't allocate a CancellationException if it's not necessary
+    if (!GENERATE_CANCELLATION_CAUSES & wasCancelled) {
+      return Cancellation.CAUSELESS_CANCELLED;
+    }
+    // Otherwise calculate the value by calling .get()
+    try {
+      Object v = getUninterruptibly(future);
+      return v == null ? NULL : v;
+    } catch (ExecutionException exception) {
+      return new Failure(exception.getCause());
+    } catch (CancellationException cancellation) {
+      if (!wasCancelled) {
+        return new Failure(
+            new IllegalArgumentException(
+                ""get() threw CancellationException, despite reporting isCancelled() == false: ""
+                    + future,
+                cancellation));
       }
+      return new Cancellation(false, cancellation);
+    } catch (Throwable t) {
+      return new Failure(t);
     }
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Don't allocate a CancellationException if cancellation causes are not enabled.

99393cf80ba7a5c861b564b3289debbf5dbbeb51",Moe Sync
3247,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java']","@@ -16,8 +16,6 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
-import static com.google.common.util.concurrent.Futures.getDone;
-import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
 import com.google.common.annotations.Beta;
@@ -863,6 +861,27 @@ private static Object getFutureValue(ListenableFuture<?> future) {
     }
   }
 
+  /**
+   * An inlined private copy of {@link Uninterruptibles#getUninterruptibly} used to break an
+   * internal dependency on other /util/concurrent classes.
+   */
+  private static <V> V getUninterruptibly(Future<V> future) throws ExecutionException {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          return future.get();
+        } catch (InterruptedException e) {
+          interrupted = true;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   /** Unblocks all threads and runs all listeners. */
   private static void complete(AbstractFuture<?> future) {
     Listener next = null;
@@ -1028,7 +1047,7 @@ protected String pendingToString() {
 
   private void addDoneString(StringBuilder builder) {
     try {
-      V value = getDone(this);
+      V value = getUninterruptibly(this);
       builder.append(""SUCCESS, result=["").append(userObjectToString(value)).append(""]"");
     } catch (ExecutionException e) {
       builder.append(""FAILURE, cause=["").append(e.getCause()).append(""]"");, @@ -16,8 +16,6 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Throwables.throwIfUnchecked;
-import static com.google.common.util.concurrent.Futures.getDone;
-import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 
 import com.google.common.annotations.Beta;
@@ -863,6 +861,27 @@ private static Object getFutureValue(ListenableFuture<?> future) {
     }
   }
 
+  /**
+   * An inlined private copy of {@link Uninterruptibles#getUninterruptibly} used to break an
+   * internal dependency on other /util/concurrent classes.
+   */
+  private static <V> V getUninterruptibly(Future<V> future) throws ExecutionException {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          return future.get();
+        } catch (InterruptedException e) {
+          interrupted = true;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   /** Unblocks all threads and runs all listeners. */
   private static void complete(AbstractFuture<?> future) {
     Listener next = null;
@@ -1027,7 +1046,7 @@ public String toString() {
 
   private void addDoneString(StringBuilder builder) {
     try {
-      V value = getDone(this);
+      V value = getUninterruptibly(this);
       builder.append(""SUCCESS, result=["").append(userObjectToString(value)).append(""]"");
     } catch (ExecutionException e) {
       builder.append(""FAILURE, cause=["").append(e.getCause()).append(""]"");, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add Javadoc for MediaType.KML+KMZ+MBOX

Via https://github.com/google/guava/pull/3244

Original Author=Simon Legner (simon04)

7ac917c8d73768129499bd76fe41aa651391ba93

-------

<p> [guava concurrent] Inlined getDone() and getUninterruptibly() to break the source dependency from AbstractFuture to other classes in /util/concurrent.

b6726e17f9aa455ff5aa8ee7cee6089d37feb1ba",Moe Sync
3248,Ron Shapiro,"['android/guava/src/com/google/common/net/InternetDomainName.java', 'guava/src/com/google/common/net/InternetDomainName.java']","@@ -202,8 +202,8 @@ private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {
    *
    *
    * @param domain A domain name (not IP address)
-   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to {@link
-   *     #isValid}
+   * @throws IllegalArgumentException if {@code domain} is not syntactically valid according to
+   *     {@link #isValid}
    * @since 10.0 (previously named {@code fromLenient})
    */
   public static InternetDomainName from(String domain) {, @@ -202,8 +202,8 @@ private int findSuffixOfType(Optional<PublicSuffixType> desiredType) {
    *
    *
    * @param domain A domain name (not IP address)
-   * @throws IllegalArgumentException if {@code name} is not syntactically valid according to {@link
-   *     #isValid}
+   * @throws IllegalArgumentException if {@code domain} is not syntactically valid according to
+   *     {@link #isValid}
    * @since 10.0 (previously named {@code fromLenient})
    */
   public static InternetDomainName from(String domain) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix parameter name in Javadoc

`name` doesn't exist in the current context.

#CodeHealth

RELNOTES=Fix parameter name in Javadoc

9dbaf13b31c58b67ecc7d1ae3950534cdf04a344",Moe Sync
3254,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add more validation to AbstractFuture when cancellation causes are enabled, so that it matches the behavior when they are disabled.

f380040f0041f94c83d24623c10f32de58d436c4

-------

<p> Suppress warnings on thread suspending test.

d51037de530cfe76884271f164b3fbe914493fdb

-------

<p> Suppress violation of MissingEqualsCall for EqualsTesterTest, given it quite legitimately fails to call #testEquals.

16e6fcebf07c0f2ce92411604bd3c9d03407374c

-------

<p> Automated rollback of changelist f380040f0041f94c83d24623c10f32de58d436c4

*** Reason for rollback ***

Test depends on incorrect Future implementation

*** Original change description ***

Add more validation to AbstractFuture when cancellation causes are enabled, so that it matches the behavior when they are disabled.

***

47d758e506f838ebc14da5cb85b7f3150efe00fb

-------

<p> Update Public Suffix data.

The copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

5fafe7832579ab221804480a7545d486a14d083d",Moe Sync
3256,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractTransformFuture.java']","@@ -69,6 +69,13 @@ public final void run() {
     }
     inputFuture = null;
 
+    if (localInputFuture.isCancelled()) {
+      @SuppressWarnings(""unchecked"")
+      boolean unused =
+          setFuture((ListenableFuture<O>) localInputFuture); // Respects cancellation cause setting
+      return;
+    }
+
     /*
      * Any of the setException() calls below can fail if the output Future is cancelled between now
      * and then. This means that we're silently swallowing an exception -- maybe even an Error. But
@@ -77,11 +84,12 @@ public final void run() {
      *
      * Contrast this to the situation we have if setResult() throws, a situation described below.
      */
-
     I sourceResult;
     try {
       sourceResult = getDone(localInputFuture);
     } catch (CancellationException e) {
+      // TODO(user): verify future behavior - unify logic with getFutureValue in AbstractFuture. This
+      // code should be unreachable with correctly implemented Futures.
       // Cancel this future and return.
       // At this point, inputFuture is cancelled and outputFuture doesn't exist, so the value of
       // mayInterruptIfRunning is irrelevant., @@ -69,6 +69,13 @@ public final void run() {
     }
     inputFuture = null;
 
+    if (localInputFuture.isCancelled()) {
+      @SuppressWarnings(""unchecked"")
+      boolean unused =
+          setFuture((ListenableFuture<O>) localInputFuture); // Respects cancellation cause setting
+      return;
+    }
+
     /*
      * Any of the setException() calls below can fail if the output Future is cancelled between now
      * and then. This means that we're silently swallowing an exception -- maybe even an Error. But
@@ -77,11 +84,12 @@ public final void run() {
      *
      * Contrast this to the situation we have if setResult() throws, a situation described below.
      */
-
     I sourceResult;
     try {
       sourceResult = getDone(localInputFuture);
     } catch (CancellationException e) {
+      // TODO(user): verify future behavior - unify logic with getFutureValue in AbstractFuture. This
+      // code should be unreachable with correctly implemented Futures.
       // Cancel this future and return.
       // At this point, inputFuture is cancelled and outputFuture doesn't exist, so the value of
       // mayInterruptIfRunning is irrelevant., ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add more validation to AbstractFuture when cancellation causes are enabled, so that it matches the behavior when they are disabled.

49c73aaf7aef734e1f488aa0eb8d1b1bfebf5255

-------

<p> Bail early without a CancellationException in AbstractTransformFuture.

2ba14fdad20628de9eb7ea537af22e198d4d31a0",Moe Sync
3257,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'guava/src/com/google/common/util/concurrent/MoreExecutors.java']","@@ -25,7 +25,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
-import com.google.common.util.concurrent.DirectExecutor;
 import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
@@ -602,8 +601,8 @@ public int compareTo(Delayed other) {
     }
 
     @GwtIncompatible // TODO
-    private static final class NeverSuccessfulListenableFutureTask extends AbstractFuture<Void>
-        implements Runnable {
+    private static final class NeverSuccessfulListenableFutureTask
+        extends AbstractFuture.TrustedFuture<Void> implements Runnable {
       private final Runnable delegate;
 
       public NeverSuccessfulListenableFutureTask(Runnable delegate) {, @@ -25,7 +25,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Queues;
-import com.google.common.util.concurrent.DirectExecutor;
 import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
@@ -602,8 +601,8 @@ public int compareTo(Delayed other) {
     }
 
     @GwtIncompatible // TODO
-    private static final class NeverSuccessfulListenableFutureTask extends AbstractFuture<Void>
-        implements Runnable {
+    private static final class NeverSuccessfulListenableFutureTask
+        extends AbstractFuture.TrustedFuture<Void> implements Runnable {
       private final Runnable delegate;
 
       public NeverSuccessfulListenableFutureTask(Runnable delegate) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use TrustedFuture where possible

5f1436678dc0a28d78b8d8b4fa9e1d4b50313cdf",Moe Sync
3261,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/Monitor.java', 'guava/src/com/google/common/util/concurrent/Monitor.java']","@@ -18,7 +18,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Throwables;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 import com.google.j2objc.annotations.Weak;
 import java.util.concurrent.TimeUnit;
@@ -121,10 +120,10 @@
  *
  * <pre>{@code
  * public class SafeBox<V> {
+ *   private V value;
  *   private final ReentrantLock lock = new ReentrantLock();
  *   private final Condition valuePresent = lock.newCondition();
  *   private final Condition valueAbsent = lock.newCondition();
- *   private V value;
  *
  *   public V get() throws InterruptedException {
  *     lock.lock();
@@ -166,18 +165,10 @@
  *
  * <pre>{@code
  * public class SafeBox<V> {
- *   private final Monitor monitor = new Monitor();
- *   private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {
- *     public boolean isSatisfied() {
- *       return value != null;
- *     }
- *   };
- *   private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {
- *     public boolean isSatisfied() {
- *       return value == null;
- *     }
- *   };
  *   private V value;
+ *   private final Monitor monitor = new Monitor();
+ *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);
+ *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);
  *
  *   public V get() throws InterruptedException {
  *     monitor.enterWhen(valuePresent);
@@ -1015,7 +1006,7 @@ private boolean isSatisfied(Guard guard) {
       return guard.isSatisfied();
     } catch (Throwable throwable) {
       signalAllWaiters();
-      throw Throwables.propagate(throwable);
+      throw throwable;
     }
   }
 , @@ -18,7 +18,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.common.base.Throwables;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 import com.google.j2objc.annotations.Weak;
 import java.util.concurrent.TimeUnit;
@@ -122,10 +121,10 @@
  *
  * <pre>{@code
  * public class SafeBox<V> {
+ *   private V value;
  *   private final ReentrantLock lock = new ReentrantLock();
  *   private final Condition valuePresent = lock.newCondition();
  *   private final Condition valueAbsent = lock.newCondition();
- *   private V value;
  *
  *   public V get() throws InterruptedException {
  *     lock.lock();
@@ -167,18 +166,10 @@
  *
  * <pre>{@code
  * public class SafeBox<V> {
- *   private final Monitor monitor = new Monitor();
- *   private final Monitor.Guard valuePresent = new Monitor.Guard(monitor) {
- *     public boolean isSatisfied() {
- *       return value != null;
- *     }
- *   };
- *   private final Monitor.Guard valueAbsent = new Monitor.Guard(monitor) {
- *     public boolean isSatisfied() {
- *       return value == null;
- *     }
- *   };
  *   private V value;
+ *   private final Monitor monitor = new Monitor();
+ *   private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null);
+ *   private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null);
  *
  *   public V get() throws InterruptedException {
  *     monitor.enterWhen(valuePresent);
@@ -369,9 +360,10 @@ public Monitor(boolean fair) {
   }
 
   /**
-   * Creates a new {@link Guard} for {@code this} monitor. @Param isSatisfied The guards boolean
-   * condition. See {@link Guard#isSatisfied}.
+   * Creates a new {@linkplain Guard guard} for this monitor.
    *
+   * @param isSatisfied the new guard's boolean condition (see {@link Guard#isSatisfied
+   *     isSatisfied()})
    * @since 21.0
    */
   public Guard newGuard(final BooleanSupplier isSatisfied) {
@@ -1033,7 +1025,7 @@ private boolean isSatisfied(Guard guard) {
       return guard.isSatisfied();
     } catch (Throwable throwable) {
       signalAllWaiters();
-      throw Throwables.propagate(throwable);
+      throw throwable;
     }
   }
 , ",NaN,Moe Sync
3262,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFuture.java']","@@ -1010,17 +1010,6 @@ protected final Throwable tryInternalFastPathGetFailure() {
     return null;
   }
 
-  /**
-   * Returns the exception that this {@code Future} completed with. This includes completion through
-   * a call to {@link #setException} or {@link #setFuture setFuture}{@code (failedFuture)} but not
-   * cancellation.
-   *
-   * @throws RuntimeException if the {@code Future} has not failed
-   */
-  final Throwable trustedGetException() {
-    return ((Failure) value).exception;
-  }
-
   /**
    * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)
    * the given future (if available)., @@ -200,7 +200,7 @@ private void handleException(Throwable throwable) {
     final void addInitialException(Set<Throwable> seen) {
       if (!isCancelled()) {
         // TODO(cpovirk): Think about whether we could/should use Verify to check this.
-        boolean unused = addCausalChain(seen, trustedGetException());
+        boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
       }
     }
 , @@ -1010,17 +1010,6 @@ protected final Throwable tryInternalFastPathGetFailure() {
     return null;
   }
 
-  /**
-   * Returns the exception that this {@code Future} completed with. This includes completion through
-   * a call to {@link #setException} or {@link #setFuture setFuture}{@code (failedFuture)} but not
-   * cancellation.
-   *
-   * @throws RuntimeException if the {@code Future} has not failed
-   */
-  final Throwable trustedGetException() {
-    return ((Failure) value).exception;
-  }
-
   /**
    * If this future has been cancelled (and possibly interrupted), cancels (and possibly interrupts)
    * the given future (if available)., @@ -200,7 +200,7 @@ private void handleException(Throwable throwable) {
     final void addInitialException(Set<Throwable> seen) {
       if (!isCancelled()) {
         // TODO(cpovirk): Think about whether we could/should use Verify to check this.
-        boolean unused = addCausalChain(seen, trustedGetException());
+        boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
       }
     }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove trustedGetException()

tryInternalFastPathGetFailure gives access to similar fast-path

RELNOTES=N/A

9d9d4d253c377a41919542ac65c5fa7205bd7f52",Moe Sync
3270,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava/src/com/google/common/util/concurrent/AbstractCatchingFuture.java']","@@ -1006,6 +1006,15 @@ public void testCatchingAsync_inputRaisesException() throws Exception {
     fallback.verifyCallCount(1);
   }
 
+  @GwtIncompatible // non-Throwable exceptionType
+  public void testCatchingAsync_inputCancelledWithoutFallback() throws Exception {
+    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();
+    ListenableFuture<Integer> originalFuture = immediateCancelledFuture();
+    ListenableFuture<Integer> faultTolerantFuture =
+        catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
+    assertTrue(faultTolerantFuture.isCancelled());
+  }
+
   public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {
     RuntimeException expectedException = new RuntimeException();
     runExpectedExceptionCatchingAsyncTest(expectedException, false);
@@ -1286,6 +1295,15 @@ public Integer apply(Throwable t) {
     fallback.verifyCallCount(1);
   }
 
+  @GwtIncompatible // non-Throwable exceptionType
+  public void testCatching_inputCancelledWithoutFallback() throws Exception {
+    Function<IOException, Integer> fallback = unexpectedFunction();
+    ListenableFuture<Integer> originalFuture = immediateCancelledFuture();
+    ListenableFuture<Integer> faultTolerantFuture =
+        catching(originalFuture, IOException.class, fallback, directExecutor());
+    assertTrue(faultTolerantFuture.isCancelled());
+  }
+
   public void testCatching_fallbackGeneratesRuntimeException() throws Exception {
     RuntimeException expectedException = new RuntimeException();
     runExpectedExceptionCatchingTest(expectedException);, @@ -95,7 +95,7 @@ public final void run() {
     }
 
     if (!isInstanceOfThrowableClass(throwable, localExceptionType)) {
-      setException(throwable);
+      setFuture(localInputFuture);
       // TODO(cpovirk): Test that fallback is not run in this case.
       return;
     }, @@ -1006,6 +1006,15 @@ public void testCatchingAsync_inputRaisesException() throws Exception {
     fallback.verifyCallCount(1);
   }
 
+  @GwtIncompatible // non-Throwable exceptionType
+  public void testCatchingAsync_inputCancelledWithoutFallback() throws Exception {
+    AsyncFunction<Throwable, Integer> fallback = unexpectedAsyncFunction();
+    ListenableFuture<Integer> originalFuture = immediateCancelledFuture();
+    ListenableFuture<Integer> faultTolerantFuture =
+        catchingAsync(originalFuture, IOException.class, fallback, directExecutor());
+    assertTrue(faultTolerantFuture.isCancelled());
+  }
+
   public void testCatchingAsync_fallbackGeneratesRuntimeException() throws Exception {
     RuntimeException expectedException = new RuntimeException();
     runExpectedExceptionCatchingAsyncTest(expectedException, false);
@@ -1286,6 +1295,15 @@ public Integer apply(Throwable t) {
     fallback.verifyCallCount(1);
   }
 
+  @GwtIncompatible // non-Throwable exceptionType
+  public void testCatching_inputCancelledWithoutFallback() throws Exception {
+    Function<IOException, Integer> fallback = unexpectedFunction();
+    ListenableFuture<Integer> originalFuture = immediateCancelledFuture();
+    ListenableFuture<Integer> faultTolerantFuture =
+        catching(originalFuture, IOException.class, fallback, directExecutor());
+    assertTrue(faultTolerantFuture.isCancelled());
+  }
+
   public void testCatching_fallbackGeneratesRuntimeException() throws Exception {
     RuntimeException expectedException = new RuntimeException();
     runExpectedExceptionCatchingTest(expectedException);, @@ -95,7 +95,7 @@ public final void run() {
     }
 
     if (!isInstanceOfThrowableClass(throwable, localExceptionType)) {
-      setException(throwable);
+      setFuture(localInputFuture);
       // TODO(cpovirk): Test that fallback is not run in this case.
       return;
     }, ",NaN,Moe Sync
3281,Colin Decker,"['android/guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/Futures.java']","@@ -772,8 +772,8 @@ public Void call() throws Exception {
 
     @Override
     public void run() {
-      // This prevents cancellation from propagating because we don't assign delegate until
-      // delegate is already done, so calling cancel() on it is a no-op.
+      // This prevents cancellation from propagating because we don't call setFuture(delegate) until
+      // delegate is already done, so calling cancel() on this future won't affect it.
       ListenableFuture<V> localDelegate = delegate;
       if (localDelegate != null) {
         setFuture(localDelegate);, @@ -772,8 +772,8 @@ public Void call() throws Exception {
 
     @Override
     public void run() {
-      // This prevents cancellation from propagating because we don't assign delegate until
-      // delegate is already done, so calling cancel() on it is a no-op.
+      // This prevents cancellation from propagating because we don't call setFuture(delegate) until
+      // delegate is already done, so calling cancel() on this future won't affect it.
       ListenableFuture<V> localDelegate = delegate;
       if (localDelegate != null) {
         setFuture(localDelegate);, ",This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.,Moe Sync
3298,Ron Shapiro,"['android/guava/src/com/google/common/base/Suppliers.java', 'android/guava/src/com/google/common/cache/CacheBuilder.java', 'android/guava/src/com/google/common/collect/Queues.java', 'android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'android/guava/src/com/google/common/util/concurrent/FluentFuture.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'android/guava/src/com/google/common/util/concurrent/Monitor.java', 'android/guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'android/guava/src/com/google/common/util/concurrent/RateLimiter.java', 'android/guava/src/com/google/common/util/concurrent/Service.java', 'android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'android/guava/src/com/google/common/util/concurrent/TimeLimiter.java', 'android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java', 'guava/src/com/google/common/base/Suppliers.java', 'guava/src/com/google/common/cache/CacheBuilder.java', 'guava/src/com/google/common/collect/Queues.java', 'guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'guava/src/com/google/common/util/concurrent/FluentFuture.java', 'guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/Monitor.java', 'guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'guava/src/com/google/common/util/concurrent/RateLimiter.java', 'guava/src/com/google/common/util/concurrent/Service.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/TimeLimiter.java', 'guava/src/com/google/common/util/concurrent/Uninterruptibles.java']","@@ -206,6 +206,7 @@ public String toString() {
    * @throws IllegalArgumentException if {@code duration} is not positive
    * @since 2.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <T> Supplier<T> memoizeWithExpiration(
       Supplier<T> delegate, long duration, TimeUnit unit) {
     return new ExpiringMemoizingSupplier<T>(delegate, duration, unit);, @@ -640,6 +640,7 @@ Strength getValueStrength() {
    * @throws IllegalArgumentException if {@code duration} is negative
    * @throws IllegalStateException if the time to live or time to idle was already set
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {
     checkState(
         expireAfterWriteNanos == UNSET_INT,
@@ -676,6 +677,7 @@ long getExpireAfterWriteNanos() {
    * @throws IllegalArgumentException if {@code duration} is negative
    * @throws IllegalStateException if the time to idle or time to live was already set
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {
     checkState(
         expireAfterAccessNanos == UNSET_INT,
@@ -719,6 +721,7 @@ long getExpireAfterAccessNanos() {
    * @since 11.0
    */
   @GwtIncompatible // To be supported (synchronously).
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit) {
     checkNotNull(unit);
     checkState(refreshNanos == UNSET_INT, ""refresh was already set to %s ns"", refreshNanos);, @@ -267,6 +267,7 @@ private Queues() {}
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // BlockingQueue
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <E> int drain(
       BlockingQueue<E> q,
       Collection<? super E> buffer,
@@ -314,6 +315,7 @@ private Queues() {}
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // BlockingQueue
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <E> int drainUninterruptibly(
       BlockingQueue<E> q,
       Collection<? super E> buffer,, @@ -122,6 +122,7 @@
      *     next
      * @param unit the time unit of the initialDelay and delay parameters
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     public static Scheduler newFixedDelaySchedule(
         final long initialDelay, final long delay, final TimeUnit unit) {
       checkNotNull(unit);
@@ -143,6 +144,7 @@ public static Scheduler newFixedDelaySchedule(
      * @param period the period between successive executions of the task
      * @param unit the time unit of the initialDelay and period parameters
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     public static Scheduler newFixedRateSchedule(
         final long initialDelay, final long period, final TimeUnit unit) {
       checkNotNull(unit);, @@ -244,6 +244,7 @@ public final boolean cancel(boolean mayInterruptIfRunning) {
    * @param scheduledExecutor The executor service to enforce the timeout.
    */
   @GwtIncompatible // ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public final FluentFuture<V> withTimeout(
       long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {
     return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);, @@ -260,6 +260,7 @@ private Futures() {}
    * @since 23.0
    */
   @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <O> ListenableFuture<O> scheduleAsync(
       AsyncCallable<O> callable,
       long delay,
@@ -408,6 +409,7 @@ public void run() {
    * @since 19.0
    */
   @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V> ListenableFuture<V> withTimeout(
       ListenableFuture<V> delegate,
       long time,
@@ -1197,6 +1199,7 @@ public String toString() {
    */
   @CanIgnoreReturnValue
   @GwtIncompatible // reflection
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {
     return FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit);, @@ -367,6 +367,7 @@ public void enter() {
    *
    * @return whether the monitor was entered
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enter(long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     final ReentrantLock lock = this.lock;
@@ -406,6 +407,7 @@ public void enterInterruptibly() throws InterruptedException {
    * @return whether the monitor was entered
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {
     return lock.tryLock(time, unit);
   }
@@ -455,6 +457,7 @@ public void enterWhen(Guard guard) throws InterruptedException {
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (guard.monitor != this) {
@@ -534,6 +537,7 @@ public void enterWhenUninterruptibly(Guard guard) {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (guard.monitor != this) {
@@ -623,6 +627,7 @@ public boolean enterIf(Guard guard) {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterIf(Guard guard, long time, TimeUnit unit) {
     if (guard.monitor != this) {
       throw new IllegalMonitorStateException();
@@ -671,6 +676,7 @@ public boolean enterIfInterruptibly(Guard guard) throws InterruptedException {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)
       throws InterruptedException {
     if (guard.monitor != this) {
@@ -740,6 +746,7 @@ public void waitFor(Guard guard) throws InterruptedException {
    * @return whether the guard is now satisfied
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {
@@ -773,6 +780,7 @@ public void waitForUninterruptibly(Guard guard) {
    *
    * @return whether the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {, @@ -79,6 +79,7 @@ private MoreExecutors() {}
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static ExecutorService getExitingExecutorService(
       ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
     return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);
@@ -118,6 +119,7 @@ public static ExecutorService getExitingExecutorService(ThreadPoolExecutor execu
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static ScheduledExecutorService getExitingScheduledExecutorService(
       ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
     return new Application()
@@ -157,6 +159,7 @@ public static ScheduledExecutorService getExitingScheduledExecutorService(
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void addDelayedShutdownHook(
       ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {
     new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);
@@ -636,6 +639,7 @@ public void run() {
    * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}
    * implementations.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   @GwtIncompatible static <T> T invokeAnyImpl(
       ListeningExecutorService executorService,
       Collection<? extends Callable<T>> tasks,
@@ -927,6 +931,7 @@ protected Runnable wrapTask(Runnable command) {
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean shutdownAndAwaitTermination(
       ExecutorService service, long timeout, TimeUnit unit) {
     long halfTimeoutNanos = unit.toNanos(timeout) / 2;, @@ -92,6 +92,7 @@
 // would mean a maximum rate of ""1MB/s"", which might be small in some cases.
 @Beta
 @GwtIncompatible
+@SuppressWarnings(""GoodTime"") // lots of violations - also how should we model a rate?
 public abstract class RateLimiter {
   /**
    * Creates a {@code RateLimiter} with the specified stable throughput, given as ""permits per, @@ -106,6 +106,7 @@
    *     State#TERMINATED} when this method is called then this will throw an IllegalStateException.
    * @since 15.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException;
 
   /**
@@ -126,6 +127,7 @@
    * @throws IllegalStateException if the service {@linkplain State#FAILED fails}.
    * @since 15.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException;
 
   /**, @@ -325,6 +325,7 @@ public void awaitHealthy() {
    * @throws IllegalStateException if the service manager reaches a state from which it cannot
    *     become {@linkplain #isHealthy() healthy}.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {
     state.awaitHealthy(timeout, unit);
   }
@@ -361,6 +362,7 @@ public void awaitStopped() {
    * @param unit the time unit of the timeout argument
    * @throws TimeoutException if not all of the services have stopped within the deadline
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {
     state.awaitStopped(timeout, unit);
   }, @@ -31,6 +31,7 @@
  */
 @Beta
 @GwtIncompatible
+@SuppressWarnings(""GoodTime"") // should have java.time.Duration overloads
 public interface TimeLimiter {
 
   /**, @@ -72,6 +72,7 @@ public static void awaitUninterruptibly(CountDownLatch latch) {
    */
   @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -101,6 +102,7 @@ public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, T
    * @since 23.6
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(Condition condition, long timeout, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -147,6 +149,7 @@ public static void joinUninterruptibly(Thread toJoin) {
    * uninterruptibly.
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit unit) {
     Preconditions.checkNotNull(toJoin);
     boolean interrupted = false;
@@ -225,6 +228,7 @@ public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit uni
    */
   @CanIgnoreReturnValue
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V> V getUninterruptibly(Future<V> future, long timeout, TimeUnit unit)
       throws ExecutionException, TimeoutException {
     boolean interrupted = false;
@@ -297,6 +301,7 @@ public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit uni
   // TODO(user): Support Sleeper somehow (wrapper or interface method)?
   /** Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly. */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -326,6 +331,7 @@ public static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
    * @since 18.0
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, long timeout, TimeUnit unit) {
     return tryAcquireUninterruptibly(semaphore, 1, timeout, unit);
@@ -338,6 +344,7 @@ public static boolean tryAcquireUninterruptibly(
    * @since 18.0
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, int permits, long timeout, TimeUnit unit) {
     boolean interrupted = false;, @@ -206,6 +206,7 @@ public String toString() {
    * @throws IllegalArgumentException if {@code duration} is not positive
    * @since 2.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <T> Supplier<T> memoizeWithExpiration(
       Supplier<T> delegate, long duration, TimeUnit unit) {
     return new ExpiringMemoizingSupplier<T>(delegate, duration, unit);, @@ -670,6 +670,7 @@ Strength getValueStrength() {
    * @throws IllegalArgumentException if {@code duration} is negative
    * @throws IllegalStateException if the time to live or time to idle was already set
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> expireAfterWrite(long duration, TimeUnit unit) {
     checkState(
         expireAfterWriteNanos == UNSET_INT,
@@ -738,6 +739,7 @@ long getExpireAfterWriteNanos() {
    * @throws IllegalArgumentException if {@code duration} is negative
    * @throws IllegalStateException if the time to idle or time to live was already set
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> expireAfterAccess(long duration, TimeUnit unit) {
     checkState(
         expireAfterAccessNanos == UNSET_INT,
@@ -816,6 +818,7 @@ long getExpireAfterAccessNanos() {
    * @since 11.0
    */
   @GwtIncompatible // To be supported (synchronously).
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheBuilder<K, V> refreshAfterWrite(long duration, TimeUnit unit) {
     checkNotNull(unit);
     checkState(refreshNanos == UNSET_INT, ""refresh was already set to %s ns"", refreshNanos);, @@ -267,6 +267,7 @@ private Queues() {}
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // BlockingQueue
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <E> int drain(
       BlockingQueue<E> q,
       Collection<? super E> buffer,
@@ -314,6 +315,7 @@ private Queues() {}
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // BlockingQueue
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <E> int drainUninterruptibly(
       BlockingQueue<E> q,
       Collection<? super E> buffer,, @@ -122,6 +122,7 @@
      *     next
      * @param unit the time unit of the initialDelay and delay parameters
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     public static Scheduler newFixedDelaySchedule(
         final long initialDelay, final long delay, final TimeUnit unit) {
       checkNotNull(unit);
@@ -143,6 +144,7 @@ public static Scheduler newFixedDelaySchedule(
      * @param period the period between successive executions of the task
      * @param unit the time unit of the initialDelay and period parameters
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     public static Scheduler newFixedRateSchedule(
         final long initialDelay, final long period, final TimeUnit unit) {
       checkNotNull(unit);, @@ -244,6 +244,7 @@ public final boolean cancel(boolean mayInterruptIfRunning) {
    * @param scheduledExecutor The executor service to enforce the timeout.
    */
   @GwtIncompatible // ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public final FluentFuture<V> withTimeout(
       long timeout, TimeUnit unit, ScheduledExecutorService scheduledExecutor) {
     return (FluentFuture<V>) Futures.withTimeout(this, timeout, unit, scheduledExecutor);, @@ -260,6 +260,7 @@ private Futures() {}
    * @since 23.0
    */
   @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <O> ListenableFuture<O> scheduleAsync(
       AsyncCallable<O> callable,
       long delay,
@@ -408,6 +409,7 @@ public void run() {
    * @since 19.0
    */
   @GwtIncompatible // java.util.concurrent.ScheduledExecutorService
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V> ListenableFuture<V> withTimeout(
       ListenableFuture<V> delegate,
       long time,
@@ -1197,6 +1199,7 @@ public String toString() {
    */
   @CanIgnoreReturnValue
   @GwtIncompatible // reflection
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V, X extends Exception> V getChecked(
       Future<V> future, Class<X> exceptionClass, long timeout, TimeUnit unit) throws X {
     return FuturesGetChecked.getChecked(future, exceptionClass, timeout, unit);, @@ -386,6 +386,7 @@ public void enter() {
    *
    * @return whether the monitor was entered
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enter(long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     final ReentrantLock lock = this.lock;
@@ -425,6 +426,7 @@ public void enterInterruptibly() throws InterruptedException {
    * @return whether the monitor was entered
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {
     return lock.tryLock(time, unit);
   }
@@ -474,6 +476,7 @@ public void enterWhen(Guard guard) throws InterruptedException {
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (guard.monitor != this) {
@@ -553,6 +556,7 @@ public void enterWhenUninterruptibly(Guard guard) {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterWhenUninterruptibly(Guard guard, long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (guard.monitor != this) {
@@ -642,6 +646,7 @@ public boolean enterIf(Guard guard) {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterIf(Guard guard, long time, TimeUnit unit) {
     if (guard.monitor != this) {
       throw new IllegalMonitorStateException();
@@ -690,6 +695,7 @@ public boolean enterIfInterruptibly(Guard guard) throws InterruptedException {
    *
    * @return whether the monitor was entered, which guarantees that the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean enterIfInterruptibly(Guard guard, long time, TimeUnit unit)
       throws InterruptedException {
     if (guard.monitor != this) {
@@ -759,6 +765,7 @@ public void waitFor(Guard guard) throws InterruptedException {
    * @return whether the guard is now satisfied
    * @throws InterruptedException if interrupted while waiting
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean waitFor(Guard guard, long time, TimeUnit unit) throws InterruptedException {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {
@@ -792,6 +799,7 @@ public void waitForUninterruptibly(Guard guard) {
    *
    * @return whether the guard is now satisfied
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {
     final long timeoutNanos = toSafeNanos(time, unit);
     if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {, @@ -79,6 +79,7 @@ private MoreExecutors() {}
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static ExecutorService getExitingExecutorService(
       ThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
     return new Application().getExitingExecutorService(executor, terminationTimeout, timeUnit);
@@ -118,6 +119,7 @@ public static ExecutorService getExitingExecutorService(ThreadPoolExecutor execu
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static ScheduledExecutorService getExitingScheduledExecutorService(
       ScheduledThreadPoolExecutor executor, long terminationTimeout, TimeUnit timeUnit) {
     return new Application()
@@ -157,6 +159,7 @@ public static ScheduledExecutorService getExitingScheduledExecutorService(
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void addDelayedShutdownHook(
       ExecutorService service, long terminationTimeout, TimeUnit timeUnit) {
     new Application().addDelayedShutdownHook(service, terminationTimeout, timeUnit);
@@ -636,6 +639,7 @@ public void run() {
    * An implementation of {@link ExecutorService#invokeAny} for {@link ListeningExecutorService}
    * implementations.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   @GwtIncompatible static <T> T invokeAnyImpl(
       ListeningExecutorService executorService,
       Collection<? extends Callable<T>> tasks,
@@ -927,6 +931,7 @@ protected Runnable wrapTask(Runnable command) {
   @Beta
   @CanIgnoreReturnValue
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean shutdownAndAwaitTermination(
       ExecutorService service, long timeout, TimeUnit unit) {
     long halfTimeoutNanos = unit.toNanos(timeout) / 2;, @@ -92,6 +92,7 @@
 // would mean a maximum rate of ""1MB/s"", which might be small in some cases.
 @Beta
 @GwtIncompatible
+@SuppressWarnings(""GoodTime"") // lots of violations - also how should we model a rate?
 public abstract class RateLimiter {
   /**
    * Creates a {@code RateLimiter} with the specified stable throughput, given as ""permits per, @@ -106,6 +106,7 @@
    *     State#TERMINATED} when this method is called then this will throw an IllegalStateException.
    * @since 15.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   void awaitRunning(long timeout, TimeUnit unit) throws TimeoutException;
 
   /**
@@ -126,6 +127,7 @@
    * @throws IllegalStateException if the service {@linkplain State#FAILED fails}.
    * @since 15.0
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutException;
 
   /**, @@ -325,6 +325,7 @@ public void awaitHealthy() {
    * @throws IllegalStateException if the service manager reaches a state from which it cannot
    *     become {@linkplain #isHealthy() healthy}.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public void awaitHealthy(long timeout, TimeUnit unit) throws TimeoutException {
     state.awaitHealthy(timeout, unit);
   }
@@ -361,6 +362,7 @@ public void awaitStopped() {
    * @param unit the time unit of the timeout argument
    * @throws TimeoutException if not all of the services have stopped within the deadline
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {
     state.awaitStopped(timeout, unit);
   }, @@ -31,6 +31,7 @@
  */
 @Beta
 @GwtIncompatible
+@SuppressWarnings(""GoodTime"") // should have java.time.Duration overloads
 public interface TimeLimiter {
 
   /**, @@ -72,6 +72,7 @@ public static void awaitUninterruptibly(CountDownLatch latch) {
    */
   @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -101,6 +102,7 @@ public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, T
    * @since 23.6
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(Condition condition, long timeout, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -147,6 +149,7 @@ public static void joinUninterruptibly(Thread toJoin) {
    * uninterruptibly.
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit unit) {
     Preconditions.checkNotNull(toJoin);
     boolean interrupted = false;
@@ -225,6 +228,7 @@ public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit uni
    */
   @CanIgnoreReturnValue
   @GwtIncompatible // TODO
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static <V> V getUninterruptibly(Future<V> future, long timeout, TimeUnit unit)
       throws ExecutionException, TimeoutException {
     boolean interrupted = false;
@@ -297,6 +301,7 @@ public static void joinUninterruptibly(Thread toJoin, long timeout, TimeUnit uni
   // TODO(user): Support Sleeper somehow (wrapper or interface method)?
   /** Invokes {@code unit.}{@link TimeUnit#sleep(long) sleep(sleepFor)} uninterruptibly. */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
     boolean interrupted = false;
     try {
@@ -326,6 +331,7 @@ public static void sleepUninterruptibly(long sleepFor, TimeUnit unit) {
    * @since 18.0
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, long timeout, TimeUnit unit) {
     return tryAcquireUninterruptibly(semaphore, 1, timeout, unit);
@@ -338,6 +344,7 @@ public static boolean tryAcquireUninterruptibly(
    * @since 18.0
    */
   @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public static boolean tryAcquireUninterruptibly(
       Semaphore semaphore, int permits, long timeout, TimeUnit unit) {
     boolean interrupted = false;, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Enable GoodTime API checker for Guava

753e1d5be8e1cc4c5ebaa080b095c7ef24117cba",Moe Sync
3305,Ron Shapiro,"['android/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java', 'android/guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java', 'android/guava-testlib/test/com/google/common/testing/SerializableTesterTest.java', 'android/guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java', 'guava-testlib/test/com/google/common/testing/EqualsTesterTest.java', 'guava-testlib/test/com/google/common/testing/NullPointerTesterTest.java', 'guava-testlib/test/com/google/common/testing/SerializableTesterTest.java', 'guava-testlib/test/com/google/common/testing/anotherpackage/ForwardingWrapperTesterTest.java']","@@ -326,6 +326,7 @@ public int hashCode() {
       this.aspect2 = aspect2;
     }
 
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object o) {
       if (!(o instanceof InvalidHashCodeObject)) {, @@ -1384,6 +1384,7 @@ private static String rootLocaleFormat(String format, Object... args) {
   }
 
   static class OverridesEquals {
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object o) {
       return true;, @@ -80,6 +80,7 @@ public void testObjectWhichIsEqualButChangesClass() {
   private static class ClassWhichIsAlwaysEqualButHasDifferentHashcodes implements Serializable {
     private static final long serialVersionUID = 2L;
 
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object other) {
       return (other instanceof ClassWhichIsAlwaysEqualButHasDifferentHashcodes);, @@ -116,6 +116,8 @@ public void testFailsToForwardHashCode() {
           @Override
           public Runnable apply(final Runnable runnable) {
             return new ForwardingRunnable(runnable) {
+
+              @SuppressWarnings(""EqualsHashCode"")
               @Override
               public boolean equals(Object o) {
                 if (o instanceof ForwardingRunnable) {, @@ -326,6 +326,7 @@ public int hashCode() {
       this.aspect2 = aspect2;
     }
 
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object o) {
       if (!(o instanceof InvalidHashCodeObject)) {, @@ -1437,6 +1437,7 @@ private static String rootLocaleFormat(String format, Object... args) {
   }
 
   static class OverridesEquals {
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object o) {
       return true;, @@ -80,6 +80,7 @@ public void testObjectWhichIsEqualButChangesClass() {
   private static class ClassWhichIsAlwaysEqualButHasDifferentHashcodes implements Serializable {
     private static final long serialVersionUID = 2L;
 
+    @SuppressWarnings(""EqualsHashCode"")
     @Override
     public boolean equals(Object other) {
       return (other instanceof ClassWhichIsAlwaysEqualButHasDifferentHashcodes);, @@ -116,6 +116,8 @@ public void testFailsToForwardHashCode() {
           @Override
           public Runnable apply(final Runnable runnable) {
             return new ForwardingRunnable(runnable) {
+
+              @SuppressWarnings(""EqualsHashCode"")
               @Override
               public boolean equals(Object o) {
                 if (o instanceof ForwardingRunnable) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Enable goodtime-api for Guava (with some exceptions).

603ecca60c11d9a343423ae908bbc325521a7f50

-------

<p> *Builder.java: add @param documentation for the node/value/edge types that clarifies their behavior.

This is in response to (and should resolve) https://github.com/google/guava/issues/3299.

9db70c6519ef588697a9c522ee36aea439f36241

-------

<p> Suppress warnings in classes that implement equals() without also implementing
hashCode().

The contract for Object.hashCode states that if two objects are equal, then
calling the hashCode() method on each of the two objects must produce the same
result. Implementing equals() but not hashCode() causes broken behaviour when
trying to store the object in a collection.

73f7e84a345805dc4fcc9927201e03fdbf408c5f",Moe Sync
3306,Ron Shapiro,"['android/guava/src/com/google/common/primitives/Chars.java', 'guava/src/com/google/common/primitives/Chars.java']","@@ -369,10 +369,11 @@ public static String join(String separator, char... array) {
 
   /**
    * Returns a comparator that compares two {@code char} arrays <a
-   * href=""http://en.wikipedia.org/wiki/Lexicographical_order"">lexicographically</a>. That is, it
-   * compares, using {@link #compare(char, char)}), the first pair of values that follow any common
-   * prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
-   * example, {@code [] < ['a'] < ['a', 'b'] < ['b']}.
+   * href=""http://en.wikipedia.org/wiki/Lexicographical_order"">lexicographically</a>; not advisable
+   * for sorting user-visible strings as the ordering may not match the conventions of the user's
+   * locale. That is, it compares, using {@link #compare(char, char)}), the first pair of values
+   * that follow any common prefix, or when one array is a prefix of the other, treats the shorter
+   * array as the lesser. For example, {@code [] < ['a'] < ['a', 'b'] < ['b']}.
    *
    * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
    * support only identity equality), but it is consistent with {@link Arrays#equals(char[],, @@ -369,10 +369,11 @@ public static String join(String separator, char... array) {
 
   /**
    * Returns a comparator that compares two {@code char} arrays <a
-   * href=""http://en.wikipedia.org/wiki/Lexicographical_order"">lexicographically</a>. That is, it
-   * compares, using {@link #compare(char, char)}), the first pair of values that follow any common
-   * prefix, or when one array is a prefix of the other, treats the shorter array as the lesser. For
-   * example, {@code [] < ['a'] < ['a', 'b'] < ['b']}.
+   * href=""http://en.wikipedia.org/wiki/Lexicographical_order"">lexicographically</a>; not advisable
+   * for sorting user-visible strings as the ordering may not match the conventions of the user's
+   * locale. That is, it compares, using {@link #compare(char, char)}), the first pair of values
+   * that follow any common prefix, or when one array is a prefix of the other, treats the shorter
+   * array as the lesser. For example, {@code [] < ['a'] < ['a', 'b'] < ['b']}.
    *
    * <p>The returned comparator is inconsistent with {@link Object#equals(Object)} (since arrays
    * support only identity equality), but it is consistent with {@link Arrays#equals(char[],, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Document that Chars.lexicographicalOrdering is different than Alphabetical
ordering, which is more appropriate for user text.

5377565bc5be4bcce52a07952595b50c11c75f1a",Moe Sync
3312,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -95,7 +95,7 @@
       <plugins>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
+          <version>3.8.0</version>
           <configuration>
             <source>1.7</source>
             <target>1.7</target>, @@ -96,7 +96,7 @@
       <plugins>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
+          <version>3.8.0</version>
           <configuration>
             <source>1.8</source>
             <target>1.8</target>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add MediaType.MICROSOFT_OUTLOOK and add missing javadocs to a few other MediaTypes.

Closes https://github.com/google/guava/pull/3309

522d3aa499742f7ca0cf1753c4d7688acdc0410a

-------

<p> Use maven-compiler-plugin version 3.8.0.

Closes https://github.com/google/guava/pull/3294.

f31bf941cab3acbee83f7d000b4b09bc24ca1032",Moe Sync
3313,Ron Shapiro,"['android/guava-tests/test/com/google/common/graph/PackageSanityTests.java', 'guava-tests/test/com/google/common/graph/PackageSanityTests.java']","@@ -51,6 +51,7 @@ public PackageSanityTests() {
     setDistinctValues(Graph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);
     setDistinctValues(NetworkBuilder.class, NETWORK_BUILDER_A, NETWORK_BUILDER_B);
     setDistinctValues(Network.class, IMMUTABLE_NETWORK_A, IMMUTABLE_NETWORK_B);
+    setDefault(EndpointPair.class, EndpointPair.ordered(""A"", ""B""));
   }
 
   @Override, @@ -51,6 +51,7 @@ public PackageSanityTests() {
     setDistinctValues(Graph.class, IMMUTABLE_GRAPH_A, IMMUTABLE_GRAPH_B);
     setDistinctValues(NetworkBuilder.class, NETWORK_BUILDER_A, NETWORK_BUILDER_B);
     setDistinctValues(Network.class, IMMUTABLE_NETWORK_A, IMMUTABLE_NETWORK_B);
+    setDefault(EndpointPair.class, EndpointPair.ordered(""A"", ""B""));
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct documentation for Splitter#withKeyValueSeparator(Splitter)

8340e5a770401494da5194e33153079754381006

-------

<p> Standardise message format for ""duplicate key"" IllegalArgumentException thrown from ImmutableTable.Builder.build().

Internally, ImmutableTable.Builder.build() delegates to two classes, {Dense,Sparse}ImmutableTable and these currently have inconsistent error messages when a duplicate key is detected.

Prior to this CL, SparseImmutableTable had a message formatted like:
  ""Duplicate value for row=%rowKey%, column=%columnKey%: %newValue%, %oldValue%""
Whereas DenseImmutableTable had:
  ""duplicate key: (%rowKey%, %columnKey%)""

After this CL both classes will format the message like:
  ""Duplicate key: (row=%rowKey%, column=%columnKey%), values: [%newValue%, %oldValue%].""

RELNOTES=Standardise message format for ""duplicate key"" IllegalArgumentException thrown from ImmutableTable.Builder.build().

96e21ae4f9fce2dc622658cff322b01f1721012e

-------

<p> common.graph PackageSanityTests: specify a default object for EndpointPair inputs.
This should resolve a few internal flaky test issues

4210f57678985b51439b0fa37779ec5b369024b8",Moe Sync
3318,Ron Shapiro,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -259,6 +259,11 @@ private ReferrerPolicyValues() {}
   public static final String LINK = ""Link"";
   /** The HTTP {@code Location} header field name. */
   public static final String LOCATION = ""Location"";
+  /**
+   * The HTTP <a href=""https://googlechrome.github.io/OriginTrials/#header"">{@code Origin-Trial}</a>
+   * header field name.
+   */
+  public static final String ORIGIN_TRIAL = ""Origin-Trial"";
   /** The HTTP {@code P3P} header field name. Limited browser support. */
   public static final String P3P = ""P3P"";
   /** The HTTP {@code Proxy-Authenticate} header field name. */, @@ -259,6 +259,11 @@ private ReferrerPolicyValues() {}
   public static final String LINK = ""Link"";
   /** The HTTP {@code Location} header field name. */
   public static final String LOCATION = ""Location"";
+  /**
+   * The HTTP <a href=""https://googlechrome.github.io/OriginTrials/#header"">{@code Origin-Trial}</a>
+   * header field name.
+   */
+  public static final String ORIGIN_TRIAL = ""Origin-Trial"";
   /** The HTTP {@code P3P} header field name. Limited browser support. */
   public static final String P3P = ""P3P"";
   /** The HTTP {@code Proxy-Authenticate} header field name. */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Address why users should prefer our immutable collections to things like Collections.emptyList().

2b9f74c16acbb9bbe18bc20e171996c79a476e31

-------

<p> Add the Origin-Trial HTTP response header.

229188e18e6504ffa9747e8bd00622d28e460477",Moe Sync
3319,Ron Shapiro,"['android/guava-bom/pom.xml', 'android/pom.xml', 'guava-bom/pom.xml', 'pom.xml']","@@ -0,0 +1,52 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project
+  xmlns=""http://maven.apache.org/POM/4.0.0""
+  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>com.google.guava</groupId>
+  <artifactId>guava-bom</artifactId>
+  <version>HEAD-android-SNAPSHOT</version>
+  <packaging>pom</packaging>
+  
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>9</version>
+  </parent>
+
+  <name>Guava BOM</name>
+  <description>BOM for Guava artifacts</description>
+  <url>https://github.com/google/guava</url>
+  <inceptionYear>2010</inceptionYear>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>https://github.com/google/guava/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>The Apache Software License, Version 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+      <distribution>repo</distribution>
+    </license>
+  </licenses>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava-testlib</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+</project>, @@ -62,6 +62,7 @@
   </ciManagement>
   <modules>
     <module>guava</module>
+    <module>guava-bom</module>
     <module>guava-testlib</module>
     <module>guava-tests</module>
   </modules>, @@ -0,0 +1,57 @@
+<?xml version=""1.0"" encoding=""UTF-8""?>
+<project
+  xmlns=""http://maven.apache.org/POM/4.0.0""
+  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
+  xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <groupId>com.google.guava</groupId>
+  <artifactId>guava-bom</artifactId>
+  <version>HEAD-jre-SNAPSHOT</version>
+  <packaging>pom</packaging>
+  
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>9</version>
+  </parent>
+
+  <name>Guava BOM</name>
+  <description>BOM for Guava artifacts</description>
+  <url>https://github.com/google/guava</url>
+  <inceptionYear>2010</inceptionYear>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>https://github.com/google/guava/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>The Apache Software License, Version 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+      <distribution>repo</distribution>
+    </license>
+  </licenses>
+
+  <dependencyManagement>
+    <dependencies>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava-gwt</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava-testlib</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+    </dependencies>
+  </dependencyManagement>
+</project>, @@ -62,6 +62,7 @@
   </ciManagement>
   <modules>
     <module>guava</module>
+    <module>guava-bom</module>
     <module>guava-gwt</module>
     <module>guava-testlib</module>
     <module>guava-tests</module>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Create a Guava BOM.

RELNOTES=Create a BOM for Guava.

0a6c51ed24ba85e207ae5f258f5e264b94bf0961",Moe Sync
3325,Colin Decker,"['android/guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java', 'android/guava-testlib/test/com/google/common/testing/GcFinalizationTest.java', 'android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java', 'android/guava-tests/test/com/google/common/base/PreconditionsTest.java', 'android/guava-tests/test/com/google/common/base/SuppliersTest.java', 'android/guava-tests/test/com/google/common/base/ThrowablesTest.java', 'android/guava-tests/test/com/google/common/base/Utf8Test.java', 'android/guava-tests/test/com/google/common/base/VerifyTest.java', 'android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java', 'android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java', 'android/guava-tests/test/com/google/common/cache/NullCacheTest.java', 'android/guava-tests/test/com/google/common/collect/ArrayTableTest.java', 'android/guava-tests/test/com/google/common/collect/IteratorsTest.java', 'android/guava-tests/test/com/google/common/eventbus/SubscriberTest.java', 'android/guava-tests/test/com/google/common/graph/PackageSanityTests.java', 'android/guava-tests/test/com/google/common/hash/BloomFilterTest.java', 'android/guava-tests/test/com/google/common/io/BaseEncodingTest.java', 'android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'android/guava-tests/test/com/google/common/io/CountingInputStreamTest.java', 'android/guava-tests/test/com/google/common/io/LittleEndianDataInputStreamTest.java', 'android/guava-tests/test/com/google/common/io/ResourcesTest.java', 'android/guava-tests/test/com/google/common/net/HostSpecifierTest.java', 'android/guava-tests/test/com/google/common/net/PercentEscaperTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractExecutionThreadServiceTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractIdleServiceTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/CallablesTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/FuturesGetCheckedTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/FuturesGetDoneTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/ListenableFutureTester.java', 'android/guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/SettableFutureTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/TrustedListenableFutureTaskTest.java', 'guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/TestPlatform.java', 'guava-testlib/test/com/google/common/testing/ClassSanityTesterTest.java', 'guava-testlib/test/com/google/common/testing/GcFinalizationTest.java', 'guava-testlib/test/com/google/common/testing/TearDownStackTest.java', 'guava-tests/test/com/google/common/base/PreconditionsTest.java', 'guava-tests/test/com/google/common/base/SuppliersTest.java', 'guava-tests/test/com/google/common/base/ThrowablesTest.java', 'guava-tests/test/com/google/common/base/Utf8Test.java', 'guava-tests/test/com/google/common/base/VerifyTest.java', 'guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java', 'guava-tests/test/com/google/common/cache/CacheLoadingTest.java', 'guava-tests/test/com/google/common/cache/NullCacheTest.java', 'guava-tests/test/com/google/common/collect/ArrayTableTest.java', 'guava-tests/test/com/google/common/collect/IteratorsTest.java', 'guava-tests/test/com/google/common/eventbus/SubscriberTest.java', 'guava-tests/test/com/google/common/graph/PackageSanityTests.java', 'guava-tests/test/com/google/common/hash/BloomFilterTest.java', 'guava-tests/test/com/google/common/io/BaseEncodingTest.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava-tests/test/com/google/common/io/CountingInputStreamTest.java', 'guava-tests/test/com/google/common/io/LittleEndianDataInputStreamTest.java', 'guava-tests/test/com/google/common/io/ResourcesTest.java', 'guava-tests/test/com/google/common/net/HostSpecifierTest.java', 'guava-tests/test/com/google/common/net/PercentEscaperTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractAbstractFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractExecutionThreadServiceTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractIdleServiceTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractScheduledServiceTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java', 'guava-tests/test/com/google/common/util/concurrent/CallablesTest.java', 'guava-tests/test/com/google/common/util/concurrent/FluentFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesGetCheckedTest.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesGetDoneTest.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava-tests/test/com/google/common/util/concurrent/ListenableFutureTester.java', 'guava-tests/test/com/google/common/util/concurrent/MoreExecutorsTest.java', 'guava-tests/test/com/google/common/util/concurrent/SettableFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/TrustedListenableFutureTaskTest.java']","@@ -84,7 +84,8 @@ public void testForAllPublicStaticMethods_noPublicStaticMethods() throws Excepti
       tester.forAllPublicStaticMethods(NoPublicStaticMethods.class).testEquals();
     } catch (AssertionFailedError expected) {
       assertThat(expected)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""No public static methods that return java.lang.Object or subtype are found in ""
                   + NoPublicStaticMethods.class
                   + ""."");
@@ -138,7 +139,8 @@ public void testNullsOnReturnValues_returnTypeFiltered() throws Exception {
           .testNulls();
     } catch (AssertionFailedError expected) {
       assertThat(expected)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""No public static methods that return java.lang.Iterable or subtype are found in ""
                   + BadNullsFactory.class
                   + ""."");, @@ -136,8 +136,8 @@ void shutdown() {
   }
 
   void assertWrapsInterruptedException(RuntimeException e) {
-    assertThat(e.getMessage()).contains(""Unexpected interrupt"");
-    assertThat(e.getCause()).isInstanceOf(InterruptedException.class);
+    assertThat(e).hasMessageThat().contains(""Unexpected interrupt"");
+    assertThat(e).hasCauseThat().isInstanceOf(InterruptedException.class);
   }
 
   public void testAwait_CountDownLatch_Interrupted() {, @@ -83,7 +83,7 @@ public void testThrowingTearDown() throws Exception {
       stack.runTearDown();
       fail(""runTearDown should have thrown an exception"");
     } catch (ClusterException expected) {
-      assertThat(expected.getCause()).hasMessage(""two"");
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""two"");
     } catch (RuntimeException e) {
       throw new RuntimeException(
           ""A ClusterException should have been thrown, rather than a "" + e.getClass().getName(), e);, @@ -71,7 +71,7 @@ public void testCheckArgument_nullMessage_failure() {
       Preconditions.checkArgument(false, null);
       fail(""no exception thrown"");
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""null"");
+      assertThat(expected).hasMessageThat().isEqualTo(""null"");
     }
   }
 
@@ -172,7 +172,7 @@ public void testCheckState_nullMessage_failure() {
       Preconditions.checkState(false, null);
       fail(""no exception thrown"");
     } catch (IllegalStateException expected) {
-      assertThat(expected).hasMessage(""null"");
+      assertThat(expected).hasMessageThat().isEqualTo(""null"");
     }
   }
 
@@ -253,7 +253,7 @@ public void testCheckElementIndex_negative() {
       Preconditions.checkElementIndex(-1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (-1) must not be negative"");
     }
   }
 
@@ -262,7 +262,7 @@ public void testCheckElementIndex_tooHigh() {
       Preconditions.checkElementIndex(1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (1) must be less than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (1) must be less than size (1)"");
     }
   }
 
@@ -271,7 +271,7 @@ public void testCheckElementIndex_withDesc_negative() {
       Preconditions.checkElementIndex(-1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (-1) must not be negative"");
     }
   }
 
@@ -280,7 +280,7 @@ public void testCheckElementIndex_withDesc_tooHigh() {
       Preconditions.checkElementIndex(1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (1) must be less than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (1) must be less than size (1)"");
     }
   }
 
@@ -305,7 +305,7 @@ public void testCheckPositionIndex_negative() {
       Preconditions.checkPositionIndex(-1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (-1) must not be negative"");
     }
   }
 
@@ -314,7 +314,9 @@ public void testCheckPositionIndex_tooHigh() {
       Preconditions.checkPositionIndex(2, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (2) must not be greater than size (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""index (2) must not be greater than size (1)"");
     }
   }
 
@@ -323,7 +325,7 @@ public void testCheckPositionIndex_withDesc_negative() {
       Preconditions.checkPositionIndex(-1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (-1) must not be negative"");
     }
   }
 
@@ -332,7 +334,7 @@ public void testCheckPositionIndex_withDesc_tooHigh() {
       Preconditions.checkPositionIndex(2, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (2) must not be greater than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (2) must not be greater than size (1)"");
     }
   }
 
@@ -356,7 +358,7 @@ public void testCheckPositionIndex_startNegative() {
       Preconditions.checkPositionIndexes(-1, 1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""start index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""start index (-1) must not be negative"");
     }
   }
 
@@ -365,7 +367,9 @@ public void testCheckPositionIndexes_endTooHigh() {
       Preconditions.checkPositionIndexes(0, 2, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""end index (2) must not be greater than size (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""end index (2) must not be greater than size (1)"");
     }
   }
 
@@ -374,7 +378,9 @@ public void testCheckPositionIndexes_reversed() {
       Preconditions.checkPositionIndexes(1, 0, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""end index (0) must not be less than start index (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""end index (0) must not be less than start index (1)"");
     }
   }
 
@@ -438,12 +444,13 @@ private void assertFailureCause(
       Throwable throwable, Class<? extends Throwable> clazz, Object[] params) {
     assertThat(throwable).isInstanceOf(clazz);
     if (params.length == 1) {
-      assertThat(throwable).hasMessage(null);
+      assertThat(throwable).hasMessageThat().isNull();
     } else if (params.length == 2) {
-      assertThat(throwable).hasMessage("""");
+      assertThat(throwable).hasMessageThat().isEmpty();
     } else {
       assertThat(throwable)
-          .hasMessage(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
+          .hasMessageThat()
+          .isEqualTo(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
     }
   }
 
@@ -558,10 +565,10 @@ public String toString() {
   private static final String FORMAT = ""I ate %s pies."";
 
   private static void verifySimpleMessage(Exception e) {
-    assertThat(e).hasMessage(""A message"");
+    assertThat(e).hasMessageThat().isEqualTo(""A message"");
   }
 
   private static void verifyComplexMessage(Exception e) {
-    assertThat(e).hasMessage(""I ate 5 pies."");
+    assertThat(e).hasMessageThat().isEqualTo(""I ate 5 pies."");
   }
 }, @@ -142,7 +142,7 @@ public void testMemoizeNonSerializable() throws Exception {
       reserialize(memoizedSupplier);
       fail();
     } catch (RuntimeException ex) {
-      assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass());
+      assertThat(ex).hasCauseThat().isInstanceOf(java.io.NotSerializableException.class);
     }
   }
 , @@ -415,7 +415,7 @@ public void noneDeclared() {
       sample.noneDeclared();
       fail();
     } catch (RuntimeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(SomeCheckedException.class);
     }
   }
 
@@ -532,7 +532,7 @@ public void oneDeclared() throws SomeCheckedException {
       sample.oneDeclared();
       fail();
     } catch (RuntimeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(SomeOtherCheckedException.class);
     }
   }
 
@@ -684,15 +684,15 @@ public void testGetCauseAs() {
     SomeCheckedException cause = new SomeCheckedException();
     SomeChainingException thrown = new SomeChainingException(cause);
 
-    assertThat(thrown.getCause()).isSameAs(cause);
+    assertThat(thrown).hasCauseThat().isSameAs(cause);
     assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause);
     assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);
 
     try {
       Throwables.getCauseAs(thrown, IllegalStateException.class);
       fail(""Should have thrown CCE"");
     } catch (ClassCastException expected) {
-      assertThat(expected.getCause()).isSameAs(thrown);
+      assertThat(expected).hasCauseThat().isSameAs(thrown);
     }
   }
 , @@ -121,7 +121,9 @@ private static void testEncodedLengthFails(String invalidString, int invalidCode
       Utf8.encodedLength(invalidString);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Unpaired surrogate at index "" + invalidCodePointIndex);
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""Unpaired surrogate at index "" + invalidCodePointIndex);
     }
   }
 , @@ -46,7 +46,7 @@ public void testVerify_simpleMessage_failure() {
       verify(false, ""message"");
       fail();
     } catch (VerifyException expected) {
-      assertThat(expected).hasMessage(""message"");
+      assertThat(expected).hasMessageThat().isEqualTo(""message"");
     }
   }
 
@@ -103,6 +103,6 @@ public String toString() {
   private static final String FORMAT = ""I ate %s pies."";
 
   private static void checkMessage(Exception e) {
-    assertThat(e).hasMessage(""I ate 5 pies."");
+    assertThat(e).hasMessageThat().isEqualTo(""I ate 5 pies."");
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.util.concurrent.ExecutionError;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import java.util.concurrent.ExecutionException;
@@ -53,7 +55,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -85,7 +87,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -117,7 +119,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -149,7 +151,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();, @@ -87,11 +87,11 @@ private Throwable popLoggedThrowable() {
   }
 
   private void checkNothingLogged() {
-    assertTrue(logHandler.getStoredLogRecords().isEmpty());
+    assertThat(logHandler.getStoredLogRecords()).isEmpty();
   }
 
   private void checkLoggedCause(Throwable t) {
-    assertSame(t, popLoggedThrowable().getCause());
+    assertThat(popLoggedThrowable()).hasCauseThat().isSameAs(t);
   }
 
   private void checkLoggedInvalidLoad() {
@@ -889,7 +889,7 @@ public void testLoadError() throws ExecutionException {
       cache.get(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -901,7 +901,7 @@ public void testLoadError() throws ExecutionException {
       cache.getUnchecked(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -929,7 +929,7 @@ public Object call() {
           });
       fail();
     } catch (ExecutionError expected) {
-      assertSame(callableError, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableError);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -941,7 +941,7 @@ public Object call() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1122,7 +1122,7 @@ public void testBulkLoadError() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1145,7 +1145,7 @@ public void testLoadCheckedException() {
       cache.get(new Object());
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1157,7 +1157,7 @@ public void testLoadCheckedException() {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -1178,7 +1178,7 @@ public void testLoadCheckedException() {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -1190,7 +1190,7 @@ public void testLoadCheckedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1216,7 +1216,7 @@ public void testLoadInterruptedException() {
       cache.get(new Object());
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1229,7 +1229,7 @@ public void testLoadInterruptedException() {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1252,7 +1252,7 @@ public void testLoadInterruptedException() {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1265,7 +1265,7 @@ public void testLoadInterruptedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1447,7 +1447,7 @@ public void testBulkLoadCheckedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1471,7 +1471,7 @@ public void testBulkLoadInterruptedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1495,7 +1495,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.get(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1507,7 +1507,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -1528,7 +1528,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -1540,7 +1540,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1721,7 +1721,7 @@ public void testBulkLoadUncheckedException() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1752,7 +1752,7 @@ public String load(Integer key) throws Exception {
       cache.getUnchecked(1);
       fail();
     } catch (UncheckedExecutionException ue) {
-      assertSame(e, ue.getCause());
+      assertThat(ue).hasCauseThat().isSameAs(e);
     }
 
     assertEquals(""1"", cache.getUnchecked(1));
@@ -1866,14 +1866,14 @@ public void testLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheUnchecked.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException caughtUee) {
-      assertSame(uee, caughtUee.getCause());
+      assertThat(caughtUee).hasCauseThat().isSameAs(uee);
     }
 
     cacheUnchecked.refresh(new Object());
@@ -1885,21 +1885,21 @@ public void testLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheChecked.get(new Object());
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
 
     try {
       cacheChecked.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException caughtUee) {
-      assertSame(ee, caughtUee.getCause());
+      assertThat(caughtUee).hasCauseThat().isSameAs(ee);
     }
 
     cacheChecked.refresh(new Object());
@@ -1909,7 +1909,7 @@ public void testLoadingExceptionWithCause() {
       cacheChecked.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
   }
 
@@ -1929,14 +1929,14 @@ public void testBulkLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheChecked.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
   }
 
@@ -2057,7 +2057,7 @@ public String load(String key) throws InterruptedException {
       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
       assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
-      assertSame(e, ((UncheckedExecutionException) result.get(i)).getCause());
+      assertThat(((UncheckedExecutionException) result.get(i))).hasCauseThat().isSameAs(e);
     }
 
     // subsequent calls should call the loader again, not get the old exception
@@ -2103,10 +2103,10 @@ public String load(String key) throws IOException, InterruptedException {
       int mod = i % 3;
       if (mod == 0 || mod == 2) {
         assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
-        assertSame(e, ((ExecutionException) result.get(i)).getCause());
+        assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameAs(e);
       } else {
         assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
-        assertSame(e, ((UncheckedExecutionException) result.get(i)).getCause());
+        assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameAs(e);
       }
     }
 , @@ -18,6 +18,7 @@
 import static com.google.common.cache.TestingCacheLoaders.constantLoader;
 import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
 import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
@@ -122,7 +123,7 @@ public void testGet_runtimeException() {
       map.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException uee) {
-      assertSame(e, uee.getCause());
+      assertThat(uee).hasCauseThat().isSameAs(e);
     }
     assertTrue(listener.isEmpty());
     checkEmpty(map);, @@ -427,13 +427,13 @@ public void testPutIllegal() {
       table.put(""dog"", 1, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Row dog not in [foo, bar, cat]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Row dog not in [foo, bar, cat]"");
     }
     try {
       table.put(""foo"", 4, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Column 4 not in [1, 2, 3]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Column 4 not in [1, 2, 3]"");
     }
     assertFalse(table.containsValue('d'));
   }
@@ -504,7 +504,7 @@ public void testRowPutIllegal() {
       map.put(4, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Column 4 not in [1, 2, 3]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Column 4 not in [1, 2, 3]"");
     }
   }
 
@@ -515,7 +515,7 @@ public void testColumnPutIllegal() {
       map.put(""dog"", 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Row dog not in [foo, bar, cat]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Row dog not in [foo, bar, cat]"");
     }
   }
 , @@ -194,7 +194,7 @@ public void testGetOnlyElement_noDefault_moreThanOneLessThanFiveElements() {
       Iterators.getOnlyElement(iterator);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""expected one element but was: <one, two>"");
+      assertThat(expected).hasMessageThat().isEqualTo(""expected one element but was: <one, two>"");
     }
   }
 
@@ -205,7 +205,8 @@ public void testGetOnlyElement_noDefault_fiveElements() {
       fail();
     } catch (IllegalArgumentException expected) {
       assertThat(expected)
-          .hasMessage(""expected one element but was: <one, two, three, four, five>"");
+          .hasMessageThat()
+          .isEqualTo(""expected one element but was: <one, two, three, four, five>"");
     }
   }
 
@@ -216,7 +217,8 @@ public void testGetOnlyElement_noDefault_moreThanFiveElements() {
       fail();
     } catch (IllegalArgumentException expected) {
       assertThat(expected)
-          .hasMessage(""expected one element but was: <one, two, three, four, five, ...>"");
+          .hasMessageThat()
+          .isEqualTo(""expected one element but was: <one, two, three, four, five, ...>"");
     }
   }
 
@@ -241,7 +243,7 @@ public void testGetOnlyElement_withDefault_two() {
       Iterators.getOnlyElement(iterator, ""x"");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""expected one element but was: <foo, bar>"");
+      assertThat(expected).hasMessageThat().isEqualTo(""expected one element but was: <foo, bar>"");
     }
   }
 , @@ -73,7 +73,7 @@ public void testInvokeSubscriberMethod_exceptionWrapping() throws Throwable {
       subscriber.invokeSubscriberMethod(FIXTURE_ARGUMENT);
       fail(""Subscribers whose methods throw must throw InvocationTargetException"");
     } catch (InvocationTargetException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IntentionalException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(IntentionalException.class);
     }
   }
 , @@ -60,7 +60,9 @@ public void testNulls() throws Exception {
       super.testNulls();
     } catch (AssertionFailedError e) {
       assertWithMessage(""Method did not throw null pointer OR element not in graph exception."")
-          .that(e.getCause().getMessage())
+          .that(e)
+          .hasCauseThat()
+          .hasMessageThat()
           .contains(ERROR_ELEMENT_NOT_IN_GRAPH);
     }
   }, @@ -294,7 +294,9 @@ public void testOptimalSize() {
           BloomFilter.create(HashTestUtils.BAD_FUNNEL, Integer.MAX_VALUE, Double.MIN_VALUE);
       fail(""we can't represent such a large BF!"");
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Could not create BloomFilter of 3327428144502 bits"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""Could not create BloomFilter of 3327428144502 bits"");
     }
   }
 , @@ -395,15 +395,15 @@ private static void assertFailsToDecode(
       fail(""Expected IllegalArgumentException"");
     } catch (IllegalArgumentException expected) {
       if (expectedMessage != null) {
-        assertThat(expected.getCause()).hasMessage(expectedMessage);
+        assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(expectedMessage);
       }
     }
     try {
       encoding.decodeChecked(cannotDecode);
       fail(""Expected DecodingException"");
     } catch (DecodingException expected) {
       if (expectedMessage != null) {
-        assertThat(expected).hasMessage(expectedMessage);
+        assertThat(expected).hasMessageThat().isEqualTo(expectedMessage);
       }
     }
   }, @@ -193,7 +193,7 @@ public void testNewDataInput_readFullyAndThenSome() {
       in.readFully(actual);
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -275,7 +275,7 @@ public void testNewDataInput_readByte() {
       in.readByte();
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -288,7 +288,7 @@ public void testNewDataInput_readUnsignedByte() {
       in.readUnsignedByte();
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -650,7 +650,7 @@ public void testLimit_markNotSet() {
       lin.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not set"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not set"");
     }
   }
 
@@ -661,7 +661,7 @@ public void testLimit_markNotSupported() {
       lin.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not supported"");
     }
   }
 , @@ -94,7 +94,7 @@ public void testMarkNotSet() {
       counter.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not set"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not set"");
     }
   }
 
@@ -105,7 +105,7 @@ public void testMarkNotSupported() {
       counter.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not supported"");
     }
   }
 , @@ -98,7 +98,7 @@ public void testReadLine() throws IOException {
       in.readLine();
       fail();
     } catch (UnsupportedOperationException expected) {
-      assertThat(expected).hasMessage(""readLine is not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""readLine is not supported"");
     }
   }
 , @@ -109,7 +109,7 @@ public void testGetResource_notFound() {
       Resources.getResource(""no such resource"");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""resource no such resource not found."");
+      assertThat(e).hasMessageThat().isEqualTo(""resource no such resource not found."");
     }
   }
 
@@ -123,7 +123,8 @@ public void testGetResource_relativePath_notFound() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""resource com/google/common/io/testdata/i18n.txt""
                   + "" relative to com.google.common.io.ResourcesTest not found."");
     }, @@ -108,7 +108,7 @@ private void assertBad(String spec) {
       HostSpecifier.from(spec);
       fail(""Should have thrown ParseException: "" + spec);
     } catch (ParseException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IllegalArgumentException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
     }
 
     assertFalse(HostSpecifier.isValid(spec));, @@ -116,7 +116,7 @@ public void testBadArguments_badchars() {
       new PercentEscaper(""-+#abc.!"", false);
       fail(msg);
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(msg);
+      assertThat(expected).hasMessageThat().isEqualTo(msg);
     }
   }
 
@@ -135,7 +135,7 @@ public void testBadArguments_plusforspace() {
       new PercentEscaper("" "", true);
       fail(msg);
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(msg);
+      assertThat(expected).hasMessageThat().isEqualTo(msg);
     }
   }
 , @@ -469,7 +469,7 @@ private static void assertFailed(AbstractFuture<Integer> future, Throwable expec
       getDoneFromTimeoutOverload(future);
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(expectedException);
+      assertThat(e).hasCauseThat().isSameAs(expectedException);
     }
   }
 , @@ -179,13 +179,13 @@ public void testServiceThrowOnStartUp() throws Exception {
       service.awaitRunning();
       fail();
     } catch (IllegalStateException expected) {
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
     executionThread.join();
 
     assertTrue(service.startUpCalled);
     assertEquals(Service.State.FAILED, service.state());
-    assertThat(service.failureCause()).hasMessage(""kaboom!"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""kaboom!"");
   }
 
   private class ThrowOnStartUpService extends AbstractExecutionThreadService {
@@ -217,8 +217,8 @@ public void testServiceThrowOnRun() throws Exception {
       fail();
     } catch (IllegalStateException expected) {
       executionThread.join();
-      assertEquals(service.failureCause(), expected.getCause());
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().isEqualTo(service.failureCause());
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
     assertTrue(service.shutDownCalled);
     assertEquals(Service.State.FAILED, service.state());
@@ -234,8 +234,8 @@ public void testServiceThrowOnRunAndThenAgainOnShutDown() throws Exception {
       fail();
     } catch (IllegalStateException expected) {
       executionThread.join();
-      assertEquals(service.failureCause(), expected.getCause());
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().isEqualTo(service.failureCause());
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
 
     assertTrue(service.shutDownCalled);
@@ -276,7 +276,7 @@ public void testServiceThrowOnShutDown() throws Exception {
     executionThread.join();
 
     assertEquals(Service.State.FAILED, service.state());
-    assertThat(service.failureCause()).hasMessage(""kaboom!"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""kaboom!"");
   }
 
   private class ThrowOnShutDown extends AbstractExecutionThreadService {
@@ -381,7 +381,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -78,8 +78,8 @@ public void testException() throws InterruptedException {
     // Ensure we get a unique execution exception on each get
     assertNotSame(ee1, ee2);
 
-    assertSame(failure, ee1.getCause());
-    assertSame(failure, ee2.getCause());
+    assertThat(ee1).hasCauseThat().isSameAs(failure);
+    assertThat(ee2).hasCauseThat().isSameAs(failure);
 
     checkStackTrace(ee1);
     checkStackTrace(ee2);
@@ -97,7 +97,7 @@ public void testCancel_notDoneNoInterrupt() throws Exception {
       fail(""Expected CancellationException"");
     } catch (CancellationException e) {
       // See AbstractFutureCancellationCauseTest for how to set causes
-      assertNull(e.getCause());
+      assertThat(e).hasCauseThat().isNull();
     }
   }
 
@@ -113,7 +113,7 @@ public void testCancel_notDoneInterrupt() throws Exception {
       fail(""Expected CancellationException"");
     } catch (CancellationException e) {
       // See AbstractFutureCancellationCauseTest for how to set causes
-      assertNull(e.getCause());
+      assertThat(e).hasCauseThat().isNull();
     }
   }
 
@@ -155,7 +155,7 @@ public void addListener(Runnable r, Executor e) {
       normalFuture.get();
       fail();
     } catch (ExecutionException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
   }
 , @@ -68,7 +68,7 @@ protected void startUp() throws Exception {
         service.startAsync().awaitRunning();
         fail();
       } catch (RuntimeException e) {
-        assertSame(exception, e.getCause());
+        assertThat(e).hasCauseThat().isSameAs(exception);
       }
       assertEquals(Service.State.FAILED, service.state());
     }
@@ -87,7 +87,7 @@ protected void shutDown() throws Exception {
         service.stopAsync().awaitTerminated();
         fail();
       } catch (RuntimeException e) {
-        assertSame(exception, e.getCause());
+        assertThat(e).hasCauseThat().isSameAs(exception);
       }
       assertEquals(Service.State.FAILED, service.state());
     }
@@ -117,7 +117,7 @@ protected void startUp() throws Exception {
       service.startAsync().awaitRunning();
       fail();
     } catch (RuntimeException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
     assertEquals(1, service.startUpCalled);
     assertEquals(Service.State.FAILED, service.state());
@@ -164,7 +164,7 @@ protected void shutDown() throws Exception {
       service.stopAsync().awaitTerminated();
       fail();
     } catch (RuntimeException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
     assertEquals(1, service.startUpCalled);
     assertEquals(1, service.shutDownCalled);
@@ -204,7 +204,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -295,7 +295,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -371,7 +371,7 @@ public void run() {
     waiter.join(LONG_TIMEOUT_MILLIS);
     assertFalse(waiter.isAlive());
     assertThat(exception.get()).isInstanceOf(IllegalStateException.class);
-    assertEquals(EXCEPTION, exception.get().getCause());
+    assertThat(exception.get()).hasCauseThat().isEqualTo(EXCEPTION);
   }
 
   public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
@@ -448,12 +448,12 @@ public void testManualServiceFailureIdempotence() {
     service.startAsync();
     service.notifyFailed(new Exception(""1""));
     service.notifyFailed(new Exception(""2""));
-    assertThat(service.failureCause()).hasMessage(""1"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""1"");
     try {
       service.awaitRunning();
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getCause()).hasMessage(""1"");
+      assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(""1"");
     }
   }
 
@@ -548,7 +548,7 @@ public void testFailingServiceStartAndWait() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
   }
@@ -563,7 +563,7 @@ public void testFailingServiceStopAndWait_stopFailing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
@@ -580,7 +580,7 @@ public void testFailingServiceStopAndWait_runFailing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
@@ -595,7 +595,7 @@ public void testThrowingServiceStartAndWait() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
   }
@@ -610,7 +610,7 @@ public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
@@ -627,7 +627,7 @@ public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
@@ -651,7 +651,7 @@ public void testFailureCause_throwsIfNotFailed() {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
   }
 
@@ -858,11 +858,10 @@ public synchronized void stopping(State from) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException expected) {
-          assertNull(expected.getCause());
-          assertTrue(
-              expected
-                  .getMessage()
-                  .equals(""Expected the service "" + service + "" to be RUNNING, but was STOPPING""));
+          assertThat(expected).hasCauseThat().isNull();
+          assertThat(expected)
+              .hasMessageThat()
+              .isEqualTo(""Expected the service "" + service + "" to be RUNNING, but was STOPPING"");
         }
       }
       assertNotSame(from, service.state());
@@ -878,12 +877,10 @@ public synchronized void terminated(State from) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException expected) {
-          assertNull(expected.getCause());
-          assertTrue(
-              expected
-                  .getMessage()
-                  .equals(
-                      ""Expected the service "" + service + "" to be RUNNING, but was TERMINATED""));
+          assertThat(expected).hasCauseThat().isNull();
+          assertThat(expected)
+              .hasMessageThat()
+              .isEqualTo(""Expected the service "" + service + "" to be RUNNING, but was TERMINATED"");
         }
       }
       completionLatch.countDown();
@@ -900,14 +897,14 @@ public synchronized void failed(State from, Throwable failure) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException e) {
-          assertEquals(failure, e.getCause());
+          assertThat(e).hasCauseThat().isEqualTo(failure);
         }
       }
       try {
         service.awaitTerminated();
         fail();
       } catch (IllegalStateException e) {
-        assertEquals(failure, e.getCause());
+        assertThat(e).hasCauseThat().isEqualTo(failure);
       }
       completionLatch.countDown();
     }, @@ -16,6 +16,8 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
@@ -80,7 +82,7 @@ public String call() throws Exception {
       future.get();
       fail(""Expected exception to be thrown"");
     } catch (ExecutionException e) {
-      assertSame(expected, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(expected);
     }
   }
 , @@ -137,7 +137,7 @@ public void testWithTimeout() throws Exception {
         f.get();
         fail();
       } catch (ExecutionException e) {
-        assertThat(e.getCause()).isInstanceOf(TimeoutException.class);
+        assertThat(e).hasCauseThat().isInstanceOf(TimeoutException.class);
       }
     } finally {
       executor.shutdown();, @@ -64,7 +64,7 @@ public void testGetCheckedUntimed_interrupted() {
       getChecked(future, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(InterruptedException.class);
       assertTrue(Thread.currentThread().isInterrupted());
     } finally {
       Thread.interrupted();
@@ -86,7 +86,7 @@ public void testGetCheckedUntimed_ExecutionExceptionChecked() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 
@@ -96,7 +96,7 @@ public void testGetCheckedUntimed_ExecutionExceptionUnchecked()
       getChecked(FAILED_FUTURE_UNCHECKED_EXCEPTION, TwoArgConstructorException.class);
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(UNCHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(UNCHECKED_EXCEPTION);
     }
   }
 
@@ -105,7 +105,7 @@ public void testGetCheckedUntimed_ExecutionExceptionError() throws TwoArgConstru
       getChecked(FAILED_FUTURE_ERROR, TwoArgConstructorException.class);
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(ERROR, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(ERROR);
     }
   }
 
@@ -114,7 +114,7 @@ public void testGetCheckedUntimed_ExecutionExceptionOtherThrowable() {
       getChecked(FAILED_FUTURE_OTHER_THROWABLE, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(OTHER_THROWABLE, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(OTHER_THROWABLE);
     }
   }
 
@@ -160,7 +160,7 @@ public void testGetCheckedUntimed_withGoodAndBadExceptionConstructor() throws Ex
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, ExceptionWithGoodAndBadConstructor.class);
       fail();
     } catch (ExceptionWithGoodAndBadConstructor expected) {
-      assertSame(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(CHECKED_EXCEPTION);
     }
   }
 
@@ -178,7 +178,7 @@ public void testGetCheckedTimed_interrupted() {
       getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(InterruptedException.class);
       assertTrue(Thread.currentThread().isInterrupted());
     } finally {
       Thread.interrupted();
@@ -200,7 +200,7 @@ public void testGetCheckedTimed_ExecutionExceptionChecked() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 
@@ -209,7 +209,7 @@ public void testGetCheckedTimed_ExecutionExceptionUnchecked() throws TwoArgConst
       getChecked(FAILED_FUTURE_UNCHECKED_EXCEPTION, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(UNCHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(UNCHECKED_EXCEPTION);
     }
   }
 
@@ -218,7 +218,7 @@ public void testGetCheckedTimed_ExecutionExceptionError() throws TwoArgConstruct
       getChecked(FAILED_FUTURE_ERROR, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(ERROR, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(ERROR);
     }
   }
 
@@ -227,7 +227,7 @@ public void testGetCheckedTimed_ExecutionExceptionOtherThrowable() {
       getChecked(FAILED_FUTURE_OTHER_THROWABLE, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(OTHER_THROWABLE, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(OTHER_THROWABLE);
     }
   }
 
@@ -256,7 +256,7 @@ public void testGetCheckedTimed_TimeoutException() {
       getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(TimeoutException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(TimeoutException.class);
     }
   }
 
@@ -278,7 +278,7 @@ public void testGetCheckedTimed_badExceptionConstructor_wrapsOriginalChecked() t
     }
   }
 
-  public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() throws Exception {
+  public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() {
     try {
       getChecked(
           FAILED_FUTURE_CHECKED_EXCEPTION,
@@ -287,7 +287,7 @@ public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() throws Exce
           TimeUnit.SECONDS);
       fail();
     } catch (ExceptionWithGoodAndBadConstructor expected) {
-      assertSame(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(CHECKED_EXCEPTION);
     }
   }
 
@@ -344,8 +344,8 @@ public void testGetCheckedUntimed_exceptionClassUsedInitCause() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, ExceptionWithoutThrowableConstructor.class);
       fail();
     } catch (ExceptionWithoutThrowableConstructor expected) {
-      assertThat(expected.getMessage()).contains(""mymessage"");
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasMessageThat().contains(""mymessage"");
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 , @@ -42,7 +42,7 @@ public void testFailed() {
       getDone(immediateFailedFuture(failureCause));
       fail();
     } catch (ExecutionException expected) {
-      assertThat(expected.getCause()).isEqualTo(failureCause);
+      assertThat(expected).hasCauseThat().isEqualTo(failureCause);
     }
   }
 , @@ -3813,7 +3813,7 @@ public void testCompletionOrderExceptionThrown() throws Exception {
           getDone(future);
           fail();
         } catch (ExecutionException expected) {
-          assertThat(expected.getCause()).hasMessage(""2L"");
+          assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""2L"");
         }
       }
       expectedResult++;, @@ -106,7 +106,7 @@ public void testFailedFuture(@NullableDecl String message) throws InterruptedExc
       future.get();
       fail(""Future should rethrow the exception."");
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).hasMessage(message);
+      assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(message);
     }
   }
 }, @@ -467,7 +467,7 @@ private static void assertExecutionException(Future<?> future, Exception expecte
       future.get();
       fail(""Expected ExecutionException"");
     } catch (ExecutionException e) {
-      assertSame(expectedCause, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(expectedCause);
     }
   }
 
@@ -525,7 +525,7 @@ public void testInvokeAnyImpl_noTaskCompletes() throws Exception {
       invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);
       fail();
     } catch (ExecutionException success) {
-      assertThat(success.getCause()).isInstanceOf(NullPointerException.class);
+      assertThat(success).hasCauseThat().isInstanceOf(NullPointerException.class);
     } finally {
       joinPool(e);
     }, @@ -16,6 +16,8 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -110,7 +112,7 @@ public void testSetException() throws Exception {
       future.get();
       fail(""Expected ExecutionException"");
     } catch (ExecutionException ee) {
-      assertSame(e, ee.getCause());
+      assertThat(ee).hasCauseThat().isSameAs(e);
     }
   }
 , @@ -79,7 +79,7 @@ public Integer call() throws Exception {
       getDone(task);
       fail();
     } catch (ExecutionException executionException) {
-      assertEquals(e, executionException.getCause());
+      assertThat(executionException).hasCauseThat().isEqualTo(e);
     }
   }
 , @@ -33,7 +33,7 @@ static void verifyGetOnPendingFuture(Future<?> future) {
       fail();
     } catch (Exception e) {
       assertThat(e).isInstanceOf(IllegalStateException.class);
-      assertThat(e).hasMessage(""Cannot get() on a pending future."");
+      assertThat(e).hasMessageThat().isEqualTo(""Cannot get() on a pending future."");
     }
   }
 
@@ -43,7 +43,7 @@ static void verifyTimedGetOnPendingFuture(Future<?> future) {
       fail();
     } catch (Exception e) {
       assertThat(e).isInstanceOf(IllegalStateException.class);
-      assertThat(e).hasMessage(""Cannot get() on a pending future."");
+      assertThat(e).hasMessageThat().isEqualTo(""Cannot get() on a pending future."");
     }
   }
 , @@ -86,7 +86,8 @@ public void testForAllPublicStaticMethods_noPublicStaticMethods() throws Excepti
       tester.forAllPublicStaticMethods(NoPublicStaticMethods.class).testEquals();
     } catch (AssertionFailedError expected) {
       assertThat(expected)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""No public static methods that return java.lang.Object or subtype are found in ""
                   + NoPublicStaticMethods.class
                   + ""."");
@@ -140,7 +141,8 @@ public void testNullsOnReturnValues_returnTypeFiltered() throws Exception {
           .testNulls();
     } catch (AssertionFailedError expected) {
       assertThat(expected)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""No public static methods that return java.lang.Iterable or subtype are found in ""
                   + BadNullsFactory.class
                   + ""."");, @@ -136,8 +136,8 @@ void shutdown() {
   }
 
   void assertWrapsInterruptedException(RuntimeException e) {
-    assertThat(e.getMessage()).contains(""Unexpected interrupt"");
-    assertThat(e.getCause()).isInstanceOf(InterruptedException.class);
+    assertThat(e).hasMessageThat().contains(""Unexpected interrupt"");
+    assertThat(e).hasCauseThat().isInstanceOf(InterruptedException.class);
   }
 
   public void testAwait_CountDownLatch_Interrupted() {, @@ -83,7 +83,7 @@ public void testThrowingTearDown() throws Exception {
       stack.runTearDown();
       fail(""runTearDown should have thrown an exception"");
     } catch (ClusterException expected) {
-      assertThat(expected.getCause()).hasMessage(""two"");
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""two"");
     } catch (RuntimeException e) {
       throw new RuntimeException(
           ""A ClusterException should have been thrown, rather than a "" + e.getClass().getName(), e);, @@ -71,7 +71,7 @@ public void testCheckArgument_nullMessage_failure() {
       Preconditions.checkArgument(false, null);
       fail(""no exception thrown"");
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""null"");
+      assertThat(expected).hasMessageThat().isEqualTo(""null"");
     }
   }
 
@@ -172,7 +172,7 @@ public void testCheckState_nullMessage_failure() {
       Preconditions.checkState(false, null);
       fail(""no exception thrown"");
     } catch (IllegalStateException expected) {
-      assertThat(expected).hasMessage(""null"");
+      assertThat(expected).hasMessageThat().isEqualTo(""null"");
     }
   }
 
@@ -253,7 +253,7 @@ public void testCheckElementIndex_negative() {
       Preconditions.checkElementIndex(-1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (-1) must not be negative"");
     }
   }
 
@@ -262,7 +262,7 @@ public void testCheckElementIndex_tooHigh() {
       Preconditions.checkElementIndex(1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (1) must be less than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (1) must be less than size (1)"");
     }
   }
 
@@ -271,7 +271,7 @@ public void testCheckElementIndex_withDesc_negative() {
       Preconditions.checkElementIndex(-1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (-1) must not be negative"");
     }
   }
 
@@ -280,7 +280,7 @@ public void testCheckElementIndex_withDesc_tooHigh() {
       Preconditions.checkElementIndex(1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (1) must be less than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (1) must be less than size (1)"");
     }
   }
 
@@ -305,7 +305,7 @@ public void testCheckPositionIndex_negative() {
       Preconditions.checkPositionIndex(-1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""index (-1) must not be negative"");
     }
   }
 
@@ -314,7 +314,9 @@ public void testCheckPositionIndex_tooHigh() {
       Preconditions.checkPositionIndex(2, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""index (2) must not be greater than size (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""index (2) must not be greater than size (1)"");
     }
   }
 
@@ -323,7 +325,7 @@ public void testCheckPositionIndex_withDesc_negative() {
       Preconditions.checkPositionIndex(-1, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (-1) must not be negative"");
     }
   }
 
@@ -332,7 +334,7 @@ public void testCheckPositionIndex_withDesc_tooHigh() {
       Preconditions.checkPositionIndex(2, 1, ""foo"");
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""foo (2) must not be greater than size (1)"");
+      assertThat(expected).hasMessageThat().isEqualTo(""foo (2) must not be greater than size (1)"");
     }
   }
 
@@ -356,7 +358,7 @@ public void testCheckPositionIndex_startNegative() {
       Preconditions.checkPositionIndexes(-1, 1, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""start index (-1) must not be negative"");
+      assertThat(expected).hasMessageThat().isEqualTo(""start index (-1) must not be negative"");
     }
   }
 
@@ -365,7 +367,9 @@ public void testCheckPositionIndexes_endTooHigh() {
       Preconditions.checkPositionIndexes(0, 2, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""end index (2) must not be greater than size (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""end index (2) must not be greater than size (1)"");
     }
   }
 
@@ -374,7 +378,9 @@ public void testCheckPositionIndexes_reversed() {
       Preconditions.checkPositionIndexes(1, 0, 1);
       fail();
     } catch (IndexOutOfBoundsException expected) {
-      assertThat(expected).hasMessage(""end index (0) must not be less than start index (1)"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""end index (0) must not be less than start index (1)"");
     }
   }
 
@@ -438,12 +444,13 @@ private void assertFailureCause(
       Throwable throwable, Class<? extends Throwable> clazz, Object[] params) {
     assertThat(throwable).isInstanceOf(clazz);
     if (params.length == 1) {
-      assertThat(throwable).hasMessage(null);
+      assertThat(throwable).hasMessageThat().isNull();
     } else if (params.length == 2) {
-      assertThat(throwable).hasMessage("""");
+      assertThat(throwable).hasMessageThat().isEmpty();
     } else {
       assertThat(throwable)
-          .hasMessage(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
+          .hasMessageThat()
+          .isEqualTo(Strings.lenientFormat("""", Arrays.copyOfRange(params, 2, params.length)));
     }
   }
 
@@ -558,10 +565,10 @@ public String toString() {
   private static final String FORMAT = ""I ate %s pies."";
 
   private static void verifySimpleMessage(Exception e) {
-    assertThat(e).hasMessage(""A message"");
+    assertThat(e).hasMessageThat().isEqualTo(""A message"");
   }
 
   private static void verifyComplexMessage(Exception e) {
-    assertThat(e).hasMessage(""I ate 5 pies."");
+    assertThat(e).hasMessageThat().isEqualTo(""I ate 5 pies."");
   }
 }, @@ -142,7 +142,7 @@ public void testMemoizeNonSerializable() throws Exception {
       reserialize(memoizedSupplier);
       fail();
     } catch (RuntimeException ex) {
-      assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass());
+      assertThat(ex).hasCauseThat().isInstanceOf(java.io.NotSerializableException.class);
     }
   }
 , @@ -415,7 +415,7 @@ public void noneDeclared() {
       sample.noneDeclared();
       fail();
     } catch (RuntimeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(SomeCheckedException.class);
     }
   }
 
@@ -532,7 +532,7 @@ public void oneDeclared() throws SomeCheckedException {
       sample.oneDeclared();
       fail();
     } catch (RuntimeException expected) {
-      assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(SomeOtherCheckedException.class);
     }
   }
 
@@ -684,15 +684,15 @@ public void testGetCauseAs() {
     SomeCheckedException cause = new SomeCheckedException();
     SomeChainingException thrown = new SomeChainingException(cause);
 
-    assertThat(thrown.getCause()).isSameAs(cause);
+    assertThat(thrown).hasCauseThat().isSameAs(cause);
     assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause);
     assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);
 
     try {
       Throwables.getCauseAs(thrown, IllegalStateException.class);
       fail(""Should have thrown CCE"");
     } catch (ClassCastException expected) {
-      assertThat(expected.getCause()).isSameAs(thrown);
+      assertThat(expected).hasCauseThat().isSameAs(thrown);
     }
   }
 , @@ -121,7 +121,9 @@ private static void testEncodedLengthFails(String invalidString, int invalidCode
       Utf8.encodedLength(invalidString);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Unpaired surrogate at index "" + invalidCodePointIndex);
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""Unpaired surrogate at index "" + invalidCodePointIndex);
     }
   }
 , @@ -46,7 +46,7 @@ public void testVerify_simpleMessage_failure() {
       verify(false, ""message"");
       fail();
     } catch (VerifyException expected) {
-      assertThat(expected).hasMessage(""message"");
+      assertThat(expected).hasMessageThat().isEqualTo(""message"");
     }
   }
 
@@ -103,6 +103,6 @@ public String toString() {
   private static final String FORMAT = ""I ate %s pies."";
 
   private static void checkMessage(Exception e) {
-    assertThat(e).hasMessage(""I ate 5 pies."");
+    assertThat(e).hasMessageThat().isEqualTo(""I ate 5 pies."");
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.util.concurrent.ExecutionError;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import java.util.concurrent.ExecutionException;
@@ -53,7 +55,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -85,7 +87,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -117,7 +119,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();
@@ -149,7 +151,7 @@ public Object getIfPresent(Object key) {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(cause, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(cause);
     }
 
     Object newValue = new Object();, @@ -87,11 +87,11 @@ private Throwable popLoggedThrowable() {
   }
 
   private void checkNothingLogged() {
-    assertTrue(logHandler.getStoredLogRecords().isEmpty());
+    assertThat(logHandler.getStoredLogRecords()).isEmpty();
   }
 
   private void checkLoggedCause(Throwable t) {
-    assertSame(t, popLoggedThrowable().getCause());
+    assertThat(popLoggedThrowable()).hasCauseThat().isSameAs(t);
   }
 
   private void checkLoggedInvalidLoad() {
@@ -889,7 +889,7 @@ public void testLoadError() throws ExecutionException {
       cache.get(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -901,7 +901,7 @@ public void testLoadError() throws ExecutionException {
       cache.getUnchecked(new Object());
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -929,7 +929,7 @@ public Object call() {
           });
       fail();
     } catch (ExecutionError expected) {
-      assertSame(callableError, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableError);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -941,7 +941,7 @@ public Object call() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1122,7 +1122,7 @@ public void testBulkLoadError() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionError expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1145,7 +1145,7 @@ public void testLoadCheckedException() {
       cache.get(new Object());
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1157,7 +1157,7 @@ public void testLoadCheckedException() {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -1178,7 +1178,7 @@ public void testLoadCheckedException() {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -1190,7 +1190,7 @@ public void testLoadCheckedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1216,7 +1216,7 @@ public void testLoadInterruptedException() {
       cache.get(new Object());
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1229,7 +1229,7 @@ public void testLoadInterruptedException() {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1252,7 +1252,7 @@ public void testLoadInterruptedException() {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1265,7 +1265,7 @@ public void testLoadInterruptedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1447,7 +1447,7 @@ public void testBulkLoadCheckedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1471,7 +1471,7 @@ public void testBulkLoadInterruptedException() {
       cache.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     assertTrue(currentThread().interrupted());
     stats = cache.stats();
@@ -1495,7 +1495,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.get(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1507,7 +1507,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(2, stats.missCount());
@@ -1528,7 +1528,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.get(new Object(), throwing(callableException));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(callableException, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(callableException);
     }
     stats = cache.stats();
     assertEquals(3, stats.missCount());
@@ -1540,7 +1540,7 @@ public void testLoadUncheckedException() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(4, stats.missCount());
@@ -1721,7 +1721,7 @@ public void testBulkLoadUncheckedException() throws ExecutionException {
       cache.getAll(asList(new Object()));
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertSame(e, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(e);
     }
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1752,7 +1752,7 @@ public String load(Integer key) throws Exception {
       cache.getUnchecked(1);
       fail();
     } catch (UncheckedExecutionException ue) {
-      assertSame(e, ue.getCause());
+      assertThat(ue).hasCauseThat().isSameAs(e);
     }
 
     assertEquals(""1"", cache.getUnchecked(1));
@@ -1866,14 +1866,14 @@ public void testLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheUnchecked.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException caughtUee) {
-      assertSame(uee, caughtUee.getCause());
+      assertThat(caughtUee).hasCauseThat().isSameAs(uee);
     }
 
     cacheUnchecked.refresh(new Object());
@@ -1885,21 +1885,21 @@ public void testLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheChecked.get(new Object());
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
 
     try {
       cacheChecked.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException caughtUee) {
-      assertSame(ee, caughtUee.getCause());
+      assertThat(caughtUee).hasCauseThat().isSameAs(ee);
     }
 
     cacheChecked.refresh(new Object());
@@ -1909,7 +1909,7 @@ public void testLoadingExceptionWithCause() {
       cacheChecked.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
   }
 
@@ -1929,14 +1929,14 @@ public void testBulkLoadingExceptionWithCause() {
     } catch (ExecutionException e) {
       fail();
     } catch (UncheckedExecutionException caughtEe) {
-      assertSame(uee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(uee);
     }
 
     try {
       cacheChecked.getAll(asList(new Object()));
       fail();
     } catch (ExecutionException caughtEe) {
-      assertSame(ee, caughtEe.getCause());
+      assertThat(caughtEe).hasCauseThat().isSameAs(ee);
     }
   }
 
@@ -2057,7 +2057,7 @@ public String load(String key) throws InterruptedException {
       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
       assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
-      assertSame(e, ((UncheckedExecutionException) result.get(i)).getCause());
+      assertThat(((UncheckedExecutionException) result.get(i))).hasCauseThat().isSameAs(e);
     }
 
     // subsequent calls should call the loader again, not get the old exception
@@ -2103,10 +2103,10 @@ public String load(String key) throws IOException, InterruptedException {
       int mod = i % 3;
       if (mod == 0 || mod == 2) {
         assertThat(result.get(i)).isInstanceOf(ExecutionException.class);
-        assertSame(e, ((ExecutionException) result.get(i)).getCause());
+        assertThat((ExecutionException) result.get(i)).hasCauseThat().isSameAs(e);
       } else {
         assertThat(result.get(i)).isInstanceOf(UncheckedExecutionException.class);
-        assertSame(e, ((UncheckedExecutionException) result.get(i)).getCause());
+        assertThat((UncheckedExecutionException) result.get(i)).hasCauseThat().isSameAs(e);
       }
     }
 , @@ -18,6 +18,7 @@
 import static com.google.common.cache.TestingCacheLoaders.constantLoader;
 import static com.google.common.cache.TestingCacheLoaders.exceptionLoader;
 import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
@@ -122,7 +123,7 @@ public void testGet_runtimeException() {
       map.getUnchecked(new Object());
       fail();
     } catch (UncheckedExecutionException uee) {
-      assertSame(e, uee.getCause());
+      assertThat(uee).hasCauseThat().isSameAs(e);
     }
     assertTrue(listener.isEmpty());
     checkEmpty(map);, @@ -427,13 +427,13 @@ public void testPutIllegal() {
       table.put(""dog"", 1, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Row dog not in [foo, bar, cat]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Row dog not in [foo, bar, cat]"");
     }
     try {
       table.put(""foo"", 4, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Column 4 not in [1, 2, 3]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Column 4 not in [1, 2, 3]"");
     }
     assertFalse(table.containsValue('d'));
   }
@@ -504,7 +504,7 @@ public void testRowPutIllegal() {
       map.put(4, 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Column 4 not in [1, 2, 3]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Column 4 not in [1, 2, 3]"");
     }
   }
 
@@ -515,7 +515,7 @@ public void testColumnPutIllegal() {
       map.put(""dog"", 'd');
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Row dog not in [foo, bar, cat]"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Row dog not in [foo, bar, cat]"");
     }
   }
 , @@ -194,7 +194,7 @@ public void testGetOnlyElement_noDefault_moreThanOneLessThanFiveElements() {
       Iterators.getOnlyElement(iterator);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""expected one element but was: <one, two>"");
+      assertThat(expected).hasMessageThat().isEqualTo(""expected one element but was: <one, two>"");
     }
   }
 
@@ -205,7 +205,8 @@ public void testGetOnlyElement_noDefault_fiveElements() {
       fail();
     } catch (IllegalArgumentException expected) {
       assertThat(expected)
-          .hasMessage(""expected one element but was: <one, two, three, four, five>"");
+          .hasMessageThat()
+          .isEqualTo(""expected one element but was: <one, two, three, four, five>"");
     }
   }
 
@@ -216,7 +217,8 @@ public void testGetOnlyElement_noDefault_moreThanFiveElements() {
       fail();
     } catch (IllegalArgumentException expected) {
       assertThat(expected)
-          .hasMessage(""expected one element but was: <one, two, three, four, five, ...>"");
+          .hasMessageThat()
+          .isEqualTo(""expected one element but was: <one, two, three, four, five, ...>"");
     }
   }
 
@@ -241,7 +243,7 @@ public void testGetOnlyElement_withDefault_two() {
       Iterators.getOnlyElement(iterator, ""x"");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""expected one element but was: <foo, bar>"");
+      assertThat(expected).hasMessageThat().isEqualTo(""expected one element but was: <foo, bar>"");
     }
   }
 , @@ -73,7 +73,7 @@ public void testInvokeSubscriberMethod_exceptionWrapping() throws Throwable {
       subscriber.invokeSubscriberMethod(FIXTURE_ARGUMENT);
       fail(""Subscribers whose methods throw must throw InvocationTargetException"");
     } catch (InvocationTargetException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IntentionalException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(IntentionalException.class);
     }
   }
 , @@ -60,7 +60,9 @@ public void testNulls() throws Exception {
       super.testNulls();
     } catch (AssertionFailedError e) {
       assertWithMessage(""Method did not throw null pointer OR element not in graph exception."")
-          .that(e.getCause().getMessage())
+          .that(e)
+          .hasCauseThat()
+          .hasMessageThat()
           .contains(ERROR_ELEMENT_NOT_IN_GRAPH);
     }
   }, @@ -295,7 +295,9 @@ public void testOptimalSize() {
           BloomFilter.create(HashTestUtils.BAD_FUNNEL, Integer.MAX_VALUE, Double.MIN_VALUE);
       fail(""we can't represent such a large BF!"");
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(""Could not create BloomFilter of 3327428144502 bits"");
+      assertThat(expected)
+          .hasMessageThat()
+          .isEqualTo(""Could not create BloomFilter of 3327428144502 bits"");
     }
   }
 , @@ -395,15 +395,15 @@ private static void assertFailsToDecode(
       fail(""Expected IllegalArgumentException"");
     } catch (IllegalArgumentException expected) {
       if (expectedMessage != null) {
-        assertThat(expected.getCause()).hasMessage(expectedMessage);
+        assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(expectedMessage);
       }
     }
     try {
       encoding.decodeChecked(cannotDecode);
       fail(""Expected DecodingException"");
     } catch (DecodingException expected) {
       if (expectedMessage != null) {
-        assertThat(expected).hasMessage(expectedMessage);
+        assertThat(expected).hasMessageThat().isEqualTo(expectedMessage);
       }
     }
   }, @@ -193,7 +193,7 @@ public void testNewDataInput_readFullyAndThenSome() {
       in.readFully(actual);
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -275,7 +275,7 @@ public void testNewDataInput_readByte() {
       in.readByte();
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -288,7 +288,7 @@ public void testNewDataInput_readUnsignedByte() {
       in.readUnsignedByte();
       fail(""expected exception"");
     } catch (IllegalStateException ex) {
-      assertThat(ex.getCause()).isInstanceOf(EOFException.class);
+      assertThat(ex).hasCauseThat().isInstanceOf(EOFException.class);
     }
   }
 
@@ -650,7 +650,7 @@ public void testLimit_markNotSet() {
       lin.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not set"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not set"");
     }
   }
 
@@ -661,7 +661,7 @@ public void testLimit_markNotSupported() {
       lin.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not supported"");
     }
   }
 , @@ -94,7 +94,7 @@ public void testMarkNotSet() {
       counter.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not set"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not set"");
     }
   }
 
@@ -105,7 +105,7 @@ public void testMarkNotSupported() {
       counter.reset();
       fail();
     } catch (IOException expected) {
-      assertThat(expected).hasMessage(""Mark not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""Mark not supported"");
     }
   }
 , @@ -98,7 +98,7 @@ public void testReadLine() throws IOException {
       in.readLine();
       fail();
     } catch (UnsupportedOperationException expected) {
-      assertThat(expected).hasMessage(""readLine is not supported"");
+      assertThat(expected).hasMessageThat().isEqualTo(""readLine is not supported"");
     }
   }
 , @@ -109,7 +109,7 @@ public void testGetResource_notFound() {
       Resources.getResource(""no such resource"");
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(""resource no such resource not found."");
+      assertThat(e).hasMessageThat().isEqualTo(""resource no such resource not found."");
     }
   }
 
@@ -123,7 +123,8 @@ public void testGetResource_relativePath_notFound() {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e)
-          .hasMessage(
+          .hasMessageThat()
+          .isEqualTo(
               ""resource com/google/common/io/testdata/i18n.txt""
                   + "" relative to com.google.common.io.ResourcesTest not found."");
     }, @@ -108,7 +108,7 @@ private void assertBad(String spec) {
       HostSpecifier.from(spec);
       fail(""Should have thrown ParseException: "" + spec);
     } catch (ParseException expected) {
-      assertThat(expected.getCause()).isInstanceOf(IllegalArgumentException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(IllegalArgumentException.class);
     }
 
     assertFalse(HostSpecifier.isValid(spec));, @@ -116,7 +116,7 @@ public void testBadArguments_badchars() {
       new PercentEscaper(""-+#abc.!"", false);
       fail(msg);
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(msg);
+      assertThat(expected).hasMessageThat().isEqualTo(msg);
     }
   }
 
@@ -135,7 +135,7 @@ public void testBadArguments_plusforspace() {
       new PercentEscaper("" "", true);
       fail(msg);
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage(msg);
+      assertThat(expected).hasMessageThat().isEqualTo(msg);
     }
   }
 , @@ -469,7 +469,7 @@ private static void assertFailed(AbstractFuture<Integer> future, Throwable expec
       getDoneFromTimeoutOverload(future);
       fail();
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(expectedException);
+      assertThat(e).hasCauseThat().isSameAs(expectedException);
     }
   }
 , @@ -179,13 +179,13 @@ public void testServiceThrowOnStartUp() throws Exception {
       service.awaitRunning();
       fail();
     } catch (IllegalStateException expected) {
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
     executionThread.join();
 
     assertTrue(service.startUpCalled);
     assertEquals(Service.State.FAILED, service.state());
-    assertThat(service.failureCause()).hasMessage(""kaboom!"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""kaboom!"");
   }
 
   private class ThrowOnStartUpService extends AbstractExecutionThreadService {
@@ -217,8 +217,8 @@ public void testServiceThrowOnRun() throws Exception {
       fail();
     } catch (IllegalStateException expected) {
       executionThread.join();
-      assertEquals(service.failureCause(), expected.getCause());
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().isEqualTo(service.failureCause());
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
     assertTrue(service.shutDownCalled);
     assertEquals(Service.State.FAILED, service.state());
@@ -234,8 +234,8 @@ public void testServiceThrowOnRunAndThenAgainOnShutDown() throws Exception {
       fail();
     } catch (IllegalStateException expected) {
       executionThread.join();
-      assertEquals(service.failureCause(), expected.getCause());
-      assertThat(expected.getCause()).hasMessage(""kaboom!"");
+      assertThat(expected).hasCauseThat().isEqualTo(service.failureCause());
+      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""kaboom!"");
     }
 
     assertTrue(service.shutDownCalled);
@@ -276,7 +276,7 @@ public void testServiceThrowOnShutDown() throws Exception {
     executionThread.join();
 
     assertEquals(Service.State.FAILED, service.state());
-    assertThat(service.failureCause()).hasMessage(""kaboom!"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""kaboom!"");
   }
 
   private class ThrowOnShutDown extends AbstractExecutionThreadService {
@@ -381,7 +381,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -78,8 +78,8 @@ public void testException() throws InterruptedException {
     // Ensure we get a unique execution exception on each get
     assertNotSame(ee1, ee2);
 
-    assertSame(failure, ee1.getCause());
-    assertSame(failure, ee2.getCause());
+    assertThat(ee1).hasCauseThat().isSameAs(failure);
+    assertThat(ee2).hasCauseThat().isSameAs(failure);
 
     checkStackTrace(ee1);
     checkStackTrace(ee2);
@@ -97,7 +97,7 @@ public void testCancel_notDoneNoInterrupt() throws Exception {
       fail(""Expected CancellationException"");
     } catch (CancellationException e) {
       // See AbstractFutureCancellationCauseTest for how to set causes
-      assertNull(e.getCause());
+      assertThat(e).hasCauseThat().isNull();
     }
   }
 
@@ -113,7 +113,7 @@ public void testCancel_notDoneInterrupt() throws Exception {
       fail(""Expected CancellationException"");
     } catch (CancellationException e) {
       // See AbstractFutureCancellationCauseTest for how to set causes
-      assertNull(e.getCause());
+      assertThat(e).hasCauseThat().isNull();
     }
   }
 
@@ -155,7 +155,7 @@ public void addListener(Runnable r, Executor e) {
       normalFuture.get();
       fail();
     } catch (ExecutionException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
   }
 , @@ -68,7 +68,7 @@ protected void startUp() throws Exception {
         service.startAsync().awaitRunning();
         fail();
       } catch (RuntimeException e) {
-        assertSame(exception, e.getCause());
+        assertThat(e).hasCauseThat().isSameAs(exception);
       }
       assertEquals(Service.State.FAILED, service.state());
     }
@@ -87,7 +87,7 @@ protected void shutDown() throws Exception {
         service.stopAsync().awaitTerminated();
         fail();
       } catch (RuntimeException e) {
-        assertSame(exception, e.getCause());
+        assertThat(e).hasCauseThat().isSameAs(exception);
       }
       assertEquals(Service.State.FAILED, service.state());
     }
@@ -117,7 +117,7 @@ protected void startUp() throws Exception {
       service.startAsync().awaitRunning();
       fail();
     } catch (RuntimeException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
     assertEquals(1, service.startUpCalled);
     assertEquals(Service.State.FAILED, service.state());
@@ -164,7 +164,7 @@ protected void shutDown() throws Exception {
       service.stopAsync().awaitTerminated();
       fail();
     } catch (RuntimeException e) {
-      assertSame(exception, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(exception);
     }
     assertEquals(1, service.startUpCalled);
     assertEquals(1, service.shutDownCalled);
@@ -204,7 +204,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -295,7 +295,9 @@ protected String serviceName() {
       service.startAsync().awaitRunning(1, TimeUnit.MILLISECONDS);
       fail(""Expected timeout"");
     } catch (TimeoutException e) {
-      assertThat(e).hasMessage(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
+      assertThat(e)
+          .hasMessageThat()
+          .isEqualTo(""Timed out waiting for Foo [STARTING] to reach the RUNNING state."");
     }
   }
 , @@ -371,7 +371,7 @@ public void run() {
     waiter.join(LONG_TIMEOUT_MILLIS);
     assertFalse(waiter.isAlive());
     assertThat(exception.get()).isInstanceOf(IllegalStateException.class);
-    assertEquals(EXCEPTION, exception.get().getCause());
+    assertThat(exception.get()).hasCauseThat().isEqualTo(EXCEPTION);
   }
 
   public void testThreadedServiceStartAndWaitStopAndWait() throws Throwable {
@@ -448,12 +448,12 @@ public void testManualServiceFailureIdempotence() {
     service.startAsync();
     service.notifyFailed(new Exception(""1""));
     service.notifyFailed(new Exception(""2""));
-    assertThat(service.failureCause()).hasMessage(""1"");
+    assertThat(service.failureCause()).hasMessageThat().isEqualTo(""1"");
     try {
       service.awaitRunning();
       fail();
     } catch (IllegalStateException e) {
-      assertThat(e.getCause()).hasMessage(""1"");
+      assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(""1"");
     }
   }
 
@@ -548,7 +548,7 @@ public void testFailingServiceStartAndWait() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
   }
@@ -563,7 +563,7 @@ public void testFailingServiceStopAndWait_stopFailing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
@@ -580,7 +580,7 @@ public void testFailingServiceStopAndWait_runFailing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
@@ -595,7 +595,7 @@ public void testThrowingServiceStartAndWait() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(ImmutableList.of(State.STARTING, State.FAILED), listener.getStateHistory());
   }
@@ -610,7 +610,7 @@ public void testThrowingServiceStopAndWait_stopThrowing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.STOPPING, State.FAILED),
@@ -627,7 +627,7 @@ public void testThrowingServiceStopAndWait_runThrowing() throws Exception {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(service.exception, service.failureCause());
-      assertEquals(service.exception, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(service.exception);
     }
     assertEquals(
         ImmutableList.of(State.STARTING, State.RUNNING, State.FAILED), listener.getStateHistory());
@@ -651,7 +651,7 @@ public void testFailureCause_throwsIfNotFailed() {
       fail();
     } catch (IllegalStateException e) {
       assertEquals(EXCEPTION, service.failureCause());
-      assertEquals(EXCEPTION, e.getCause());
+      assertThat(e).hasCauseThat().isEqualTo(EXCEPTION);
     }
   }
 
@@ -858,11 +858,10 @@ public synchronized void stopping(State from) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException expected) {
-          assertNull(expected.getCause());
-          assertTrue(
-              expected
-                  .getMessage()
-                  .equals(""Expected the service "" + service + "" to be RUNNING, but was STOPPING""));
+          assertThat(expected).hasCauseThat().isNull();
+          assertThat(expected)
+              .hasMessageThat()
+              .isEqualTo(""Expected the service "" + service + "" to be RUNNING, but was STOPPING"");
         }
       }
       assertNotSame(from, service.state());
@@ -878,12 +877,10 @@ public synchronized void terminated(State from) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException expected) {
-          assertNull(expected.getCause());
-          assertTrue(
-              expected
-                  .getMessage()
-                  .equals(
-                      ""Expected the service "" + service + "" to be RUNNING, but was TERMINATED""));
+          assertThat(expected).hasCauseThat().isNull();
+          assertThat(expected)
+              .hasMessageThat()
+              .isEqualTo(""Expected the service "" + service + "" to be RUNNING, but was TERMINATED"");
         }
       }
       completionLatch.countDown();
@@ -900,14 +897,14 @@ public synchronized void failed(State from, Throwable failure) {
           service.awaitRunning();
           fail();
         } catch (IllegalStateException e) {
-          assertEquals(failure, e.getCause());
+          assertThat(e).hasCauseThat().isEqualTo(failure);
         }
       }
       try {
         service.awaitTerminated();
         fail();
       } catch (IllegalStateException e) {
-        assertEquals(failure, e.getCause());
+        assertThat(e).hasCauseThat().isEqualTo(failure);
       }
       completionLatch.countDown();
     }, @@ -16,6 +16,8 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
@@ -80,7 +82,7 @@ public String call() throws Exception {
       future.get();
       fail(""Expected exception to be thrown"");
     } catch (ExecutionException e) {
-      assertSame(expected, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(expected);
     }
   }
 , @@ -137,7 +137,7 @@ public void testWithTimeout() throws Exception {
         f.get();
         fail();
       } catch (ExecutionException e) {
-        assertThat(e.getCause()).isInstanceOf(TimeoutException.class);
+        assertThat(e).hasCauseThat().isInstanceOf(TimeoutException.class);
       }
     } finally {
       executor.shutdown();, @@ -64,7 +64,7 @@ public void testGetCheckedUntimed_interrupted() {
       getChecked(future, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(InterruptedException.class);
       assertTrue(Thread.currentThread().isInterrupted());
     } finally {
       Thread.interrupted();
@@ -86,7 +86,7 @@ public void testGetCheckedUntimed_ExecutionExceptionChecked() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 
@@ -96,7 +96,7 @@ public void testGetCheckedUntimed_ExecutionExceptionUnchecked()
       getChecked(FAILED_FUTURE_UNCHECKED_EXCEPTION, TwoArgConstructorException.class);
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(UNCHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(UNCHECKED_EXCEPTION);
     }
   }
 
@@ -105,7 +105,7 @@ public void testGetCheckedUntimed_ExecutionExceptionError() throws TwoArgConstru
       getChecked(FAILED_FUTURE_ERROR, TwoArgConstructorException.class);
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(ERROR, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(ERROR);
     }
   }
 
@@ -114,7 +114,7 @@ public void testGetCheckedUntimed_ExecutionExceptionOtherThrowable() {
       getChecked(FAILED_FUTURE_OTHER_THROWABLE, TwoArgConstructorException.class);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(OTHER_THROWABLE, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(OTHER_THROWABLE);
     }
   }
 
@@ -160,7 +160,7 @@ public void testGetCheckedUntimed_withGoodAndBadExceptionConstructor() throws Ex
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, ExceptionWithGoodAndBadConstructor.class);
       fail();
     } catch (ExceptionWithGoodAndBadConstructor expected) {
-      assertSame(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(CHECKED_EXCEPTION);
     }
   }
 
@@ -178,7 +178,7 @@ public void testGetCheckedTimed_interrupted() {
       getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(InterruptedException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(InterruptedException.class);
       assertTrue(Thread.currentThread().isInterrupted());
     } finally {
       Thread.interrupted();
@@ -200,7 +200,7 @@ public void testGetCheckedTimed_ExecutionExceptionChecked() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 
@@ -209,7 +209,7 @@ public void testGetCheckedTimed_ExecutionExceptionUnchecked() throws TwoArgConst
       getChecked(FAILED_FUTURE_UNCHECKED_EXCEPTION, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (UncheckedExecutionException expected) {
-      assertEquals(UNCHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(UNCHECKED_EXCEPTION);
     }
   }
 
@@ -218,7 +218,7 @@ public void testGetCheckedTimed_ExecutionExceptionError() throws TwoArgConstruct
       getChecked(FAILED_FUTURE_ERROR, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (ExecutionError expected) {
-      assertEquals(ERROR, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(ERROR);
     }
   }
 
@@ -227,7 +227,7 @@ public void testGetCheckedTimed_ExecutionExceptionOtherThrowable() {
       getChecked(FAILED_FUTURE_OTHER_THROWABLE, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertEquals(OTHER_THROWABLE, expected.getCause());
+      assertThat(expected).hasCauseThat().isEqualTo(OTHER_THROWABLE);
     }
   }
 
@@ -256,7 +256,7 @@ public void testGetCheckedTimed_TimeoutException() {
       getChecked(future, TwoArgConstructorException.class, 0, SECONDS);
       fail();
     } catch (TwoArgConstructorException expected) {
-      assertThat(expected.getCause()).isInstanceOf(TimeoutException.class);
+      assertThat(expected).hasCauseThat().isInstanceOf(TimeoutException.class);
     }
   }
 
@@ -278,7 +278,7 @@ public void testGetCheckedTimed_badExceptionConstructor_wrapsOriginalChecked() t
     }
   }
 
-  public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() throws Exception {
+  public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() {
     try {
       getChecked(
           FAILED_FUTURE_CHECKED_EXCEPTION,
@@ -287,7 +287,7 @@ public void testGetCheckedTimed_withGoodAndBadExceptionConstructor() throws Exce
           TimeUnit.SECONDS);
       fail();
     } catch (ExceptionWithGoodAndBadConstructor expected) {
-      assertSame(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasCauseThat().isSameAs(CHECKED_EXCEPTION);
     }
   }
 
@@ -344,8 +344,8 @@ public void testGetCheckedUntimed_exceptionClassUsedInitCause() {
       getChecked(FAILED_FUTURE_CHECKED_EXCEPTION, ExceptionWithoutThrowableConstructor.class);
       fail();
     } catch (ExceptionWithoutThrowableConstructor expected) {
-      assertThat(expected.getMessage()).contains(""mymessage"");
-      assertEquals(CHECKED_EXCEPTION, expected.getCause());
+      assertThat(expected).hasMessageThat().contains(""mymessage"");
+      assertThat(expected).hasCauseThat().isEqualTo(CHECKED_EXCEPTION);
     }
   }
 , @@ -42,7 +42,7 @@ public void testFailed() {
       getDone(immediateFailedFuture(failureCause));
       fail();
     } catch (ExecutionException expected) {
-      assertThat(expected.getCause()).isEqualTo(failureCause);
+      assertThat(expected).hasCauseThat().isEqualTo(failureCause);
     }
   }
 , @@ -3813,7 +3813,7 @@ public void testCompletionOrderExceptionThrown() throws Exception {
           getDone(future);
           fail();
         } catch (ExecutionException expected) {
-          assertThat(expected.getCause()).hasMessage(""2L"");
+          assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(""2L"");
         }
       }
       expectedResult++;, @@ -106,7 +106,7 @@ public void testFailedFuture(@Nullable String message) throws InterruptedExcepti
       future.get();
       fail(""Future should rethrow the exception."");
     } catch (ExecutionException e) {
-      assertThat(e.getCause()).hasMessage(message);
+      assertThat(e).hasCauseThat().hasMessageThat().isEqualTo(message);
     }
   }
 }, @@ -467,7 +467,7 @@ private static void assertExecutionException(Future<?> future, Exception expecte
       future.get();
       fail(""Expected ExecutionException"");
     } catch (ExecutionException e) {
-      assertSame(expectedCause, e.getCause());
+      assertThat(e).hasCauseThat().isSameAs(expectedCause);
     }
   }
 
@@ -525,7 +525,7 @@ public void testInvokeAnyImpl_noTaskCompletes() throws Exception {
       invokeAnyImpl(e, l, false, 0, TimeUnit.NANOSECONDS);
       fail();
     } catch (ExecutionException success) {
-      assertThat(success.getCause()).isInstanceOf(NullPointerException.class);
+      assertThat(success).hasCauseThat().isInstanceOf(NullPointerException.class);
     } finally {
       joinPool(e);
     }, @@ -16,6 +16,8 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -110,7 +112,7 @@ public void testSetException() throws Exception {
       future.get();
       fail(""Expected ExecutionException"");
     } catch (ExecutionException ee) {
-      assertSame(e, ee.getCause());
+      assertThat(ee).hasCauseThat().isSameAs(e);
     }
   }
 , @@ -79,7 +79,7 @@ public Integer call() throws Exception {
       getDone(task);
       fail();
     } catch (ExecutionException executionException) {
-      assertEquals(e, executionException.getCause());
+      assertThat(executionException).hasCauseThat().isEqualTo(e);
     }
   }
 , ",This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.,Moe Sync
3327,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Public Suffix data.

The copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

When that bug is not updated, the copy is updated 3 weeks before the
Estimated Week of Stable:

https://www.chromium.org/developers/calendar#TOC-Estimated-Stable-Dates

648071f0c529c87cb28537488f27f971bce3c3c5",Moe Sync
3330,Ron Shapiro,"['android/guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java', 'guava/src/com/google/common/collect/ImmutableClassToInstanceMap.java']","@@ -21,6 +21,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.Map;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
@@ -32,6 +33,7 @@
  * @author Kevin Bourrillion
  * @since 2.0
  */
+@Immutable(containerOf = ""B"")
 @GwtIncompatible
 public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<? extends B>, B>
     implements ClassToInstanceMap<B>, Serializable {, @@ -21,6 +21,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.primitives.Primitives;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.Immutable;
 import java.io.Serializable;
 import java.util.Map;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -32,6 +33,7 @@
  * @author Kevin Bourrillion
  * @since 2.0
  */
+@Immutable(containerOf = ""B"")
 @GwtIncompatible
 public final class ImmutableClassToInstanceMap<B> extends ForwardingMap<Class<? extends B>, B>
     implements ClassToInstanceMap<B>, Serializable {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Internal change

3e74359d4e0479bf6c461d031bb4761b06cf2e66

-------

<p> Add the @Immutable a few more classes. Both annotations enforce at compile-time that the annotated class meets the annotation’s requirements.

16001aae5eb8c4be0b7aa160970d22e6ef5b8ed0",Moe Sync
3332,Ron Shapiro,"['android/guava/src/com/google/common/net/MediaType.java', 'guava/src/com/google/common/net/MediaType.java']","@@ -198,9 +198,9 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType BMP = createConstant(IMAGE_TYPE, ""bmp"");
 
   /**
-   * The media type for the <a href=""https://en.wikipedia.org/wiki/Camera_Image_File_Format"">Canon
-   * Image File Format</a> ({@code crw} files), a widely-used ""raw image"" format for cameras. It is
-   * found in {@code /etc/mime.types}, e.g. in <a href=
+   * The <a href=""https://en.wikipedia.org/wiki/Camera_Image_File_Format"">Canon Image File
+   * Format</a> ({@code crw} files), a widely-used ""raw image"" format for cameras. It is found in
+   * {@code /etc/mime.types}, e.g. in <a href=
    * ""http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD""
    * >Debian 3.48-1</a>.
    *
@@ -214,7 +214,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType PNG = createConstant(IMAGE_TYPE, ""png"");
 
   /**
-   * The media type for the Photoshop File Format ({@code psd} files) as defined by <a
+   * The Photoshop File Format ({@code psd} files) as defined by <a
    * href=""http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop"">IANA</a>, and
    * found in {@code /etc/mime.types}, e.g. <a
    * href=""http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types""></a> of the
@@ -249,47 +249,44 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WEBM_AUDIO = createConstant(AUDIO_TYPE, ""webm"");
 
   /**
-   * Media type for L16 audio, as defined by <a href=""https://tools.ietf.org/html/rfc2586"">RFC
-   * 2586</a>.
+   * L16 audio, as defined by <a href=""https://tools.ietf.org/html/rfc2586"">RFC 2586</a>.
    *
    * @since 24.1
    */
   public static final MediaType L16_AUDIO = createConstant(AUDIO_TYPE, ""l16"");
 
   /**
-   * Media type for L24 audio, as defined by <a href=""https://tools.ietf.org/html/rfc3190"">RFC
-   * 3190</a>.
+   * L24 audio, as defined by <a href=""https://tools.ietf.org/html/rfc3190"">RFC 3190</a>.
    *
    * @since 20.0
    */
   public static final MediaType L24_AUDIO = createConstant(AUDIO_TYPE, ""l24"");
 
   /**
-   * Media type for Basic Audio, as defined by <a
-   * href=""http://tools.ietf.org/html/rfc2046#section-4.3"">RFC 2046</a>.
+   * Basic Audio, as defined by <a href=""http://tools.ietf.org/html/rfc2046#section-4.3"">RFC
+   * 2046</a>.
    *
    * @since 20.0
    */
   public static final MediaType BASIC_AUDIO = createConstant(AUDIO_TYPE, ""basic"");
 
   /**
-   * Media type for Advanced Audio Coding. For more information, see <a
+   * Advanced Audio Coding. For more information, see <a
    * href=""https://en.wikipedia.org/wiki/Advanced_Audio_Coding"">Advanced Audio Coding</a>.
    *
    * @since 20.0
    */
   public static final MediaType AAC_AUDIO = createConstant(AUDIO_TYPE, ""aac"");
 
   /**
-   * Media type for Vorbis Audio, as defined by <a href=""http://tools.ietf.org/html/rfc5215"">RFC
-   * 5215</a>.
+   * Vorbis Audio, as defined by <a href=""http://tools.ietf.org/html/rfc5215"">RFC 5215</a>.
    *
    * @since 20.0
    */
   public static final MediaType VORBIS_AUDIO = createConstant(AUDIO_TYPE, ""vorbis"");
 
   /**
-   * Media type for Windows Media Audio. For more information, see <a
+   * Windows Media Audio. For more information, see <a
    * href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx"">file
    * name extensions for Windows Media metafiles</a>.
    *
@@ -298,7 +295,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WMA_AUDIO = createConstant(AUDIO_TYPE, ""x-ms-wma"");
 
   /**
-   * Media type for Windows Media metafiles. For more information, see <a
+   * Windows Media metafiles. For more information, see <a
    * href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx"">file
    * name extensions for Windows Media metafiles</a>.
    *
@@ -307,16 +304,15 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WAX_AUDIO = createConstant(AUDIO_TYPE, ""x-ms-wax"");
 
   /**
-   * Media type for Real Audio. For more information, see <a
+   * Real Audio. For more information, see <a
    * href=""http://service.real.com/help/faq/rp8/configrp8win.html"">this link</a>.
    *
    * @since 20.0
    */
   public static final MediaType VND_REAL_AUDIO = createConstant(AUDIO_TYPE, ""vnd.rn-realaudio"");
 
   /**
-   * Media type for WAVE format, as defined by <a href=""https://tools.ietf.org/html/rfc2361"">RFC
-   * 2361</a>.
+   * WAVE format, as defined by <a href=""https://tools.ietf.org/html/rfc2361"">RFC 2361</a>.
    *
    * @since 20.0
    */
@@ -331,7 +327,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WMV = createConstant(VIDEO_TYPE, ""x-ms-wmv"");
 
   /**
-   * Media type for Flash video. For more information, see <a href=
+   * Flash video. For more information, see <a href=
    * ""http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html""
    * >this link</a>.
    *
@@ -340,7 +336,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType FLV_VIDEO = createConstant(VIDEO_TYPE, ""x-flv"");
 
   /**
-   * Media type for the 3GP multimedia container format. For more information, see <a
+   * The 3GP multimedia container format. For more information, see <a
    * href=""ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10"">3GPP TS
    * 26.244</a>.
    *
@@ -349,7 +345,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType THREE_GPP_VIDEO = createConstant(VIDEO_TYPE, ""3gpp"");
 
   /**
-   * Media type for the 3G2 multimedia container format. For more information, see <a
+   * The 3G2 multimedia container format. For more information, see <a
    * href=""http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16"">3GPP2
    * C.S0050-B</a>.
    *
@@ -371,24 +367,24 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType BZIP2 = createConstant(APPLICATION_TYPE, ""x-bzip2"");
 
   /**
-   * Media type for <a href=""https://www.dartlang.org/articles/embedding-in-html/"">dart files</a>.
+   * Files in the <a href=""https://www.dartlang.org/articles/embedding-in-html/"">dart</a>
+   * programming language.
    *
    * @since 19.0
    */
   public static final MediaType DART_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""dart"");
 
   /**
-   * Media type for <a href=""https://goo.gl/2QoMvg"">Apple Passbook</a>.
+   * <a href=""https://goo.gl/2QoMvg"">Apple Passbook</a>.
    *
    * @since 19.0
    */
   public static final MediaType APPLE_PASSBOOK =
       createConstant(APPLICATION_TYPE, ""vnd.apple.pkpass"");
 
   /**
-   * Media type for <a href=""http://en.wikipedia.org/wiki/Embedded_OpenType"">Embedded OpenType</a>
-   * fonts. This is <a
-   * href=""http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject"">registered
+   * <a href=""http://en.wikipedia.org/wiki/Embedded_OpenType"">Embedded OpenType</a> fonts. This is
+   * <a href=""http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject"">registered
    * </a> with the IANA.
    *
    * @since 17.0
@@ -433,8 +429,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType GZIP = createConstant(APPLICATION_TYPE, ""x-gzip"");
 
   /**
-   * Media type for the <a href=""https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3"">JSON
-   * Hypertext Application Language (HAL) documents</a>.
+   * <a href=""https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3"">JSON Hypertext
+   * Application Language (HAL) documents</a>.
    *
    * @since 26.0
    */
@@ -451,70 +447,67 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType JSON_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""json"");
 
   /**
-   * Media type for the <a href=""http://www.w3.org/TR/appmanifest/"">Manifest for a web
-   * application</a>.
+   * The <a href=""http://www.w3.org/TR/appmanifest/"">Manifest for a web application</a>.
    *
    * @since 19.0
    */
   public static final MediaType MANIFEST_JSON_UTF_8 =
       createConstantUtf8(APPLICATION_TYPE, ""manifest+json"");
 
   /**
-   * Media type for <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup
-   * Language)</a>.
+   * <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup Language)</a>.
    */
   public static final MediaType KML = createConstant(APPLICATION_TYPE, ""vnd.google-earth.kml+xml"");
 
   /**
-   * Media type for <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup
-   * Language)</a>, compressed using the ZIP format into KMZ archives.
+   * <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup Language)</a>,
+   * compressed using the ZIP format into KMZ archives.
    */
   public static final MediaType KMZ = createConstant(APPLICATION_TYPE, ""vnd.google-earth.kmz"");
 
   /**
-   * Media type for the <a href=""https://tools.ietf.org/html/rfc4155"">mbox database format</a>.
+   * The <a href=""https://tools.ietf.org/html/rfc4155"">mbox database format</a>.
    *
    * @since 13.0
    */
   public static final MediaType MBOX = createConstant(APPLICATION_TYPE, ""mbox"");
 
   /**
-   * Media type for <a href=""http://goo.gl/1pGBFm"">Apple over-the-air mobile configuration
-   * profiles</a>.
+   * <a href=""http://goo.gl/1pGBFm"">Apple over-the-air mobile configuration profiles</a>.
    *
    * @since 18.0
    */
   public static final MediaType APPLE_MOBILE_CONFIG =
       createConstant(APPLICATION_TYPE, ""x-apple-aspen-config"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Excel</a> spreadsheets. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Excel</a> spreadsheets. */
   public static final MediaType MICROSOFT_EXCEL = createConstant(APPLICATION_TYPE, ""vnd.ms-excel"");
 
   /**
-   * Media type for <a href=""http://goo.gl/XrTEqG"">Microsoft Outlook</a> items.
+   * <a href=""http://goo.gl/XrTEqG"">Microsoft Outlook</a> items.
    *
    * @since NEXT
    */
   public static final MediaType MICROSOFT_OUTLOOK =
       createConstant(APPLICATION_TYPE, ""vnd.ms-outlook"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Powerpoint</a> presentations. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Powerpoint</a> presentations. */
   public static final MediaType MICROSOFT_POWERPOINT =
       createConstant(APPLICATION_TYPE, ""vnd.ms-powerpoint"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Word</a> documents. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Word</a> documents. */
   public static final MediaType MICROSOFT_WORD = createConstant(APPLICATION_TYPE, ""msword"");
 
   /**
-   * Media type for WASM applications. For more information see <a
-   * href=""https://webassembly.org/"">the Web Assembly overview</a>.
+   * WASM applications. For more information see <a href=""https://webassembly.org/"">the Web Assembly
+   * overview</a>.
    *
    * @since 27.0
    */
   public static final MediaType WASM_APPLICATION = createConstant(APPLICATION_TYPE, ""wasm"");
 
   /**
-   * Media type for NaCl applications. For more information see <a
+   * NaCl applications. For more information see <a
    * href=""https://developer.chrome.com/native-client/devguide/coding/application-structure"">the
    * Developer Guide for Native Client Application Structure</a>.
    *
@@ -523,7 +516,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType NACL_APPLICATION = createConstant(APPLICATION_TYPE, ""x-nacl"");
 
   /**
-   * Media type for NaCl portable applications. For more information see <a
+   * NaCl portable applications. For more information see <a
    * href=""https://developer.chrome.com/native-client/devguide/coding/application-structure"">the
    * Developer Guide for Native Client Application Structure</a>.
    *
@@ -574,8 +567,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType RTF_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""rtf"");
 
   /**
-   * Media type for SFNT fonts (which includes <a
-   * href=""http://en.wikipedia.org/wiki/TrueType/"">TrueType</a> and <a
+   * SFNT fonts (which includes <a href=""http://en.wikipedia.org/wiki/TrueType/"">TrueType</a> and <a
    * href=""http://en.wikipedia.org/wiki/OpenType/"">OpenType</a> fonts). This is <a
    * href=""http://www.iana.org/assignments/media-types/application/font-sfnt"">registered</a> with
    * the IANA.
@@ -611,8 +603,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType TAR = createConstant(APPLICATION_TYPE, ""x-tar"");
 
   /**
-   * Media type for the <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font
-   * Format</a> (WOFF) <a href=""http://www.w3.org/TR/WOFF/"">defined</a> by the W3C. This is <a
+   * <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font Format</a> (WOFF) <a
+   * href=""http://www.w3.org/TR/WOFF/"">defined</a> by the W3C. This is <a
    * href=""http://www.iana.org/assignments/media-types/application/font-woff"">registered</a> with
    * the IANA.
    *
@@ -621,8 +613,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WOFF = createConstant(APPLICATION_TYPE, ""font-woff"");
 
   /**
-   * Media type for the <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font
-   * Format</a> (WOFF) version 2 <a href=""https://www.w3.org/TR/WOFF2/"">defined</a> by the W3C.
+   * <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font Format</a> (WOFF)
+   * version 2 <a href=""https://www.w3.org/TR/WOFF2/"">defined</a> by the W3C.
    *
    * @since 20.0
    */
@@ -631,10 +623,10 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType XHTML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""xhtml+xml"");
 
   /**
-   * Media type for Extensible Resource Descriptors. This is not yet registered with the IANA, but
-   * it is specified by OASIS in the <a
-   * href=""http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html"">XRD definition</a> and
-   * implemented in projects such as <a href=""http://code.google.com/p/webfinger/"">WebFinger</a>.
+   * Extensible Resource Descriptors. This is not yet registered with the IANA, but it is specified
+   * by OASIS in the <a href=""http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html"">XRD
+   * definition</a> and implemented in projects such as <a
+   * href=""http://code.google.com/p/webfinger/"">WebFinger</a>.
    *
    * @since 14.0
    */, @@ -198,9 +198,9 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType BMP = createConstant(IMAGE_TYPE, ""bmp"");
 
   /**
-   * The media type for the <a href=""https://en.wikipedia.org/wiki/Camera_Image_File_Format"">Canon
-   * Image File Format</a> ({@code crw} files), a widely-used ""raw image"" format for cameras. It is
-   * found in {@code /etc/mime.types}, e.g. in <a href=
+   * The <a href=""https://en.wikipedia.org/wiki/Camera_Image_File_Format"">Canon Image File
+   * Format</a> ({@code crw} files), a widely-used ""raw image"" format for cameras. It is found in
+   * {@code /etc/mime.types}, e.g. in <a href=
    * ""http://anonscm.debian.org/gitweb/?p=collab-maint/mime-support.git;a=blob;f=mime.types;hb=HEAD""
    * >Debian 3.48-1</a>.
    *
@@ -214,7 +214,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType PNG = createConstant(IMAGE_TYPE, ""png"");
 
   /**
-   * The media type for the Photoshop File Format ({@code psd} files) as defined by <a
+   * The Photoshop File Format ({@code psd} files) as defined by <a
    * href=""http://www.iana.org/assignments/media-types/image/vnd.adobe.photoshop"">IANA</a>, and
    * found in {@code /etc/mime.types}, e.g. <a
    * href=""http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types""></a> of the
@@ -249,47 +249,44 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WEBM_AUDIO = createConstant(AUDIO_TYPE, ""webm"");
 
   /**
-   * Media type for L16 audio, as defined by <a href=""https://tools.ietf.org/html/rfc2586"">RFC
-   * 2586</a>.
+   * L16 audio, as defined by <a href=""https://tools.ietf.org/html/rfc2586"">RFC 2586</a>.
    *
    * @since 24.1
    */
   public static final MediaType L16_AUDIO = createConstant(AUDIO_TYPE, ""l16"");
 
   /**
-   * Media type for L24 audio, as defined by <a href=""https://tools.ietf.org/html/rfc3190"">RFC
-   * 3190</a>.
+   * L24 audio, as defined by <a href=""https://tools.ietf.org/html/rfc3190"">RFC 3190</a>.
    *
    * @since 20.0
    */
   public static final MediaType L24_AUDIO = createConstant(AUDIO_TYPE, ""l24"");
 
   /**
-   * Media type for Basic Audio, as defined by <a
-   * href=""http://tools.ietf.org/html/rfc2046#section-4.3"">RFC 2046</a>.
+   * Basic Audio, as defined by <a href=""http://tools.ietf.org/html/rfc2046#section-4.3"">RFC
+   * 2046</a>.
    *
    * @since 20.0
    */
   public static final MediaType BASIC_AUDIO = createConstant(AUDIO_TYPE, ""basic"");
 
   /**
-   * Media type for Advanced Audio Coding. For more information, see <a
+   * Advanced Audio Coding. For more information, see <a
    * href=""https://en.wikipedia.org/wiki/Advanced_Audio_Coding"">Advanced Audio Coding</a>.
    *
    * @since 20.0
    */
   public static final MediaType AAC_AUDIO = createConstant(AUDIO_TYPE, ""aac"");
 
   /**
-   * Media type for Vorbis Audio, as defined by <a href=""http://tools.ietf.org/html/rfc5215"">RFC
-   * 5215</a>.
+   * Vorbis Audio, as defined by <a href=""http://tools.ietf.org/html/rfc5215"">RFC 5215</a>.
    *
    * @since 20.0
    */
   public static final MediaType VORBIS_AUDIO = createConstant(AUDIO_TYPE, ""vorbis"");
 
   /**
-   * Media type for Windows Media Audio. For more information, see <a
+   * Windows Media Audio. For more information, see <a
    * href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx"">file
    * name extensions for Windows Media metafiles</a>.
    *
@@ -298,7 +295,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WMA_AUDIO = createConstant(AUDIO_TYPE, ""x-ms-wma"");
 
   /**
-   * Media type for Windows Media metafiles. For more information, see <a
+   * Windows Media metafiles. For more information, see <a
    * href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd562994(v=vs.85).aspx"">file
    * name extensions for Windows Media metafiles</a>.
    *
@@ -307,16 +304,15 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WAX_AUDIO = createConstant(AUDIO_TYPE, ""x-ms-wax"");
 
   /**
-   * Media type for Real Audio. For more information, see <a
+   * Real Audio. For more information, see <a
    * href=""http://service.real.com/help/faq/rp8/configrp8win.html"">this link</a>.
    *
    * @since 20.0
    */
   public static final MediaType VND_REAL_AUDIO = createConstant(AUDIO_TYPE, ""vnd.rn-realaudio"");
 
   /**
-   * Media type for WAVE format, as defined by <a href=""https://tools.ietf.org/html/rfc2361"">RFC
-   * 2361</a>.
+   * WAVE format, as defined by <a href=""https://tools.ietf.org/html/rfc2361"">RFC 2361</a>.
    *
    * @since 20.0
    */
@@ -331,7 +327,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WMV = createConstant(VIDEO_TYPE, ""x-ms-wmv"");
 
   /**
-   * Media type for Flash video. For more information, see <a href=
+   * Flash video. For more information, see <a href=
    * ""http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7d48.html""
    * >this link</a>.
    *
@@ -340,7 +336,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType FLV_VIDEO = createConstant(VIDEO_TYPE, ""x-flv"");
 
   /**
-   * Media type for the 3GP multimedia container format. For more information, see <a
+   * The 3GP multimedia container format. For more information, see <a
    * href=""ftp://www.3gpp.org/tsg_sa/TSG_SA/TSGS_23/Docs/PDF/SP-040065.pdf#page=10"">3GPP TS
    * 26.244</a>.
    *
@@ -349,7 +345,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType THREE_GPP_VIDEO = createConstant(VIDEO_TYPE, ""3gpp"");
 
   /**
-   * Media type for the 3G2 multimedia container format. For more information, see <a
+   * The 3G2 multimedia container format. For more information, see <a
    * href=""http://www.3gpp2.org/Public_html/specs/C.S0050-B_v1.0_070521.pdf#page=16"">3GPP2
    * C.S0050-B</a>.
    *
@@ -371,24 +367,24 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType BZIP2 = createConstant(APPLICATION_TYPE, ""x-bzip2"");
 
   /**
-   * Media type for <a href=""https://www.dartlang.org/articles/embedding-in-html/"">dart files</a>.
+   * Files in the <a href=""https://www.dartlang.org/articles/embedding-in-html/"">dart</a>
+   * programming language.
    *
    * @since 19.0
    */
   public static final MediaType DART_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""dart"");
 
   /**
-   * Media type for <a href=""https://goo.gl/2QoMvg"">Apple Passbook</a>.
+   * <a href=""https://goo.gl/2QoMvg"">Apple Passbook</a>.
    *
    * @since 19.0
    */
   public static final MediaType APPLE_PASSBOOK =
       createConstant(APPLICATION_TYPE, ""vnd.apple.pkpass"");
 
   /**
-   * Media type for <a href=""http://en.wikipedia.org/wiki/Embedded_OpenType"">Embedded OpenType</a>
-   * fonts. This is <a
-   * href=""http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject"">registered
+   * <a href=""http://en.wikipedia.org/wiki/Embedded_OpenType"">Embedded OpenType</a> fonts. This is
+   * <a href=""http://www.iana.org/assignments/media-types/application/vnd.ms-fontobject"">registered
    * </a> with the IANA.
    *
    * @since 17.0
@@ -433,8 +429,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType GZIP = createConstant(APPLICATION_TYPE, ""x-gzip"");
 
   /**
-   * Media type for the <a href=""https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3"">JSON
-   * Hypertext Application Language (HAL) documents</a>.
+   * <a href=""https://tools.ietf.org/html/draft-kelly-json-hal-08#section-3"">JSON Hypertext
+   * Application Language (HAL) documents</a>.
    *
    * @since 26.0
    */
@@ -451,70 +447,67 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType JSON_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""json"");
 
   /**
-   * Media type for the <a href=""http://www.w3.org/TR/appmanifest/"">Manifest for a web
-   * application</a>.
+   * The <a href=""http://www.w3.org/TR/appmanifest/"">Manifest for a web application</a>.
    *
    * @since 19.0
    */
   public static final MediaType MANIFEST_JSON_UTF_8 =
       createConstantUtf8(APPLICATION_TYPE, ""manifest+json"");
 
   /**
-   * Media type for <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup
-   * Language)</a>.
+   * <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup Language)</a>.
    */
   public static final MediaType KML = createConstant(APPLICATION_TYPE, ""vnd.google-earth.kml+xml"");
 
   /**
-   * Media type for <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup
-   * Language)</a>, compressed using the ZIP format into KMZ archives.
+   * <a href=""http://www.opengeospatial.org/standards/kml/"">OGC KML (Keyhole Markup Language)</a>,
+   * compressed using the ZIP format into KMZ archives.
    */
   public static final MediaType KMZ = createConstant(APPLICATION_TYPE, ""vnd.google-earth.kmz"");
 
   /**
-   * Media type for the <a href=""https://tools.ietf.org/html/rfc4155"">mbox database format</a>.
+   * The <a href=""https://tools.ietf.org/html/rfc4155"">mbox database format</a>.
    *
    * @since 13.0
    */
   public static final MediaType MBOX = createConstant(APPLICATION_TYPE, ""mbox"");
 
   /**
-   * Media type for <a href=""http://goo.gl/1pGBFm"">Apple over-the-air mobile configuration
-   * profiles</a>.
+   * <a href=""http://goo.gl/1pGBFm"">Apple over-the-air mobile configuration profiles</a>.
    *
    * @since 18.0
    */
   public static final MediaType APPLE_MOBILE_CONFIG =
       createConstant(APPLICATION_TYPE, ""x-apple-aspen-config"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Excel</a> spreadsheets. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Excel</a> spreadsheets. */
   public static final MediaType MICROSOFT_EXCEL = createConstant(APPLICATION_TYPE, ""vnd.ms-excel"");
 
   /**
-   * Media type for <a href=""http://goo.gl/XrTEqG"">Microsoft Outlook</a> items.
+   * <a href=""http://goo.gl/XrTEqG"">Microsoft Outlook</a> items.
    *
    * @since NEXT
    */
   public static final MediaType MICROSOFT_OUTLOOK =
       createConstant(APPLICATION_TYPE, ""vnd.ms-outlook"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Powerpoint</a> presentations. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Powerpoint</a> presentations. */
   public static final MediaType MICROSOFT_POWERPOINT =
       createConstant(APPLICATION_TYPE, ""vnd.ms-powerpoint"");
 
-  /** Media type for <a href=""http://goo.gl/XDQ1h2"">Microsoft Word</a> documents. */
+  /** <a href=""http://goo.gl/XDQ1h2"">Microsoft Word</a> documents. */
   public static final MediaType MICROSOFT_WORD = createConstant(APPLICATION_TYPE, ""msword"");
 
   /**
-   * Media type for WASM applications. For more information see <a
-   * href=""https://webassembly.org/"">the Web Assembly overview</a>.
+   * WASM applications. For more information see <a href=""https://webassembly.org/"">the Web Assembly
+   * overview</a>.
    *
    * @since 27.0
    */
   public static final MediaType WASM_APPLICATION = createConstant(APPLICATION_TYPE, ""wasm"");
 
   /**
-   * Media type for NaCl applications. For more information see <a
+   * NaCl applications. For more information see <a
    * href=""https://developer.chrome.com/native-client/devguide/coding/application-structure"">the
    * Developer Guide for Native Client Application Structure</a>.
    *
@@ -523,7 +516,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType NACL_APPLICATION = createConstant(APPLICATION_TYPE, ""x-nacl"");
 
   /**
-   * Media type for NaCl portable applications. For more information see <a
+   * NaCl portable applications. For more information see <a
    * href=""https://developer.chrome.com/native-client/devguide/coding/application-structure"">the
    * Developer Guide for Native Client Application Structure</a>.
    *
@@ -574,8 +567,7 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType RTF_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""rtf"");
 
   /**
-   * Media type for SFNT fonts (which includes <a
-   * href=""http://en.wikipedia.org/wiki/TrueType/"">TrueType</a> and <a
+   * SFNT fonts (which includes <a href=""http://en.wikipedia.org/wiki/TrueType/"">TrueType</a> and <a
    * href=""http://en.wikipedia.org/wiki/OpenType/"">OpenType</a> fonts). This is <a
    * href=""http://www.iana.org/assignments/media-types/application/font-sfnt"">registered</a> with
    * the IANA.
@@ -611,8 +603,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType TAR = createConstant(APPLICATION_TYPE, ""x-tar"");
 
   /**
-   * Media type for the <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font
-   * Format</a> (WOFF) <a href=""http://www.w3.org/TR/WOFF/"">defined</a> by the W3C. This is <a
+   * <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font Format</a> (WOFF) <a
+   * href=""http://www.w3.org/TR/WOFF/"">defined</a> by the W3C. This is <a
    * href=""http://www.iana.org/assignments/media-types/application/font-woff"">registered</a> with
    * the IANA.
    *
@@ -621,8 +613,8 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType WOFF = createConstant(APPLICATION_TYPE, ""font-woff"");
 
   /**
-   * Media type for the <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font
-   * Format</a> (WOFF) version 2 <a href=""https://www.w3.org/TR/WOFF2/"">defined</a> by the W3C.
+   * <a href=""http://en.wikipedia.org/wiki/Web_Open_Font_Format"">Web Open Font Format</a> (WOFF)
+   * version 2 <a href=""https://www.w3.org/TR/WOFF2/"">defined</a> by the W3C.
    *
    * @since 20.0
    */
@@ -631,10 +623,10 @@ private static MediaType addKnownType(MediaType mediaType) {
   public static final MediaType XHTML_UTF_8 = createConstantUtf8(APPLICATION_TYPE, ""xhtml+xml"");
 
   /**
-   * Media type for Extensible Resource Descriptors. This is not yet registered with the IANA, but
-   * it is specified by OASIS in the <a
-   * href=""http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html"">XRD definition</a> and
-   * implemented in projects such as <a href=""http://code.google.com/p/webfinger/"">WebFinger</a>.
+   * Extensible Resource Descriptors. This is not yet registered with the IANA, but it is specified
+   * by OASIS in the <a href=""http://docs.oasis-open.org/xri/xrd/v1.0/cd02/xrd-1.0-cd02.html"">XRD
+   * definition</a> and implemented in projects such as <a
+   * href=""http://code.google.com/p/webfinger/"">WebFinger</a>.
    *
    * @since 14.0
    */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add missing documentation and @since tags to MediaType entries that were added
after its initial relase of 12.0

b545d0ed1066906d238852f2f510132cbfcc4af8

-------

<p> Remove ""Media type for"" or similar phrasing for visible constants in the MediaType class.

172bb45c149601a52e45bff8b2e3aa409f66d658",Moe Sync
3334,Ron Shapiro,"['android/guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/MoreFiles.java']","@@ -828,8 +828,9 @@ public String toString() {
    * a directory, no exception will be thrown and the returned {@link Iterable} will contain a
    * single element: that file.
    *
-   * <p>Example: {@code Files.fileTraverser().breadthFirst(""/"")} may return files with the following
-   * paths: {@code [""/"", ""/etc"", ""/home"", ""/usr"", ""/etc/config.txt"", ""/etc/fonts"", ...]}
+   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(""/""))} may return files
+   * with the following paths: {@code [""/"", ""/etc"", ""/etc/config.txt"", ""/etc/fonts"", ""/home"",
+   * ""/home/alice"", ...]}
    *
    * @since 23.5
    */, @@ -828,8 +828,9 @@ public String toString() {
    * a directory, no exception will be thrown and the returned {@link Iterable} will contain a
    * single element: that file.
    *
-   * <p>Example: {@code Files.fileTraverser().breadthFirst(""/"")} may return files with the following
-   * paths: {@code [""/"", ""/etc"", ""/home"", ""/usr"", ""/etc/config.txt"", ""/etc/fonts"", ...]}
+   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(""/""))} may return files
+   * with the following paths: {@code [""/"", ""/etc"", ""/etc/config.txt"", ""/etc/fonts"", ""/home"",
+   * ""/home/alice"", ...]}
    *
    * @since 23.5
    */, @@ -283,8 +283,9 @@ public static CharSink asCharSink(Path path, Charset charset, OpenOption... opti
    * created by this traverser if an {@link IOException} is thrown by a call to {@link
    * #listFiles(Path)}.
    *
-   * <p>Example: {@code MoreFiles.fileTraverser().breadthFirst(""/"")} may return files with the
-   * following paths: {@code [""/"", ""/etc"", ""/home"", ""/usr"", ""/etc/config.txt"", ""/etc/fonts"", ...]}
+   * <p>Example: {@code MoreFiles.fileTraverser().depthFirstPreOrder(Paths.get(""/""))} may return the
+   * following paths: {@code [""/"", ""/etc"", ""/etc/config.txt"", ""/etc/fonts"", ""/home"", ""/home/alice"",
+   * ...]}
    *
    * @since 23.5
    */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make example compile (i.e. supply a Path/File) and use depth first instead of breadth first.

Reason: Depth first is more common for file traversal.

RELNOTES=N/A

e7b80454e4d463af61fc81c3beb96b5e46b07312",Moe Sync
3337,Ron Shapiro,['guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java'],"@@ -67,7 +67,7 @@ static native String emptyToNull(@Nullable String string) /*-{
     return string || null;
   }-*/;
 
-  @JsType(isNative = true, name = ""Number"", namespace = GLOBAL)
+  @JsType(isNative = true, name = ""number"", namespace = GLOBAL)
   private interface Number {
     double toPrecision(int precision);
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use the primitive ""number"" type instead of the object counterpart ""Number"" to avoid a jscompiler error.

An upcoming change to J2CL that simplifies how casting logic is transpiled will make the code ""(Number) (Object) 3"" here transpile to just ""/** @type {Number} */ (3)"" and jscompiler will see the ""invalid cast"" since ""3"" is not ""Number"" in the closure type system.

065a831ca171767dcc73b7b74c996029a5f286e3",Moe Sync
3339,Ron Shapiro,"['android/guava/src/com/google/common/cache/AbstractCache.java', 'android/guava/src/com/google/common/cache/CacheStats.java', 'guava/src/com/google/common/cache/AbstractCache.java', 'guava/src/com/google/common/cache/CacheStats.java']","@@ -160,6 +160,7 @@ public CacheStats stats() {
      * @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
      *     value
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     void recordLoadSuccess(long loadTime);
 
     /**
@@ -170,6 +171,7 @@ public CacheStats stats() {
      * @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
      *     value prior to an exception being thrown
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     void recordLoadException(long loadTime);
 
     /**, @@ -69,6 +69,7 @@
    * <p>Five parameters of the same type in a row is a bad thing, but this class is not constructed
    * by end users and is too fine-grained for a builder.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheStats(
       long hitCount,
       long missCount,
@@ -190,6 +191,7 @@ public double loadExceptionRate() {
    * used to calculate the miss penalty. This value is increased every time {@code loadSuccessCount}
    * or {@code loadExceptionCount} is incremented.
    */
+  @SuppressWarnings(""GoodTime"") // should return a java.time.Duration
   public long totalLoadTime() {
     return totalLoadTime;
   }, @@ -160,6 +160,7 @@ public CacheStats stats() {
      * @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
      *     value
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     void recordLoadSuccess(long loadTime);
 
     /**
@@ -170,6 +171,7 @@ public CacheStats stats() {
      * @param loadTime the number of nanoseconds the cache spent computing or retrieving the new
      *     value prior to an exception being thrown
      */
+    @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
     void recordLoadException(long loadTime);
 
     /**, @@ -69,6 +69,7 @@
    * <p>Five parameters of the same type in a row is a bad thing, but this class is not constructed
    * by end users and is too fine-grained for a builder.
    */
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
   public CacheStats(
       long hitCount,
       long missCount,
@@ -190,6 +191,7 @@ public double loadExceptionRate() {
    * used to calculate the miss penalty. This value is increased every time {@code loadSuccessCount}
    * or {@code loadExceptionCount} is incremented.
    */
+  @SuppressWarnings(""GoodTime"") // should return a java.time.Duration
   public long totalLoadTime() {
     return totalLoadTime;
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add the application/jose and application/jose+json media types.

https://www.iana.org/assignments/media-types/application/jose
https://www.iana.org/assignments/media-types/application/jose+json
https://tools.ietf.org/html/rfc7515#section-9.2

RELNOTES=Add MediaType for ""application/jose"" and ""application/jose+json"".

e846cdf26bb7cc52b664e8f78e670222da88ac51

-------

<p> Suppress soon to be GoodTime errors ('time' is now considered a keyword).

2705b06e3c61dfe16eb14befe52de2c37d9e0313",Moe Sync
3344,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -20,7 +20,7 @@
     <test.include>%regex[.*.class]</test.include>
     <truth.version>0.42</truth.version>
     <animal.sniffer.version>1.17</animal.sniffer.version>
-    <maven-javadoc-plugin.version>3.0.0</maven-javadoc-plugin.version>
+    <maven-javadoc-plugin.version>3.0.1</maven-javadoc-plugin.version>
   </properties>
   <issueManagement>
     <system>GitHub Issues</system>, @@ -20,7 +20,7 @@
     <test.include>%regex[.*.class]</test.include>
     <truth.version>0.42</truth.version>
     <animal.sniffer.version>1.17</animal.sniffer.version>
-    <maven-javadoc-plugin.version>3.0.0</maven-javadoc-plugin.version>
+    <maven-javadoc-plugin.version>3.0.1</maven-javadoc-plugin.version>
   </properties>
   <issueManagement>
     <system>GitHub Issues</system>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use maven-javadoc-plugin 3.0.1.

cd52f44bf6f1943ad3b9a60053acff133cf2b152",Moe Sync
3350,Ron Shapiro,"['android/guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Files.java']","@@ -331,7 +331,8 @@ public static void copy(File from, File to) throws IOException {
    *     be removed in January 2019.
    */
   @Deprecated
-  public static void copy(File from, Charset charset, Appendable to) throws IOException {
+  public
+  static void copy(File from, Charset charset, Appendable to) throws IOException {
     asCharSource(from, charset).copyTo(to);
   }
 
@@ -347,7 +348,8 @@ public static void copy(File from, Charset charset, Appendable to) throws IOExce
    *     method is scheduled to be removed in January 2019.
    */
   @Deprecated
-  public static void append(CharSequence from, File to, Charset charset) throws IOException {
+  public
+  static void append(CharSequence from, File to, Charset charset) throws IOException {
     asCharSink(to, charset, FileWriteMode.APPEND).write(from);
   }
 
@@ -500,7 +502,8 @@ public static void move(File from, File to) throws IOException {
    *     scheduled to be removed in January 2019.
    */
   @Deprecated
-  public static String readFirstLine(File file, Charset charset) throws IOException {
+  public
+  static String readFirstLine(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).readFirstLine();
   }
 
@@ -556,8 +559,8 @@ public boolean processLine(String line) {
    */
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(File file, Charset charset, LineProcessor<T> callback)
-      throws IOException {
+  public
+  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(file, charset).readLines(callback);
   }
 
@@ -575,7 +578,8 @@ public boolean processLine(String line) {
    */
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
+  public
+  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
     return asByteSource(file).read(processor);
   }
 
@@ -591,7 +595,8 @@ public boolean processLine(String line) {
    *     be removed in January 2019.
    */
   @Deprecated
-  public static HashCode hash(File file, HashFunction hashFunction) throws IOException {
+  public
+  static HashCode hash(File file, HashFunction hashFunction) throws IOException {
     return asByteSource(file).hash(hashFunction);
   }
 , @@ -331,7 +331,8 @@ public static void copy(File from, File to) throws IOException {
    *     be removed in January 2019.
    */
   @Deprecated
-  public static void copy(File from, Charset charset, Appendable to) throws IOException {
+  public
+  static void copy(File from, Charset charset, Appendable to) throws IOException {
     asCharSource(from, charset).copyTo(to);
   }
 
@@ -347,7 +348,8 @@ public static void copy(File from, Charset charset, Appendable to) throws IOExce
    *     method is scheduled to be removed in January 2019.
    */
   @Deprecated
-  public static void append(CharSequence from, File to, Charset charset) throws IOException {
+  public
+  static void append(CharSequence from, File to, Charset charset) throws IOException {
     asCharSink(to, charset, FileWriteMode.APPEND).write(from);
   }
 
@@ -500,7 +502,8 @@ public static void move(File from, File to) throws IOException {
    *     scheduled to be removed in January 2019.
    */
   @Deprecated
-  public static String readFirstLine(File file, Charset charset) throws IOException {
+  public
+  static String readFirstLine(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).readFirstLine();
   }
 
@@ -556,8 +559,8 @@ public boolean processLine(String line) {
    */
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(File file, Charset charset, LineProcessor<T> callback)
-      throws IOException {
+  public
+  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(file, charset).readLines(callback);
   }
 
@@ -575,7 +578,8 @@ public boolean processLine(String line) {
    */
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
+  public
+  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
     return asByteSource(file).read(processor);
   }
 
@@ -591,7 +595,8 @@ public boolean processLine(String line) {
    *     be removed in January 2019.
    */
   @Deprecated
-  public static HashCode hash(File file, HashFunction hashFunction) throws IOException {
+  public
+  static HashCode hash(File file, HashFunction hashFunction) throws IOException {
     return asByteSource(file).hash(hashFunction);
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Hide Files methods that are @Deprecated internally

cf8ea79dc50d7c0441045b020873561a4bb3791b",Moe Sync
3359,Ron Shapiro,"['android/guava/src/com/google/common/collect/Range.java', 'guava/src/com/google/common/collect/Range.java']","@@ -161,6 +161,7 @@ public Cut apply(Range range) {
    *
    * @throws IllegalArgumentException if {@code lower} is greater than <i>or equal to</i> {@code
    *     upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> open(C lower, C upper) {
@@ -172,6 +173,7 @@ public Cut apply(Range range) {
    * or equal to {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> closed(C lower, C upper) {
@@ -183,6 +185,7 @@ public Cut apply(Range range) {
    * less than {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> closedOpen(C lower, C upper) {
@@ -194,6 +197,7 @@ public Cut apply(Range range) {
    * equal to {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> openClosed(C lower, C upper) {
@@ -205,6 +209,7 @@ public Cut apply(Range range) {
    * endpoint may be either inclusive (closed) or exclusive (open).
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> range(
@@ -315,7 +320,7 @@ public Cut apply(Range range) {
    * Returns the minimal range that {@linkplain Range#contains(Comparable) contains} all of the
    * given values. The returned range is {@linkplain BoundType#CLOSED closed} on both ends.
    *
-   * @throws ClassCastException if the parameters are not <i>mutually comparable</i>
+   * @throws ClassCastException if the values are not mutually comparable
    * @throws NoSuchElementException if {@code values} is empty
    * @throws NullPointerException if any of {@code values} is null
    * @since 14.0, @@ -161,6 +161,7 @@ public Cut apply(Range range) {
    *
    * @throws IllegalArgumentException if {@code lower} is greater than <i>or equal to</i> {@code
    *     upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> open(C lower, C upper) {
@@ -172,6 +173,7 @@ public Cut apply(Range range) {
    * or equal to {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> closed(C lower, C upper) {
@@ -183,6 +185,7 @@ public Cut apply(Range range) {
    * less than {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> closedOpen(C lower, C upper) {
@@ -194,6 +197,7 @@ public Cut apply(Range range) {
    * equal to {@code upper}.
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> openClosed(C lower, C upper) {
@@ -205,6 +209,7 @@ public Cut apply(Range range) {
    * endpoint may be either inclusive (closed) or exclusive (open).
    *
    * @throws IllegalArgumentException if {@code lower} is greater than {@code upper}
+   * @throws ClassCastException if {@code lower} and {@code upper} are not mutually comparable
    * @since 14.0
    */
   public static <C extends Comparable<?>> Range<C> range(
@@ -315,7 +320,7 @@ public Cut apply(Range range) {
    * Returns the minimal range that {@linkplain Range#contains(Comparable) contains} all of the
    * given values. The returned range is {@linkplain BoundType#CLOSED closed} on both ends.
    *
-   * @throws ClassCastException if the parameters are not <i>mutually comparable</i>
+   * @throws ClassCastException if the values are not mutually comparable
    * @throws NoSuchElementException if {@code values} is empty
    * @throws NullPointerException if any of {@code values} is null
    * @since 14.0, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Specify that Range static factories can throw ClassCastException if the provided endpoints are not mutually comparable.

Fixes https://github.com/google/guava/issues/3343

RELNOTES=Specify that Range static factories can throw ClassCastException if the provided endpoints are not mutually comparable.

7b8f8bd9aa435b742079eb7e3fc7d56f122c3bd4",Moe Sync
3363,Ron Shapiro,['guava-gwt/test/com/google/common/html/testModule.gwt.xml'],"@@ -6,6 +6,7 @@
   <inherits name=""com.google.common.escape.testing.Testing""/>
   <inherits name=""com.google.common.html.Html""/>
   <inherits name=""com.google.common.truth.Truth""/>
+  <inherits name=""auto.Auto_value""/>
   <inherits name=""com.google.javascript.rhino.Token_stream""/>
   <entry-point class=""com.google.common.html.TestModuleEntryPoint""/>
    , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct the spelling of the Range class.

It's Range not Ranges.

40993be1bf4c7dc33190b20d9712bea7f6487af1",Moe Sync
3393,Ron Shapiro,"['guava-gwt/src-super/java/lang/Lang.gwt.xml', 'guava-gwt/src-super/java/lang/super/java/lang/InterruptedException.java', 'guava-gwt/src-super/java/util/Util.gwt.xml', 'guava-gwt/src-super/java/util/super/java/util/concurrent/Callable.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/CancellationException.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/ConcurrentHashMap.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/ConcurrentMap.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/Delayed.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/ExecutionException.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/Executor.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/Executors.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/Future.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/RejectedExecutionException.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/RunnableFuture.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/ScheduledFuture.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/TimeUnit.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/TimeoutException.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/atomic/AtomicBoolean.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/atomic/AtomicInteger.java', 'guava-gwt/src-super/java/util/super/java/util/concurrent/atomic/AtomicLong.java']","@@ -1 +0,0 @@
-<module><super-source path=""super""/></module>
\ No newline at end of file, @@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2012 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.lang;
-
-/**
- * Minimal emulation of {@link java.lang.InterruptedException}, that should only be used in method
- * signatures. New GWT code should not reference this class at all. It is here only to ease the
- * GWTification of common code.
- *
- * @author Tom O'Neill
- */
-public class InterruptedException extends Exception {
-  public InterruptedException() {}
-
-  public InterruptedException(String message) {
-    super(message);
-  }
-}, @@ -1,6 +0,0 @@
-
-<module>
- <super-source path=""super""/>
- <inherits name=""java.lang.Lang""/>
-</module>
-, @@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/**
- * Emulation of Callable.
- *
- * @author Charles Fry
- */
-public interface Callable<V> {
-  V call() throws Exception;
-}, @@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/** Emulation of CancellationException. */
-public class CancellationException extends IllegalStateException {
-
-  public CancellationException() {}
-
-  public CancellationException(String message) {
-    super(message);
-  }
-}, @@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2009 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-import java.util.AbstractMap;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Minimal emulation of {@link java.util.concurrent.ConcurrentHashMap}. Note that the javascript
- * interpreter is <a
- * href=""http://code.google.com/docreader/#p=google-web-toolkit-doc-1-5&t=DevGuideJavaCompatibility"">
- * single-threaded</a>, it is essentially a {@link java.util.HashMap}, implementing the new methods
- * introduced by {@link ConcurrentMap}.
- *
- * @author Hayward Chan
- */
-public class ConcurrentHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
-
-  private final Map<K, V> backingMap;
-
-  public ConcurrentHashMap() {
-    this.backingMap = new HashMap<K, V>();
-  }
-
-  public ConcurrentHashMap(int initialCapacity) {
-    this.backingMap = new HashMap<K, V>(initialCapacity);
-  }
-
-  public ConcurrentHashMap(int initialCapacity, float loadFactor) {
-    this.backingMap = new HashMap<K, V>(initialCapacity, loadFactor);
-  }
-
-  public ConcurrentHashMap(Map<? extends K, ? extends V> t) {
-    this.backingMap = new HashMap<K, V>(t);
-  }
-
-  public V putIfAbsent(K key, V value) {
-    if (!containsKey(key)) {
-      return put(key, value);
-    } else {
-      return get(key);
-    }
-  }
-
-  public boolean remove(Object key, Object value) {
-    if (containsKey(key) && get(key).equals(value)) {
-      remove(key);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  public boolean replace(K key, V oldValue, V newValue) {
-    if (oldValue == null || newValue == null) {
-      throw new NullPointerException();
-    } else if (containsKey(key) && get(key).equals(oldValue)) {
-      put(key, newValue);
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  public V replace(K key, V value) {
-    if (value == null) {
-      throw new NullPointerException();
-    } else if (containsKey(key)) {
-      return put(key, value);
-    } else {
-      return null;
-    }
-  }
-
-  @Override
-  public boolean containsKey(Object key) {
-    if (key == null) {
-      throw new NullPointerException();
-    }
-    return backingMap.containsKey(key);
-  }
-
-  @Override
-  public V get(Object key) {
-    if (key == null) {
-      throw new NullPointerException();
-    }
-    return backingMap.get(key);
-  }
-
-  @Override
-  public V put(K key, V value) {
-    if (key == null || value == null) {
-      throw new NullPointerException();
-    }
-    return backingMap.put(key, value);
-  }
-
-  @Override
-  public boolean containsValue(Object value) {
-    if (value == null) {
-      throw new NullPointerException();
-    }
-    return backingMap.containsValue(value);
-  }
-
-  @Override
-  public V remove(Object key) {
-    if (key == null) {
-      throw new NullPointerException();
-    }
-    return backingMap.remove(key);
-  }
-
-  @Override
-  public Set<Entry<K, V>> entrySet() {
-    return backingMap.entrySet();
-  }
-
-  public boolean contains(Object value) {
-    return containsValue(value);
-  }
-
-  public Enumeration<V> elements() {
-    return Collections.enumeration(values());
-  }
-
-  public Enumeration<K> keys() {
-    return Collections.enumeration(keySet());
-  }
-}, @@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2009 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-import java.util.Map;
-
-/**
- * Minimal GWT emulation of a map providing atomic operations.
- *
- * @author Jesse Wilson
- */
-public interface ConcurrentMap<K, V> extends Map<K, V> {
-
-  V putIfAbsent(K key, V value);
-
-  boolean remove(Object key, Object value);
-
-  V replace(K key, V value);
-
-  boolean replace(K key, V oldValue, V newValue);
-}, @@ -1,16 +0,0 @@
-/*
- * This file is a modified version of
- * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/Delayed.java?revision=1.11
- * which contained the following notice:
- *
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package java.util.concurrent;
-
-/** Emulation of Delayed. */
-public interface Delayed extends Comparable<Delayed> {
-  long getDelay(TimeUnit unit);
-}, @@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/**
- * Emulation of ExecutionException.
- *
- * @author Charles Fry
- */
-public class ExecutionException extends Exception {
-  protected ExecutionException() {}
-
-  protected ExecutionException(String message) {
-    super(message);
-  }
-
-  public ExecutionException(String message, Throwable cause) {
-    super(message, cause);
-  }
-
-  public ExecutionException(Throwable cause) {
-    super(cause);
-  }
-}, @@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/** Emulation of Executor. */
-public interface Executor {
-  void execute(Runnable command);
-}, @@ -1,47 +0,0 @@
-/*
- * This file is a modified version of
- * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/Executors.java?revision=1.90
- * which contained the following notice:
- *
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package java.util.concurrent;
-
-/** Emulation of executors. */
-public class Executors {
-
-  public static <T> Callable<T> callable(Runnable task, T result) {
-    if (task == null) {
-      throw new NullPointerException();
-    }
-    return new RunnableAdapter<T>(task, result);
-  }
-
-  public static Callable<Object> callable(Runnable task) {
-    if (task == null) {
-      throw new NullPointerException();
-    }
-    return new RunnableAdapter<Object>(task, null);
-  }
-
-  static final class RunnableAdapter<T> implements Callable<T> {
-
-    final Runnable task;
-    final T result;
-
-    RunnableAdapter(Runnable task, T result) {
-      this.task = task;
-      this.result = result;
-    }
-
-    public T call() {
-      task.run();
-      return result;
-    }
-  }
-
-  private Executors() {}
-}, @@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/**
- * Emulation of Future. Since GWT environment is single threaded, attempting to block on the future
- * by calling {@link #get()} or {@link #get(long, TimeUnit)} when the future is not yet done is
- * considered illegal because it would lead to a deadlock. Future implementations must throw {@link
- * IllegalStateException} to avoid a deadlock.
- *
- * @param <V> value type returned by the future.
- */
-public interface Future<V> {
-  boolean cancel(boolean mayInterruptIfRunning);
-
-  boolean isCancelled();
-
-  boolean isDone();
-
-  // Even though the 'get' methods below are blocking, they are the only built-in APIs to get the
-  // result of the {@code Future}, hence they are not removed. The implementation must throw {@link
-  // IllegalStateException} if the {@code Future} is not done yet (see the class javadoc).
-
-  V get() throws InterruptedException, ExecutionException;
-
-  V get(long timeout, TimeUnit unit)
-      throws InterruptedException, ExecutionException, TimeoutException;
-}, @@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/** GWT emulation of RejectedExecutionException. */
-public class RejectedExecutionException extends RuntimeException {
-  public RejectedExecutionException() {}
-
-  public RejectedExecutionException(String message) {
-    super(message);
-  }
-
-  public RejectedExecutionException(String message, Throwable cause) {
-    super(message, cause);
-  }
-
-  public RejectedExecutionException(Throwable cause) {
-    super(cause);
-  }
-}, @@ -1,20 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/** Emulation of RunnableFuture. */
-public interface RunnableFuture<V> extends Runnable, Future<V> {}, @@ -1,18 +0,0 @@
-/*
- * This file is a modified version of
- * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/ScheduledFuture.java?revision=1.6
- * which contained the following notice:
- *
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package java.util.concurrent;
-
-/**
- * Emulation of ScheduleFuture.
- *
- * @param <V> value type returned by the future.
- */
-public interface ScheduledFuture<V> extends Delayed, Future<V> {}, @@ -1,336 +0,0 @@
-/*
- * This file is a modified version of
- * http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/TimeUnit.java
- * which contained the following notice:
- *
- * Written by Doug Lea with assistance from members of JCP JSR-166
- * Expert Group and released to the public domain, as explained at
- * http://creativecommons.org/publicdomain/zero/1.0/
- */
-
-package java.util.concurrent;
-
-/**
- * GWT emulation of TimeUnit, created by removing unsupported operations from Doug Lea's public
- * domain version.
- */
-public enum TimeUnit {
-  NANOSECONDS {
-    public long toNanos(long d) {
-      return d;
-    }
-
-    public long toMicros(long d) {
-      return d / C1_C0;
-    }
-
-    public long toMillis(long d) {
-      return d / C2_C0;
-    }
-
-    public long toSeconds(long d) {
-      return d / C3_C0;
-    }
-
-    public long toMinutes(long d) {
-      return d / C4_C0;
-    }
-
-    public long toHours(long d) {
-      return d / C5_C0;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C0;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toNanos(d);
-    }
-  },
-  MICROSECONDS {
-    public long toNanos(long d) {
-      return x(d, C1_C0, MAX_C1_C0);
-    }
-
-    public long toMicros(long d) {
-      return d;
-    }
-
-    public long toMillis(long d) {
-      return d / C2_C1;
-    }
-
-    public long toSeconds(long d) {
-      return d / C3_C1;
-    }
-
-    public long toMinutes(long d) {
-      return d / C4_C1;
-    }
-
-    public long toHours(long d) {
-      return d / C5_C1;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C1;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toMicros(d);
-    }
-  },
-  MILLISECONDS {
-    public long toNanos(long d) {
-      return x(d, C2_C0, MAX_C2_C0);
-    }
-
-    public long toMicros(long d) {
-      return x(d, C2_C1, MAX_C2_C1);
-    }
-
-    public long toMillis(long d) {
-      return d;
-    }
-
-    public long toSeconds(long d) {
-      return d / C3_C2;
-    }
-
-    public long toMinutes(long d) {
-      return d / C4_C2;
-    }
-
-    public long toHours(long d) {
-      return d / C5_C2;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C2;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toMillis(d);
-    }
-  },
-  SECONDS {
-    public long toNanos(long d) {
-      return x(d, C3_C0, MAX_C3_C0);
-    }
-
-    public long toMicros(long d) {
-      return x(d, C3_C1, MAX_C3_C1);
-    }
-
-    public long toMillis(long d) {
-      return x(d, C3_C2, MAX_C3_C2);
-    }
-
-    public long toSeconds(long d) {
-      return d;
-    }
-
-    public long toMinutes(long d) {
-      return d / C4_C3;
-    }
-
-    public long toHours(long d) {
-      return d / C5_C3;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C3;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toSeconds(d);
-    }
-  },
-  MINUTES {
-    public long toNanos(long d) {
-      return x(d, C4_C0, MAX_C4_C0);
-    }
-
-    public long toMicros(long d) {
-      return x(d, C4_C1, MAX_C4_C1);
-    }
-
-    public long toMillis(long d) {
-      return x(d, C4_C2, MAX_C4_C2);
-    }
-
-    public long toSeconds(long d) {
-      return x(d, C4_C3, MAX_C4_C3);
-    }
-
-    public long toMinutes(long d) {
-      return d;
-    }
-
-    public long toHours(long d) {
-      return d / C5_C4;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C4;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toMinutes(d);
-    }
-  },
-  HOURS {
-    public long toNanos(long d) {
-      return x(d, C5_C0, MAX_C5_C0);
-    }
-
-    public long toMicros(long d) {
-      return x(d, C5_C1, MAX_C5_C1);
-    }
-
-    public long toMillis(long d) {
-      return x(d, C5_C2, MAX_C5_C2);
-    }
-
-    public long toSeconds(long d) {
-      return x(d, C5_C3, MAX_C5_C3);
-    }
-
-    public long toMinutes(long d) {
-      return x(d, C5_C4, MAX_C5_C4);
-    }
-
-    public long toHours(long d) {
-      return d;
-    }
-
-    public long toDays(long d) {
-      return d / C6_C5;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toHours(d);
-    }
-  },
-  DAYS {
-    public long toNanos(long d) {
-      return x(d, C6_C0, MAX_C6_C0);
-    }
-
-    public long toMicros(long d) {
-      return x(d, C6_C1, MAX_C6_C1);
-    }
-
-    public long toMillis(long d) {
-      return x(d, C6_C2, MAX_C6_C2);
-    }
-
-    public long toSeconds(long d) {
-      return x(d, C6_C3, MAX_C6_C3);
-    }
-
-    public long toMinutes(long d) {
-      return x(d, C6_C4, MAX_C6_C4);
-    }
-
-    public long toHours(long d) {
-      return x(d, C6_C5, MAX_C6_C5);
-    }
-
-    public long toDays(long d) {
-      return d;
-    }
-
-    public long convert(long d, TimeUnit u) {
-      return u.toDays(d);
-    }
-  };
-
-  // Handy constants for conversion methods
-  private static final long C0 = 1L;
-  private static final long C1 = C0 * 1000L;
-  private static final long C2 = C1 * 1000L;
-  private static final long C3 = C2 * 1000L;
-  private static final long C4 = C3 * 60L;
-  private static final long C5 = C4 * 60L;
-  private static final long C6 = C5 * 24L;
-
-  private static final long MAX = Long.MAX_VALUE;
-
-  private static final long C6_C0 = C6 / C0;
-  private static final long C6_C1 = C6 / C1;
-  private static final long C6_C2 = C6 / C2;
-  private static final long C6_C3 = C6 / C3;
-  private static final long C6_C4 = C6 / C4;
-  private static final long C6_C5 = C6 / C5;
-
-  private static final long C5_C0 = C5 / C0;
-  private static final long C5_C1 = C5 / C1;
-  private static final long C5_C2 = C5 / C2;
-  private static final long C5_C3 = C5 / C3;
-  private static final long C5_C4 = C5 / C4;
-
-  private static final long C4_C0 = C4 / C0;
-  private static final long C4_C1 = C4 / C1;
-  private static final long C4_C2 = C4 / C2;
-  private static final long C4_C3 = C4 / C3;
-
-  private static final long C3_C0 = C3 / C0;
-  private static final long C3_C1 = C3 / C1;
-  private static final long C3_C2 = C3 / C2;
-
-  private static final long C2_C0 = C2 / C0;
-  private static final long C2_C1 = C2 / C1;
-
-  private static final long C1_C0 = C1 / C0;
-
-  private static final long MAX_C6_C0 = MAX / C6_C0;
-  private static final long MAX_C6_C1 = MAX / C6_C1;
-  private static final long MAX_C6_C2 = MAX / C6_C2;
-  private static final long MAX_C6_C3 = MAX / C6_C3;
-  private static final long MAX_C6_C4 = MAX / C6_C4;
-  private static final long MAX_C6_C5 = MAX / C6_C5;
-
-  private static final long MAX_C5_C0 = MAX / C5_C0;
-  private static final long MAX_C5_C1 = MAX / C5_C1;
-  private static final long MAX_C5_C2 = MAX / C5_C2;
-  private static final long MAX_C5_C3 = MAX / C5_C3;
-  private static final long MAX_C5_C4 = MAX / C5_C4;
-
-  private static final long MAX_C4_C0 = MAX / C4_C0;
-  private static final long MAX_C4_C1 = MAX / C4_C1;
-  private static final long MAX_C4_C2 = MAX / C4_C2;
-  private static final long MAX_C4_C3 = MAX / C4_C3;
-
-  private static final long MAX_C3_C0 = MAX / C3_C0;
-  private static final long MAX_C3_C1 = MAX / C3_C1;
-  private static final long MAX_C3_C2 = MAX / C3_C2;
-
-  private static final long MAX_C2_C0 = MAX / C2_C0;
-  private static final long MAX_C2_C1 = MAX / C2_C1;
-
-  private static final long MAX_C1_C0 = MAX / C1_C0;
-
-  static long x(long d, long m, long over) {
-    if (d > over) return Long.MAX_VALUE;
-    if (d < -over) return Long.MIN_VALUE;
-    return d * m;
-  }
-
-  public abstract long convert(long sourceDuration, TimeUnit sourceUnit);
-
-  public abstract long toNanos(long duration);
-
-  public abstract long toMicros(long duration);
-
-  public abstract long toMillis(long duration);
-
-  public abstract long toSeconds(long duration);
-
-  public abstract long toMinutes(long duration);
-
-  public abstract long toHours(long duration);
-
-  public abstract long toDays(long duration);
-}, @@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent;
-
-/** Emulation of TimeoutException. */
-public class TimeoutException extends Exception {
-  public TimeoutException() {}
-
-  public TimeoutException(String message) {
-    super(message);
-  }
-}, @@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2015 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/**
- * Atomically sets the value to the given updated value if the current value {@code ==} the expected
- * value.
- *
- * <p>May <a href=""package-summary.html#Spurious"">fail spuriously</a> and does not provide ordering
- * guarantees, so is only rarely an appropriate alternative to {@code compareAndSet}.
- *
- * @param expect the expected value
- * @param update the new value
- * @return true if successful.
- */
-package java.util.concurrent.atomic;
-
-/** GWT emulation of AtomicBoolean. */
-public class AtomicBoolean implements java.io.Serializable {
-  private boolean value;
-
-  public AtomicBoolean(boolean initialValue) {
-    value = initialValue;
-  }
-
-  public AtomicBoolean() {}
-
-  public final boolean get() {
-    return value;
-  }
-
-  public final boolean compareAndSet(boolean expect, boolean update) {
-    if (get() == expect) {
-      set(update);
-      return true;
-    }
-
-    return false;
-  }
-
-  public boolean weakCompareAndSet(boolean expect, boolean update) {
-    return compareAndSet(expect, update);
-  }
-
-  public final void set(boolean newValue) {
-    value = newValue;
-  }
-
-  public final void lazySet(boolean newValue) {
-    set(newValue);
-  }
-
-  public final boolean getAndSet(boolean newValue) {
-    boolean current = get();
-    set(newValue);
-    return current;
-  }
-
-  public String toString() {
-    return Boolean.toString(get());
-  }
-}, @@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2009 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent.atomic;
-
-/**
- * GWT emulated version of {@link AtomicInteger}. It's a thin wrapper around the primitive {@code
- * int}.
- *
- * @author Hayward Chan
- */
-public class AtomicInteger extends Number implements java.io.Serializable {
-
-  private int value;
-
-  public AtomicInteger(int initialValue) {
-    value = initialValue;
-  }
-
-  public AtomicInteger() {}
-
-  public final int get() {
-    return value;
-  }
-
-  public final void set(int newValue) {
-    value = newValue;
-  }
-
-  public final void lazySet(int newValue) {
-    set(newValue);
-  }
-
-  public final int getAndSet(int newValue) {
-    int current = value;
-    value = newValue;
-    return current;
-  }
-
-  public final boolean compareAndSet(int expect, int update) {
-    if (value == expect) {
-      value = update;
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  public final int getAndIncrement() {
-    return value++;
-  }
-
-  public final int getAndDecrement() {
-    return value--;
-  }
-
-  public final int getAndAdd(int delta) {
-    int current = value;
-    value += delta;
-    return current;
-  }
-
-  public final int incrementAndGet() {
-    return ++value;
-  }
-
-  public final int decrementAndGet() {
-    return --value;
-  }
-
-  public final int addAndGet(int delta) {
-    value += delta;
-    return value;
-  }
-
-  @Override
-  public String toString() {
-    return Integer.toString(value);
-  }
-
-  public int intValue() {
-    return value;
-  }
-
-  public long longValue() {
-    return (long) value;
-  }
-
-  public float floatValue() {
-    return (float) value;
-  }
-
-  public double doubleValue() {
-    return (double) value;
-  }
-}, @@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package java.util.concurrent.atomic;
-
-/**
- * GWT emulated version of {@link AtomicLong}. It's a thin wrapper around the primitive {@code
- * long}.
- *
- * @author Jige Yu
- */
-public class AtomicLong extends Number implements java.io.Serializable {
-
-  private long value;
-
-  public AtomicLong(long initialValue) {
-    this.value = initialValue;
-  }
-
-  public AtomicLong() {}
-
-  public final long get() {
-    return value;
-  }
-
-  public final void set(long newValue) {
-    value = newValue;
-  }
-
-  public final void lazySet(long newValue) {
-    set(newValue);
-  }
-
-  public final long getAndSet(long newValue) {
-    long current = value;
-    value = newValue;
-    return current;
-  }
-
-  public final boolean compareAndSet(long expect, long update) {
-    if (value == expect) {
-      value = update;
-      return true;
-    } else {
-      return false;
-    }
-  }
-
-  public final long getAndIncrement() {
-    return value++;
-  }
-
-  public final long getAndDecrement() {
-    return value--;
-  }
-
-  public final long getAndAdd(long delta) {
-    long current = value;
-    value += delta;
-    return current;
-  }
-
-  public final long incrementAndGet() {
-    return ++value;
-  }
-
-  public final long decrementAndGet() {
-    return --value;
-  }
-
-  public final long addAndGet(long delta) {
-    value += delta;
-    return value;
-  }
-
-  @Override
-  public String toString() {
-    return Long.toString(value);
-  }
-
-  public int intValue() {
-    return (int) value;
-  }
-
-  public long longValue() {
-    return value;
-  }
-
-  public float floatValue() {
-    return (float) value;
-  }
-
-  public double doubleValue() {
-    return (double) value;
-  }
-}, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add Report-To header.

https://www.w3.org/TR/reporting/

504978f1032ab9b6284ffadd1f94bdb7c870557a

-------

<p> Remove unused imports and warnings.

Fixes #3356

f0945a2ca741ead2a435cf52ddae2217763cc092

-------

<p> Reformat with google-java-format

RELNOTES=N/A

7809097021927058b21523e7b4d24d1f7fdb91b8

-------

<p> Add missing @Override annotations

8843b6ca39c8baddcf01991ea34ad91f87b30d82

-------

<p> Document the retention of listeners added to Guava implementations of ListenableFuture.

RELNOTES=Document the retention of listeners added to Guava implementations of `ListenableFuture`.

f6287e1b85eb4daf5678d252aaaf215a82f4fd2d

-------

<p> Reformat with google-java-format

RELNOTES=N/A

28cff42bc92b7685937c5771868167e0c03155d3

-------

<p> Name the method parameter 'unused' for ImmutableSortedSet.readObject(ObjectInputStream) (so the static analysis doesn't complain)

0967c796d6e6be72b0d9e8d68af66d6a7b524b54

-------

<p> Remove @Beta from APIs:

collect
- most Collectors (aside from BloomFilter and ImmutableRange*, as those whole classes are @Beta (though I did remove the redundant @Beta annotation from the Collector-returning methods for clarity))
- Maps: asConverter, immutableEnumMap
- MultimapBuilder
- Streams: stream(Iterable), concat

io
- ByteStreams: copy, toByteArray
- CharStreams: copy, toString
- Files: as(Char|Byte)(Source|Sink)

util.concurrent
- Futures: addCallback, getDone, getUnchecked, immediateCancelledFuture, immediateFailedFuture, immediateFuture
- ListeningScheduledExecutorService
- Uninterruptibles

other
- HtmlEscapers
- Splitter.splitToList
- Ticker

Fixes https://github.com/google/guava/pull/3287
Fixes https://github.com/google/guava/issues/3251 (aside from ImmutableRange*, but those whole classes are @Beta, anyway)
Addresses the main concerns of https://github.com/google/guava/issues/3285 but doesn't cover the broader request
Fixes https://github.com/google/guava/issues/3340
Partially addresses https://github.com/google/guava/issues/3239

RELNOTES=Removed `@Beta` from a number of frequently used APIs.

068cb9005cc701ed98e31df9b56117b86df21d0f

-------

<p> Add some known UTF-8 hash values to Murmur3_32 tests. UTF-8 is more comparable between platforms than relying on Java's internal encoding.

e7ec53773bcf89533496de1611ac4dddd876fb54

-------

<p> Remove @CanIgnoreReturnValue from Ordering.sortedCopy() and immutableSortedCopy().

RELNOTES=Remove `@CanIgnoreReturnValue` from `Ordering.sortedCopy()` and `immutableSortedCopy()`.

da2895f5c3a55b84771488e0f8a38c67e0f63543

-------

<p> Make a constructor private.

(I'm looking into EnumMap stuff for other reasons, and I got to wondering if this was used outside the file. Nope.)

b1933ce7d8c8ff0fac90b494b33ab8af159e1906

-------

<p> Delete WellBehavedMap.

The bug it worked around was fixed in Java 7:
https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6312706

And I don't believe it was ever present under Android:
https://android.googlesource.com/platform/libcore/+/fdb2704414a9ed92394ada0d1395e4db86889465/luni/src/main/java/java/util/EnumMap.java#146

I haven't looked for the absolute first version ever of GWT, but the still very old GWT file doesn't have the bug, either.

Deleting this class will simplify some work I'm doing around our EnumMap usage for j2cl.

2115c74c21ab47c3a41c2fb73a16aa6d051bf784

-------

<p> Internal GWT change

1d49ade94c3e7d2c056893a630739c8a6b897f66

-------

<p> Automated rollback of commit 1d49ade94c3e7d2c056893a630739c8a6b897f66

*** Original change description ***

Internal GWT change

***

46a2123f4b077840b4b466fe6344579ac4b52bad

-------

<p> Use J2ObjC's @RetainedWith annotation instead of @Weak on ImmutableMap.keySet
to prevent crashes on iOS.

TESTED=Created a map inside a autorelease pool and saved a reference to the
keyset. Checked that the keyset functions correctly outside the autorelease
pool. Checked that both the keyset and the map are deallocated by the
autorelease pool when not holding a reference to the keyset. Did this test with
both ImmutableMap.of(<2 entries>) and ImmutableBiMap.of(<2 entries>).

RELNOTES=J2ObjC: Fixes crashes from use of `ImmutableMap.keySet()`.

76c954518752acb36256009840ed004eef412291

-------

<p> Annotate checkNotNull's input and output as @NonNull.

We don't want to go down the road of annotating most things @NonNull, as we eventually want to use tools that assume that that's the default. However, it's pretty weird for checkNotNull() to return a @Nullable value in the minds of some tools, so let's annotate just that method and see how it goes.

RELNOTES=Annotated `checkNotNull`'s input and output as `@NonNull`.

63d0b31e62b4d4da33ec61a1d84d026391ffd126

-------

<p> Document the JDK 9+ alternative to `Maps#immutableEntry`

Fixes #3385

998858f9abd06b3774bf72a3b4f2fdaa18a88ceb

-------

<p> Modernize book reference.

7eafede7552490351956e8038bb07596b227e3ef

-------

<p> Create constants for the SourceMap header

None of the tests like this header name, so each required some workarounds.

RELNOTES=Add the SourceMap header to HttpHeaders

81f191e80265001b3dc8b4544cd0bb277a05ba7b

-------

<p> Internal GWT change

db6ada7b4f9db07b8de6ec549ca7e2ab6079b354

-------

<p> Use J2ObjC's @RetainedWith annotation instead of @Weak on ImmutableMap.values
to prevent crashes on iOS.

TESTED=Created a map inside an autorelease pool and saved a reference to the
values collection. Checked that the values collection functions correctly
outside the autorelease pool. Checked that both the values collection and the
map are deallocated by the autorelease pool when not holding a strong reference
to the values collection. Did this test with ImmutableMap.of(<2 entries>) and
ImmutableMap.copyOf(<EnumMap with 2 entries>).

RELNOTES=J2ObjC: Fixes crashes from use of `ImmutableMap.values()`.

05ac56322f6c3a4b0109aab2b46671716f109cb5

-------

<p> Fix Javadoc breakage under JDK11 canary.

https://bugs.openjdk.java.net/browse/JDK-8212233
https://bugs.openjdk.java.net/browse/JDK-8193030

d8bdef58d54712286d86a9146778d25614fd3c9a

-------

<p> Remove GWT emulations that are no longer needed as of GWT 2.8.2.

RELNOTES=Removed GWT emulations that are no longer needed as of GWT 2.8.2. This means that GWT projects that use this version of Guava must use GWT 2.8.2 or higher.

be02df5ad4a530d5cb206a7042de8c2f5dbbff32",Moe Sync
3399,Ron Shapiro,"['android/guava/src/com/google/common/collect/ImmutableMap.java', 'android/guava/src/com/google/common/collect/ImmutableMapEntrySet.java', 'android/guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava/src/com/google/common/collect/ImmutableMap.java', 'guava/src/com/google/common/collect/ImmutableMapEntrySet.java', 'guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava/src/com/google/common/collect/RegularImmutableBiMap.java']","@@ -415,7 +415,6 @@ void sortEntries() {
 
     @Override
     ImmutableSet<Entry<K, V>> createEntrySet() {
-      @WeakOuter
       class EntrySetImpl extends ImmutableMapEntrySet<K, V> {
         @Override
         ImmutableMap<K, V> map() {
@@ -524,7 +523,7 @@ public final V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultVal
     return (result != null) ? result : defaultValue;
   }
 
-  @LazyInit private transient ImmutableSet<Entry<K, V>> entrySet;
+  @LazyInit @RetainedWith private transient ImmutableSet<Entry<K, V>> entrySet;
 
   /**
    * Returns an immutable set of the mappings in this map. The iteration order is specified by the, @@ -18,7 +18,6 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.j2objc.annotations.Weak;
 import java.io.Serializable;
 import java.util.Map.Entry;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
@@ -32,7 +31,7 @@
 @GwtCompatible(emulated = true)
 abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet<Entry<K, V>> {
   static final class RegularEntrySet<K, V> extends ImmutableMapEntrySet<K, V> {
-    @Weak private final transient ImmutableMap<K, V> map;
+    private final transient ImmutableMap<K, V> map;
     private final transient ImmutableList<Entry<K, V>> entries;
 
     RegularEntrySet(ImmutableMap<K, V> map, Entry<K, V>[] entries) {, @@ -24,7 +24,6 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractMap;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -582,7 +581,6 @@ boolean isPartialView() {
 
   @Override
   ImmutableSet<Entry<K, V>> createEntrySet() {
-    @WeakOuter
     class EntrySet extends ImmutableMapEntrySet<K, V> {
       @Override
       public UnmodifiableIterator<Entry<K, V>> iterator() {, @@ -492,7 +492,6 @@ private void ensureCapacity(int minCapacity) {
 
     @Override
     ImmutableSet<Entry<K, V>> createEntrySet() {
-      @WeakOuter
       class EntrySetImpl extends ImmutableMapEntrySet<K, V> {
         @Override
         ImmutableMap<K, V> map() {
@@ -705,7 +704,7 @@ public final V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
     return (result != null) ? result : defaultValue;
   }
 
-  @LazyInit private transient ImmutableSet<Entry<K, V>> entrySet;
+  @LazyInit @RetainedWith private transient ImmutableSet<Entry<K, V>> entrySet;
 
   /**
    * Returns an immutable set of the mappings in this map. The iteration order is specified by the, @@ -18,7 +18,6 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import com.google.j2objc.annotations.Weak;
 import java.io.Serializable;
 import java.util.Map.Entry;
 import java.util.Spliterator;
@@ -34,7 +33,7 @@
 @GwtCompatible(emulated = true)
 abstract class ImmutableMapEntrySet<K, V> extends ImmutableSet<Entry<K, V>> {
   static final class RegularEntrySet<K, V> extends ImmutableMapEntrySet<K, V> {
-    @Weak private final transient ImmutableMap<K, V> map;
+    private final transient ImmutableMap<K, V> map;
     private final transient ImmutableList<Entry<K, V>> entries;
 
     RegularEntrySet(ImmutableMap<K, V> map, Entry<K, V>[] entries) {, @@ -24,7 +24,6 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractMap;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -606,7 +605,6 @@ boolean isPartialView() {
 
   @Override
   ImmutableSet<Entry<K, V>> createEntrySet() {
-    @WeakOuter
     class EntrySet extends ImmutableMapEntrySet<K, V> {
       @Override
       public UnmodifiableIterator<Entry<K, V>> iterator() {, @@ -28,7 +28,6 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.Serializable;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
@@ -234,7 +233,6 @@ public K get(@Nullable Object value) {
       return new InverseEntrySet();
     }
 
-    @WeakOuter
     final class InverseEntrySet extends ImmutableMapEntrySet<V, K> {
       @Override
       ImmutableMap<V, K> map() {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use J2ObjC's @RetainedWith annotation instead of @Weak on
ImmutableMap.entrySet() to prevent crashes on iOS.

TESTED=Created a map inside an autorelease pool and saved a reference to the
entry set. Checked that the entry set functions correctly outside the
autorelease pool. Checked that both the entry set and the are deallocated by the
autorelease pool when not holding a strong reference to the entry set. Did this
test with the following constructions to cover all entry set implementations:
- ImmutableMap.of(<2 entries>)
- ImmutableMap.copyOf(<EnumMap with 2 entries>)
- ImmutableSortedMap.of(<2 entries>)
- ImmutableBiMap.of(<2 entries>).inverse()

RELNOTES=J2ObjC: Fixes crashes from use of ImmutableMap.entrySet().

c4eef3f4fa8f30fef8061d3ea2197fb427ee3cfd",Moe Sync
3404,Ron Shapiro,"['android/guava-tests/test/com/google/common/collect/CompactHashMapTest.java', 'android/guava-tests/test/com/google/common/collect/CompactHashSetTest.java', 'android/guava-tests/test/com/google/common/collect/CompactLinkedHashMapTest.java', 'android/guava-tests/test/com/google/common/collect/CompactLinkedHashSetTest.java', 'android/guava/src/com/google/common/collect/CompactHashMap.java', 'android/guava/src/com/google/common/collect/CompactHashSet.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashSet.java', 'guava-tests/test/com/google/common/collect/CompactHashMapTest.java', 'guava-tests/test/com/google/common/collect/CompactHashSetTest.java', 'guava-tests/test/com/google/common/collect/CompactLinkedHashMapTest.java', 'guava-tests/test/com/google/common/collect/CompactLinkedHashSetTest.java', 'guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/CompactHashSet.java', 'guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'guava/src/com/google/common/collect/CompactLinkedHashSet.java']","@@ -85,4 +85,35 @@ public void testEntrySetValueAfterRemoved() {
     entry.setValue(""one"");
     assertThat(map).containsEntry(1, ""one"");
   }
+
+  public void testAllocArraysDefault() {
+    CompactHashMap<Integer, String> map = CompactHashMap.create();
+    assertThat(map.needsAllocArrays()).isTrue();
+    assertThat(map.entries).isNull();
+    assertThat(map.keys).isNull();
+    assertThat(map.values).isNull();
+
+    map.put(1, ""1"");
+    assertThat(map.needsAllocArrays()).isFalse();
+    assertThat(map.entries).hasLength(CompactHashMap.DEFAULT_SIZE);
+    assertThat(map.keys).hasLength(CompactHashMap.DEFAULT_SIZE);
+    assertThat(map.values).hasLength(CompactHashMap.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashMap.DEFAULT_SIZE; i++) {
+      CompactHashMap<Integer, String> map = CompactHashMap.createWithExpectedSize(i);
+      assertThat(map.needsAllocArrays()).isTrue();
+      assertThat(map.entries).isNull();
+      assertThat(map.keys).isNull();
+      assertThat(map.values).isNull();
+
+      map.put(1, ""1"");
+      assertThat(map.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(map.entries).hasLength(expectedSize);
+      assertThat(map.keys).hasLength(expectedSize);
+      assertThat(map.values).hasLength(expectedSize);
+    }
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.SetTestSuiteBuilder;
 import com.google.common.collect.testing.TestStringSetGenerator;
@@ -83,7 +85,26 @@ public static Test suite() {
     return suite;
   }
 
-  public void testDummyMethod() {
-    // Just make sure the test runner doesn't complain about no test methods.
+  public void testAllocArraysDefault() {
+    CompactHashSet<Integer> set = CompactHashSet.create();
+    assertThat(set.needsAllocArrays()).isTrue();
+    assertThat(set.elements).isNull();
+
+    set.add(1);
+    assertThat(set.needsAllocArrays()).isFalse();
+    assertThat(set.elements).hasLength(CompactHashSet.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashSet.DEFAULT_SIZE; i++) {
+      CompactHashSet<Integer> set = CompactHashSet.createWithExpectedSize(i);
+      assertThat(set.needsAllocArrays()).isTrue();
+      assertThat(set.elements).isNull();
+
+      set.add(1);
+      assertThat(set.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(set.elements).hasLength(expectedSize);
+    }
   }
 }, @@ -141,4 +141,39 @@ private void testHasMapEntriesInOrder(Map<?, ?> map, Object... alternatingKeysAn
       assertEquals(expectedValue, values.get(i));
     }
   }
+
+  public void testAllocArraysDefault() {
+    CompactLinkedHashMap<Integer, String> map = CompactLinkedHashMap.create();
+    assertThat(map.needsAllocArrays()).isTrue();
+    assertThat(map.entries).isNull();
+    assertThat(map.keys).isNull();
+    assertThat(map.values).isNull();
+    assertThat(map.links).isNull();
+
+    map.put(1, Integer.toString(1));
+    assertThat(map.needsAllocArrays()).isFalse();
+    assertThat(map.entries).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.keys).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.values).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.links).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactLinkedHashMap.DEFAULT_SIZE; i++) {
+      CompactLinkedHashMap<Integer, String> map = CompactLinkedHashMap.createWithExpectedSize(i);
+      assertThat(map.needsAllocArrays()).isTrue();
+      assertThat(map.entries).isNull();
+      assertThat(map.keys).isNull();
+      assertThat(map.values).isNull();
+      assertThat(map.links).isNull();
+
+      map.put(1, Integer.toString(1));
+      assertThat(map.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(map.entries).hasLength(expectedSize);
+      assertThat(map.keys).hasLength(expectedSize);
+      assertThat(map.values).hasLength(expectedSize);
+      assertThat(map.links).hasLength(expectedSize);
+    }
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.SetTestSuiteBuilder;
 import com.google.common.collect.testing.TestStringSetGenerator;
@@ -65,7 +67,26 @@ public static Test suite() {
     return suite;
   }
 
-  public void testDummyMethod() {
-    // Just make sure the test runner doesn't complain about no test methods.
+  public void testAllocArraysDefault() {
+    CompactHashSet<Integer> set = CompactHashSet.create();
+    assertThat(set.needsAllocArrays()).isTrue();
+    assertThat(set.elements).isNull();
+
+    set.add(1);
+    assertThat(set.needsAllocArrays()).isFalse();
+    assertThat(set.elements).hasLength(CompactHashSet.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashSet.DEFAULT_SIZE; i++) {
+      CompactHashSet<Integer> set = CompactHashSet.createWithExpectedSize(i);
+      assertThat(set.needsAllocArrays()).isTrue();
+      assertThat(set.elements).isNull();
+
+      set.add(1);
+      assertThat(set.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(set.elements).hasLength(expectedSize);
+    }
   }
 }, @@ -26,6 +26,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
+import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -169,20 +170,40 @@
    * @param capacity the initial capacity of this {@code CompactHashMap}.
    */
   CompactHashMap(int capacity) {
-    this(capacity, DEFAULT_LOAD_FACTOR);
+    init(capacity, DEFAULT_LOAD_FACTOR);
   }
 
-  CompactHashMap(int expectedSize, float loadFactor) {
-    init(expectedSize, loadFactor);
+  /**
+   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load
+   * factor.
+   *
+   * @param capacity the initial capacity of this {@code CompactHashMap}.
+   * @param loadFactor the load factor of this {@code CompactHashMap}.
+   */
+  CompactHashMap(int capacity, float loadFactor) {
+    init(capacity, loadFactor);
   }
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize, float loadFactor) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
     Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
+    this.loadFactor = loadFactor;
+    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+  }
+
+  /** Returns whether arrays need to be allocated. */
+  boolean needsAllocArrays() {
+    return table == null;
+  }
+
+  /** Handle lazy allocation of arrays. */
+  void allocArrays() {
+    Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
+
+    int expectedSize = threshold;
     int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
     this.table = newTable(buckets);
-    this.loadFactor = loadFactor;
 
     this.keys = new Object[expectedSize];
     this.values = new Object[expectedSize];
@@ -233,6 +254,9 @@ void accessEntry(int index) {
   @Override
   @NullableDecl
   public V put(@NullableDecl K key, @NullableDecl V value) {
+    if (needsAllocArrays()) {
+      allocArrays();
+    }
     long[] entries = this.entries;
     Object[] keys = this.keys;
     Object[] values = this.values;
@@ -285,7 +309,7 @@ void insertEntry(int entryIndex, @NullableDecl K key, @NullableDecl V value, int
     this.values[entryIndex] = value;
   }
 
-  /** Returns currentSize + 1, after resizing the entries storage if necessary. */
+  /** Resizes the entries storage if necessary. */
   private void resizeMeMaybe(int newSize) {
     int entriesSize = entries.length;
     if (newSize > entriesSize) {
@@ -341,6 +365,9 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
   }
 
   private int indexOf(@NullableDecl Object key) {
+    if (needsAllocArrays()) {
+      return -1;
+    }
     int hash = smearedHash(key);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -370,6 +397,9 @@ public V get(@NullableDecl Object key) {
   @Override
   @NullableDecl
   public V remove(@NullableDecl Object key) {
+    if (needsAllocArrays()) {
+      return null;
+    }
     return remove(key, smearedHash(key));
   }
 
@@ -740,6 +770,9 @@ V getOutput(int entry) {
    * current size.
    */
   public void trimToSize() {
+    if (needsAllocArrays()) {
+      return;
+    }
     int size = this.size;
     if (size < entries.length) {
       resizeEntries(size);
@@ -763,11 +796,14 @@ public void trimToSize() {
 
   @Override
   public void clear() {
+    if (needsAllocArrays()) {
+      return;
+    }
     modCount++;
     Arrays.fill(keys, 0, size, null);
     Arrays.fill(values, 0, size, null);
     Arrays.fill(table, UNSET);
-    Arrays.fill(entries, UNSET);
+    Arrays.fill(entries, 0, size, UNSET);
     this.size = 0;
   }
 
@@ -778,7 +814,7 @@ public void clear() {
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(size);
-    for (int i = 0; i < size; i++) {
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
       stream.writeObject(keys[i]);
       stream.writeObject(values[i]);
     }
@@ -787,9 +823,12 @@ private void writeObject(ObjectOutputStream stream) throws IOException {
   @SuppressWarnings(""unchecked"")
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
     int elementCount = stream.readInt();
-    for (int i = elementCount; --i >= 0; ) {
+    if (elementCount < 0) {
+      throw new InvalidObjectException(""Invalid size: "" + elementCount);
+    }
+    init(elementCount, DEFAULT_LOAD_FACTOR);
+    for (int i = 0; i < elementCount; i++) {
       K key = (K) stream.readObject();
       V value = (V) stream.readObject();
       put(key, value);, @@ -20,10 +20,12 @@
 import static com.google.common.collect.Hashing.smearedHash;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
+import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -123,7 +125,7 @@
   private static final long HASH_MASK = ~NEXT_MASK;
 
   // TODO(user): decide default size
-  private static final int DEFAULT_SIZE = 3;
+  @VisibleForTesting static final int DEFAULT_SIZE = 3;
 
   static final int UNSET = -1;
 
@@ -182,10 +184,25 @@
   void init(int expectedSize, float loadFactor) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
     Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
+    this.loadFactor = loadFactor;
+    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+  }
+
+  /** Returns whether arrays need to be allocated. */
+  boolean needsAllocArrays() {
+    return table == null;
+  }
+
+  /** Handle lazy allocation of arrays. */
+  void allocArrays() {
+    Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
+
+    int expectedSize = threshold;
     int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
     this.table = newTable(buckets);
-    this.loadFactor = loadFactor;
+
     this.elements = new Object[expectedSize];
+
     this.entries = newEntries(expectedSize);
     this.threshold = Math.max(1, (int) (buckets * loadFactor));
   }
@@ -223,6 +240,9 @@ private int hashTableMask() {
   @CanIgnoreReturnValue
   @Override
   public boolean add(@NullableDecl E object) {
+    if (needsAllocArrays()) {
+      allocArrays();
+    }
     long[] entries = this.entries;
     Object[] elements = this.elements;
     int hash = smearedHash(object);
@@ -266,7 +286,7 @@ void insertEntry(int entryIndex, E object, int hash) {
     this.elements[entryIndex] = object;
   }
 
-  /** Returns currentSize + 1, after resizing the entries storage if necessary. */
+  /** Resizes the entries storage if necessary. */
   private void resizeMeMaybe(int newSize) {
     int entriesSize = entries.length;
     if (newSize > entriesSize) {
@@ -322,6 +342,9 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
 
   @Override
   public boolean contains(@NullableDecl Object object) {
+    if (needsAllocArrays()) {
+      return false;
+    }
     int hash = smearedHash(object);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -337,6 +360,9 @@ public boolean contains(@NullableDecl Object object) {
   @CanIgnoreReturnValue
   @Override
   public boolean remove(@NullableDecl Object object) {
+    if (needsAllocArrays()) {
+      return false;
+    }
     return remove(object, smearedHash(object));
   }
 
@@ -480,12 +506,21 @@ public boolean isEmpty() {
 
   @Override
   public Object[] toArray() {
+    if (needsAllocArrays()) {
+      return new Object[0];
+    }
     return Arrays.copyOf(elements, size);
   }
 
   @CanIgnoreReturnValue
   @Override
   public <T> T[] toArray(T[] a) {
+    if (needsAllocArrays()) {
+      if (a.length > 0) {
+        a[0] = null;
+      }
+      return a;
+    }
     return ObjectArrays.toArrayImpl(elements, 0, size, a);
   }
 
@@ -494,6 +529,9 @@ public boolean isEmpty() {
    * current size.
    */
   public void trimToSize() {
+    if (needsAllocArrays()) {
+      return;
+    }
     int size = this.size;
     if (size < entries.length) {
       resizeEntries(size);
@@ -517,10 +555,13 @@ public void trimToSize() {
 
   @Override
   public void clear() {
+    if (needsAllocArrays()) {
+      return;
+    }
     modCount++;
     Arrays.fill(elements, 0, size, null);
     Arrays.fill(table, UNSET);
-    Arrays.fill(entries, UNSET);
+    Arrays.fill(entries, 0, size, UNSET);
     this.size = 0;
   }
 
@@ -531,17 +572,20 @@ public void clear() {
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(size);
-    for (E e : this) {
-      stream.writeObject(e);
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
+      stream.writeObject(elements[i]);
     }
   }
 
   @SuppressWarnings(""unchecked"")
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
     int elementCount = stream.readInt();
-    for (int i = elementCount; --i >= 0; ) {
+    if (elementCount < 0) {
+      throw new InvalidObjectException(""Invalid size: "" + elementCount);
+    }
+    init(elementCount, DEFAULT_LOAD_FACTOR);
+    for (int i = 0; i < elementCount; i++) {
       E element = (E) stream.readObject();
       add(element);
     }, @@ -101,6 +101,12 @@ void init(int expectedSize, float loadFactor) {
     super.init(expectedSize, loadFactor);
     firstEntry = ENDPOINT;
     lastEntry = ENDPOINT;
+  }
+
+  @Override
+  void allocArrays() {
+    super.allocArrays();
+    int expectedSize = keys.length; // allocated size may be different than initial capacity
     links = new long[expectedSize];
     Arrays.fill(links, UNSET);
   }
@@ -164,13 +170,18 @@ void moveLastEntry(int dstIndex) {
       setSucceeds(getPredecessor(srcIndex), dstIndex);
       setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
+    links[srcIndex] = UNSET;
     super.moveLastEntry(dstIndex);
   }
 
   @Override
   void resizeEntries(int newCapacity) {
     super.resizeEntries(newCapacity);
+    int oldCapacity = links.length;
     links = Arrays.copyOf(links, newCapacity);
+    if (oldCapacity < newCapacity) {
+      Arrays.fill(links, oldCapacity, newCapacity, UNSET);
+    }
   }
 
   @Override
@@ -185,8 +196,12 @@ int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {
 
   @Override
   public void clear() {
-    super.clear();
+    if (needsAllocArrays()) {
+      return;
+    }
     this.firstEntry = ENDPOINT;
     this.lastEntry = ENDPOINT;
+    Arrays.fill(links, 0, size(), UNSET);
+    super.clear();
   }
 }, @@ -122,13 +122,19 @@
   @Override
   void init(int expectedSize, float loadFactor) {
     super.init(expectedSize, loadFactor);
+    firstEntry = ENDPOINT;
+    lastEntry = ENDPOINT;
+  }
+
+  @Override
+  void allocArrays() {
+    super.allocArrays();
+    int expectedSize = elements.length; // allocated size may be different than initial capacity
     this.predecessor = new int[expectedSize];
     this.successor = new int[expectedSize];
 
     Arrays.fill(predecessor, UNSET);
     Arrays.fill(successor, UNSET);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
   }
 
   private void succeeds(int pred, int succ) {
@@ -168,11 +174,14 @@ void moveEntry(int dstIndex) {
 
   @Override
   public void clear() {
-    super.clear();
+    if (needsAllocArrays()) {
+      return;
+    }
     firstEntry = ENDPOINT;
     lastEntry = ENDPOINT;
-    Arrays.fill(predecessor, UNSET);
-    Arrays.fill(successor, UNSET);
+    Arrays.fill(predecessor, 0, size(), UNSET);
+    Arrays.fill(successor, 0, size(), UNSET);
+    super.clear();
   }
 
   @Override, @@ -85,4 +85,35 @@ public void testEntrySetValueAfterRemoved() {
     entry.setValue(""one"");
     assertThat(map).containsEntry(1, ""one"");
   }
+
+  public void testAllocArraysDefault() {
+    CompactHashMap<Integer, String> map = CompactHashMap.create();
+    assertThat(map.needsAllocArrays()).isTrue();
+    assertThat(map.entries).isNull();
+    assertThat(map.keys).isNull();
+    assertThat(map.values).isNull();
+
+    map.put(1, ""1"");
+    assertThat(map.needsAllocArrays()).isFalse();
+    assertThat(map.entries).hasLength(CompactHashMap.DEFAULT_SIZE);
+    assertThat(map.keys).hasLength(CompactHashMap.DEFAULT_SIZE);
+    assertThat(map.values).hasLength(CompactHashMap.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashMap.DEFAULT_SIZE; i++) {
+      CompactHashMap<Integer, String> map = CompactHashMap.createWithExpectedSize(i);
+      assertThat(map.needsAllocArrays()).isTrue();
+      assertThat(map.entries).isNull();
+      assertThat(map.keys).isNull();
+      assertThat(map.values).isNull();
+
+      map.put(1, ""1"");
+      assertThat(map.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(map.entries).hasLength(expectedSize);
+      assertThat(map.keys).hasLength(expectedSize);
+      assertThat(map.values).hasLength(expectedSize);
+    }
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.SetTestSuiteBuilder;
 import com.google.common.collect.testing.TestStringSetGenerator;
@@ -83,7 +85,26 @@ public static Test suite() {
     return suite;
   }
 
-  public void testDummyMethod() {
-    // Just make sure the test runner doesn't complain about no test methods.
+  public void testAllocArraysDefault() {
+    CompactHashSet<Integer> set = CompactHashSet.create();
+    assertThat(set.needsAllocArrays()).isTrue();
+    assertThat(set.elements).isNull();
+
+    set.add(1);
+    assertThat(set.needsAllocArrays()).isFalse();
+    assertThat(set.elements).hasLength(CompactHashSet.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashSet.DEFAULT_SIZE; i++) {
+      CompactHashSet<Integer> set = CompactHashSet.createWithExpectedSize(i);
+      assertThat(set.needsAllocArrays()).isTrue();
+      assertThat(set.elements).isNull();
+
+      set.add(1);
+      assertThat(set.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(set.elements).hasLength(expectedSize);
+    }
   }
 }, @@ -141,4 +141,39 @@ private void testHasMapEntriesInOrder(Map<?, ?> map, Object... alternatingKeysAn
       assertEquals(expectedValue, values.get(i));
     }
   }
+
+  public void testAllocArraysDefault() {
+    CompactLinkedHashMap<Integer, String> map = CompactLinkedHashMap.create();
+    assertThat(map.needsAllocArrays()).isTrue();
+    assertThat(map.entries).isNull();
+    assertThat(map.keys).isNull();
+    assertThat(map.values).isNull();
+    assertThat(map.links).isNull();
+
+    map.put(1, Integer.toString(1));
+    assertThat(map.needsAllocArrays()).isFalse();
+    assertThat(map.entries).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.keys).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.values).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+    assertThat(map.links).hasLength(CompactLinkedHashMap.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactLinkedHashMap.DEFAULT_SIZE; i++) {
+      CompactLinkedHashMap<Integer, String> map = CompactLinkedHashMap.createWithExpectedSize(i);
+      assertThat(map.needsAllocArrays()).isTrue();
+      assertThat(map.entries).isNull();
+      assertThat(map.keys).isNull();
+      assertThat(map.values).isNull();
+      assertThat(map.links).isNull();
+
+      map.put(1, Integer.toString(1));
+      assertThat(map.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(map.entries).hasLength(expectedSize);
+      assertThat(map.keys).hasLength(expectedSize);
+      assertThat(map.values).hasLength(expectedSize);
+      assertThat(map.links).hasLength(expectedSize);
+    }
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.SetTestSuiteBuilder;
 import com.google.common.collect.testing.TestStringSetGenerator;
@@ -65,7 +67,26 @@ public static Test suite() {
     return suite;
   }
 
-  public void testDummyMethod() {
-    // Just make sure the test runner doesn't complain about no test methods.
+  public void testAllocArraysDefault() {
+    CompactHashSet<Integer> set = CompactHashSet.create();
+    assertThat(set.needsAllocArrays()).isTrue();
+    assertThat(set.elements).isNull();
+
+    set.add(1);
+    assertThat(set.needsAllocArrays()).isFalse();
+    assertThat(set.elements).hasLength(CompactHashSet.DEFAULT_SIZE);
+  }
+
+  public void testAllocArraysExpectedSize() {
+    for (int i = 0; i <= CompactHashSet.DEFAULT_SIZE; i++) {
+      CompactHashSet<Integer> set = CompactHashSet.createWithExpectedSize(i);
+      assertThat(set.needsAllocArrays()).isTrue();
+      assertThat(set.elements).isNull();
+
+      set.add(1);
+      assertThat(set.needsAllocArrays()).isFalse();
+      int expectedSize = Math.max(1, i);
+      assertThat(set.elements).hasLength(expectedSize);
+    }
   }
 }, @@ -27,6 +27,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
+import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -174,20 +175,40 @@
    * @param capacity the initial capacity of this {@code CompactHashMap}.
    */
   CompactHashMap(int capacity) {
-    this(capacity, DEFAULT_LOAD_FACTOR);
+    init(capacity, DEFAULT_LOAD_FACTOR);
   }
 
-  CompactHashMap(int expectedSize, float loadFactor) {
-    init(expectedSize, loadFactor);
+  /**
+   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load
+   * factor.
+   *
+   * @param capacity the initial capacity of this {@code CompactHashMap}.
+   * @param loadFactor the load factor of this {@code CompactHashMap}.
+   */
+  CompactHashMap(int capacity, float loadFactor) {
+    init(capacity, loadFactor);
   }
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize, float loadFactor) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
     Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
+    this.loadFactor = loadFactor;
+    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+  }
+
+  /** Returns whether arrays need to be allocated. */
+  boolean needsAllocArrays() {
+    return table == null;
+  }
+
+  /** Handle lazy allocation of arrays. */
+  void allocArrays() {
+    Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
+
+    int expectedSize = threshold;
     int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
     this.table = newTable(buckets);
-    this.loadFactor = loadFactor;
 
     this.keys = new Object[expectedSize];
     this.values = new Object[expectedSize];
@@ -237,6 +258,9 @@ void accessEntry(int index) {
   @CanIgnoreReturnValue
   @Override
   public @Nullable V put(@Nullable K key, @Nullable V value) {
+    if (needsAllocArrays()) {
+      allocArrays();
+    }
     long[] entries = this.entries;
     Object[] keys = this.keys;
     Object[] values = this.values;
@@ -289,7 +313,7 @@ void insertEntry(int entryIndex, @Nullable K key, @Nullable V value, int hash) {
     this.values[entryIndex] = value;
   }
 
-  /** Returns currentSize + 1, after resizing the entries storage if necessary. */
+  /** Resizes the entries storage if necessary. */
   private void resizeMeMaybe(int newSize) {
     int entriesSize = entries.length;
     if (newSize > entriesSize) {
@@ -345,6 +369,9 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
   }
 
   private int indexOf(@Nullable Object key) {
+    if (needsAllocArrays()) {
+      return -1;
+    }
     int hash = smearedHash(key);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -373,6 +400,9 @@ public V get(@Nullable Object key) {
   @CanIgnoreReturnValue
   @Override
   public @Nullable V remove(@Nullable Object key) {
+    if (needsAllocArrays()) {
+      return null;
+    }
     return remove(key, smearedHash(key));
   }
 
@@ -542,11 +572,20 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
 
     @Override
     public Object[] toArray() {
+      if (needsAllocArrays()) {
+        return new Object[0];
+      }
       return ObjectArrays.copyAsObjectArray(keys, 0, size);
     }
 
     @Override
     public <T> T[] toArray(T[] a) {
+      if (needsAllocArrays()) {
+        if (a.length > 0) {
+          a[0] = null;
+        }
+        return a;
+      }
       return ObjectArrays.toArrayImpl(keys, 0, size, a);
     }
 
@@ -568,6 +607,9 @@ public boolean remove(@Nullable Object o) {
 
     @Override
     public Spliterator<K> spliterator() {
+      if (needsAllocArrays()) {
+        return Spliterators.spliterator(new Object[0], Spliterator.DISTINCT | Spliterator.ORDERED);
+      }
       return Spliterators.spliterator(keys, 0, size, Spliterator.DISTINCT | Spliterator.ORDERED);
     }
 
@@ -758,16 +800,28 @@ public void forEach(Consumer<? super V> action) {
 
     @Override
     public Spliterator<V> spliterator() {
+      if (needsAllocArrays()) {
+        return Spliterators.spliterator(new Object[0], Spliterator.ORDERED);
+      }
       return Spliterators.spliterator(values, 0, size, Spliterator.ORDERED);
     }
 
     @Override
     public Object[] toArray() {
+      if (needsAllocArrays()) {
+        return new Object[0];
+      }
       return ObjectArrays.copyAsObjectArray(values, 0, size);
     }
 
     @Override
     public <T> T[] toArray(T[] a) {
+      if (needsAllocArrays()) {
+        if (a.length > 0) {
+          a[0] = null;
+        }
+        return a;
+      }
       return ObjectArrays.toArrayImpl(values, 0, size, a);
     }
   }
@@ -787,6 +841,9 @@ V getOutput(int entry) {
    * current size.
    */
   public void trimToSize() {
+    if (needsAllocArrays()) {
+      return;
+    }
     int size = this.size;
     if (size < entries.length) {
       resizeEntries(size);
@@ -810,11 +867,14 @@ public void trimToSize() {
 
   @Override
   public void clear() {
+    if (needsAllocArrays()) {
+      return;
+    }
     modCount++;
     Arrays.fill(keys, 0, size, null);
     Arrays.fill(values, 0, size, null);
     Arrays.fill(table, UNSET);
-    Arrays.fill(entries, UNSET);
+    Arrays.fill(entries, 0, size, UNSET);
     this.size = 0;
   }
 
@@ -825,7 +885,7 @@ public void clear() {
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(size);
-    for (int i = 0; i < size; i++) {
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
       stream.writeObject(keys[i]);
       stream.writeObject(values[i]);
     }
@@ -834,9 +894,12 @@ private void writeObject(ObjectOutputStream stream) throws IOException {
   @SuppressWarnings(""unchecked"")
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
     int elementCount = stream.readInt();
-    for (int i = elementCount; --i >= 0; ) {
+    if (elementCount < 0) {
+      throw new InvalidObjectException(""Invalid size: "" + elementCount);
+    }
+    init(elementCount, DEFAULT_LOAD_FACTOR);
+    for (int i = 0; i < elementCount; i++) {
       K key = (K) stream.readObject();
       V value = (V) stream.readObject();
       put(key, value);, @@ -21,10 +21,12 @@
 import static com.google.common.collect.Hashing.smearedHash;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
+import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -127,7 +129,7 @@
   private static final long HASH_MASK = ~NEXT_MASK;
 
   // TODO(user): decide default size
-  private static final int DEFAULT_SIZE = 3;
+  @VisibleForTesting static final int DEFAULT_SIZE = 3;
 
   static final int UNSET = -1;
 
@@ -186,10 +188,25 @@
   void init(int expectedSize, float loadFactor) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
     Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
+    this.loadFactor = loadFactor;
+    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+  }
+
+  /** Returns whether arrays need to be allocated. */
+  boolean needsAllocArrays() {
+    return table == null;
+  }
+
+  /** Handle lazy allocation of arrays. */
+  void allocArrays() {
+    Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
+
+    int expectedSize = threshold;
     int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
     this.table = newTable(buckets);
-    this.loadFactor = loadFactor;
+
     this.elements = new Object[expectedSize];
+
     this.entries = newEntries(expectedSize);
     this.threshold = Math.max(1, (int) (buckets * loadFactor));
   }
@@ -227,6 +244,9 @@ private int hashTableMask() {
   @CanIgnoreReturnValue
   @Override
   public boolean add(@Nullable E object) {
+    if (needsAllocArrays()) {
+      allocArrays();
+    }
     long[] entries = this.entries;
     Object[] elements = this.elements;
     int hash = smearedHash(object);
@@ -270,7 +290,7 @@ void insertEntry(int entryIndex, E object, int hash) {
     this.elements[entryIndex] = object;
   }
 
-  /** Returns currentSize + 1, after resizing the entries storage if necessary. */
+  /** Resizes the entries storage if necessary. */
   private void resizeMeMaybe(int newSize) {
     int entriesSize = entries.length;
     if (newSize > entriesSize) {
@@ -326,6 +346,9 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
 
   @Override
   public boolean contains(@Nullable Object object) {
+    if (needsAllocArrays()) {
+      return false;
+    }
     int hash = smearedHash(object);
     int next = table[hash & hashTableMask()];
     while (next != UNSET) {
@@ -341,6 +364,9 @@ public boolean contains(@Nullable Object object) {
   @CanIgnoreReturnValue
   @Override
   public boolean remove(@Nullable Object object) {
+    if (needsAllocArrays()) {
+      return false;
+    }
     return remove(object, smearedHash(object));
   }
 
@@ -474,6 +500,9 @@ private void checkForConcurrentModification() {
 
   @Override
   public Spliterator<E> spliterator() {
+    if (needsAllocArrays()) {
+      return Spliterators.spliterator(new Object[0], Spliterator.DISTINCT | Spliterator.ORDERED);
+    }
     return Spliterators.spliterator(elements, 0, size, Spliterator.DISTINCT | Spliterator.ORDERED);
   }
 
@@ -497,12 +526,21 @@ public boolean isEmpty() {
 
   @Override
   public Object[] toArray() {
+    if (needsAllocArrays()) {
+      return new Object[0];
+    }
     return Arrays.copyOf(elements, size);
   }
 
   @CanIgnoreReturnValue
   @Override
   public <T> T[] toArray(T[] a) {
+    if (needsAllocArrays()) {
+      if (a.length > 0) {
+        a[0] = null;
+      }
+      return a;
+    }
     return ObjectArrays.toArrayImpl(elements, 0, size, a);
   }
 
@@ -511,6 +549,9 @@ public boolean isEmpty() {
    * current size.
    */
   public void trimToSize() {
+    if (needsAllocArrays()) {
+      return;
+    }
     int size = this.size;
     if (size < entries.length) {
       resizeEntries(size);
@@ -534,10 +575,13 @@ public void trimToSize() {
 
   @Override
   public void clear() {
+    if (needsAllocArrays()) {
+      return;
+    }
     modCount++;
     Arrays.fill(elements, 0, size, null);
     Arrays.fill(table, UNSET);
-    Arrays.fill(entries, UNSET);
+    Arrays.fill(entries, 0, size, UNSET);
     this.size = 0;
   }
 
@@ -548,17 +592,20 @@ public void clear() {
   private void writeObject(ObjectOutputStream stream) throws IOException {
     stream.defaultWriteObject();
     stream.writeInt(size);
-    for (E e : this) {
-      stream.writeObject(e);
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
+      stream.writeObject(elements[i]);
     }
   }
 
   @SuppressWarnings(""unchecked"")
   private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
     stream.defaultReadObject();
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
     int elementCount = stream.readInt();
-    for (int i = elementCount; --i >= 0; ) {
+    if (elementCount < 0) {
+      throw new InvalidObjectException(""Invalid size: "" + elementCount);
+    }
+    init(elementCount, DEFAULT_LOAD_FACTOR);
+    for (int i = 0; i < elementCount; i++) {
       E element = (E) stream.readObject();
       add(element);
     }, @@ -110,6 +110,12 @@ void init(int expectedSize, float loadFactor) {
     super.init(expectedSize, loadFactor);
     firstEntry = ENDPOINT;
     lastEntry = ENDPOINT;
+  }
+
+  @Override
+  void allocArrays() {
+    super.allocArrays();
+    int expectedSize = keys.length; // allocated size may be different than initial capacity
     links = new long[expectedSize];
     Arrays.fill(links, UNSET);
   }
@@ -173,13 +179,18 @@ void moveLastEntry(int dstIndex) {
       setSucceeds(getPredecessor(srcIndex), dstIndex);
       setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
+    links[srcIndex] = UNSET;
     super.moveLastEntry(dstIndex);
   }
 
   @Override
   void resizeEntries(int newCapacity) {
     super.resizeEntries(newCapacity);
+    int oldCapacity = links.length;
     links = Arrays.copyOf(links, newCapacity);
+    if (oldCapacity < newCapacity) {
+      Arrays.fill(links, oldCapacity, newCapacity, UNSET);
+    }
   }
 
   @Override
@@ -274,8 +285,12 @@ public void forEach(Consumer<? super V> action) {
 
   @Override
   public void clear() {
-    super.clear();
+    if (needsAllocArrays()) {
+      return;
+    }
     this.firstEntry = ENDPOINT;
     this.lastEntry = ENDPOINT;
+    Arrays.fill(links, 0, size(), UNSET);
+    super.clear();
   }
 }, @@ -127,13 +127,19 @@
   @Override
   void init(int expectedSize, float loadFactor) {
     super.init(expectedSize, loadFactor);
+    firstEntry = ENDPOINT;
+    lastEntry = ENDPOINT;
+  }
+
+  @Override
+  void allocArrays() {
+    super.allocArrays();
+    int expectedSize = elements.length; // allocated size may be different than initial capacity
     this.predecessor = new int[expectedSize];
     this.successor = new int[expectedSize];
 
     Arrays.fill(predecessor, UNSET);
     Arrays.fill(successor, UNSET);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
   }
 
   private void succeeds(int pred, int succ) {
@@ -173,11 +179,14 @@ void moveEntry(int dstIndex) {
 
   @Override
   public void clear() {
-    super.clear();
+    if (needsAllocArrays()) {
+      return;
+    }
     firstEntry = ENDPOINT;
     lastEntry = ENDPOINT;
-    Arrays.fill(predecessor, UNSET);
-    Arrays.fill(successor, UNSET);
+    Arrays.fill(predecessor, 0, size(), UNSET);
+    Arrays.fill(successor, 0, size(), UNSET);
+    super.clear();
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Lazily allocate CompactHash backing arrays on first write

Empty maps/sets are extremely common. Lazily allocating the backing arrays can
save hundreds of KB of heap and reduce load on the garbage collector.

While here:
- Use serialized size to pre-size the arrays
- Respect ordering during serialization (without using an iterator)
- Consistently mark unused links as UNSET

Memory savings before first write (bytes):
- CompactHashMap.create(): 184 -> 64
- CompactLinkedHashMap.create(): 240 -> 80
- CompactHashSet.create(): 136 -> 40
- CompactLinkedHashSet.create(): 200 -> 56
- CompactHashMap.createWithExpectedSize(0): 136 -> 64
- CompactLinkedHashMap.createWithExpectedSize(0): 168 -> 80
- CompactHashSet.createWithExpectedSize(0): 96 -> 40
- CompactLinkedHashSet.createWithExpectedSize(0): 144 -> 56

801e018184d2f5196c80e2b2168a883c093ffe5a",Moe Sync
3428,Ron Shapiro,"['android/guava-tests/test/com/google/common/graph/ImmutableNetworkTest.java', 'android/guava/src/com/google/common/graph/ImmutableNetwork.java', 'android/guava/src/com/google/common/graph/NetworkBuilder.java', 'guava-tests/test/com/google/common/graph/ImmutableNetworkTest.java', 'guava/src/com/google/common/graph/ImmutableNetwork.java', 'guava/src/com/google/common/graph/NetworkBuilder.java']","@@ -74,4 +74,74 @@ public void edgesConnecting_undirected() {
     assertThat(network.edgesConnecting(""A"", ""B"")).containsExactly(""AB"");
     assertThat(network.edgesConnecting(""B"", ""A"")).containsExactly(""AB"");
   }
+
+  @Test
+  public void immutableNetworkBuilder_appliesNetworkBuilderConfig() {
+    ImmutableNetwork<String, Integer> emptyNetwork =
+        NetworkBuilder.directed()
+            .allowsSelfLoops(true)
+            .nodeOrder(ElementOrder.<String>natural())
+            .<String, Integer>immutable()
+            .build();
+
+    assertThat(emptyNetwork.isDirected()).isTrue();
+    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
+    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());
+  }
+
+  /**
+   * Tests that the ImmutableNetwork.Builder doesn't change when the creating NetworkBuilder
+   * changes.
+   */
+  @Test
+  @SuppressWarnings(""CheckReturnValue"")
+  public void immutableNetworkBuilder_copiesNetworkBuilder() {
+    NetworkBuilder<String, Object> networkBuilder =
+        NetworkBuilder.directed()
+            .allowsSelfLoops(true)
+            .<String>nodeOrder(ElementOrder.<String>natural());
+    ImmutableNetwork.Builder<String, Integer> immutableNetworkBuilder =
+        networkBuilder.<String, Integer>immutable();
+
+    // Update NetworkBuilder, but this shouldn't impact immutableNetworkBuilder
+    networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());
+
+    ImmutableNetwork<String, Integer> emptyNetwork = immutableNetworkBuilder.build();
+
+    assertThat(emptyNetwork.isDirected()).isTrue();
+    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
+    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());
+  }
+
+  @Test
+  public void immutableNetworkBuilder_addNode() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed().<String, Integer>immutable().addNode(""A"").build();
+
+    assertThat(network.nodes()).containsExactly(""A"");
+    assertThat(network.edges()).isEmpty();
+  }
+
+  @Test
+  public void immutableNetworkBuilder_putEdgeFromNodes() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed().<String, Integer>immutable().addEdge(""A"", ""B"", 10).build();
+
+    assertThat(network.nodes()).containsExactly(""A"", ""B"");
+    assertThat(network.edges()).containsExactly(10);
+    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(""A"", ""B""));
+  }
+
+  @Test
+  public void immutableNetworkBuilder_putEdgeFromEndpointPair() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed()
+            .<String, Integer>immutable()
+            .addEdge(EndpointPair.ordered(""A"", ""B""), 10)
+            .build();
+
+    assertThat(network.nodes()).containsExactly(""A"", ""B"");
+    assertThat(network.edges()).containsExactly(10);
+    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(""A"", ""B""));
+  }
 }, @@ -22,6 +22,7 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.Immutable;
 import java.util.Map;
 
@@ -37,6 +38,7 @@
  * @author James Sexton
  * @author Joshua O'Madadhain
  * @author Omar Darwish
+ * @author Jens Nyman
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  * @since 20.0
@@ -138,4 +140,115 @@ public N apply(E edge) {
       }
     };
   }
+
+  /**
+   * A builder for creating {@link ImmutableNetwork} instances, especially {@code static final}
+   * networks. Example:
+   *
+   * <pre>{@code
+   * static final ImmutableNetwork<City, Train> TRAIN_NETWORK =
+   *     NetworkBuilder.undirected()
+   *         .allowsParallelEdges(true)
+   *         .<City, Train>immutable()
+   *         .addEdge(PARIS, BRUSSELS, Thalys.trainNumber(""1111""))
+   *         .addEdge(PARIS, BRUSSELS, RegionalTrain.trainNumber(""2222""))
+   *         .addEdge(LONDON, PARIS, Eurostar.trainNumber(""3333""))
+   *         .addEdge(LONDON, BRUSSELS, Eurostar.trainNumber(""4444""))
+   *         .addNode(REYKJAVIK)
+   *         .build();
+   * }</pre>
+   *
+   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
+   * multiple networks in series. Each new network contains all the elements of the ones created
+   * before it.
+   *
+   * @since NEXT
+   */
+  public static class Builder<N, E> {
+
+    private final MutableNetwork<N, E> mutableNetwork;
+
+    Builder(NetworkBuilder<N, E> networkBuilder) {
+      this.mutableNetwork = networkBuilder.build();
+    }
+
+    /**
+     * Adds {@code node} if it is not already present.
+     *
+     * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.
+     *
+     * @return this {@code Builder} object
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addNode(N node) {
+      mutableNetwork.addNode(node);
+      return this;
+    }
+
+    /**
+     * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.
+     *
+     * <p>If the network is directed, {@code edge} will be directed in this network; otherwise, it
+     * will be undirected.
+     *
+     * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
+     * must also be non-null.
+     *
+     * <p>If {@code nodeU} and {@code nodeV} are not already present in this network, this method
+     * will silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the network.
+     *
+     * <p>If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if
+     * this network {@link #isDirected()}, else in any order), then this method will have no effect.
+     *
+     * @return this {@code Builder} object
+     * @throws IllegalArgumentException if {@code edge} already exists in the network and does not
+     *     connect {@code nodeU} to {@code nodeV}
+     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
+     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addEdge(N nodeU, N nodeV, E edge) {
+      mutableNetwork.addEdge(nodeU, nodeV, edge);
+      return this;
+    }
+
+    /**
+     * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will
+     * also connect {@code nodeV} to {@code nodeU}.
+     *
+     * <p>If this network is directed, {@code edge} will be directed in this network; if it is
+     * undirected, {@code edge} will be undirected in this network.
+     *
+     * <p>If this network is directed, {@code endpoints} must be ordered.
+     *
+     * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
+     * must also be non-null.
+     *
+     * <p>If either or both endpoints are not already present in this network, this method will
+     * silently {@link #addNode(Object) add} each missing endpoint to the network.
+     *
+     * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this
+     * method will have no effect.
+     *
+     * @return this {@code Builder} object
+     * @throws IllegalArgumentException if {@code edge} already exists in the network and connects
+     *     some other endpoint pair that is not equal to {@code endpoints}
+     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
+     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
+     * @throws IllegalArgumentException if the endpoints are unordered and the network is directed
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addEdge(EndpointPair<N> endpoints, E edge) {
+      mutableNetwork.addEdge(endpoints, edge);
+      return this;
+    }
+
+    /**
+     * Returns a newly-created {@code ImmutableNetwork} based on the contents of this {@code
+     * Builder}.
+     */
+    public ImmutableNetwork<N, E> build() {
+      return ImmutableNetwork.copyOf(mutableNetwork);
+    }
+  }
 }, @@ -91,6 +91,18 @@ private NetworkBuilder(boolean directed) {
         .edgeOrder(network.edgeOrder());
   }
 
+  /**
+   * Returns an {@link ImmutableNetwork#Builder} with the properties of this {@link NetworkBuilder}.
+   *
+   * <p>The returned builder can be used for populating an {@link ImmutableNetwork}.
+   *
+   * @since NEXT
+   */
+  public <N1 extends N, E1 extends E> ImmutableNetwork.Builder<N1, E1> immutable() {
+    NetworkBuilder<N1, E1> castBuilder = cast();
+    return new ImmutableNetwork.Builder<>(castBuilder);
+  }
+
   /**
    * Specifies whether the network will allow parallel edges. Attempting to add a parallel edge to a
    * network that does not allow them will throw an {@link UnsupportedOperationException}., @@ -74,4 +74,74 @@ public void edgesConnecting_undirected() {
     assertThat(network.edgesConnecting(""A"", ""B"")).containsExactly(""AB"");
     assertThat(network.edgesConnecting(""B"", ""A"")).containsExactly(""AB"");
   }
+
+  @Test
+  public void immutableNetworkBuilder_appliesNetworkBuilderConfig() {
+    ImmutableNetwork<String, Integer> emptyNetwork =
+        NetworkBuilder.directed()
+            .allowsSelfLoops(true)
+            .nodeOrder(ElementOrder.<String>natural())
+            .<String, Integer>immutable()
+            .build();
+
+    assertThat(emptyNetwork.isDirected()).isTrue();
+    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
+    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());
+  }
+
+  /**
+   * Tests that the ImmutableNetwork.Builder doesn't change when the creating NetworkBuilder
+   * changes.
+   */
+  @Test
+  @SuppressWarnings(""CheckReturnValue"")
+  public void immutableNetworkBuilder_copiesNetworkBuilder() {
+    NetworkBuilder<String, Object> networkBuilder =
+        NetworkBuilder.directed()
+            .allowsSelfLoops(true)
+            .<String>nodeOrder(ElementOrder.<String>natural());
+    ImmutableNetwork.Builder<String, Integer> immutableNetworkBuilder =
+        networkBuilder.<String, Integer>immutable();
+
+    // Update NetworkBuilder, but this shouldn't impact immutableNetworkBuilder
+    networkBuilder.allowsSelfLoops(false).nodeOrder(ElementOrder.<String>unordered());
+
+    ImmutableNetwork<String, Integer> emptyNetwork = immutableNetworkBuilder.build();
+
+    assertThat(emptyNetwork.isDirected()).isTrue();
+    assertThat(emptyNetwork.allowsSelfLoops()).isTrue();
+    assertThat(emptyNetwork.nodeOrder()).isEqualTo(ElementOrder.<String>natural());
+  }
+
+  @Test
+  public void immutableNetworkBuilder_addNode() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed().<String, Integer>immutable().addNode(""A"").build();
+
+    assertThat(network.nodes()).containsExactly(""A"");
+    assertThat(network.edges()).isEmpty();
+  }
+
+  @Test
+  public void immutableNetworkBuilder_putEdgeFromNodes() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed().<String, Integer>immutable().addEdge(""A"", ""B"", 10).build();
+
+    assertThat(network.nodes()).containsExactly(""A"", ""B"");
+    assertThat(network.edges()).containsExactly(10);
+    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(""A"", ""B""));
+  }
+
+  @Test
+  public void immutableNetworkBuilder_putEdgeFromEndpointPair() {
+    ImmutableNetwork<String, Integer> network =
+        NetworkBuilder.directed()
+            .<String, Integer>immutable()
+            .addEdge(EndpointPair.ordered(""A"", ""B""), 10)
+            .build();
+
+    assertThat(network.nodes()).containsExactly(""A"", ""B"");
+    assertThat(network.edges()).containsExactly(10);
+    assertThat(network.incidentNodes(10)).isEqualTo(EndpointPair.ordered(""A"", ""B""));
+  }
 }, @@ -22,6 +22,7 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.Immutable;
 import java.util.Map;
 
@@ -37,6 +38,7 @@
  * @author James Sexton
  * @author Joshua O'Madadhain
  * @author Omar Darwish
+ * @author Jens Nyman
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  * @since 20.0
@@ -138,4 +140,115 @@ public N apply(E edge) {
       }
     };
   }
+
+  /**
+   * A builder for creating {@link ImmutableNetwork} instances, especially {@code static final}
+   * networks. Example:
+   *
+   * <pre>{@code
+   * static final ImmutableNetwork<City, Train> TRAIN_NETWORK =
+   *     NetworkBuilder.undirected()
+   *         .allowsParallelEdges(true)
+   *         .<City, Train>immutable()
+   *         .addEdge(PARIS, BRUSSELS, Thalys.trainNumber(""1111""))
+   *         .addEdge(PARIS, BRUSSELS, RegionalTrain.trainNumber(""2222""))
+   *         .addEdge(LONDON, PARIS, Eurostar.trainNumber(""3333""))
+   *         .addEdge(LONDON, BRUSSELS, Eurostar.trainNumber(""4444""))
+   *         .addNode(REYKJAVIK)
+   *         .build();
+   * }</pre>
+   *
+   * <p>Builder instances can be reused; it is safe to call {@link #build} multiple times to build
+   * multiple networks in series. Each new network contains all the elements of the ones created
+   * before it.
+   *
+   * @since NEXT
+   */
+  public static class Builder<N, E> {
+
+    private final MutableNetwork<N, E> mutableNetwork;
+
+    Builder(NetworkBuilder<N, E> networkBuilder) {
+      this.mutableNetwork = networkBuilder.build();
+    }
+
+    /**
+     * Adds {@code node} if it is not already present.
+     *
+     * <p><b>Nodes must be unique</b>, just as {@code Map} keys must be. They must also be non-null.
+     *
+     * @return this {@code Builder} object
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addNode(N node) {
+      mutableNetwork.addNode(node);
+      return this;
+    }
+
+    /**
+     * Adds {@code edge} connecting {@code nodeU} to {@code nodeV}.
+     *
+     * <p>If the network is directed, {@code edge} will be directed in this network; otherwise, it
+     * will be undirected.
+     *
+     * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
+     * must also be non-null.
+     *
+     * <p>If {@code nodeU} and {@code nodeV} are not already present in this network, this method
+     * will silently {@link #addNode(Object) add} {@code nodeU} and {@code nodeV} to the network.
+     *
+     * <p>If {@code edge} already connects {@code nodeU} to {@code nodeV} (in the specified order if
+     * this network {@link #isDirected()}, else in any order), then this method will have no effect.
+     *
+     * @return this {@code Builder} object
+     * @throws IllegalArgumentException if {@code edge} already exists in the network and does not
+     *     connect {@code nodeU} to {@code nodeV}
+     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
+     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addEdge(N nodeU, N nodeV, E edge) {
+      mutableNetwork.addEdge(nodeU, nodeV, edge);
+      return this;
+    }
+
+    /**
+     * Adds {@code edge} connecting {@code endpoints}. In an undirected network, {@code edge} will
+     * also connect {@code nodeV} to {@code nodeU}.
+     *
+     * <p>If this network is directed, {@code edge} will be directed in this network; if it is
+     * undirected, {@code edge} will be undirected in this network.
+     *
+     * <p>If this network is directed, {@code endpoints} must be ordered.
+     *
+     * <p><b>{@code edge} must be unique to this network</b>, just as a {@code Map} key must be. It
+     * must also be non-null.
+     *
+     * <p>If either or both endpoints are not already present in this network, this method will
+     * silently {@link #addNode(Object) add} each missing endpoint to the network.
+     *
+     * <p>If {@code edge} already connects an endpoint pair equal to {@code endpoints}, then this
+     * method will have no effect.
+     *
+     * @return this {@code Builder} object
+     * @throws IllegalArgumentException if {@code edge} already exists in the network and connects
+     *     some other endpoint pair that is not equal to {@code endpoints}
+     * @throws IllegalArgumentException if the introduction of the edge would violate {@link
+     *     #allowsParallelEdges()} or {@link #allowsSelfLoops()}
+     * @throws IllegalArgumentException if the endpoints are unordered and the network is directed
+     */
+    @CanIgnoreReturnValue
+    public ImmutableNetwork.Builder<N, E> addEdge(EndpointPair<N> endpoints, E edge) {
+      mutableNetwork.addEdge(endpoints, edge);
+      return this;
+    }
+
+    /**
+     * Returns a newly-created {@code ImmutableNetwork} based on the contents of this {@code
+     * Builder}.
+     */
+    public ImmutableNetwork<N, E> build() {
+      return ImmutableNetwork.copyOf(mutableNetwork);
+    }
+  }
 }, @@ -91,6 +91,18 @@ private NetworkBuilder(boolean directed) {
         .edgeOrder(network.edgeOrder());
   }
 
+  /**
+   * Returns an {@link ImmutableNetwork#Builder} with the properties of this {@link NetworkBuilder}.
+   *
+   * <p>The returned builder can be used for populating an {@link ImmutableNetwork}.
+   *
+   * @since NEXT
+   */
+  public <N1 extends N, E1 extends E> ImmutableNetwork.Builder<N1, E1> immutable() {
+    NetworkBuilder<N1, E1> castBuilder = cast();
+    return new ImmutableNetwork.Builder<>(castBuilder);
+  }
+
   /**
    * Specifies whether the network will allow parallel edges. Attempting to add a parallel edge to a
    * network that does not allow them will throw an {@link UnsupportedOperationException}., ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add (unimplemented) API for GrapbBuilder.immutable() and ImmutableGraph.Builder.

50eddd03e92dc2855a3ae05c3b8d93de18e6bddd

-------

<p> Adds constants for prefetch headers.

Of note, X-Purpose is NOT just a google specific header as previously defined.

https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ#As_a_server_admin.2C_can_I_distinguish_prefetch_requests_from_normal_requests.3F

https://developers.google.com/web/updates/2018/07/nostate-prefetch

RELNOTES=Adds constants for prefetch headers.

966879ff982425a4418341c9ccbe9a7249bb0a4d

-------

<p> Implement GraphBuilder.immutable().

RELNOTES=`graph`: Added `GraphBuilder.immutable()` for building immutable graphs in a fluent way

7998dc473efbfa7ec7d57ece8b4c527fa9e11b9b

-------

<p> Add FluentFuture.from(FluentFuture) factory method.

This follows the steps of FluentIterable.from(FluentIterable) and other
“migration aid” methods that are deprecated from inception and are just here to
point out code that is no longer needed.

RELNOTES=Added deprecated `FluentFuture.from(FluentFuture)` to point out redundant code.

2d060028e9d99f798a29fd1ec09c844f4fc58a1d

-------

<p> Use byte[]/short[]/int[] for hashtable depending on size

The hashtable is stored as an Object and cast to the correct type using
instanceof checks.

Memory:
byte[] sizes (2-89): 12-41% better (average: 32% better)
short[] sizes (90-22937): 20-29% better (average: 24% better)
int[] sizes (22938+): unchanged

Runtime on a Pixel 2:
createAndPopulate: 9% better to 6% worse (average: 4.3% better)
get: 1% better to 8% worse (average: 3.5% worse)
iterateWithKeySetAndGet: 9% better to 13% worse (average: 3.2% worse)
iterateWithEntrySet: unchanged (doesn't use hashtable)

Effects on ImmutableMapProGuard:
59105 bytes => 60369 bytes (+2.1%)
21 classes => 21 classes (0%)
200 methods => 201 methods (+0.5%)

Effects on ImmutableBiMapProGuard:
68893 bytes => 70235 bytes (+1.9%)
25 classes => 25 classes (0%)
232 methods => 233 methods (+0.4%)

b1a11396bd731ddcd1efd60850b0aa004c9f874b

-------

<p> Add ValueGraphBuilder.immutable().

RELNOTES=`graph`: Added `ValueGraphBuilder.immutable()` for building immutable value graphs in a fluent way

79e0a573fc00db17f0916426ce2107d3bf63d481

-------

<p> Remove unnecessary Type parameter

6f0b66d172a9532aaa82dac8a1add496c916ad97

-------

<p> Add NetworkBuilder.immutable().

RELNOTES=`graph`: Added `NetworkBuilder.immutable()` for building immutable networks in a fluent way

a812af75ee14d8cb01a1a180b2c369c2f16311a3",Moe Sync
3431,Ron Shapiro,"['android/guava/src/com/google/common/collect/CompactHashMap.java', 'android/guava/src/com/google/common/collect/CompactHashSet.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashSet.java', 'guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/CompactHashSet.java', 'guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'guava/src/com/google/common/collect/CompactLinkedHashSet.java']","@@ -96,10 +96,7 @@
     return new CompactHashMap<>(expectedSize);
   }
 
-  private static final int MAXIMUM_CAPACITY = 1 << 30;
-
-  // TODO(user): decide, and inline, load factor. 0.75?
-  static final float DEFAULT_LOAD_FACTOR = 1.0f;
+  private static final float LOAD_FACTOR = 1.0f;
 
   /** Bitmask that selects the low 32 bits. */
   private static final long NEXT_MASK = (1L << 32) - 1;
@@ -143,53 +140,34 @@
    */
   @VisibleForTesting @MonotonicNonNullDecl transient Object[] values;
 
-  /** The load factor. */
-  transient float loadFactor;
-
   /**
    * Keeps track of modifications of this set, to make it possible to throw
    * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,
    * so we do less of a ""best effort"" to track such errors, for better performance.
    */
   transient int modCount;
 
-  /** When we have this many elements, resize the hashtable. */
-  private transient int threshold;
-
   /** The number of elements contained in the set. */
   private transient int size;
 
   /** Constructs a new empty instance of {@code CompactHashMap}. */
   CompactHashMap() {
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
+    init(DEFAULT_SIZE);
   }
 
   /**
    * Constructs a new instance of {@code CompactHashMap} with the specified capacity.
    *
    * @param capacity the initial capacity of this {@code CompactHashMap}.
    */
-  CompactHashMap(int capacity) {
-    init(capacity, DEFAULT_LOAD_FACTOR);
-  }
-
-  /**
-   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load
-   * factor.
-   *
-   * @param capacity the initial capacity of this {@code CompactHashMap}.
-   * @param loadFactor the load factor of this {@code CompactHashMap}.
-   */
-  CompactHashMap(int capacity, float loadFactor) {
-    init(capacity, loadFactor);
+  CompactHashMap(int expectedSize) {
+    init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
-  void init(int expectedSize, float loadFactor) {
+  void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
-    Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
-    this.loadFactor = loadFactor;
-    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 
   /** Returns whether arrays need to be allocated. */
@@ -201,15 +179,13 @@ boolean needsAllocArrays() {
   void allocArrays() {
     Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
 
-    int expectedSize = threshold;
-    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
+    int expectedSize = modCount;
+    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
     this.table = newTable(buckets);
 
+    this.entries = newEntries(expectedSize);
     this.keys = new Object[expectedSize];
     this.values = new Object[expectedSize];
-
-    this.entries = newEntries(expectedSize);
-    this.threshold = Math.max(1, (int) (buckets * loadFactor));
   }
 
   private static int[] newTable(int size) {
@@ -265,7 +241,7 @@ public V put(@NullableDecl K key, @NullableDecl V value) {
     int tableIndex = hash & hashTableMask();
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
     int next = table[tableIndex];
-    if (next == UNSET) {
+    if (next == UNSET) { // uninitialized bucket
       table[tableIndex] = newEntryIndex;
     } else {
       int last;
@@ -293,8 +269,9 @@ public V put(@NullableDecl K key, @NullableDecl V value) {
     resizeMeMaybe(newSize);
     insertEntry(newEntryIndex, key, value, hash);
     this.size = newSize;
-    if (newEntryIndex >= threshold) {
-      resizeTable(2 * table.length);
+    int oldCapacity = table.length;
+    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {
+      resizeTable(2 * oldCapacity);
     }
     modCount++;
     return null;
@@ -340,13 +317,6 @@ void resizeEntries(int newCapacity) {
   }
 
   private void resizeTable(int newCapacity) { // newCapacity always a power of two
-    int[] oldTable = table;
-    int oldCapacity = oldTable.length;
-    if (oldCapacity >= MAXIMUM_CAPACITY) {
-      threshold = Integer.MAX_VALUE;
-      return;
-    }
-    int newThreshold = 1 + (int) (newCapacity * loadFactor);
     int[] newTable = newTable(newCapacity);
     long[] entries = this.entries;
 
@@ -360,7 +330,6 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
       entries[i] = ((long) hash << 32) | (NEXT_MASK & next);
     }
 
-    this.threshold = newThreshold;
     this.table = newTable;
   }
 
@@ -412,25 +381,23 @@ private V remove(@NullableDecl Object key, int hash) {
     }
     int last = UNSET;
     do {
-      if (getHash(entries[next]) == hash) {
-        if (Objects.equal(key, keys[next])) {
-          @SuppressWarnings(""unchecked"") // values only contains Vs
-          @NullableDecl
-          V oldValue = (V) values[next];
-
-          if (last == UNSET) {
-            // we need to update the root link from table[]
-            table[tableIndex] = getNext(entries[next]);
-          } else {
-            // we need to update the link from the chain
-            entries[last] = swapNext(entries[last], getNext(entries[next]));
-          }
-
-          moveLastEntry(next);
-          size--;
-          modCount++;
-          return oldValue;
+      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {
+        @SuppressWarnings(""unchecked"") // values only contains Vs
+        @NullableDecl
+        V oldValue = (V) values[next];
+
+        if (last == UNSET) {
+          // we need to update the root link from table[]
+          table[tableIndex] = getNext(entries[next]);
+        } else {
+          // we need to update the link from the chain
+          entries[last] = swapNext(entries[last], getNext(entries[next]));
         }
+
+        moveLastEntry(next);
+        size--;
+        modCount++;
+        return oldValue;
       }
       last = next;
       next = getNext(entries[next]);
@@ -777,18 +744,7 @@ public void trimToSize() {
     if (size < entries.length) {
       resizeEntries(size);
     }
-    // size / loadFactor gives the table size of the appropriate load factor,
-    // but that may not be a power of two. We floor it to a power of two by
-    // keeping its highest bit. But the smaller table may have a load factor
-    // larger than what we want; then we want to go to the next power of 2 if we can
-    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));
-    if (minimumTableSize < MAXIMUM_CAPACITY) {
-      double load = (double) size / minimumTableSize;
-      if (load > loadFactor) {
-        minimumTableSize <<= 1; // increase to next power if possible
-      }
-    }
-
+    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);
     if (minimumTableSize < table.length) {
       resizeTable(minimumTableSize);
     }
@@ -827,7 +783,7 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
     if (elementCount < 0) {
       throw new InvalidObjectException(""Invalid size: "" + elementCount);
     }
-    init(elementCount, DEFAULT_LOAD_FACTOR);
+    init(elementCount);
     for (int i = 0; i < elementCount; i++) {
       K key = (K) stream.readObject();
       V value = (V) stream.readObject();, @@ -71,7 +71,7 @@
 
   /** Creates an empty {@code CompactHashSet} instance. */
   public static <E> CompactHashSet<E> create() {
-    return new CompactHashSet<E>();
+    return new CompactHashSet<>();
   }
 
   /**
@@ -110,13 +110,10 @@
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
   public static <E> CompactHashSet<E> createWithExpectedSize(int expectedSize) {
-    return new CompactHashSet<E>(expectedSize);
+    return new CompactHashSet<>(expectedSize);
   }
 
-  private static final int MAXIMUM_CAPACITY = 1 << 30;
-
-  // TODO(user): decide, and inline, load factor. 0.75?
-  private static final float DEFAULT_LOAD_FACTOR = 1.0f;
+  private static final float LOAD_FACTOR = 1.0f;
 
   /** Bitmask that selects the low 32 bits. */
   private static final long NEXT_MASK = (1L << 32) - 1;
@@ -127,10 +124,11 @@
   // TODO(user): decide default size
   @VisibleForTesting static final int DEFAULT_SIZE = 3;
 
+  // used to indicate blank table entries
   static final int UNSET = -1;
 
   /**
-   * The hashtable. Its values are indexes to both the elements and entries arrays.
+   * The hashtable. Its values are indexes to the elements and entries arrays.
    *
    * <p>Currently, the UNSET value means ""null pointer"", and any non negative value x is the actual
    * index.
@@ -147,28 +145,25 @@
    */
   @MonotonicNonNullDecl private transient long[] entries;
 
-  /** The elements contained in the set, in the range of [0, size()). */
+  /**
+   * The elements contained in the set, in the range of [0, size()). The elements in [size(),
+   * elements.length) are all {@code null}.
+   */
   @MonotonicNonNullDecl transient Object[] elements;
 
-  /** The load factor. */
-  transient float loadFactor;
-
   /**
    * Keeps track of modifications of this set, to make it possible to throw
    * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,
    * so we do less of a ""best effort"" to track such errors, for better performance.
    */
   transient int modCount;
 
-  /** When we have this many elements, resize the hashtable. */
-  private transient int threshold;
-
   /** The number of elements contained in the set. */
   private transient int size;
 
   /** Constructs a new empty instance of {@code CompactHashSet}. */
   CompactHashSet() {
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
+    init(DEFAULT_SIZE);
   }
 
   /**
@@ -177,15 +172,13 @@
    * @param expectedSize the initial capacity of this {@code CompactHashSet}.
    */
   CompactHashSet(int expectedSize) {
-    init(expectedSize, DEFAULT_LOAD_FACTOR);
+    init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
-  void init(int expectedSize, float loadFactor) {
+  void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
-    Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
-    this.loadFactor = loadFactor;
-    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 
   /** Returns whether arrays need to be allocated. */
@@ -197,14 +190,12 @@ boolean needsAllocArrays() {
   void allocArrays() {
     Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
 
-    int expectedSize = threshold;
-    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
+    int expectedSize = modCount;
+    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
     this.table = newTable(buckets);
 
-    this.elements = new Object[expectedSize];
-
     this.entries = newEntries(expectedSize);
-    this.threshold = Math.max(1, (int) (buckets * loadFactor));
+    this.elements = new Object[expectedSize];
   }
 
   private static int[] newTable(int size) {
@@ -219,6 +210,10 @@ void allocArrays() {
     return array;
   }
 
+  private int hashTableMask() {
+    return table.length - 1;
+  }
+
   private static int getHash(long entry) {
     return (int) (entry >>> 32);
   }
@@ -233,10 +228,6 @@ private static long swapNext(long entry, int newNext) {
     return (HASH_MASK & entry) | (NEXT_MASK & newNext);
   }
 
-  private int hashTableMask() {
-    return table.length - 1;
-  }
-
   @CanIgnoreReturnValue
   @Override
   public boolean add(@NullableDecl E object) {
@@ -245,6 +236,7 @@ public boolean add(@NullableDecl E object) {
     }
     long[] entries = this.entries;
     Object[] elements = this.elements;
+
     int hash = smearedHash(object);
     int tableIndex = hash & hashTableMask();
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
@@ -271,8 +263,9 @@ public boolean add(@NullableDecl E object) {
     resizeMeMaybe(newSize);
     insertEntry(newEntryIndex, object, hash);
     this.size = newSize;
-    if (newEntryIndex >= threshold) {
-      resizeTable(2 * table.length);
+    int oldCapacity = table.length;
+    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {
+      resizeTable(2 * oldCapacity);
     }
     modCount++;
     return true;
@@ -307,22 +300,15 @@ private void resizeMeMaybe(int newSize) {
   void resizeEntries(int newCapacity) {
     this.elements = Arrays.copyOf(elements, newCapacity);
     long[] entries = this.entries;
-    int oldSize = entries.length;
+    int oldCapacity = entries.length;
     entries = Arrays.copyOf(entries, newCapacity);
-    if (newCapacity > oldSize) {
-      Arrays.fill(entries, oldSize, newCapacity, UNSET);
+    if (newCapacity > oldCapacity) {
+      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);
     }
     this.entries = entries;
   }
 
   private void resizeTable(int newCapacity) { // newCapacity always a power of two
-    int[] oldTable = table;
-    int oldCapacity = oldTable.length;
-    if (oldCapacity >= MAXIMUM_CAPACITY) {
-      threshold = Integer.MAX_VALUE;
-      return;
-    }
-    int newThreshold = 1 + (int) (newCapacity * loadFactor);
     int[] newTable = newTable(newCapacity);
     long[] entries = this.entries;
 
@@ -336,7 +322,6 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
       entries[i] = ((long) hash << 32) | (NEXT_MASK & next);
     }
 
-    this.threshold = newThreshold;
     this.table = newTable;
   }
 
@@ -384,7 +369,7 @@ private boolean remove(Object object, int hash) {
           entries[last] = swapNext(entries[last], getNext(entries[next]));
         }
 
-        moveEntry(next);
+        moveLastEntry(next);
         size--;
         modCount++;
         return true;
@@ -398,7 +383,7 @@ private boolean remove(Object object, int hash) {
   /**
    * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.
    */
-  void moveEntry(int dstIndex) {
+  void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
     if (dstIndex < srcIndex) {
       // move last entry to deleted spot
@@ -455,12 +440,12 @@ int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(""unused"") int ind
   public Iterator<E> iterator() {
     return new Iterator<E>() {
       int expectedModCount = modCount;
-      int index = firstEntryIndex();
+      int currentIndex = firstEntryIndex();
       int indexToRemove = -1;
 
       @Override
       public boolean hasNext() {
-        return index >= 0;
+        return currentIndex >= 0;
       }
 
       @Override
@@ -470,9 +455,9 @@ public E next() {
         if (!hasNext()) {
           throw new NoSuchElementException();
         }
-        indexToRemove = index;
-        E result = (E) elements[index];
-        index = getSuccessor(index);
+        indexToRemove = currentIndex;
+        E result = (E) elements[currentIndex];
+        currentIndex = getSuccessor(currentIndex);
         return result;
       }
 
@@ -482,7 +467,7 @@ public void remove() {
         checkRemove(indexToRemove >= 0);
         expectedModCount++;
         CompactHashSet.this.remove(elements[indexToRemove], getHash(entries[indexToRemove]));
-        index = adjustAfterRemove(index, indexToRemove);
+        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);
         indexToRemove = -1;
       }
 
@@ -536,18 +521,7 @@ public void trimToSize() {
     if (size < entries.length) {
       resizeEntries(size);
     }
-    // size / loadFactor gives the table size of the appropriate load factor,
-    // but that may not be a power of two. We floor it to a power of two by
-    // keeping its highest bit. But the smaller table may have a load factor
-    // larger than what we want; then we want to go to the next power of 2 if we can
-    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));
-    if (minimumTableSize < MAXIMUM_CAPACITY) {
-      double load = (double) size / minimumTableSize;
-      if (load > loadFactor) {
-        minimumTableSize <<= 1; // increase to next power if possible
-      }
-    }
-
+    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);
     if (minimumTableSize < table.length) {
       resizeTable(minimumTableSize);
     }
@@ -584,7 +558,7 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
     if (elementCount < 0) {
       throw new InvalidObjectException(""Invalid size: "" + elementCount);
     }
-    init(elementCount, DEFAULT_LOAD_FACTOR);
+    init(elementCount);
     for (int i = 0; i < elementCount; i++) {
       E element = (E) stream.readObject();
       add(element);, @@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.google.common.collect;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -51,7 +52,7 @@
 
   /**
    * Creates a {@code CompactLinkedHashMap} instance, with a high enough ""initial capacity"" that it
-   * <i>should</i> hold {@code expectedSize} elements without growth.
+   * <i>should</i> hold {@code expectedSize} elements without rebuilding internal data structures.
    *
    * @param expectedSize the number of elements you expect to add to the returned set
    * @return a new, empty {@code CompactLinkedHashMap} with enough capacity to hold {@code
@@ -88,26 +89,26 @@
   }
 
   CompactLinkedHashMap(int expectedSize) {
-    this(expectedSize, DEFAULT_LOAD_FACTOR, false);
+    this(expectedSize, false);
   }
 
-  CompactLinkedHashMap(int expectedSize, float loadFactor, boolean accessOrder) {
-    super(expectedSize, loadFactor);
+  CompactLinkedHashMap(int expectedSize, boolean accessOrder) {
+    super(expectedSize);
     this.accessOrder = accessOrder;
   }
 
   @Override
-  void init(int expectedSize, float loadFactor) {
-    super.init(expectedSize, loadFactor);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
+  void init(int expectedSize) {
+    super.init(expectedSize);
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
   }
 
   @Override
   void allocArrays() {
     super.allocArrays();
     int expectedSize = keys.length; // allocated size may be different than initial capacity
-    links = new long[expectedSize];
+    this.links = new long[expectedSize];
     Arrays.fill(links, UNSET);
   }
 
@@ -136,6 +137,7 @@ private void setSucceeds(int pred, int succ) {
     } else {
       setSuccessor(pred, succ);
     }
+
     if (succ == ENDPOINT) {
       lastEntry = pred;
     } else {
@@ -165,13 +167,14 @@ void accessEntry(int index) {
   @Override
   void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
+    super.moveLastEntry(dstIndex);
+
     setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
     if (dstIndex < srcIndex) {
       setSucceeds(getPredecessor(srcIndex), dstIndex);
       setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
     links[srcIndex] = UNSET;
-    super.moveLastEntry(dstIndex);
   }
 
   @Override, @@ -48,7 +48,7 @@
 
   /** Creates an empty {@code CompactLinkedHashSet} instance. */
   public static <E> CompactLinkedHashSet<E> create() {
-    return new CompactLinkedHashSet<E>();
+    return new CompactLinkedHashSet<>();
   }
 
   /**
@@ -87,7 +87,7 @@
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
   public static <E> CompactLinkedHashSet<E> createWithExpectedSize(int expectedSize) {
-    return new CompactLinkedHashSet<E>(expectedSize);
+    return new CompactLinkedHashSet<>(expectedSize);
   }
 
   private static final int ENDPOINT = -2;
@@ -108,7 +108,10 @@
    */
   @MonotonicNonNullDecl private transient int[] successor;
 
+  /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;
+
+  /** Pointer to the last node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int lastEntry;
 
   CompactLinkedHashSet() {
@@ -120,10 +123,10 @@
   }
 
   @Override
-  void init(int expectedSize, float loadFactor) {
-    super.init(expectedSize, loadFactor);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
+  void init(int expectedSize) {
+    super.init(expectedSize);
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
   }
 
   @Override
@@ -132,93 +135,103 @@ void allocArrays() {
     int expectedSize = elements.length; // allocated size may be different than initial capacity
     this.predecessor = new int[expectedSize];
     this.successor = new int[expectedSize];
-
     Arrays.fill(predecessor, UNSET);
     Arrays.fill(successor, UNSET);
   }
 
-  private void succeeds(int pred, int succ) {
+  private int getPredecessor(int entry) {
+    return predecessor[entry];
+  }
+
+  @Override
+  int getSuccessor(int entry) {
+    return successor[entry];
+  }
+
+  private void setSuccessor(int entry, int succ) {
+    successor[entry] = succ;
+  }
+
+  private void setPredecessor(int entry, int pred) {
+    predecessor[entry] = pred;
+  }
+
+  private void setSucceeds(int pred, int succ) {
     if (pred == ENDPOINT) {
       firstEntry = succ;
     } else {
-      successor[pred] = succ;
+      setSuccessor(pred, succ);
     }
 
     if (succ == ENDPOINT) {
       lastEntry = pred;
     } else {
-      predecessor[succ] = pred;
+      setPredecessor(succ, pred);
     }
   }
 
   @Override
   void insertEntry(int entryIndex, E object, int hash) {
     super.insertEntry(entryIndex, object, hash);
-    succeeds(lastEntry, entryIndex);
-    succeeds(entryIndex, ENDPOINT);
+    setSucceeds(lastEntry, entryIndex);
+    setSucceeds(entryIndex, ENDPOINT);
   }
 
   @Override
-  void moveEntry(int dstIndex) {
+  void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
-    super.moveEntry(dstIndex);
+    super.moveLastEntry(dstIndex);
 
-    succeeds(predecessor[dstIndex], successor[dstIndex]);
-    if (srcIndex != dstIndex) {
-      succeeds(predecessor[srcIndex], dstIndex);
-      succeeds(dstIndex, successor[srcIndex]);
+    setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
+    if (dstIndex < srcIndex) {
+      setSucceeds(getPredecessor(srcIndex), dstIndex);
+      setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
     predecessor[srcIndex] = UNSET;
     successor[srcIndex] = UNSET;
   }
 
-  @Override
-  public void clear() {
-    if (needsAllocArrays()) {
-      return;
-    }
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
-    Arrays.fill(predecessor, 0, size(), UNSET);
-    Arrays.fill(successor, 0, size(), UNSET);
-    super.clear();
-  }
-
   @Override
   void resizeEntries(int newCapacity) {
     super.resizeEntries(newCapacity);
     int oldCapacity = predecessor.length;
     predecessor = Arrays.copyOf(predecessor, newCapacity);
     successor = Arrays.copyOf(successor, newCapacity);
-
     if (oldCapacity < newCapacity) {
       Arrays.fill(predecessor, oldCapacity, newCapacity, UNSET);
       Arrays.fill(successor, oldCapacity, newCapacity, UNSET);
     }
   }
 
   @Override
-  public Object[] toArray() {
-    return ObjectArrays.toArrayImpl(this);
+  int firstEntryIndex() {
+    return firstEntry;
   }
 
   @Override
-  public <T> T[] toArray(T[] a) {
-    return ObjectArrays.toArrayImpl(this, a);
+  int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {
+    return (indexBeforeRemove >= size()) ? indexRemoved : indexBeforeRemove;
   }
 
   @Override
-  int firstEntryIndex() {
-    return firstEntry;
+  public Object[] toArray() {
+    return ObjectArrays.toArrayImpl(this);
   }
 
   @Override
-  int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {
-    return (indexBeforeRemove == size()) ? indexRemoved : indexBeforeRemove;
+  public <T> T[] toArray(T[] a) {
+    return ObjectArrays.toArrayImpl(this, a);
   }
 
   @Override
-  int getSuccessor(int entryIndex) {
-    return successor[entryIndex];
+  public void clear() {
+    if (needsAllocArrays()) {
+      return;
+    }
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
+    Arrays.fill(predecessor, 0, size(), UNSET);
+    Arrays.fill(successor, 0, size(), UNSET);
+    super.clear();
   }
 }, @@ -101,10 +101,7 @@
     return new CompactHashMap<>(expectedSize);
   }
 
-  private static final int MAXIMUM_CAPACITY = 1 << 30;
-
-  // TODO(user): decide, and inline, load factor. 0.75?
-  static final float DEFAULT_LOAD_FACTOR = 1.0f;
+  private static final float LOAD_FACTOR = 1.0f;
 
   /** Bitmask that selects the low 32 bits. */
   private static final long NEXT_MASK = (1L << 32) - 1;
@@ -148,53 +145,34 @@
    */
   @VisibleForTesting transient Object @MonotonicNonNull [] values;
 
-  /** The load factor. */
-  transient float loadFactor;
-
   /**
    * Keeps track of modifications of this set, to make it possible to throw
    * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,
    * so we do less of a ""best effort"" to track such errors, for better performance.
    */
   transient int modCount;
 
-  /** When we have this many elements, resize the hashtable. */
-  private transient int threshold;
-
   /** The number of elements contained in the set. */
   private transient int size;
 
   /** Constructs a new empty instance of {@code CompactHashMap}. */
   CompactHashMap() {
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
+    init(DEFAULT_SIZE);
   }
 
   /**
    * Constructs a new instance of {@code CompactHashMap} with the specified capacity.
    *
    * @param capacity the initial capacity of this {@code CompactHashMap}.
    */
-  CompactHashMap(int capacity) {
-    init(capacity, DEFAULT_LOAD_FACTOR);
-  }
-
-  /**
-   * Constructs a new instance of {@code CompactHashMap} with the specified capacity and load
-   * factor.
-   *
-   * @param capacity the initial capacity of this {@code CompactHashMap}.
-   * @param loadFactor the load factor of this {@code CompactHashMap}.
-   */
-  CompactHashMap(int capacity, float loadFactor) {
-    init(capacity, loadFactor);
+  CompactHashMap(int expectedSize) {
+    init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
-  void init(int expectedSize, float loadFactor) {
+  void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
-    Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
-    this.loadFactor = loadFactor;
-    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 
   /** Returns whether arrays need to be allocated. */
@@ -206,15 +184,13 @@ boolean needsAllocArrays() {
   void allocArrays() {
     Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
 
-    int expectedSize = threshold;
-    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
+    int expectedSize = modCount;
+    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
     this.table = newTable(buckets);
 
+    this.entries = newEntries(expectedSize);
     this.keys = new Object[expectedSize];
     this.values = new Object[expectedSize];
-
-    this.entries = newEntries(expectedSize);
-    this.threshold = Math.max(1, (int) (buckets * loadFactor));
   }
 
   private static int[] newTable(int size) {
@@ -269,7 +245,7 @@ void accessEntry(int index) {
     int tableIndex = hash & hashTableMask();
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
     int next = table[tableIndex];
-    if (next == UNSET) {
+    if (next == UNSET) { // uninitialized bucket
       table[tableIndex] = newEntryIndex;
     } else {
       int last;
@@ -297,8 +273,9 @@ void accessEntry(int index) {
     resizeMeMaybe(newSize);
     insertEntry(newEntryIndex, key, value, hash);
     this.size = newSize;
-    if (newEntryIndex >= threshold) {
-      resizeTable(2 * table.length);
+    int oldCapacity = table.length;
+    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {
+      resizeTable(2 * oldCapacity);
     }
     modCount++;
     return null;
@@ -344,13 +321,6 @@ void resizeEntries(int newCapacity) {
   }
 
   private void resizeTable(int newCapacity) { // newCapacity always a power of two
-    int[] oldTable = table;
-    int oldCapacity = oldTable.length;
-    if (oldCapacity >= MAXIMUM_CAPACITY) {
-      threshold = Integer.MAX_VALUE;
-      return;
-    }
-    int newThreshold = 1 + (int) (newCapacity * loadFactor);
     int[] newTable = newTable(newCapacity);
     long[] entries = this.entries;
 
@@ -364,7 +334,6 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
       entries[i] = ((long) hash << 32) | (NEXT_MASK & next);
     }
 
-    this.threshold = newThreshold;
     this.table = newTable;
   }
 
@@ -414,25 +383,23 @@ public V get(@Nullable Object key) {
     }
     int last = UNSET;
     do {
-      if (getHash(entries[next]) == hash) {
-        if (Objects.equal(key, keys[next])) {
-          @SuppressWarnings(""unchecked"") // values only contains Vs
-          @Nullable
-          V oldValue = (V) values[next];
-
-          if (last == UNSET) {
-            // we need to update the root link from table[]
-            table[tableIndex] = getNext(entries[next]);
-          } else {
-            // we need to update the link from the chain
-            entries[last] = swapNext(entries[last], getNext(entries[next]));
-          }
-
-          moveLastEntry(next);
-          size--;
-          modCount++;
-          return oldValue;
+      if (getHash(entries[next]) == hash && Objects.equal(key, keys[next])) {
+        @SuppressWarnings(""unchecked"") // values only contains Vs
+        @Nullable
+        V oldValue = (V) values[next];
+
+        if (last == UNSET) {
+          // we need to update the root link from table[]
+          table[tableIndex] = getNext(entries[next]);
+        } else {
+          // we need to update the link from the chain
+          entries[last] = swapNext(entries[last], getNext(entries[next]));
         }
+
+        moveLastEntry(next);
+        size--;
+        modCount++;
+        return oldValue;
       }
       last = next;
       next = getNext(entries[next]);
@@ -616,7 +583,7 @@ public boolean remove(@Nullable Object o) {
     @Override
     public void forEach(Consumer<? super K> action) {
       checkNotNull(action);
-      for (int i = 0; i < size; i++) {
+      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
         action.accept((K) keys[i]);
       }
     }
@@ -635,7 +602,7 @@ K getOutput(int entry) {
   @Override
   public void forEach(BiConsumer<? super K, ? super V> action) {
     checkNotNull(action);
-    for (int i = 0; i < size; i++) {
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
       action.accept((K) keys[i], (V) values[i]);
     }
   }
@@ -793,7 +760,7 @@ public boolean containsValue(@Nullable Object value) {
     @Override
     public void forEach(Consumer<? super V> action) {
       checkNotNull(action);
-      for (int i = 0; i < size; i++) {
+      for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
         action.accept((V) values[i]);
       }
     }
@@ -848,18 +815,7 @@ public void trimToSize() {
     if (size < entries.length) {
       resizeEntries(size);
     }
-    // size / loadFactor gives the table size of the appropriate load factor,
-    // but that may not be a power of two. We floor it to a power of two by
-    // keeping its highest bit. But the smaller table may have a load factor
-    // larger than what we want; then we want to go to the next power of 2 if we can
-    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));
-    if (minimumTableSize < MAXIMUM_CAPACITY) {
-      double load = (double) size / minimumTableSize;
-      if (load > loadFactor) {
-        minimumTableSize <<= 1; // increase to next power if possible
-      }
-    }
-
+    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);
     if (minimumTableSize < table.length) {
       resizeTable(minimumTableSize);
     }
@@ -898,7 +854,7 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
     if (elementCount < 0) {
       throw new InvalidObjectException(""Invalid size: "" + elementCount);
     }
-    init(elementCount, DEFAULT_LOAD_FACTOR);
+    init(elementCount);
     for (int i = 0; i < elementCount; i++) {
       K key = (K) stream.readObject();
       V value = (V) stream.readObject();, @@ -75,7 +75,7 @@
 
   /** Creates an empty {@code CompactHashSet} instance. */
   public static <E> CompactHashSet<E> create() {
-    return new CompactHashSet<E>();
+    return new CompactHashSet<>();
   }
 
   /**
@@ -114,13 +114,10 @@
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
   public static <E> CompactHashSet<E> createWithExpectedSize(int expectedSize) {
-    return new CompactHashSet<E>(expectedSize);
+    return new CompactHashSet<>(expectedSize);
   }
 
-  private static final int MAXIMUM_CAPACITY = 1 << 30;
-
-  // TODO(user): decide, and inline, load factor. 0.75?
-  private static final float DEFAULT_LOAD_FACTOR = 1.0f;
+  private static final float LOAD_FACTOR = 1.0f;
 
   /** Bitmask that selects the low 32 bits. */
   private static final long NEXT_MASK = (1L << 32) - 1;
@@ -131,10 +128,11 @@
   // TODO(user): decide default size
   @VisibleForTesting static final int DEFAULT_SIZE = 3;
 
+  // used to indicate blank table entries
   static final int UNSET = -1;
 
   /**
-   * The hashtable. Its values are indexes to both the elements and entries arrays.
+   * The hashtable. Its values are indexes to the elements and entries arrays.
    *
    * <p>Currently, the UNSET value means ""null pointer"", and any non negative value x is the actual
    * index.
@@ -151,28 +149,25 @@
    */
   private transient long @MonotonicNonNull [] entries;
 
-  /** The elements contained in the set, in the range of [0, size()). */
+  /**
+   * The elements contained in the set, in the range of [0, size()). The elements in [size(),
+   * elements.length) are all {@code null}.
+   */
   transient Object @MonotonicNonNull [] elements;
 
-  /** The load factor. */
-  transient float loadFactor;
-
   /**
    * Keeps track of modifications of this set, to make it possible to throw
    * ConcurrentModificationException in the iterator. Note that we choose not to make this volatile,
    * so we do less of a ""best effort"" to track such errors, for better performance.
    */
   transient int modCount;
 
-  /** When we have this many elements, resize the hashtable. */
-  private transient int threshold;
-
   /** The number of elements contained in the set. */
   private transient int size;
 
   /** Constructs a new empty instance of {@code CompactHashSet}. */
   CompactHashSet() {
-    init(DEFAULT_SIZE, DEFAULT_LOAD_FACTOR);
+    init(DEFAULT_SIZE);
   }
 
   /**
@@ -181,15 +176,13 @@
    * @param expectedSize the initial capacity of this {@code CompactHashSet}.
    */
   CompactHashSet(int expectedSize) {
-    init(expectedSize, DEFAULT_LOAD_FACTOR);
+    init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
-  void init(int expectedSize, float loadFactor) {
+  void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
-    Preconditions.checkArgument(loadFactor > 0, ""Illegal load factor"");
-    this.loadFactor = loadFactor;
-    this.threshold = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
+    this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 
   /** Returns whether arrays need to be allocated. */
@@ -201,14 +194,12 @@ boolean needsAllocArrays() {
   void allocArrays() {
     Preconditions.checkState(needsAllocArrays(), ""Arrays already allocated"");
 
-    int expectedSize = threshold;
-    int buckets = Hashing.closedTableSize(expectedSize, loadFactor);
+    int expectedSize = modCount;
+    int buckets = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
     this.table = newTable(buckets);
 
-    this.elements = new Object[expectedSize];
-
     this.entries = newEntries(expectedSize);
-    this.threshold = Math.max(1, (int) (buckets * loadFactor));
+    this.elements = new Object[expectedSize];
   }
 
   private static int[] newTable(int size) {
@@ -223,6 +214,10 @@ void allocArrays() {
     return array;
   }
 
+  private int hashTableMask() {
+    return table.length - 1;
+  }
+
   private static int getHash(long entry) {
     return (int) (entry >>> 32);
   }
@@ -237,10 +232,6 @@ private static long swapNext(long entry, int newNext) {
     return (HASH_MASK & entry) | (NEXT_MASK & newNext);
   }
 
-  private int hashTableMask() {
-    return table.length - 1;
-  }
-
   @CanIgnoreReturnValue
   @Override
   public boolean add(@Nullable E object) {
@@ -249,6 +240,7 @@ public boolean add(@Nullable E object) {
     }
     long[] entries = this.entries;
     Object[] elements = this.elements;
+
     int hash = smearedHash(object);
     int tableIndex = hash & hashTableMask();
     int newEntryIndex = this.size; // current size, and pointer to the entry to be appended
@@ -275,8 +267,9 @@ public boolean add(@Nullable E object) {
     resizeMeMaybe(newSize);
     insertEntry(newEntryIndex, object, hash);
     this.size = newSize;
-    if (newEntryIndex >= threshold) {
-      resizeTable(2 * table.length);
+    int oldCapacity = table.length;
+    if (Hashing.needsResizing(newEntryIndex, oldCapacity, LOAD_FACTOR)) {
+      resizeTable(2 * oldCapacity);
     }
     modCount++;
     return true;
@@ -311,22 +304,15 @@ private void resizeMeMaybe(int newSize) {
   void resizeEntries(int newCapacity) {
     this.elements = Arrays.copyOf(elements, newCapacity);
     long[] entries = this.entries;
-    int oldSize = entries.length;
+    int oldCapacity = entries.length;
     entries = Arrays.copyOf(entries, newCapacity);
-    if (newCapacity > oldSize) {
-      Arrays.fill(entries, oldSize, newCapacity, UNSET);
+    if (newCapacity > oldCapacity) {
+      Arrays.fill(entries, oldCapacity, newCapacity, UNSET);
     }
     this.entries = entries;
   }
 
   private void resizeTable(int newCapacity) { // newCapacity always a power of two
-    int[] oldTable = table;
-    int oldCapacity = oldTable.length;
-    if (oldCapacity >= MAXIMUM_CAPACITY) {
-      threshold = Integer.MAX_VALUE;
-      return;
-    }
-    int newThreshold = 1 + (int) (newCapacity * loadFactor);
     int[] newTable = newTable(newCapacity);
     long[] entries = this.entries;
 
@@ -340,7 +326,6 @@ private void resizeTable(int newCapacity) { // newCapacity always a power of two
       entries[i] = ((long) hash << 32) | (NEXT_MASK & next);
     }
 
-    this.threshold = newThreshold;
     this.table = newTable;
   }
 
@@ -388,7 +373,7 @@ private boolean remove(Object object, int hash) {
           entries[last] = swapNext(entries[last], getNext(entries[next]));
         }
 
-        moveEntry(next);
+        moveLastEntry(next);
         size--;
         modCount++;
         return true;
@@ -402,7 +387,7 @@ private boolean remove(Object object, int hash) {
   /**
    * Moves the last entry in the entry array into {@code dstIndex}, and nulls out its old position.
    */
-  void moveEntry(int dstIndex) {
+  void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
     if (dstIndex < srcIndex) {
       // move last entry to deleted spot
@@ -459,12 +444,12 @@ int adjustAfterRemove(int indexBeforeRemove, @SuppressWarnings(""unused"") int ind
   public Iterator<E> iterator() {
     return new Iterator<E>() {
       int expectedModCount = modCount;
-      int index = firstEntryIndex();
+      int currentIndex = firstEntryIndex();
       int indexToRemove = -1;
 
       @Override
       public boolean hasNext() {
-        return index >= 0;
+        return currentIndex >= 0;
       }
 
       @Override
@@ -474,9 +459,9 @@ public E next() {
         if (!hasNext()) {
           throw new NoSuchElementException();
         }
-        indexToRemove = index;
-        E result = (E) elements[index];
-        index = getSuccessor(index);
+        indexToRemove = currentIndex;
+        E result = (E) elements[currentIndex];
+        currentIndex = getSuccessor(currentIndex);
         return result;
       }
 
@@ -486,7 +471,7 @@ public void remove() {
         checkRemove(indexToRemove >= 0);
         expectedModCount++;
         CompactHashSet.this.remove(elements[indexToRemove], getHash(entries[indexToRemove]));
-        index = adjustAfterRemove(index, indexToRemove);
+        currentIndex = adjustAfterRemove(currentIndex, indexToRemove);
         indexToRemove = -1;
       }
 
@@ -509,7 +494,7 @@ private void checkForConcurrentModification() {
   @Override
   public void forEach(Consumer<? super E> action) {
     checkNotNull(action);
-    for (int i = 0; i < size; i++) {
+    for (int i = firstEntryIndex(); i >= 0; i = getSuccessor(i)) {
       action.accept((E) elements[i]);
     }
   }
@@ -556,18 +541,7 @@ public void trimToSize() {
     if (size < entries.length) {
       resizeEntries(size);
     }
-    // size / loadFactor gives the table size of the appropriate load factor,
-    // but that may not be a power of two. We floor it to a power of two by
-    // keeping its highest bit. But the smaller table may have a load factor
-    // larger than what we want; then we want to go to the next power of 2 if we can
-    int minimumTableSize = Math.max(1, Integer.highestOneBit((int) (size / loadFactor)));
-    if (minimumTableSize < MAXIMUM_CAPACITY) {
-      double load = (double) size / minimumTableSize;
-      if (load > loadFactor) {
-        minimumTableSize <<= 1; // increase to next power if possible
-      }
-    }
-
+    int minimumTableSize = Hashing.closedTableSize(size, LOAD_FACTOR);
     if (minimumTableSize < table.length) {
       resizeTable(minimumTableSize);
     }
@@ -604,7 +578,7 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
     if (elementCount < 0) {
       throw new InvalidObjectException(""Invalid size: "" + elementCount);
     }
-    init(elementCount, DEFAULT_LOAD_FACTOR);
+    init(elementCount);
     for (int i = 0; i < elementCount; i++) {
       E element = (E) stream.readObject();
       add(element);, @@ -13,9 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+package com.google.common.collect;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
@@ -25,8 +24,6 @@
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
@@ -60,7 +57,7 @@
 
   /**
    * Creates a {@code CompactLinkedHashMap} instance, with a high enough ""initial capacity"" that it
-   * <i>should</i> hold {@code expectedSize} elements without growth.
+   * <i>should</i> hold {@code expectedSize} elements without rebuilding internal data structures.
    *
    * @param expectedSize the number of elements you expect to add to the returned set
    * @return a new, empty {@code CompactLinkedHashMap} with enough capacity to hold {@code
@@ -97,26 +94,26 @@
   }
 
   CompactLinkedHashMap(int expectedSize) {
-    this(expectedSize, DEFAULT_LOAD_FACTOR, false);
+    this(expectedSize, false);
   }
 
-  CompactLinkedHashMap(int expectedSize, float loadFactor, boolean accessOrder) {
-    super(expectedSize, loadFactor);
+  CompactLinkedHashMap(int expectedSize, boolean accessOrder) {
+    super(expectedSize);
     this.accessOrder = accessOrder;
   }
 
   @Override
-  void init(int expectedSize, float loadFactor) {
-    super.init(expectedSize, loadFactor);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
+  void init(int expectedSize) {
+    super.init(expectedSize);
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
   }
 
   @Override
   void allocArrays() {
     super.allocArrays();
     int expectedSize = keys.length; // allocated size may be different than initial capacity
-    links = new long[expectedSize];
+    this.links = new long[expectedSize];
     Arrays.fill(links, UNSET);
   }
 
@@ -145,6 +142,7 @@ private void setSucceeds(int pred, int succ) {
     } else {
       setSuccessor(pred, succ);
     }
+
     if (succ == ENDPOINT) {
       lastEntry = pred;
     } else {
@@ -174,13 +172,14 @@ void accessEntry(int index) {
   @Override
   void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
+    super.moveLastEntry(dstIndex);
+
     setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
     if (dstIndex < srcIndex) {
       setSucceeds(getPredecessor(srcIndex), dstIndex);
       setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
     links[srcIndex] = UNSET;
-    super.moveLastEntry(dstIndex);
   }
 
   @Override
@@ -203,14 +202,6 @@ int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {
     return (indexBeforeRemove >= size()) ? indexRemoved : indexBeforeRemove;
   }
 
-  @Override
-  public void forEach(BiConsumer<? super K, ? super V> action) {
-    checkNotNull(action);
-    for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {
-      action.accept((K) keys[i], (V) values[i]);
-    }
-  }
-
   @Override
   Set<Entry<K, V>> createEntrySet() {
     @WeakOuter
@@ -241,14 +232,6 @@ public void forEach(BiConsumer<? super K, ? super V> action) {
       public Spliterator<K> spliterator() {
         return Spliterators.spliterator(this, Spliterator.ORDERED | Spliterator.DISTINCT);
       }
-
-      @Override
-      public void forEach(Consumer<? super K> action) {
-        checkNotNull(action);
-        for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {
-          action.accept((K) keys[i]);
-        }
-      }
     }
     return new KeySetImpl();
   }
@@ -271,14 +254,6 @@ public void forEach(Consumer<? super K> action) {
       public Spliterator<V> spliterator() {
         return Spliterators.spliterator(this, Spliterator.ORDERED);
       }
-
-      @Override
-      public void forEach(Consumer<? super V> action) {
-        checkNotNull(action);
-        for (int i = firstEntry; i != ENDPOINT; i = getSuccessor(i)) {
-          action.accept((V) values[i]);
-        }
-      }
     }
     return new ValuesImpl();
   }, @@ -16,15 +16,12 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
@@ -53,7 +50,7 @@
 
   /** Creates an empty {@code CompactLinkedHashSet} instance. */
   public static <E> CompactLinkedHashSet<E> create() {
-    return new CompactLinkedHashSet<E>();
+    return new CompactLinkedHashSet<>();
   }
 
   /**
@@ -92,7 +89,7 @@
    * @throws IllegalArgumentException if {@code expectedSize} is negative
    */
   public static <E> CompactLinkedHashSet<E> createWithExpectedSize(int expectedSize) {
-    return new CompactLinkedHashSet<E>(expectedSize);
+    return new CompactLinkedHashSet<>(expectedSize);
   }
 
   private static final int ENDPOINT = -2;
@@ -113,7 +110,10 @@
    */
   private transient int @MonotonicNonNull [] successor;
 
+  /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;
+
+  /** Pointer to the last node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int lastEntry;
 
   CompactLinkedHashSet() {
@@ -125,10 +125,10 @@
   }
 
   @Override
-  void init(int expectedSize, float loadFactor) {
-    super.init(expectedSize, loadFactor);
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
+  void init(int expectedSize) {
+    super.init(expectedSize);
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
   }
 
   @Override
@@ -137,94 +137,92 @@ void allocArrays() {
     int expectedSize = elements.length; // allocated size may be different than initial capacity
     this.predecessor = new int[expectedSize];
     this.successor = new int[expectedSize];
-
     Arrays.fill(predecessor, UNSET);
     Arrays.fill(successor, UNSET);
   }
 
-  private void succeeds(int pred, int succ) {
+  private int getPredecessor(int entry) {
+    return predecessor[entry];
+  }
+
+  @Override
+  int getSuccessor(int entry) {
+    return successor[entry];
+  }
+
+  private void setSuccessor(int entry, int succ) {
+    successor[entry] = succ;
+  }
+
+  private void setPredecessor(int entry, int pred) {
+    predecessor[entry] = pred;
+  }
+
+  private void setSucceeds(int pred, int succ) {
     if (pred == ENDPOINT) {
       firstEntry = succ;
     } else {
-      successor[pred] = succ;
+      setSuccessor(pred, succ);
     }
 
     if (succ == ENDPOINT) {
       lastEntry = pred;
     } else {
-      predecessor[succ] = pred;
+      setPredecessor(succ, pred);
     }
   }
 
   @Override
   void insertEntry(int entryIndex, E object, int hash) {
     super.insertEntry(entryIndex, object, hash);
-    succeeds(lastEntry, entryIndex);
-    succeeds(entryIndex, ENDPOINT);
+    setSucceeds(lastEntry, entryIndex);
+    setSucceeds(entryIndex, ENDPOINT);
   }
 
   @Override
-  void moveEntry(int dstIndex) {
+  void moveLastEntry(int dstIndex) {
     int srcIndex = size() - 1;
-    super.moveEntry(dstIndex);
+    super.moveLastEntry(dstIndex);
 
-    succeeds(predecessor[dstIndex], successor[dstIndex]);
-    if (srcIndex != dstIndex) {
-      succeeds(predecessor[srcIndex], dstIndex);
-      succeeds(dstIndex, successor[srcIndex]);
+    setSucceeds(getPredecessor(dstIndex), getSuccessor(dstIndex));
+    if (dstIndex < srcIndex) {
+      setSucceeds(getPredecessor(srcIndex), dstIndex);
+      setSucceeds(dstIndex, getSuccessor(srcIndex));
     }
     predecessor[srcIndex] = UNSET;
     successor[srcIndex] = UNSET;
   }
 
-  @Override
-  public void clear() {
-    if (needsAllocArrays()) {
-      return;
-    }
-    firstEntry = ENDPOINT;
-    lastEntry = ENDPOINT;
-    Arrays.fill(predecessor, 0, size(), UNSET);
-    Arrays.fill(successor, 0, size(), UNSET);
-    super.clear();
-  }
-
   @Override
   void resizeEntries(int newCapacity) {
     super.resizeEntries(newCapacity);
     int oldCapacity = predecessor.length;
     predecessor = Arrays.copyOf(predecessor, newCapacity);
     successor = Arrays.copyOf(successor, newCapacity);
-
     if (oldCapacity < newCapacity) {
       Arrays.fill(predecessor, oldCapacity, newCapacity, UNSET);
       Arrays.fill(successor, oldCapacity, newCapacity, UNSET);
     }
   }
 
-  @Override
-  public Object[] toArray() {
-    return ObjectArrays.toArrayImpl(this);
-  }
-
-  @Override
-  public <T> T[] toArray(T[] a) {
-    return ObjectArrays.toArrayImpl(this, a);
-  }
-
   @Override
   int firstEntryIndex() {
     return firstEntry;
   }
 
   @Override
   int adjustAfterRemove(int indexBeforeRemove, int indexRemoved) {
-    return (indexBeforeRemove == size()) ? indexRemoved : indexBeforeRemove;
+    return (indexBeforeRemove >= size()) ? indexRemoved : indexBeforeRemove;
   }
 
   @Override
-  int getSuccessor(int entryIndex) {
-    return successor[entryIndex];
+  public Object[] toArray() {
+    return ObjectArrays.toArrayImpl(this);
+  }
+
+  @Override
+  public <T> T[] toArray(T[] a) {
+    return ObjectArrays.toArrayImpl(this, a);
   }
 
   @Override
@@ -233,10 +231,14 @@ int getSuccessor(int entryIndex) {
   }
 
   @Override
-  public void forEach(Consumer<? super E> action) {
-    checkNotNull(action);
-    for (int i = firstEntry; i != ENDPOINT; i = successor[i]) {
-      action.accept((E) elements[i]);
+  public void clear() {
+    if (needsAllocArrays()) {
+      return;
     }
+    this.firstEntry = ENDPOINT;
+    this.lastEntry = ENDPOINT;
+    Arrays.fill(predecessor, 0, size(), UNSET);
+    Arrays.fill(successor, 0, size(), UNSET);
+    super.clear();
   }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove unused configuration of load factor

This allows removal of loadFactor/threshold which saves 8 bytes per object.

While here:
- Reduce diff between Map/Set classes
- Make base forEach() work for Linked classes

Shallow object size (bytes):
- CompactHashMap: 64 -> 56
- CompactLinkedHashMap: 80 -> 72
- CompactHashSet: 40 -> 32
- CompactLinkedHashSet: 56 -> 48

062afc318cc7f60f6d681d6a3fa6cdc4f437a2d7",Moe Sync
3434,Ron Shapiro,"['android/guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/CompactHashMap.java']","@@ -158,15 +158,15 @@
   /**
    * Constructs a new instance of {@code CompactHashMap} with the specified capacity.
    *
-   * @param capacity the initial capacity of this {@code CompactHashMap}.
+   * @param expectedSize the initial capacity of this {@code CompactHashMap}.
    */
   CompactHashMap(int expectedSize) {
     init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize) {
-    Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
+    Preconditions.checkArgument(expectedSize >= 0, ""Expected size must be non-negative"");
     this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 , @@ -163,15 +163,15 @@
   /**
    * Constructs a new instance of {@code CompactHashMap} with the specified capacity.
    *
-   * @param capacity the initial capacity of this {@code CompactHashMap}.
+   * @param expectedSize the initial capacity of this {@code CompactHashMap}.
    */
   CompactHashMap(int expectedSize) {
     init(expectedSize);
   }
 
   /** Pseudoconstructor for serialization support. */
   void init(int expectedSize) {
-    Preconditions.checkArgument(expectedSize >= 0, ""Initial capacity must be non-negative"");
+    Preconditions.checkArgument(expectedSize >= 0, ""Expected size must be non-negative"");
     this.modCount = Math.max(1, expectedSize); // Save expectedSize for use in allocArrays()
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix @param tag as per https://github.com/google/guava/pull/3431#pullrequestreview-221507095

cc @jbduncan

c691708b4c214b5caf9a92826cdfa07b19485f6e",Moe Sync
3436,Ron Shapiro,"['android/guava-tests/test/com/google/common/hash/BloomFilterTest.java', 'guava-tests/test/com/google/common/hash/BloomFilterTest.java']","@@ -304,7 +304,7 @@ public void testOptimalSize() {
   public void testLargeNumberOfInsertions() {
     // We use horrible FPPs here to keep Java from OOM'ing
     BloomFilter<String> unused =
-        BloomFilter.create(Funnels.unencodedCharsFunnel(), Integer.MAX_VALUE / 2, 0.29);
+        BloomFilter.create(Funnels.unencodedCharsFunnel(), Integer.MAX_VALUE / 2, 0.30);
     unused = BloomFilter.create(Funnels.unencodedCharsFunnel(), 45L * Integer.MAX_VALUE, 0.99);
   }
 , @@ -305,7 +305,7 @@ public void testOptimalSize() {
   public void testLargeNumberOfInsertions() {
     // We use horrible FPPs here to keep Java from OOM'ing
     BloomFilter<String> unused =
-        BloomFilter.create(Funnels.unencodedCharsFunnel(), Integer.MAX_VALUE / 2, 0.29);
+        BloomFilter.create(Funnels.unencodedCharsFunnel(), Integer.MAX_VALUE / 2, 0.30);
     unused = BloomFilter.create(Funnels.unencodedCharsFunnel(), 45L * Integer.MAX_VALUE, 0.99);
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Bumped the FPP to prevent OOMs on JDK 11.

8acb5b990f7fe0467dd318e262dd423b19b710b7",Moe Sync
3440,Ron Shapiro,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -492,4 +492,39 @@ private ReferrerPolicyValues() {}
    * @since 25.1
    */
   public static final String SEC_REFERRED_TOKEN_BINDING_ID = ""Sec-Referred-Token-Binding-ID"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Accept}</a> header
+   * field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_ACCEPT = ""Sec-Websocket-Accept"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Extensions}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_EXTENSIONS = ""Sec-Websocket-Extensions"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Key}</a> header
+   * field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_KEY = ""Sec-Websocket-Key"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Protocol}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_PROTOCOL = ""Sec-Websocket-Protocol"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Versions}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_VERSIONS = ""Sec-Websocket-Versions"";
 }, @@ -492,4 +492,39 @@ private ReferrerPolicyValues() {}
    * @since 25.1
    */
   public static final String SEC_REFERRED_TOKEN_BINDING_ID = ""Sec-Referred-Token-Binding-ID"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Accept}</a> header
+   * field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_ACCEPT = ""Sec-Websocket-Accept"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Extensions}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_EXTENSIONS = ""Sec-Websocket-Extensions"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Key}</a> header
+   * field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_KEY = ""Sec-Websocket-Key"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Protocol}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_PROTOCOL = ""Sec-Websocket-Protocol"";
+  /**
+   * The HTTP <a href=""https://tools.ietf.org/html/rfc6455"">{@code Sec-WebSocket-Versions}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_WEBSOCKET_VERSIONS = ""Sec-Websocket-Versions"";
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add websocket headers to HTTP header listings.

This adds five headers, as defined in RFC 6455: Sec-WebSocket-Accept,
Sec-WebSocket-Extensions, Sec-WebSocket-Key, Sec-WebSocket-Protocol, and
Sec-WebSocket-Versions.

This also changes the C++ per-header unit test so that it can recognize the
alternate capitalization of WebSocket, instead of adding five special cases. The
Go and Java versions use the ""Websocket"" capitalization instead.

78fe31027ec67c0648667582e40d49351757cfe9",Moe Sync
3441,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -233,7 +233,7 @@
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>2.2.0</version>
+        <version>2.3.2</version>
       </dependency>
       <dependency>
         <groupId>com.google.j2objc</groupId>, @@ -229,7 +229,7 @@
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>2.2.0</version>
+        <version>2.3.2</version>
       </dependency>
       <dependency>
         <groupId>com.google.j2objc</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update GraphBuilder documentation with option of building an immutable graph

9b01341e204457911174d5b3fbb0222b543ba0e6

-------

<p> Simplify graph.PackageSanityTests by applying the new immutable graph builder.

c6c6c7323a16371dbbc65f5e31862bab3e38206c

-------

<p> Upgrade error_prone

Fixes #3439

0e928fc2b8ed23d2cca05c6cee40d95e495bc87c",Moe Sync
3445,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -4,11 +4,6 @@
          xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
 
   <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-  </parent>
   <groupId>com.google.guava</groupId>
   <artifactId>guava-parent</artifactId>
   <version>HEAD-android-SNAPSHOT</version>
@@ -212,6 +207,16 @@
     </pluginManagement>
   </build>
   <distributionManagement>
+    <snapshotRepository>
+      <id>sonatype-nexus-snapshots</id>
+      <name>Sonatype Nexus Snapshots</name>
+      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
+    </snapshotRepository>
+    <repository>
+      <id>sonatype-nexus-staging</id>
+      <name>Nexus Release Repository</name>
+      <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
+    </repository>
     <site>
       <id>guava-site</id>
       <name>Guava Documentation Site</name>
@@ -292,4 +297,53 @@
       </dependency>
     </dependencies>
   </dependencyManagement>
+  <profiles>
+    <profile>
+        <id>sonatype-oss-release</id>
+        <build>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-source-plugin</artifactId>
+              <version>2.1.2</version>
+              <executions>
+                <execution>
+                  <id>attach-sources</id>
+                  <goals>
+                    <goal>jar-no-fork</goal>
+                  </goals>
+                </execution>
+              </executions>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-javadoc-plugin</artifactId>
+              <version>${maven-javadoc-plugin.version}</version>
+                <executions>
+                  <execution>
+                    <id>attach-javadocs</id>
+                    <goals>
+                      <goal>jar</goal>
+                    </goals>
+                </execution>
+              </executions>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-gpg-plugin</artifactId>
+              <version>1.1</version>
+              <executions>
+                <execution>
+                  <id>sign-artifacts</id>
+                  <phase>verify</phase>
+                  <goals>
+                    <goal>sign</goal>
+                  </goals>
+                </execution>
+              </executions>
+            </plugin>
+          </plugins>
+      </build>
+    </profile>
+  </profiles>
 </project>, @@ -4,11 +4,6 @@
          xsi:schemaLocation=""http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"">
 
   <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>9</version>
-  </parent>
   <groupId>com.google.guava</groupId>
   <artifactId>guava-parent</artifactId>
   <version>HEAD-jre-SNAPSHOT</version>
@@ -208,6 +203,16 @@
     </pluginManagement>
   </build>
   <distributionManagement>
+    <snapshotRepository>
+      <id>sonatype-nexus-snapshots</id>
+      <name>Sonatype Nexus Snapshots</name>
+      <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
+    </snapshotRepository>
+    <repository>
+      <id>sonatype-nexus-staging</id>
+      <name>Nexus Release Repository</name>
+      <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
+    </repository>
     <site>
       <id>guava-site</id>
       <name>Guava Documentation Site</name>
@@ -301,4 +306,53 @@
       </dependency>
     </dependencies>
   </dependencyManagement>
+  <profiles>
+    <profile>
+        <id>sonatype-oss-release</id>
+        <build>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-source-plugin</artifactId>
+              <version>2.1.2</version>
+              <executions>
+                <execution>
+                  <id>attach-sources</id>
+                  <goals>
+                    <goal>jar-no-fork</goal>
+                  </goals>
+                </execution>
+              </executions>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-javadoc-plugin</artifactId>
+              <version>${maven-javadoc-plugin.version}</version>
+                <executions>
+                  <execution>
+                    <id>attach-javadocs</id>
+                    <goals>
+                      <goal>jar</goal>
+                    </goals>
+                </execution>
+              </executions>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-gpg-plugin</artifactId>
+              <version>1.1</version>
+              <executions>
+                <execution>
+                  <id>sign-artifacts</id>
+                  <phase>verify</phase>
+                  <goals>
+                    <goal>sign</goal>
+                  </goals>
+                </execution>
+              </executions>
+            </plugin>
+          </plugins>
+      </build>
+    </profile>
+  </profiles>
 </project>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove obsolete parent per https://github.com/sonatype/oss-parents
and Fixes https://github.com/google/guava/issues/2756

0bc019e4540f2ea126efa99b0f3c07c13e7e834f",Moe Sync
3449,Ron Shapiro,"['android/guava-tests/test/com/google/common/graph/MapCacheTest.java', 'android/guava-tests/test/com/google/common/primitives/ImmutableDoubleArrayTest.java', 'android/guava-tests/test/com/google/common/primitives/ImmutableIntArrayTest.java', 'android/guava-tests/test/com/google/common/primitives/ImmutableLongArrayTest.java', 'guava-tests/test/com/google/common/graph/MapCacheTest.java', 'guava-tests/test/com/google/common/primitives/ImmutableDoubleArrayTest.java', 'guava-tests/test/com/google/common/primitives/ImmutableIntArrayTest.java', 'guava-tests/test/com/google/common/primitives/ImmutableLongArrayTest.java']","@@ -83,7 +83,7 @@ public void testPutNewValue() {
   public void testRemoveEqualKeyWithDifferentReference() {
     String fooReference1 = new String(""foo"");
     String fooReference2 = new String(""foo"");
-    assertThat(fooReference1).isNotSameAs(fooReference2);
+    assertThat(fooReference1).isNotSameInstanceAs(fooReference2);
 
     assertThat(mapCache.put(fooReference1, ""bar"")).isNull();
     assertThat(mapCache.get(fooReference1)).isEqualTo(""bar""); // ensure first reference is cached, @@ -412,7 +412,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableDoubleArray iia) {
     ImmutableDoubleArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, @@ -400,7 +400,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableIntArray iia) {
     ImmutableIntArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, @@ -402,7 +402,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableLongArray iia) {
     ImmutableLongArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, @@ -83,7 +83,7 @@ public void testPutNewValue() {
   public void testRemoveEqualKeyWithDifferentReference() {
     String fooReference1 = new String(""foo"");
     String fooReference2 = new String(""foo"");
-    assertThat(fooReference1).isNotSameAs(fooReference2);
+    assertThat(fooReference1).isNotSameInstanceAs(fooReference2);
 
     assertThat(mapCache.put(fooReference1, ""bar"")).isNull();
     assertThat(mapCache.get(fooReference1)).isEqualTo(""bar""); // ensure first reference is cached, @@ -448,7 +448,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableDoubleArray iia) {
     ImmutableDoubleArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, @@ -433,7 +433,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableIntArray iia) {
     ImmutableIntArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, @@ -436,7 +436,7 @@ public void testSerialization() {
 
   private static void assertActuallyTrims(ImmutableLongArray iia) {
     ImmutableLongArray trimmed = iia.trimmed();
-    assertThat(trimmed).isNotSameAs(iia);
+    assertThat(trimmed).isNotSameInstanceAs(iia);
 
     // Yes, this is apparently how you check array equality in Truth
     assertThat(trimmed.toArray()).isEqualTo(iia.toArray());, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Override a method instead of special-casing it.

75e7b296f6530a9f58b501822457fc3be03e7948

-------

<p> Mitigate https://github.com/google/guava/issues/3223 by guessing that Sets are already deduplicated and making ""half and half"" expectations about un-duplicated inputs in ImmutableSet creation.

RELNOTES=Mitigate https://github.com/google/guava/issues/3223.

f1aa0f6194814b9b8821e5438216098c850a2ed9

-------

<p> Update ValueGraphBuilder documentation with option of building an immutable graph.

5879ed3133f4154ccca013941166be8c61f1ed97

-------

<p> Update NetworkBuilder documentation with option of building an immutable graph.

cdb288c576ff3c1e71e0315cde03cc68e4af33f3

-------

<p> Enable GoodTime-API

b34102f9b9ea11187de8f9961d02ab4d7e603fae

-------

<p> Fix misspelled Sec-WebSocket-Version header.

The correct name is Sec-WebSocket-Version, not Sec-WebSocket-Versions.

86ffa6e267b88db547b7aab9587d3e8a19081bf0

-------

<p> Match the casing of the WebSocket HTTP headers to the RFC directly.

RELNOTES=Match the casing of the WebSocket HTTP headers to the RFC directly.

517b59607597d659fb54bc6c71e33e974c41c494

-------

<p> Update Public Suffix data.

646d0e06333a3b64b101fdbe0ef93fa948b62c49

-------

<p> Remove outdated references to the ""next release of Guava"".

f2591b5c2a67b89b8c1cc1303b3a3cef5a9aa237

-------

<p> Update to Truth 0.44.

b61237ca571489a0a0ac738f707a4a0359c59e86

-------

<p> Migrate from isNotSameAs to isNotSameInstanceAs.

The two behave identically, and isNotSameAs is being removed.

8c4225f652e289025040f2454fefeaa90671310f",Moe Sync
3455,Ron Shapiro,"['guava-tests/test/com/google/common/collect/ImmutableBiMapTest.java', 'guava-tests/test/com/google/common/collect/ImmutableMapTest.java', 'guava-tests/test/com/google/common/collect/ImmutableMultisetTest.java', 'guava-tests/test/com/google/common/collect/ImmutableSetTest.java']","@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.stream.Collectors.toList;
 
 import com.google.common.annotations.GwtCompatible;
@@ -840,11 +841,11 @@ public void testResistsHashFloodingInConstruction() {
         long largeOps = largeCounter.total();
 
         double ratio = (double) largeOps / smallOps;
-        assertThat(ratio)
-            .named(
+        assertWithMessage(
                 ""ratio of equals/hashCode/compareTo operations to build an ImmutableBiMap with %s""
                     + "" via %s with %s entries versus %s entries"",
                 adversary, pathway, largeSize, smallSize)
+            .that(ratio)
             .isAtMost(2 * (largeSize * Math.log(largeSize)) / (smallSize * Math.log(smallSize)));
         // allow up to 2x wobble in the constant factors
       }
@@ -875,11 +876,11 @@ public void testResistsHashFloodingOnForwardGet() {
       }
 
       double ratio = (double) largeOps / smallOps;
-      assertThat(ratio)
-          .named(
+      assertWithMessage(
               ""Ratio of worst case get operations for an ImmutableBiMap with %s of size ""
                   + ""%s versus %s"",
               adversary, largeSize, smallSize)
+          .that(ratio)
           .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
       // allow up to 2x wobble in the constant factors
     }
@@ -908,11 +909,11 @@ public void testResistsHashFloodingOnInverseGet() {
         continue; // no queries on the CHCAE objects
       }
       double ratio = (double) largeOps / smallOps;
-      assertThat(ratio)
-          .named(
+      assertWithMessage(
               ""Ratio of worst case get operations for an ImmutableBiMap with %s of size ""
                   + ""%s versus %s"",
               adversary, largeSize, smallSize)
+          .that(ratio)
           .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
       // allow up to 2x wobble in the constant factors
     }, @@ -19,6 +19,7 @@
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static com.google.common.testing.SerializableTester.reserialize;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -1023,11 +1024,11 @@ public void testResistsHashFloodingInConstruction() {
       long largeOps = largeCounter.total();
 
       double ratio = (double) largeOps / smallOps;
-      assertThat(ratio)
-          .named(
+      assertWithMessage(
               ""ratio of equals/hashCode/compareTo operations to build an ImmutableMap via %s""
                   + "" with %s entries versus %s entries"",
               pathway, largeSize, smallSize)
+          .that(ratio)
           .isAtMost(2 * (largeSize * Math.log(largeSize)) / (smallSize * Math.log(smallSize)));
       // allow up to 2x wobble in the constant factors
     }
@@ -1052,10 +1053,10 @@ public void testResistsHashFloodingOnGet() {
     long worstCaseQueryLarge = worstCaseQueryOperations(largeMap, largeCounter);
 
     double ratio = (double) worstCaseQueryLarge / worstCaseQuerySmall;
-    assertThat(ratio)
-        .named(
+    assertWithMessage(
             ""Ratio of worst case query operations for an ImmutableMap of size %s versus %s"",
             largeSize, smallSize)
+        .that(ratio)
         .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
     // allow up to 2x wobble in the constant factors
   }, @@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
@@ -806,11 +807,11 @@ public void testResistsHashFloodingInConstruction() {
       long largeOps = largeCounter.total();
 
       double ratio = (double) largeOps / smallOps;
-      assertThat(ratio)
-          .named(
+      assertWithMessage(
               ""ratio of equals/hashCode/compareTo operations to build an ImmutableMultiset via %s""
                   + "" with %s entries versus %s entries"",
               pathway, largeSize, smallSize)
+          .that(ratio)
           .isAtMost(2 * (largeSize * Math.log(largeSize)) / (smallSize * Math.log(smallSize)));
       // allow up to 2x wobble in the constant factors
     }
@@ -833,10 +834,10 @@ public void testResistsHashFloodingOnCount() {
     long worstCaseQueryLarge = worstCaseQueryOperations(largeMap, largeCounter);
 
     double ratio = (double) worstCaseQueryLarge / worstCaseQuerySmall;
-    assertThat(ratio)
-        .named(
+    assertWithMessage(
             ""Ratio of worst case query operations for an ImmutableMultiset of size %s versus %s"",
             largeSize, smallSize)
+        .that(ratio)
         .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
     // allow up to 2x wobble in the constant factors
   }, @@ -17,6 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -536,11 +537,11 @@ public void testResistsHashFloodingInConstruction() {
 
       double ratio = (double) largeCounter.total() / smallCounter.total();
 
-      assertThat(ratio)
-          .named(
+      assertWithMessage(
               ""ratio of equals/hashCode/compareTo operations to build an ImmutableSet via pathway ""
                   + ""%s of size %s versus size %s"",
               pathway, haveSameHashesLarge.size(), haveSameHashesSmall.size())
+          .that(ratio)
           .isAtMost(2.0 * (largeSize * Math.log(largeSize)) / (smallSize * Math.log(smallSize)));
       // We allow up to 2x wobble in the constant factors.
     }
@@ -562,11 +563,11 @@ public void testResistsHashFloodingOnContains() {
     int smallSize = haveSameHashesSmall.size();
     int largeSize = haveSameHashesLarge.size();
 
-    assertThat(ratio)
-        .named(
+    assertWithMessage(
             ""ratio of equals/hashCode/compareTo operations to worst-case query an ImmutableSet ""
                 + ""of size %s versus size %s"",
             haveSameHashesLarge.size(), haveSameHashesSmall.size())
+        .that(ratio)
         .isAtMost(2 * Math.log(largeSize) / Math.log(smallSize));
     // We allow up to 2x wobble in the constant factors.
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fixed some links.

The comparisons to the Android Hash* classes haven't been accurate since at least CL 81367572, so I've removed them entirely.

Fixes #3398

1dc514b56a0fa213baa242acf9e58163638abef8

-------

<p> Migrate from assertThat(foo).named(""foo"") to assertWithMessage(""foo"").that(foo).

(The exact change is slightly different in some cases, like when using custom subjects or check(), but it's always a migration from named(...) to [assert]WithMessage(...).)

named(...) is being removed.

This CL may slightly modify the failure messages produced, but all the old information will still be present.

e70a2f9e53583c1c508a0f7b16bdcad8c3f2f740

-------

<p> Migrate from is(Not)SameAs to is(Not)SameInstanceAs.

They behave identically, and the old names are being removed.

Open-source note: The new methods are available in Truth as of version 0.44.

c19256717b493127a355fabf1eeb827fd0c64973

-------

<p> A few more doc tweaks, caught by @jbduncan in f2591b5c2a

414084c20aeb4b74fb85eab5cf0a787d76234939

-------

<p> Remove CheckedFuture from Guava.

RELNOTES=Removed deprecated `CheckedFuture` and related utilities.

cae1b9190e4bad3b6c01afbb08d9b0a366813c99

-------

<p> Migrate from assertThat(foo).named(""foo"") to assertWithMessage(""foo"").that(foo).

(The exact change is slightly different in some cases, like when using custom subjects or check(), but it's always a migration from named(...) to [assert]WithMessage(...).)

named(...) is being removed.

This CL may slightly modify the failure messages produced, but all the old information will still be present.

1f5c4780e522c32f9412e29cd2880124c81275e7",Moe Sync
3459,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -174,7 +174,7 @@
         </plugin>
         <plugin>
           <artifactId>maven-dependency-plugin</artifactId>
-          <version>2.10</version>
+          <version>3.1.1</version>
         </plugin>
         <plugin>
           <artifactId>maven-antrun-plugin</artifactId>, @@ -170,7 +170,7 @@
         </plugin>
         <plugin>
           <artifactId>maven-dependency-plugin</artifactId>
-          <version>2.10</version>
+          <version>3.1.1</version>
         </plugin>
         <plugin>
           <artifactId>maven-antrun-plugin</artifactId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Upgrade maven dependency plugin.

Fixes https://github.com/google/guava/pull/3456

2ef701fbfdd81587cf7f45856140c1b5071dc595",Moe Sync
3463,Ron Shapiro,"['android/pom.xml', 'pom.xml']","@@ -233,7 +233,7 @@
       <dependency>
         <groupId>org.checkerframework</groupId>
         <artifactId>checker-compat-qual</artifactId>
-        <version>2.5.2</version>
+        <version>2.5.5</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
@@ -243,7 +243,7 @@
       <dependency>
         <groupId>com.google.j2objc</groupId>
         <artifactId>j2objc-annotations</artifactId>
-        <version>1.1</version>
+        <version>1.3</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>, @@ -229,7 +229,7 @@
       <dependency>
         <groupId>org.checkerframework</groupId>
         <artifactId>checker-qual</artifactId>
-        <version>2.5.2</version>
+        <version>2.8.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
@@ -239,7 +239,7 @@
       <dependency>
         <groupId>com.google.j2objc</groupId>
         <artifactId>j2objc-annotations</artifactId>
-        <version>1.1</version>
+        <version>1.3</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add app.link to the Public Suffix List.

This is a temporary solution to stop app.link affiliated websites being grouped together in the Password Manager UI. We will reach out to the owners of app.link and work with them to update the public version of the PSL.

8268487ae35ede205c770797baa4b11b171e6025

-------

<p> Add java.util.UUID to ArbitraryInstances

Fixes #3448

ad3d9adf8c846f4853be966dda779f05d4e4060c

-------

<p> Upgrade compiler plugin.

Fixes https://github.com/google/guava/pull/3454.

7092295b535033b4b00786f9bc4c0708cf3e5165

-------

<p> Update versions of some Guava dependencies.

Fixes https://github.com/google/guava/issues/3405

ed830d31f824eb34df6898bbeb4de5b649300164",Moe Sync
3474,Ron Shapiro,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add FakeTicker.advance(Duration) and setAutoIncrementStep(Duration).

#goodtime

RELNOTES=Add FakeTicker.advance(Duration) and setAutoIncrementStep(Duration).

dcb5d431e288374666b70214de836ee09053b425

-------

<p> Add Queues.drain(BlockingQueue, Collection, int, Duration) and drainUninterruptibly(BlockingQueue, Collection, int, Duration).

RELNOTES=add Duration-based Queues drain methods.

5963112d7548abb44f5502d0bec1edda91d530fc

-------

<p> Add a new header field ""CDN-Loop"" to httputils.

More details: https://tools.ietf.org/html/rfc8586

RELNOTES=Add CDN-Loop header to library according to RFC8586.

d9f85b46fd5d85c3f4db91fd1d7387f6befa90ae

-------

<p> Remove app.link from the Public Suffix List.

8fa55701cc99c3016e9bda5b2807921c0e8b39cd",Moe Sync
3486,Ron Shapiro,"['android/guava/src/com/google/common/base/Functions.java', 'guava/src/com/google/common/base/Functions.java']","@@ -122,7 +122,7 @@ public String toString() {
    * set. See also {@link #forMap(Map)}, which throws an exception in this case.
    *
    * <p><b>Java 8 users:</b> you can just write the lambda expression {@code k ->
-   * map.getWithDefault(k, defaultValue)} instead.
+   * map.getOrDefault(k, defaultValue)} instead.
    *
    * @param map source map that determines the function behavior
    * @param defaultValue the value to return for inputs that aren't map keys, @@ -121,7 +121,7 @@ public String toString() {
    * set. See also {@link #forMap(Map)}, which throws an exception in this case.
    *
    * <p><b>Java 8 users:</b> you can just write the lambda expression {@code k ->
-   * map.getWithDefault(k, defaultValue)} instead.
+   * map.getOrDefault(k, defaultValue)} instead.
    *
    * @param map source map that determines the function behavior
    * @param defaultValue the value to return for inputs that aren't map keys, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add a link back to the goodtime rate bug.

5750fb6c05d0f8b32060f56b0a94a12a52c89260

-------

<p> Copy Durations.saturatedToNanos(Duration) to package-private c.g.c.u.c.Internal so it can be used by the concurrent package (and in Guava).

#goodtime

568cbb67101fdb56436e75467a23de8d027b1089

-------

<p> Tighten the GoodTime suppression locations in RateLimiter.

#goodtime

0df55a98cf54e2c3ccf1c1180ad4a20419d69a55

-------

<p> Add Duration-based overloads to Uninterruptibles.

#goodtime

RELNOTES=Add Duration-based overloads to Uninterruptibles.

e194e7578e5e8fea2edddd5a9544ebdeac961141

-------

<p> Always complete TimeoutFuture, even if toString() throws

6c09c1732c040050752b5a087a1070ebf899ae9f

-------

<p> Add Duration-based overloads to MoreExecutors.

#goodtime

RELNOTES=Add Duration-based overloads to MoreExecutors.

e2da132822d1e62d000564e51816c789dc823998

-------

<p> Add Duration-based overloads to FluentFuture.

#goodtime

RELNOTES=Add Duration-based overloads to FluentFuture.

7f5390dcb99c6930facb2a91cca056a25b8581a4

-------

<p> Add Duration-based overloads to Futures.

#goodtime

RELNOTES=Add Duration-based overloads to Futures.

070e07da83e8320f2c368709cb773f08a383797f

-------

<p> Add Duration-based overloads to AbstractScheduledService.

#goodtime

RELNOTES=Add Duration-based overloads to AbstractScheduledService.

e7a7a1f0c4962231d73f72d101deeaa2c2b0144c

-------

<p> Add Duration-based overloads to Service.

#goodtime

RELNOTES=Add Duration-based overloads to Service.

76718f4617a2d4daea00a578f808cae59c5cdc59

-------

<p> Add Duration-based overloads to ServiceManager.

#goodtime

RELNOTES=Add Duration-based overloads to ServiceManager.

6c6edfa0b24148d5665a8e31a1811df7045b9460

-------

<p> Remove CheckedFuture utilities from util.concurrent.Futures.

d3dcc67f6da3cbd5be687e2cddec6fb13a68dd8b

-------

<p> Add Duration-based overloads to RateLimiter.

#goodtime

RELNOTES=Add Duration-based overloads to RateLimiter.

7aee4f5c283e501c854ae06aaa201fc5328ebe4f

-------

<p> Add Duration-based overload to Monitor.

#goodtime

RELNOTES=Add Duration-based overload to Monitor.

ac540c41979ade6931d9d604eff1e6223e247a9a

-------

<p> Define project build source encoding as UTF-8

Closes https://github.com/google/guava/pull/3465

196dd9edd4a8d7caa2f5f073268fab759d91b3e2

-------

<p> Fix ""Apache License, Version 2.0"" spelling

There are many Java libraries licensed under ""Apache License, Version 2.0"" that do not use its official spelling.
This causes issues like https://issues.apache.org/jira/browse/MPIR-382: with every library defining its own spelling, it's difficult in large projects to have a clear view of all licenses in use.
This PR changes the license spelling to the official one, as advised by Maven developers.

Closes https://github.com/google/guava/pull/3471

eb8695c81d20d83871ddd105954bd5ac3528de71

-------

<p> Fix Streams.zip documentation typo.

8cc9e91bafa0b90360b6972fca23f9d4f8dd3f65

-------

<p> Add MediaType for ""application/geo+json"".

via https://github.com/google/guava/pull/3243

RELNOTES=Add MediaType for ""application/geo+json"".

b47e9ba4e2efa318a0cc44cd9acdb1c215d41c42

-------

<p> Upgrade maven-javadoc-plugin to 3.1.0.

Fixes https://github.com/google/guava/pull/3478.

34b7a1eff5091a14ed3a325a5966c9c43b219754

-------

<p> Add Cross-Origin-Resource-Policy header name constants.

Details https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header

RELNOTES=Add Cross-Origin-Resource-Policy header to library.

161241d58e93dfdba5a9021d2ee8dc64e3cd3937

-------

<p> Fix Javadoc links.

Fixes https://github.com/google/guava/pull/3481

86be2d13b5677207cbc49bfb4431142b119647e6

-------

<p> Update documentation to refer correct method name.

https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#getOrDefault-java.lang.Object-V-

RELNOTES=N/A

a6f7253500de9a6a88c56e94858759c437dee20b",Moe Sync
3495,Ron Shapiro,"['android/guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java', 'guava/src/com/google/common/util/concurrent/SimpleTimeLimiter.java']","@@ -113,8 +113,7 @@ public Object call() throws Exception {
     return interfaceType.cast(object);
   }
 
-  private
-  <T> T callWithTimeout(
+  private <T> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean amInterruptible)
       throws Exception {
     checkNotNull(callable);, @@ -113,8 +113,7 @@ public Object call() throws Exception {
     return interfaceType.cast(object);
   }
 
-  private
-  <T> T callWithTimeout(
+  private <T> T callWithTimeout(
       Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit, boolean amInterruptible)
       throws Exception {
     checkNotNull(callable);, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove `@Beta` from `setFuture`.

RELNOTES=Removed `@Beta` from `setFuture`.

2c717c0092ad5abbbe6a34d426e084623c651354

-------

<p> Upgrade maven-gpg-plugin to 1.6

Fixes github.com/google/guava/pull/3490

c10a1647ffa968a96273d0961a6f9e0181a4fe70

-------

<p> Clarify behavior of `ImmutableList#copyOf` for null argument.

Fixes #3485

6f655fb940809499719ba7679a425961e39a8feb

-------

<p> Make the incidentEdges() documentation a little bit more clear.

b0a05097900ab2decf17681d3dcd9154f225d91f

-------

<p> Simplify implementation of Graphs.reachableNodes()

b917492c31401a2e6092c8f3f6bc60040c1dcebe

-------

<p> Make the adjacentNodes() documentation a little bit more clear.

7a5a43b66a4f0a22077918404fa95a165ede2811

-------

<p> Delete deprecated callWithTimeout().

fa13235f2c8edff9cd6c434f8a164250decf0249",Moe Sync
3519,Ron Shapiro,['.travis.yml'],"@@ -3,15 +3,9 @@ sudo: false
 language: java
 
 jdk:
-  - oraclejdk8
+  - openjdk8
   - openjdk11
 
-# https://github.com/travis-ci/travis-ci/issues/3259#issuecomment-130860338
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer
-
 install: mvn -B -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn install -U -DskipTests=true -f $ROOT_POM
 
 # https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add missing description tags to guava-parent poms.

We were previously apparently inheriting them from sonatype-oss-parent, until we removed that. Releases don't work without a description. ""Invalid POM: /com/google/guava/guava-parent/28.0-android/guava-parent-28.0-android.pom: Project description missing""

c417618b2be5c127baf8a739789615b3f5c5fe7c

-------

<p> Fix typo in 'stoppingCount' variable name

Fixes #3500

c168ba2f5939102ee0b3e3cbd941f213d3ff8e8a

-------

<p> Split catch() blocks so that javac doesn't generate a reference to their common supertype, ReflectiveOperationException.

ReflectiveOperationException isn't available on the old versions of Android that we support.

As far as we know, there is no actual problem with these references because no methods are called on them. However, the new version of Animal Sniffer we're updating to will flag them anyway, and I think that avoiding them is the safe thing to do.

Prepares for #3497

15c9a9385713910a1ecf9e5a5e6e50e13755fef3

-------

<p> Upgrade animal sniffer version to 1.18

Fixes #3497

afdecf706fa86c5d4760b8211df2b00806e9458c

-------

<p> Document default values of builder setters.

d5dca3613d5a47b87ed88a332e35e2f60a025630

-------

<p> Use saturatedToNanos() in CacheBuilder to avoid overflows.

RELNOTES=Use saturatedToNanos() in CacheBuilder to avoid overflows.

7d04f72bf355e9bac1312debb3af7dca28833077

-------

<p> Tweaks to the list of Guava features.

4dbc7c1a545bdf5dd20a5934ff66c171806957db

-------

<p> Add more @Nullables to variadic parameter lists.

RELNOTES=Add more @Nullables to variadic parameter lists.

fbae3f47239fbea0555b4df2c4aea474f23d4b70

-------

<p> Halve memory consumption when creating a Bloom filter.

AtomicLongArray(long[]) clones its input, which is a waste when we're passing
in a new array.

RELNOTES=Halve VmPeak when creating a Bloom filter.

f4998201486012d050092ebbdbfb10713e9df549

-------

<p> Use LongMath.saturatedAdd/Subtract in CacheStats.

Fixes https://github.com/google/guava/issues/3503

RELNOTES=avoid overflows/underflows in CacheStats

9f3d0481768aa3b0e08de20ab881df4579d6ad18

-------

<p> Fix the travis build

ba4111cb700754c4f6e9be3a5a35ab420610e2eb",Moe Sync
3525,Ron Shapiro,"['guava-tests/test/com/google/common/collect/TreeRangeMapTest.java', 'guava/src/com/google/common/collect/ImmutableRangeMap.java', 'guava/src/com/google/common/collect/RangeMap.java', 'guava/src/com/google/common/collect/TreeRangeMap.java']","@@ -28,7 +28,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
-import java.util.function.BiFunction;
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
@@ -526,156 +525,6 @@ public void testPutCoalescingComplex() {
         rangeMap.asMapOfRanges());
   }
 
-  public void testMergeOntoRangeOverlappingLowerBound() {
-    // {[0..2): 1}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(0, 2), 1);
-
-    rangeMap.merge(Range.closedOpen(1, 3), 2, Integer::sum);
-
-    // {[0..1): 1, [1..2): 3, [2, 3): 2}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 1)
-            .put(Range.closedOpen(1, 2), 3)
-            .put(Range.closedOpen(2, 3), 2)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeOntoRangeOverlappingUpperBound() {
-    // {[1..3): 1}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(1, 3), 1);
-
-    rangeMap.merge(Range.closedOpen(0, 2), 2, Integer::sum);
-
-    // {[0..1): 2, [1..2): 3, [2, 3): 1}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 2)
-            .put(Range.closedOpen(1, 2), 3)
-            .put(Range.closedOpen(2, 3), 1)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeOntoIdenticalRange() {
-    // {[0..1): 1}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(0, 1), 1);
-
-    rangeMap.merge(Range.closedOpen(0, 1), 2, Integer::sum);
-
-    // {[0..1): 3}
-    assertEquals(ImmutableMap.of(Range.closedOpen(0, 1), 3), rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeOntoSuperRange() {
-    // {[0..3): 1}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(0, 3), 1);
-
-    rangeMap.merge(Range.closedOpen(1, 2), 2, Integer::sum);
-
-    // {[0..1): 1, [1..2): 3, [2..3): 1}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 1)
-            .put(Range.closedOpen(1, 2), 3)
-            .put(Range.closedOpen(2, 3), 1)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeOntoSubRange() {
-    // {[1..2): 1}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(1, 2), 1);
-
-    rangeMap.merge(Range.closedOpen(0, 3), 2, Integer::sum);
-
-    // {[0..1): 2, [1..2): 3, [2..3): 2}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 2)
-            .put(Range.closedOpen(1, 2), 3)
-            .put(Range.closedOpen(2, 3), 2)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeOntoDisconnectedRanges() {
-    // {[0..1): 1, [2, 3): 2}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(0, 1), 1);
-    rangeMap.put(Range.closedOpen(2, 3), 2);
-
-    rangeMap.merge(Range.closedOpen(0, 3), 3, Integer::sum);
-
-    // {[0..1): 4, [1..2): 3, [2..3): 5}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 4)
-            .put(Range.closedOpen(1, 2), 3)
-            .put(Range.closedOpen(2, 3), 5)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeNullValue() {
-    // {[1..2): 1, [3, 4): 2}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(1, 2), 1);
-    rangeMap.put(Range.closedOpen(3, 4), 2);
-
-    rangeMap.merge(Range.closedOpen(0, 5), null, (v1, v2) -> v1 + 1);
-
-    // {[1..2): 2, [3..4): 3}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(1, 2), 2)
-            .put(Range.closedOpen(3, 4), 3)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeWithRemappingFunctionReturningNullValue() {
-    // {[1..2): 1, [3, 4): 2}
-    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
-    rangeMap.put(Range.closedOpen(1, 2), 1);
-    rangeMap.put(Range.closedOpen(3, 4), 2);
-
-    rangeMap.merge(Range.closedOpen(0, 5), 3, (v1, v2) -> null);
-
-    // {[0..1): 3, [2..3): 3, [4, 5): 3}
-    assertEquals(
-        new ImmutableMap.Builder<>()
-            .put(Range.closedOpen(0, 1), 3)
-            .put(Range.closedOpen(2, 3), 3)
-            .put(Range.closedOpen(4, 5), 3)
-            .build(),
-        rangeMap.asMapOfRanges());
-  }
-
-  public void testMergeAllRangeTriples() {
-    for (Range<Integer> range1 : RANGES) {
-      for (Range<Integer> range2 : RANGES) {
-        for (Range<Integer> range3 : RANGES) {
-          Map<Integer, Integer> model = Maps.newHashMap();
-          mergeModel(model, range1, 1, Integer::sum);
-          mergeModel(model, range2, 2, Integer::sum);
-          mergeModel(model, range3, 3, Integer::sum);
-          RangeMap<Integer, Integer> test = TreeRangeMap.create();
-          test.merge(range1, 1, Integer::sum);
-          test.merge(range2, 2, Integer::sum);
-          test.merge(range3, 3, Integer::sum);
-          verify(model, test);
-        }
-      }
-    }
-  }
-
   public void testSubRangeMapExhaustive() {
     for (Range<Integer> range1 : RANGES) {
       for (Range<Integer> range2 : RANGES) {
@@ -875,16 +724,4 @@ private static void removeModel(Map<Integer, Integer> model, Range<Integer> rang
       }
     }
   }
-
-  private static void mergeModel(
-      Map<Integer, Integer> model,
-      Range<Integer> range,
-      int value,
-      BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
-    for (int i = MIN_BOUND - 1; i <= MAX_BOUND + 1; i++) {
-      if (range.contains(i)) {
-        model.merge(i, value, remappingFunction);
-      }
-    }
-  }
 }, @@ -29,7 +29,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
-import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -272,21 +271,6 @@ public void remove(Range<K> range) {
     throw new UnsupportedOperationException();
   }
 
-  /**
-   * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
-   *
-   * @throws UnsupportedOperationException always
-   * @deprecated Unsupported operation.
-   */
-  @Deprecated
-  @Override
-  public void merge(
-      Range<K> range,
-      @Nullable V value,
-      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
-    throw new UnsupportedOperationException();
-  }
-
   @Override
   public ImmutableMap<Range<K>, V> asMapOfRanges() {
     if (ranges.isEmpty()) {, @@ -22,7 +22,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
-import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -108,25 +107,6 @@
    */
   void remove(Range<K> range);
 
-  /**
-   * Merges a value into the map over a range by applying a remapping function.
-   *
-   * <p>If any parts of the range are already present in this range map, those parts are mapped to
-   * new values by applying the remapping function. Any parts of the range not already present in
-   * this range map are mapped to the specified value, unless the value is {@code null}.
-   *
-   * <p>Any existing map entry spanning either range boundary may be split at the boundary, even if
-   * the merge does not affect its value.
-   *
-   * <p>For example, if {@code rangeMap} had one entry {@code [1, 5] => 3} then {@code
-   * rangeMap.merge(Range.closed(0,2), 3, Math::max)} could yield a range map with the entries
-   * {@code [0, 1) => 3, [1, 2] => 3, (2, 5] => 3}.
-   */
-  void merge(
-      Range<K> range,
-      @Nullable V value,
-      BiFunction<? super V, ? super V, ? extends V> remappingFunction);
-
   /**
    * Returns a view of this range map as an unmodifiable {@code Map<Range<K>, V>}. Modifications to
    * this range map are guaranteed to read through to the returned {@code Map}., @@ -37,7 +37,6 @@
 import java.util.NavigableMap;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -240,80 +239,6 @@ public void remove(Range<K> rangeToRemove) {
     entriesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
   }
 
-  private void split(Cut<K> cut) {
-    /*
-     * The comments for this method will use | to indicate the cut point and ( ) to indicate the
-     * bounds of ranges in the range map.
-     */
-    Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryToSplit = entriesByLowerBound.lowerEntry(cut);
-    if (mapEntryToSplit == null) {
-      return;
-    }
-    // we know ( |
-    RangeMapEntry<K, V> rangeMapEntry = mapEntryToSplit.getValue();
-    if (rangeMapEntry.getUpperBound().compareTo(cut) <= 0) {
-      return;
-    }
-    // we know ( | )
-    putRangeMapEntry(rangeMapEntry.getLowerBound(), cut, rangeMapEntry.getValue());
-    putRangeMapEntry(cut, rangeMapEntry.getUpperBound(), rangeMapEntry.getValue());
-  }
-
-  @Override
-  public void merge(
-      Range<K> range,
-      @Nullable V value,
-      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
-    checkNotNull(range);
-    checkNotNull(remappingFunction);
-
-    if (range.isEmpty()) {
-      return;
-    }
-    split(range.lowerBound);
-    split(range.upperBound);
-
-    // Due to the splitting of any entries spanning the range bounds, we know that any entry with a
-    // lower bound in the merge range is entirely contained by the merge range.
-    Set<Entry<Cut<K>, RangeMapEntry<K, V>>> entriesInMergeRange =
-        entriesByLowerBound.subMap(range.lowerBound, range.upperBound).entrySet();
-
-    // Create entries mapping any unmapped ranges in the merge range to the specified value.
-    ImmutableMap.Builder<Cut<K>, RangeMapEntry<K, V>> gaps = ImmutableMap.builder();
-    if (value != null) {
-      final Iterator<Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr =
-          entriesInMergeRange.iterator();
-      Cut<K> lowerBound = range.lowerBound;
-      while (backingItr.hasNext()) {
-        RangeMapEntry<K, V> entry = backingItr.next().getValue();
-        Cut<K> upperBound = entry.getLowerBound();
-        if (!lowerBound.equals(upperBound)) {
-          gaps.put(lowerBound, new RangeMapEntry<K, V>(lowerBound, upperBound, value));
-        }
-        lowerBound = entry.getUpperBound();
-      }
-      if (!lowerBound.equals(range.upperBound)) {
-        gaps.put(lowerBound, new RangeMapEntry<K, V>(lowerBound, range.upperBound, value));
-      }
-    }
-
-    // Remap all existing entries in the merge range.
-    final Iterator<Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr = entriesInMergeRange.iterator();
-    while (backingItr.hasNext()) {
-      Entry<Cut<K>, RangeMapEntry<K, V>> entry = backingItr.next();
-      V newValue = remappingFunction.apply(entry.getValue().getValue(), value);
-      if (newValue == null) {
-        backingItr.remove();
-      } else {
-        entry.setValue(
-            new RangeMapEntry<K, V>(
-                entry.getValue().getLowerBound(), entry.getValue().getUpperBound(), newValue));
-      }
-    }
-
-    entriesByLowerBound.putAll(gaps.build());
-  }
-
   @Override
   public Map<Range<K>, V> asMapOfRanges() {
     return new AsMapOfRanges(entriesByLowerBound.values());
@@ -422,14 +347,6 @@ public void remove(Range range) {
           checkNotNull(range);
         }
 
-        @Override
-        @SuppressWarnings(""rawtypes"") // necessary for static EMPTY_SUB_RANGE_MAP instance
-        public void merge(Range range, @Nullable Object value, BiFunction remappingFunction) {
-          checkNotNull(range);
-          throw new IllegalArgumentException(
-              ""Cannot merge range "" + range + "" into an empty subRangeMap"");
-        }
-
         @Override
         public Map<Range, Object> asMapOfRanges() {
           return Collections.emptyMap();
@@ -544,19 +461,6 @@ public void remove(Range<K> range) {
       }
     }
 
-    @Override
-    public void merge(
-        Range<K> range,
-        @Nullable V value,
-        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
-      checkArgument(
-          subRange.encloses(range),
-          ""Cannot merge range %s into a subRangeMap(%s)"",
-          range,
-          subRange);
-      TreeRangeMap.this.merge(range, value, remappingFunction);
-    }
-
     @Override
     public RangeMap<K, V> subRangeMap(Range<K> range) {
       if (!range.isConnected(subRange)) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix typo in ImmutableList.java.

922214b3068213d28b20316997a9bbab77080d52

-------

<p> Update Fetch Metadata (formerly Sec-Metadata) headers to point to w3c documentation now it's been adopted by WebAppSec.

RELNOTES=Update Fetch Metadata (formerly Sec-Metadata) headers to point to w3c documentation now it's been adopted by WebAppSec.

2ae2f73318946f99f05af4e0867fb04495ee66bf

-------

<p> Add a test for LongAdder overflow behavior.

See https://github.com/google/guava/issues/3503

558321c2ba739f1b7d0a7bf5046e6867e4aea9d5

-------

<p> Fix some rawtypes in com.google.common.cache.

310de86d74c2c77924c1a69d22c7acdf286bd258

-------

<p> Saturate LongAdder.sum() results to Long.MAX_VALUE during an overflow.

Fixes https://github.com/google/guava/issues/3503

RELNOTES=Fix potential overflow/IAE during cache stats calculations.

b28a260a3b847b627cc4c33dd4fd6bed05d4e2f6

-------

<p> Add RangeMap#merge, analogous to Map#merge.

8dc46a72fa5417d02063052f05fd0355703411fc

-------

<p> Automated rollback of 8dc46a72fa5417d02063052f05fd0355703411fc

*** Reason for rollback ***

Breaking a number of projects

*** Original change description ***

Add RangeMap#merge, analogous to Map#merge.

***

44d0870b7e4d6a9fa8cca847bf35652111bd7539",Moe Sync
3531,Ron Shapiro,"['android/guava/src/com/google/common/io/Closer.java', 'guava/src/com/google/common/io/Closer.java']","@@ -265,9 +265,9 @@ static boolean isAvailable() {
       return addSuppressed != null;
     }
 
-    static final Method addSuppressed = getAddSuppressed();
+    static final Method addSuppressed = addSuppressedMethodOrNull();
 
-    private static Method getAddSuppressed() {
+    private static Method addSuppressedMethodOrNull() {
       try {
         return Throwable.class.getMethod(""addSuppressed"", Throwable.class);
       } catch (Throwable e) {, @@ -265,9 +265,9 @@ static boolean isAvailable() {
       return addSuppressed != null;
     }
 
-    static final Method addSuppressed = getAddSuppressed();
+    static final Method addSuppressed = addSuppressedMethodOrNull();
 
-    private static Method getAddSuppressed() {
+    private static Method addSuppressedMethodOrNull() {
       try {
         return Throwable.class.getMethod(""addSuppressed"", Throwable.class);
       } catch (Throwable e) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Clarify that SortedSetMultimap exposes the values for a key in sorted order but does *not* necessarily expose the keys in sorted order.

09bf107763561ae37ddd99cf024d6c5604eedfff

-------

<p> Remove unneeded @SuppressWarnings from @Benchmark methods.

RELNOTES=none

3c3f7c9f7bfd997c5528a4ce7dd0c802c3aeb26f

-------

<p> Rename a method to avoid J2ObjC collisions

Prevent J2ObjC from treating `getAddSuppressed` as a getter by renaming it `generateAddSuppressed`. This silences a -Wobjc-property-implementation warning; soon, such warnings will become errors. See the referenced bug for full context.

cc5a55e487791db6ab2b7a98bcfd1be69d7a3638",Moe Sync
3533,Nick,"['guava-tests/test/com/google/common/collect/TreeRangeMapTest.java', 'guava/src/com/google/common/collect/ImmutableRangeMap.java', 'guava/src/com/google/common/collect/RangeMap.java', 'guava/src/com/google/common/collect/TreeRangeMap.java']","@@ -28,6 +28,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
+import java.util.function.BiFunction;
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
@@ -525,6 +526,156 @@ public void testPutCoalescingComplex() {
         rangeMap.asMapOfRanges());
   }
 
+  public void testMergeOntoRangeOverlappingLowerBound() {
+    // {[0..2): 1}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 2), 1);
+
+    rangeMap.merge(Range.closedOpen(1, 3), 2, Integer::sum);
+
+    // {[0..1): 1, [1..2): 3, [2, 3): 2}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 1)
+            .put(Range.closedOpen(1, 2), 3)
+            .put(Range.closedOpen(2, 3), 2)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeOntoRangeOverlappingUpperBound() {
+    // {[1..3): 1}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(1, 3), 1);
+
+    rangeMap.merge(Range.closedOpen(0, 2), 2, Integer::sum);
+
+    // {[0..1): 2, [1..2): 3, [2, 3): 1}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 2)
+            .put(Range.closedOpen(1, 2), 3)
+            .put(Range.closedOpen(2, 3), 1)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeOntoIdenticalRange() {
+    // {[0..1): 1}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 1), 1);
+
+    rangeMap.merge(Range.closedOpen(0, 1), 2, Integer::sum);
+
+    // {[0..1): 3}
+    assertEquals(ImmutableMap.of(Range.closedOpen(0, 1), 3), rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeOntoSuperRange() {
+    // {[0..3): 1}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 3), 1);
+
+    rangeMap.merge(Range.closedOpen(1, 2), 2, Integer::sum);
+
+    // {[0..1): 1, [1..2): 3, [2..3): 1}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 1)
+            .put(Range.closedOpen(1, 2), 3)
+            .put(Range.closedOpen(2, 3), 1)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeOntoSubRange() {
+    // {[1..2): 1}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(1, 2), 1);
+
+    rangeMap.merge(Range.closedOpen(0, 3), 2, Integer::sum);
+
+    // {[0..1): 2, [1..2): 3, [2..3): 2}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 2)
+            .put(Range.closedOpen(1, 2), 3)
+            .put(Range.closedOpen(2, 3), 2)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeOntoDisconnectedRanges() {
+    // {[0..1): 1, [2, 3): 2}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 1), 1);
+    rangeMap.put(Range.closedOpen(2, 3), 2);
+
+    rangeMap.merge(Range.closedOpen(0, 3), 3, Integer::sum);
+
+    // {[0..1): 4, [1..2): 3, [2..3): 5}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 4)
+            .put(Range.closedOpen(1, 2), 3)
+            .put(Range.closedOpen(2, 3), 5)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeNullValue() {
+    // {[1..2): 1, [3, 4): 2}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(1, 2), 1);
+    rangeMap.put(Range.closedOpen(3, 4), 2);
+
+    rangeMap.merge(Range.closedOpen(0, 5), null, (v1, v2) -> v1 + 1);
+
+    // {[1..2): 2, [3..4): 3}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(1, 2), 2)
+            .put(Range.closedOpen(3, 4), 3)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeWithRemappingFunctionReturningNullValue() {
+    // {[1..2): 1, [3, 4): 2}
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(1, 2), 1);
+    rangeMap.put(Range.closedOpen(3, 4), 2);
+
+    rangeMap.merge(Range.closedOpen(0, 5), 3, (v1, v2) -> null);
+
+    // {[0..1): 3, [2..3): 3, [4, 5): 3}
+    assertEquals(
+        new ImmutableMap.Builder<>()
+            .put(Range.closedOpen(0, 1), 3)
+            .put(Range.closedOpen(2, 3), 3)
+            .put(Range.closedOpen(4, 5), 3)
+            .build(),
+        rangeMap.asMapOfRanges());
+  }
+
+  public void testMergeAllRangeTriples() {
+    for (Range<Integer> range1 : RANGES) {
+      for (Range<Integer> range2 : RANGES) {
+        for (Range<Integer> range3 : RANGES) {
+          Map<Integer, Integer> model = Maps.newHashMap();
+          mergeModel(model, range1, 1, Integer::sum);
+          mergeModel(model, range2, 2, Integer::sum);
+          mergeModel(model, range3, 3, Integer::sum);
+          RangeMap<Integer, Integer> test = TreeRangeMap.create();
+          test.merge(range1, 1, Integer::sum);
+          test.merge(range2, 2, Integer::sum);
+          test.merge(range3, 3, Integer::sum);
+          verify(model, test);
+        }
+      }
+    }
+  }
+
   public void testSubRangeMapExhaustive() {
     for (Range<Integer> range1 : RANGES) {
       for (Range<Integer> range2 : RANGES) {
@@ -724,4 +875,16 @@ private static void removeModel(Map<Integer, Integer> model, Range<Integer> rang
       }
     }
   }
+
+  private static void mergeModel(
+      Map<Integer, Integer> model,
+      Range<Integer> range,
+      int value,
+      BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
+    for (int i = MIN_BOUND - 1; i <= MAX_BOUND + 1; i++) {
+      if (range.contains(i)) {
+        model.merge(i, value, remappingFunction);
+      }
+    }
+  }
 }, @@ -29,6 +29,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
+import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -271,6 +272,21 @@ public void remove(Range<K> range) {
     throw new UnsupportedOperationException();
   }
 
+  /**
+   * Guaranteed to throw an exception and leave the {@code RangeMap} unmodified.
+   *
+   * @throws UnsupportedOperationException always
+   * @deprecated Unsupported operation.
+   */
+  @Deprecated
+  @Override
+  public void merge(
+      Range<K> range,
+      @Nullable V value,
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+    throw new UnsupportedOperationException();
+  }
+
   @Override
   public ImmutableMap<Range<K>, V> asMapOfRanges() {
     if (ranges.isEmpty()) {, @@ -22,6 +22,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
+import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -107,6 +108,25 @@
    */
   void remove(Range<K> range);
 
+  /**
+   * Merges a value into the map over a range by applying a remapping function.
+   *
+   * <p>If any parts of the range are already present in this range map, those parts are mapped to
+   * new values by applying the remapping function. Any parts of the range not already present in
+   * this range map are mapped to the specified value, unless the value is {@code null}.
+   *
+   * <p>Any existing map entry spanning either range boundary may be split at the boundary, even if
+   * the merge does not affect its value.
+   *
+   * <p>For example, if {@code rangeMap} had one entry {@code [1, 5] => 3} then {@code
+   * rangeMap.merge(Range.closed(0,2), 3, Math::max)} could yield a range map with the entries
+   * {@code [0, 1) => 3, [1, 2] => 3, (2, 5] => 3}.
+   */
+  void merge(
+      Range<K> range,
+      @Nullable V value,
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction);
+
   /**
    * Returns a view of this range map as an unmodifiable {@code Map<Range<K>, V>}. Modifications to
    * this range map are guaranteed to read through to the returned {@code Map}., @@ -37,6 +37,7 @@
 import java.util.NavigableMap;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.function.BiFunction;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -239,6 +240,80 @@ public void remove(Range<K> rangeToRemove) {
     entriesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();
   }
 
+  private void split(Cut<K> cut) {
+    /*
+     * The comments for this method will use | to indicate the cut point and ( ) to indicate the
+     * bounds of ranges in the range map.
+     */
+    Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryToSplit = entriesByLowerBound.lowerEntry(cut);
+    if (mapEntryToSplit == null) {
+      return;
+    }
+    // we know ( |
+    RangeMapEntry<K, V> rangeMapEntry = mapEntryToSplit.getValue();
+    if (rangeMapEntry.getUpperBound().compareTo(cut) <= 0) {
+      return;
+    }
+    // we know ( | )
+    putRangeMapEntry(rangeMapEntry.getLowerBound(), cut, rangeMapEntry.getValue());
+    putRangeMapEntry(cut, rangeMapEntry.getUpperBound(), rangeMapEntry.getValue());
+  }
+
+  @Override
+  public void merge(
+      Range<K> range,
+      @Nullable V value,
+      BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+    checkNotNull(range);
+    checkNotNull(remappingFunction);
+
+    if (range.isEmpty()) {
+      return;
+    }
+    split(range.lowerBound);
+    split(range.upperBound);
+
+    // Due to the splitting of any entries spanning the range bounds, we know that any entry with a
+    // lower bound in the merge range is entirely contained by the merge range.
+    Set<Entry<Cut<K>, RangeMapEntry<K, V>>> entriesInMergeRange =
+        entriesByLowerBound.subMap(range.lowerBound, range.upperBound).entrySet();
+
+    // Create entries mapping any unmapped ranges in the merge range to the specified value.
+    ImmutableMap.Builder<Cut<K>, RangeMapEntry<K, V>> gaps = ImmutableMap.builder();
+    if (value != null) {
+      final Iterator<Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr =
+          entriesInMergeRange.iterator();
+      Cut<K> lowerBound = range.lowerBound;
+      while (backingItr.hasNext()) {
+        RangeMapEntry<K, V> entry = backingItr.next().getValue();
+        Cut<K> upperBound = entry.getLowerBound();
+        if (!lowerBound.equals(upperBound)) {
+          gaps.put(lowerBound, new RangeMapEntry<K, V>(lowerBound, upperBound, value));
+        }
+        lowerBound = entry.getUpperBound();
+      }
+      if (!lowerBound.equals(range.upperBound)) {
+        gaps.put(lowerBound, new RangeMapEntry<K, V>(lowerBound, range.upperBound, value));
+      }
+    }
+
+    // Remap all existing entries in the merge range.
+    final Iterator<Entry<Cut<K>, RangeMapEntry<K, V>>> backingItr = entriesInMergeRange.iterator();
+    while (backingItr.hasNext()) {
+      Entry<Cut<K>, RangeMapEntry<K, V>> entry = backingItr.next();
+      V newValue = remappingFunction.apply(entry.getValue().getValue(), value);
+      if (newValue == null) {
+        backingItr.remove();
+      } else {
+        entry.setValue(
+            new RangeMapEntry<K, V>(
+                entry.getValue().getLowerBound(), entry.getValue().getUpperBound(), newValue));
+      }
+    }
+
+    entriesByLowerBound.putAll(gaps.build());
+  }
+
   @Override
   public Map<Range<K>, V> asMapOfRanges() {
     return new AsMapOfRanges(entriesByLowerBound.values());
@@ -347,6 +422,14 @@ public void remove(Range range) {
           checkNotNull(range);
         }
 
+        @Override
+        @SuppressWarnings(""rawtypes"") // necessary for static EMPTY_SUB_RANGE_MAP instance
+        public void merge(Range range, @Nullable Object value, BiFunction remappingFunction) {
+          checkNotNull(range);
+          throw new IllegalArgumentException(
+              ""Cannot merge range "" + range + "" into an empty subRangeMap"");
+        }
+
         @Override
         public Map<Range, Object> asMapOfRanges() {
           return Collections.emptyMap();
@@ -461,6 +544,19 @@ public void remove(Range<K> range) {
       }
     }
 
+    @Override
+    public void merge(
+        Range<K> range,
+        @Nullable V value,
+        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+      checkArgument(
+          subRange.encloses(range),
+          ""Cannot merge range %s into a subRangeMap(%s)"",
+          range,
+          subRange);
+      TreeRangeMap.this.merge(range, value, remappingFunction);
+    }
+
     @Override
     public RangeMap<K, V> subRangeMap(Range<K> range) {
       if (!range.isConnected(subRange)) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add RangeMap#merge, analogous to Map#merge.

Rollback of 8000dc992d0124372972729b20df40a42b27a849

cebc1985b8d64f3960e363b5641428447e6d33ae",Moe Sync
3537,Nick,['README.md'],"@@ -65,6 +65,7 @@ flavor.
 - [GitHub project](https://github.com/google/guava)
 - [Issue tracker: Report a defect or feature request](https://github.com/google/guava/issues/new)
 - [StackOverflow: Ask ""how-to"" and ""why-didn't-it-work"" questions](https://stackoverflow.com/questions/ask?tags=guava+java)
+- [guava-announce: Announcements of releases and upcoming significant changes](http://groups.google.com/group/guava-announce)
 - [guava-discuss: For open-ended questions and discussion](http://groups.google.com/group/guava-discuss)
 
 ## IMPORTANT WARNINGS, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Link to guava-announce.

f088027eb9adc7308954cadeb920f32d6cead728",Moe Sync
3551,Colin Decker,['guava-testlib/src/com/google/common/collect/testing/SpliteratorTester.java'],"@@ -185,8 +185,9 @@ public final Ordered expect(Iterable<?> elements) {
     return new Ordered() {
       @Override
       public void inOrder() {
-        resultsForAllStrategies.forEach(
-            resultsForStrategy -> assertEqualInOrder(elements, resultsForStrategy));
+        for (List<E> resultsForStrategy : resultsForAllStrategies) {
+          assertEqualInOrder(elements, resultsForStrategy);
+        }
       }
     };
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove inaccurate comment.

2cc9ccd8f58402927f4903ebf40f19a63f47c789

-------

<p> Change the Splitter::limit arg to maxItems, for IDE usage.

The old name of `limit` was uninformative when presented in e.g. IDE autocompletions. `maxItems` will help distinguish it from the alternative meaning of max number of splits to make.

013d0f1b058f7c6e3ac159745fcead5f481f5b66

-------

<p> gwt.xml change from internal change.

a13896bd6b55883dbe1f4ae71603597f3831a89d

-------

<p> Add MediaType for ""image/heif"" and ""image/jp2""

RELNOTES=Add MediaType for ""image/heif"" and ""image/jp2""

4c70d7f3c3083946aa74e59098b51f521da27239

-------

<p> Change a use of Iterable.forEach, which isn't available under Desugar.

6508a374b7483ea2ec7f5170b94489cb9dc3537d",Moe Sync
3560,David P. Baker,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix an issue where the InputStream returned by BaseEncoding.decodingStream(Reader) could fail to throw DecodingException while decoding an invalid string.

This was caused by the default behavior of InputStream.read(byte[], int, int), which swallows any IOException thrown by any call to the single-byte read() method other than the first. To fix it, just override that method with an implementation that does not swallow any exceptions.

Fixes https://github.com/google/guava/issues/3542

4e6478d4bec284f047a686b8a16dc2b32628639a

-------

<p> Add more clarification on what ""access"" means in expireAfterAccess().
Previous comment doesn't mention ""containsKey()""

Copied from https://github.com/google/guava/wiki/CachesExplained#asmap

RELNOTES=comment change

f2bd7744e575393f065253c8f1bc2a512d452b63

-------

<p> Document that HashBiMap.containsValue() tends to run in faster-than-linear time (overriding the default documentation from AbstractMap.containsValue()).

Fixes #1973

7d57c233c9922ca9adbbef552b5f8f66bd7856f0

-------

<p> Add note about {@code ByteSource.wrap}'s use of the given byte array.

Fixes https://github.com/google/guava/issues/2603

9276a79f6e9b012935b791a3e6d0b7f3d00b715b

-------

<p> Fix https://github.com/google/guava/issues/3156 by implementing a proper `CollectSpliterators.flatMapTo{Int,Long,Double}`.

Also, modify the existing `CollectSpliterators.flatMap` to accept `null` from its `function` by treating it as an empty `Stream`, like `Stream.flatMap` does. Add tests for this behavior.

To test that the new methods also accept `null` through both their `{Int,Long,Double}Consumer` APIs and their `Consumer` APIs, add `of{Int,Long,Double}` methods to `SpliteratorTester`. They test the given `Spliterator.of{Int,Long,Double}` through both APIs.

0763099e769963bd0d93f865a4e7c3a5b320085a

-------

<p> Temporarily update public_suffix to include web.app

Without this, developers are not able to set up Google OAuth clients with URLs in Firebase Hosting web.app domain.

41b8aeaeb71cab1a151d4359a409bfd54bb81262",Moe Sync
3572,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java', 'guava/src/com/google/common/util/concurrent/ForwardingFluentFuture.java']","@@ -70,4 +70,9 @@ public V get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return delegate.get(timeout, unit);
   }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
+  }
 }, @@ -70,4 +70,9 @@ public V get(long timeout, TimeUnit unit)
       throws InterruptedException, ExecutionException, TimeoutException {
     return delegate.get(timeout, unit);
   }
+
+  @Override
+  public String toString() {
+    return delegate.toString();
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add toString() to ForwardingFluentFuture, to match ForwardingFuture

RELNOTES=N/A

cedfa4a718a128d30f9af953f304b425b52b6f94",Moe Sync
3573,Chris Povirk,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ",NaN,MOE sync
3575,Chris Povirk,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -171,7 +171,14 @@ private ReferrerPolicyValues() {}
   public static final String TE = ""TE"";
   /** The HTTP {@code Upgrade} header field name. */
   public static final String UPGRADE = ""Upgrade"";
-  /** The HTTP {@code User-Agent} header field name. */
+  /**
+   * The HTTP <a href=""https://w3c.github.io/webappsec-upgrade-insecure-requests/#preference"">{@code
+   * Upgrade-Insecure-Requests}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String UPGRADE_INSECURE_REQUESTS = ""Upgrade-Insecure-Requests"";
+
   public static final String USER_AGENT = ""User-Agent"";
 
   // HTTP Response header fields, @@ -171,7 +171,14 @@ private ReferrerPolicyValues() {}
   public static final String TE = ""TE"";
   /** The HTTP {@code Upgrade} header field name. */
   public static final String UPGRADE = ""Upgrade"";
-  /** The HTTP {@code User-Agent} header field name. */
+  /**
+   * The HTTP <a href=""https://w3c.github.io/webappsec-upgrade-insecure-requests/#preference"">{@code
+   * Upgrade-Insecure-Requests}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String UPGRADE_INSECURE_REQUESTS = ""Upgrade-Insecure-Requests"";
+
   public static final String USER_AGENT = ""User-Agent"";
 
   // HTTP Response header fields, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adds constant for the Upgrade-Insecure-Requests header.

https://w3c.github.io/webappsec-upgrade-insecure-requests/#preference

RELNOTES=Adds constant for the Upgrade-Insecure-Requests header.

7e5aa662985c6e54396b1e751149bef17236bc27",Moe Sync
3578,Chris Povirk,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -179,6 +179,7 @@ private ReferrerPolicyValues() {}
    */
   public static final String UPGRADE_INSECURE_REQUESTS = ""Upgrade-Insecure-Requests"";
 
+  /** The HTTP {@code User-Agent} header field name. */
   public static final String USER_AGENT = ""User-Agent"";
 
   // HTTP Response header fields, @@ -179,6 +179,7 @@ private ReferrerPolicyValues() {}
    */
   public static final String UPGRADE_INSECURE_REQUESTS = ""Upgrade-Insecure-Requests"";
 
+  /** The HTTP {@code User-Agent} header field name. */
   public static final String USER_AGENT = ""User-Agent"";
 
   // HTTP Response header fields, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Restore Javadoc unintentionally lost in CL 264984423.

https://github.com/google/guava/pull/3575#issuecomment-524440221

0a9ddbca861d787f2b1d110905e043c25dacfc89",Moe Sync
3579,Chris Povirk,"['android/guava/src/com/google/common/base/Platform.java', 'android/guava/src/com/google/common/collect/Platform.java', 'android/guava/src/com/google/common/primitives/Platform.java', 'guava-gwt/src-super/com/google/common/base/super/com/google/common/base/Platform.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java', 'guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/Platform.java', 'guava-gwt/src/com/google/common/base/Absent_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/base/PairwiseEquivalence_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/base/Present_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/AllEqualOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ArrayListMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ByFunctionOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ComparatorOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/CompoundOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/DenseImmutableTable_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/EmptyImmutableListMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/EmptyImmutableSetMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ExplicitOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/HashBasedTable_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/HashMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/HashMultiset_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableEntry_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableEnumMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableEnumSet_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableListMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableSetMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ImmutableSortedMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/JdkBackedImmutableBiMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/JdkBackedImmutableMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/JdkBackedImmutableMultiset_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/JdkBackedImmutableSet_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/LexicographicalOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/LinkedHashMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/LinkedHashMultiset_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/LinkedListMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/NaturalOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/NullsFirstOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/NullsLastOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/Range_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableAsList_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableBiMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableList_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableMultiset_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableSet_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/RegularImmutableSortedSet_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ReverseNaturalOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/ReverseOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/SingletonImmutableBiMap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/SingletonImmutableList_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/SingletonImmutableSet_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/SingletonImmutableTable_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/SparseImmutableTable_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/TreeBasedTable_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/TreeMultimap_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/collect/UsingToStringOrdering_CustomFieldSerializer.java', 'guava-gwt/src/com/google/common/primitives/UnsignedLong_CustomFieldSerializer.java', 'guava/src/com/google/common/base/Platform.java', 'guava/src/com/google/common/collect/Platform.java', 'guava/src/com/google/common/primitives/Platform.java']","@@ -14,6 +14,9 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
 import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
@@ -99,4 +102,19 @@ public boolean isPcreLike() {
       return true;
     }
   }
+
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
 }, @@ -16,6 +16,9 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
 import com.google.common.annotations.GwtCompatible;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -109,5 +112,20 @@ static int reduceExponentIfGwt(int exponent) {
     return exponent;
   }
 
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
+
   private Platform() {}
 }, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
+import com.google.common.annotations.GwtCompatible;
+
+/** Methods factored out so that they can be emulated differently in GWT. */
+@GwtCompatible(emulated = true)
+final class Platform {
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
+
+  private Platform() {}
+}, @@ -80,5 +80,16 @@ static boolean patternCompilerIsPcreLike() {
     throw new UnsupportedOperationException();
   }
 
+  /*
+   * We will eventually disable GWT-RPC on the server side, but we'll leave it nominally enabled on
+   * the client side. There's little practical difference: If it's disabled on the server, it won't
+   * work. It's just a matter of how quickly it fails. I'm not sure if failing on the client would
+   * be better or not, but it's harder: GWT's System.getProperty reads from a different property
+   * list than Java's, so anyone who needs to reenable GWT-RPC in an emergency would have to figure
+   * out how to set both properties. It's easier to have to set only one, and it might as well be
+   * the Java property, since Guava already reads another Java property.
+   */
+  static void checkGwtRpcEnabled() {}
+
   private Platform() {}
 }, @@ -99,5 +99,16 @@ static int reduceExponentIfGwt(int exponent) {
     return exponent / 2;
   }
 
+  /*
+   * We will eventually disable GWT-RPC on the server side, but we'll leave it nominally enabled on
+   * the client side. There's little practical difference: If it's disabled on the server, it won't
+   * work. It's just a matter of how quickly it fails. I'm not sure if failing on the client would
+   * be better or not, but it's harder: GWT's System.getProperty reads from a different property
+   * list than Java's, so anyone who needs to reenable GWT-RPC in an emergency would have to figure
+   * out how to set both properties. It's easier to have to set only one, and it might as well be
+   * the Java property, since Guava already reads another Java property.
+   */
+  static void checkGwtRpcEnabled() {}
+
   private Platform() {}
 }, @@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2019 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.primitives;
+
+final class Platform {
+  /*
+   * We will eventually disable GWT-RPC on the server side, but we'll leave it nominally enabled on
+   * the client side. There's little practical difference: If it's disabled on the server, it won't
+   * work. It's just a matter of how quickly it fails. I'm not sure if failing on the client would
+   * be better or not, but it's harder: GWT's System.getProperty reads from a different property
+   * list than Java's, so anyone who needs to reenable GWT-RPC in an emergency would have to figure
+   * out how to set both properties. It's easier to have to set only one, and it might as well be
+   * the Java property, since Guava already reads another Java property.
+   */
+  static void checkGwtRpcEnabled() {}
+
+  private Platform() {}
+}, @@ -16,6 +16,8 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Platform.checkGwtRpcEnabled;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,8 +36,11 @@
   public static void deserialize(SerializationStreamReader reader, Absent<?> instance) {}
 
   public static Absent<?> instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return Absent.INSTANCE;
   }
 
-  public static void serialize(SerializationStreamWriter writer, Absent<?> instance) {}
+  public static void serialize(SerializationStreamWriter writer, Absent<?> instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,6 +36,7 @@ public static void deserialize(
 
   public static PairwiseEquivalence<?> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return create((Equivalence<?>) reader.readObject());
   }
 
@@ -43,6 +46,7 @@ public static void deserialize(
 
   public static void serialize(SerializationStreamWriter writer, PairwiseEquivalence<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.elementEquivalence);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Platform.checkGwtRpcEnabled;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
@@ -32,11 +34,13 @@ public static void deserialize(SerializationStreamReader reader, Present<?> inst
 
   public static Present<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (Present<Object>) Optional.of(reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, Present<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.get());
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -28,8 +30,11 @@
   public static void deserialize(SerializationStreamReader reader, AllEqualOrdering instance) {}
 
   public static AllEqualOrdering instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return AllEqualOrdering.INSTANCE;
   }
 
-  public static void serialize(SerializationStreamWriter writer, AllEqualOrdering instance) {}
+  public static void serialize(SerializationStreamWriter writer, AllEqualOrdering instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,12 +33,14 @@ public static void deserialize(SerializationStreamReader in, ArrayListMultimap<?
 
   public static ArrayListMultimap<Object, Object> instantiate(SerializationStreamReader in)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (ArrayListMultimap<Object, Object>)
         Multimap_CustomFieldSerializerBase.populate(in, ArrayListMultimap.create());
   }
 
   public static void serialize(SerializationStreamWriter out, ArrayListMultimap<?, ?> multimap)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multimap_CustomFieldSerializerBase.serialize(out, multimap);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.common.base.Function;
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
@@ -34,12 +36,14 @@ public static void deserialize(
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static ByFunctionOrdering<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new ByFunctionOrdering<>(
         (Function<Object, Object>) reader.readObject(), (Ordering<Object>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, ByFunctionOrdering<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.function);
     writer.writeObject(instance.ordering);
   }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,11 +36,13 @@ public static void deserialize(
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static ComparatorOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new ComparatorOrdering<>((Comparator<Object>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, ComparatorOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.comparator);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -35,6 +37,7 @@ public static void deserialize(SerializationStreamReader reader, CompoundOrderin
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static CompoundOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     int n = reader.readInt();
     List<Comparator<Object>> comparators = new ArrayList<>();
     for (int i = 0; i < n; i++) {
@@ -45,6 +48,7 @@ public static void deserialize(SerializationStreamReader reader, CompoundOrderin
 
   public static void serialize(SerializationStreamWriter writer, CompoundOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeInt(instance.comparators.length);
     for (Comparator<?> comparator : instance.comparators) {
       writer.writeObject(comparator);, @@ -14,6 +14,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -29,13 +31,15 @@ public static void deserialize(
 
   public static DenseImmutableTable<Object, Object, Object> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     return (DenseImmutableTable<Object, Object, Object>)
         ImmutableTable_CustomFieldSerializerBase.instantiate(reader);
   }
 
   public static void serialize(
       SerializationStreamWriter writer, DenseImmutableTable<Object, Object, Object> table)
       throws SerializationException {
+    checkGwtRpcEnabled();
     ImmutableTable_CustomFieldSerializerBase.serialize(writer, table);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -30,9 +32,12 @@ public static void deserialize(
       SerializationStreamReader reader, EmptyImmutableListMultimap instance) {}
 
   public static EmptyImmutableListMultimap instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return EmptyImmutableListMultimap.INSTANCE;
   }
 
   public static void serialize(
-      SerializationStreamWriter writer, EmptyImmutableListMultimap instance) {}
+      SerializationStreamWriter writer, EmptyImmutableListMultimap instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -30,9 +32,12 @@ public static void deserialize(
       SerializationStreamReader reader, EmptyImmutableSetMultimap instance) {}
 
   public static EmptyImmutableSetMultimap instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return EmptyImmutableSetMultimap.INSTANCE;
   }
 
   public static void serialize(
-      SerializationStreamWriter writer, EmptyImmutableSetMultimap instance) {}
+      SerializationStreamWriter writer, EmptyImmutableSetMultimap instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,11 +34,13 @@ public static void deserialize(SerializationStreamReader reader, ExplicitOrderin
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static ExplicitOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new ExplicitOrdering<>((ImmutableMap<Object, Integer>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, ExplicitOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.rankMap);
   }
 }, @@ -14,6 +14,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -28,11 +30,13 @@ public static void deserialize(SerializationStreamReader reader, HashBasedTable<
 
   public static HashBasedTable<Object, Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return Table_CustomFieldSerializerBase.populate(reader, HashBasedTable.create());
   }
 
   public static void serialize(SerializationStreamWriter writer, HashBasedTable<?, ?, ?> table)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Table_CustomFieldSerializerBase.serialize(writer, table);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,12 +33,14 @@ public static void deserialize(SerializationStreamReader in, HashMultimap<?, ?>
 
   public static HashMultimap<Object, Object> instantiate(SerializationStreamReader in)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (HashMultimap<Object, Object>)
         Multimap_CustomFieldSerializerBase.populate(in, HashMultimap.create());
   }
 
   public static void serialize(SerializationStreamWriter out, HashMultimap<?, ?> multimap)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multimap_CustomFieldSerializerBase.serialize(out, multimap);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,12 +33,14 @@ public static void deserialize(SerializationStreamReader reader, HashMultiset<?>
 
   public static HashMultiset<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (HashMultiset<Object>)
         Multiset_CustomFieldSerializerBase.populate(reader, HashMultiset.create());
   }
 
   public static void serialize(SerializationStreamWriter writer, HashMultiset<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multiset_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,13 +33,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableEntry<
 
   public static ImmutableEntry<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Object key = reader.readObject();
     Object value = reader.readObject();
     return new ImmutableEntry<>(key, value);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableEntry<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.getKey());
     writer.writeObject(instance.getValue());
   }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,6 +36,7 @@ public static void deserialize(
 
   public static <K extends Enum<K>, V> ImmutableEnumMap<?, ?> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     Map<K, V> deserialized = Maps.newHashMap();
     Map_CustomFieldSerializerBase.deserialize(reader, deserialized);
     /*
@@ -46,6 +49,7 @@ public static void deserialize(
 
   public static void serialize(SerializationStreamWriter writer, ImmutableEnumMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,6 +35,7 @@ public static void deserialize(SerializationStreamReader reader, ImmutableEnumSe
 
   public static <E extends Enum<E>> ImmutableEnumSet<?> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     List<E> deserialized = Lists.newArrayList();
     Collection_CustomFieldSerializerBase.deserialize(reader, deserialized);
     /*
@@ -45,6 +48,7 @@ public static void deserialize(SerializationStreamReader reader, ImmutableEnumSe
 
   public static void serialize(SerializationStreamWriter writer, ImmutableEnumSet<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Collection_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,13 +34,15 @@ public static void deserialize(
 
   public static ImmutableListMultimap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (ImmutableListMultimap<Object, Object>)
         Multimap_CustomFieldSerializerBase.instantiate(reader, ImmutableListMultimap.builder());
   }
 
   public static void serialize(
       SerializationStreamWriter writer, ImmutableListMultimap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multimap_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -35,6 +37,7 @@ public static void deserialize(
   @SuppressWarnings(""unchecked"")
   public static ImmutableSetMultimap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Comparator<Object> valueComparator = (Comparator<Object>) reader.readObject();
     ImmutableSetMultimap.Builder<Object, Object> builder = ImmutableSetMultimap.builder();
     if (valueComparator != null) {
@@ -47,6 +50,7 @@ public static void deserialize(
   public static void serialize(
       SerializationStreamWriter writer, ImmutableSetMultimap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.valueComparator());
     Multimap_CustomFieldSerializerBase.serialize(writer, instance);
   }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,11 +35,13 @@ public static void deserialize(
 
   public static ImmutableSortedMap<?, ?> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return ImmutableSortedMap_CustomFieldSerializerBase.instantiate(reader);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableSortedMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     ImmutableSortedMap_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,13 +36,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableBiMap<
 
   public static ImmutableBiMap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map<Object, Object> entries = new LinkedHashMap<>();
     Map_CustomFieldSerializerBase.deserialize(reader, entries);
     return ImmutableBiMap.copyOf(entries);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableBiMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,13 +36,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableMap<?,
 
   public static ImmutableMap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map<Object, Object> entries = new LinkedHashMap<>();
     Map_CustomFieldSerializerBase.deserialize(reader, entries);
     return ImmutableMap.copyOf(entries);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,12 +33,14 @@ public static void deserialize(SerializationStreamReader reader, ImmutableMultis
 
   public static ImmutableMultiset<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return ImmutableMultiset.copyOf(
         Multiset_CustomFieldSerializerBase.populate(reader, LinkedHashMultiset.create()));
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableMultiset<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multiset_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,13 +35,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableSet<?>
 
   public static ImmutableSet<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     List<Object> elements = Lists.newArrayList();
     Collection_CustomFieldSerializerBase.deserialize(reader, elements);
     return ImmutableSet.copyOf(elements);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableSet<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Collection_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,12 +35,14 @@ public static void deserialize(
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static LexicographicalOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new LexicographicalOrdering<>((Ordering<Object>) reader.readObject());
   }
 
   public static void serialize(
       SerializationStreamWriter writer, LexicographicalOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.elementOrder);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -35,6 +37,7 @@ public static void deserialize(SerializationStreamReader in, LinkedHashMultimap<
 
   public static LinkedHashMultimap<Object, Object> instantiate(SerializationStreamReader stream)
       throws SerializationException {
+    checkGwtRpcEnabled();
     LinkedHashMultimap<Object, Object> multimap = LinkedHashMultimap.create();
 
     int distinctKeys = stream.readInt();
@@ -56,6 +59,7 @@ public static void deserialize(SerializationStreamReader in, LinkedHashMultimap<
 
   public static void serialize(SerializationStreamWriter stream, LinkedHashMultimap<?, ?> multimap)
       throws SerializationException {
+    checkGwtRpcEnabled();
     stream.writeInt(multimap.keySet().size());
     for (Object key : multimap.keySet()) {
       stream.writeObject(key);, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,12 +34,14 @@ public static void deserialize(
 
   public static LinkedHashMultiset<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return (LinkedHashMultiset<Object>)
         Multiset_CustomFieldSerializerBase.populate(reader, LinkedHashMultiset.create());
   }
 
   public static void serialize(SerializationStreamWriter writer, LinkedHashMultiset<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multiset_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,6 +34,7 @@ public static void deserialize(SerializationStreamReader in, LinkedListMultimap<
 
   public static LinkedListMultimap<Object, Object> instantiate(SerializationStreamReader in)
       throws SerializationException {
+    checkGwtRpcEnabled();
     LinkedListMultimap<Object, Object> multimap = LinkedListMultimap.create();
     int size = in.readInt();
     for (int i = 0; i < size; i++) {
@@ -44,6 +47,7 @@ public static void deserialize(SerializationStreamReader in, LinkedListMultimap<
 
   public static void serialize(SerializationStreamWriter out, LinkedListMultimap<?, ?> multimap)
       throws SerializationException {
+    checkGwtRpcEnabled();
     out.writeInt(multimap.size());
     for (Entry<?, ?> entry : multimap.entries()) {
       out.writeObject(entry.getKey());, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -29,8 +31,11 @@
   public static void deserialize(SerializationStreamReader reader, NaturalOrdering instance) {}
 
   public static NaturalOrdering instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return NaturalOrdering.INSTANCE;
   }
 
-  public static void serialize(SerializationStreamWriter writer, NaturalOrdering instance) {}
+  public static void serialize(SerializationStreamWriter writer, NaturalOrdering instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,11 +35,13 @@ public static void deserialize(
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static NullsFirstOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new NullsFirstOrdering<>((Ordering<Object>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, NullsFirstOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.ordering);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,11 +34,13 @@ public static void deserialize(SerializationStreamReader reader, NullsLastOrderi
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static NullsLastOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new NullsLastOrdering<>((Ordering<Object>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, NullsLastOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.ordering);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -31,6 +33,7 @@ public static void deserialize(SerializationStreamReader reader, Range<?> instan
 
   public static Range<?> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
 
     Cut lowerBound;
     boolean hasLowerBound = reader.readBoolean();
@@ -59,6 +62,7 @@ public static void deserialize(SerializationStreamReader reader, Range<?> instan
 
   public static void serialize(SerializationStreamWriter writer, Range<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
 
     if (instance.hasLowerBound()) {
       writer.writeBoolean(true);, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.common.annotations.GwtCompatible;
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
@@ -36,6 +38,7 @@ public static void deserialize(
 
   public static RegularImmutableAsList<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     ArrayList<Object> elements = new ArrayList<>();
     Collection_CustomFieldSerializerBase.deserialize(reader, elements);
     ImmutableList<Object> delegate = ImmutableList.copyOf(elements);
@@ -44,6 +47,7 @@ public static void deserialize(
 
   public static void serialize(SerializationStreamWriter writer, RegularImmutableAsList<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Collection_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,13 +35,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableBiMap<
 
   public static ImmutableBiMap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map<Object, Object> entries = new LinkedHashMap<>();
     Map_CustomFieldSerializerBase.deserialize(reader, entries);
     return ImmutableBiMap.copyOf(entries);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableBiMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -35,6 +37,7 @@ public static void deserialize(
 
   public static RegularImmutableList<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     List<Object> elements = new ArrayList<>();
     Collection_CustomFieldSerializerBase.deserialize(reader, elements);
     /*
@@ -48,6 +51,7 @@ public static void deserialize(
 
   public static void serialize(SerializationStreamWriter writer, RegularImmutableList<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Collection_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -34,13 +36,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableMap<?,
 
   public static ImmutableMap<Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map<Object, Object> entries = new LinkedHashMap<>();
     Map_CustomFieldSerializerBase.deserialize(reader, entries);
     return ImmutableMap.copyOf(entries);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Map_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -30,12 +32,14 @@ public static void deserialize(SerializationStreamReader reader, ImmutableMultis
 
   public static ImmutableMultiset<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return ImmutableMultiset.copyOf(
         Multiset_CustomFieldSerializerBase.populate(reader, LinkedHashMultiset.create()));
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableMultiset<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Multiset_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,13 +35,15 @@ public static void deserialize(SerializationStreamReader reader, ImmutableSet<?>
 
   public static ImmutableSet<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     List<Object> elements = Lists.newArrayList();
     Collection_CustomFieldSerializerBase.deserialize(reader, elements);
     return ImmutableSet.copyOf(elements);
   }
 
   public static void serialize(SerializationStreamWriter writer, ImmutableSet<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Collection_CustomFieldSerializerBase.serialize(writer, instance);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -35,6 +37,7 @@ public static void deserialize(
 
   public static RegularImmutableSortedSet<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     /*
      * Nothing we can do, but we're already assuming the serialized form is
      * correctly typed, anyway.
@@ -56,6 +59,7 @@ public static void deserialize(
   public static void serialize(
       SerializationStreamWriter writer, RegularImmutableSortedSet<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.comparator());
 
     Collection_CustomFieldSerializerBase.serialize(writer, instance);, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -30,8 +32,11 @@ public static void deserialize(
       SerializationStreamReader reader, ReverseNaturalOrdering instance) {}
 
   public static ReverseNaturalOrdering instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return ReverseNaturalOrdering.INSTANCE;
   }
 
-  public static void serialize(SerializationStreamWriter writer, ReverseNaturalOrdering instance) {}
+  public static void serialize(SerializationStreamWriter writer, ReverseNaturalOrdering instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,11 +34,13 @@ public static void deserialize(SerializationStreamReader reader, ReverseOrdering
   @SuppressWarnings(""unchecked"") // deserialization is unsafe
   public static ReverseOrdering<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return new ReverseOrdering<>((Ordering<Object>) reader.readObject());
   }
 
   public static void serialize(SerializationStreamWriter writer, ReverseOrdering<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.forwardOrder);
   }
 }, @@ -17,6 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
 
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
@@ -34,6 +35,7 @@ public static void deserialize(
 
   public static SingletonImmutableBiMap<Object, Object> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     Object key = checkNotNull(reader.readObject());
     Object value = checkNotNull(reader.readObject());
     return new SingletonImmutableBiMap<>(key, value);
@@ -42,6 +44,7 @@ public static void deserialize(
   public static void serialize(
       SerializationStreamWriter writer, SingletonImmutableBiMap<?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.singleKey);
     writer.writeObject(instance.singleValue);
   }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,12 +34,14 @@ public static void deserialize(
 
   public static SingletonImmutableList<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Object element = reader.readObject();
     return new SingletonImmutableList<>(element);
   }
 
   public static void serialize(SerializationStreamWriter writer, SingletonImmutableList<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.element);
   }
 }, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -32,12 +34,14 @@ public static void deserialize(
 
   public static SingletonImmutableSet<Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Object element = reader.readObject();
     return new SingletonImmutableSet<>(element);
   }
 
   public static void serialize(SerializationStreamWriter writer, SingletonImmutableSet<?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.element);
   }
 }, @@ -14,6 +14,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -29,6 +31,7 @@ public static void deserialize(
 
   public static SingletonImmutableTable<Object, Object, Object> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     Object rowKey = reader.readObject();
     Object columnKey = reader.readObject();
     Object value = reader.readObject();
@@ -38,6 +41,7 @@ public static void deserialize(
   public static void serialize(
       SerializationStreamWriter writer, SingletonImmutableTable<?, ?, ?> instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(instance.singleRowKey);
     writer.writeObject(instance.singleColumnKey);
     writer.writeObject(instance.singleValue);, @@ -14,6 +14,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -29,13 +31,15 @@ public static void deserialize(
 
   public static SparseImmutableTable<Object, Object, Object> instantiate(
       SerializationStreamReader reader) throws SerializationException {
+    checkGwtRpcEnabled();
     return (SparseImmutableTable<Object, Object, Object>)
         ImmutableTable_CustomFieldSerializerBase.instantiate(reader);
   }
 
   public static void serialize(
       SerializationStreamWriter writer, SparseImmutableTable<Object, Object, Object> table)
       throws SerializationException {
+    checkGwtRpcEnabled();
     ImmutableTable_CustomFieldSerializerBase.serialize(writer, table);
   }
 }, @@ -14,6 +14,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -29,6 +31,7 @@ public static void deserialize(SerializationStreamReader reader, TreeBasedTable<
 
   public static TreeBasedTable<Object, Object, Object> instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     @SuppressWarnings(""unchecked"") // The comparator isn't used statically.
     Comparator<Object> rowComparator = (Comparator<Object>) reader.readObject();
     @SuppressWarnings(""unchecked"") // The comparator isn't used statically.
@@ -41,6 +44,7 @@ public static void deserialize(SerializationStreamReader reader, TreeBasedTable<
 
   public static void serialize(SerializationStreamWriter writer, TreeBasedTable<?, ?, ?> table)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeObject(table.rowComparator());
     writer.writeObject(table.columnComparator());
     Table_CustomFieldSerializerBase.serialize(writer, table);, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -33,6 +35,7 @@ public static void deserialize(SerializationStreamReader in, TreeMultimap<?, ?>
   @SuppressWarnings(""unchecked"")
   public static TreeMultimap<Object, Object> instantiate(SerializationStreamReader in)
       throws SerializationException {
+    checkGwtRpcEnabled();
     Comparator<Object> keyComparator = (Comparator<Object>) in.readObject();
     Comparator<Object> valueComparator = (Comparator<Object>) in.readObject();
 
@@ -43,6 +46,7 @@ public static void deserialize(SerializationStreamReader in, TreeMultimap<?, ?>
 
   public static void serialize(SerializationStreamWriter out, TreeMultimap<?, ?> multimap)
       throws SerializationException {
+    checkGwtRpcEnabled();
     out.writeObject(multimap.keyComparator());
     out.writeObject(multimap.valueComparator());
     Multimap_CustomFieldSerializerBase.serialize(out, multimap);, @@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
 
@@ -30,8 +32,11 @@ public static void deserialize(
       SerializationStreamReader reader, UsingToStringOrdering instance) {}
 
   public static UsingToStringOrdering instantiate(SerializationStreamReader reader) {
+    checkGwtRpcEnabled();
     return UsingToStringOrdering.INSTANCE;
   }
 
-  public static void serialize(SerializationStreamWriter writer, UsingToStringOrdering instance) {}
+  public static void serialize(SerializationStreamWriter writer, UsingToStringOrdering instance) {
+    checkGwtRpcEnabled();
+  }
 }, @@ -14,6 +14,8 @@
 
 package com.google.common.primitives;
 
+import static com.google.common.primitives.Platform.checkGwtRpcEnabled;
+
 import com.google.gwt.user.client.rpc.SerializationException;
 import com.google.gwt.user.client.rpc.SerializationStreamReader;
 import com.google.gwt.user.client.rpc.SerializationStreamWriter;
@@ -28,11 +30,13 @@ public static void deserialize(SerializationStreamReader reader, UnsignedLong in
 
   public static UnsignedLong instantiate(SerializationStreamReader reader)
       throws SerializationException {
+    checkGwtRpcEnabled();
     return UnsignedLong.fromLongBits(reader.readLong());
   }
 
   public static void serialize(SerializationStreamWriter writer, UnsignedLong instance)
       throws SerializationException {
+    checkGwtRpcEnabled();
     writer.writeLong(instance.longValue());
   }
 }, @@ -14,6 +14,9 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
 import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
@@ -94,4 +97,19 @@ public boolean isPcreLike() {
       return true;
     }
   }
+
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
 }, @@ -16,6 +16,9 @@
 
 package com.google.common.collect;
 
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
 import com.google.common.annotations.GwtCompatible;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -109,5 +112,20 @@ static int reduceExponentIfGwt(int exponent) {
     return exponent;
   }
 
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
+
   private Platform() {}
 }, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import static com.google.common.base.Strings.lenientFormat;
+import static java.lang.Boolean.parseBoolean;
+
+import com.google.common.annotations.GwtCompatible;
+
+/** Methods factored out so that they can be emulated differently in GWT. */
+@GwtCompatible(emulated = true)
+final class Platform {
+  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
+
+  static void checkGwtRpcEnabled() {
+    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+      throw new UnsupportedOperationException(
+          lenientFormat(
+              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
+                  + "" support by setting the system property %s to true. For more about system""
+                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
+              GWT_RPC_PROPERTY_NAME,
+              ""https://stackoverflow.com/q/5189914/28465"",
+              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
+    }
+  }
+
+  private Platform() {}
+}, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix ""bug"" link that was actually a CL.

4c5e8a226a1c4a963d6041f7ee6aa32076fa2ac8

-------

<p> Simplify while+break into do-while.

Fixes #3577

39aadb3531f7d73ed634780abe2679c9e42bcb17

-------

<p> Release resources of whenAllSucceed/whenAllComplete once input futures are complete.

RELNOTES=Fixes potential memory leak in Futures.whenAllSucceed/whenAllComplete

a840d5bec35b56a6a6e195477e35a1b0e92d3681

-------

<p> Prepare for removing GWT-RPC support for Guava types by adding a system property that disables it.

When the time comes, we'll flip the default value, and users who didn't see our earlier warnings can use a system property to restore support until they can stop serializing our types.

[]

967010aa4d5ecf35fd3861913c3f17c10c4f6d40",Moe Sync
3583,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'android/guava/src/com/google/common/util/concurrent/AggregateFutureState.java', 'android/guava/src/com/google/common/util/concurrent/CollectionFuture.java', 'android/guava/src/com/google/common/util/concurrent/CombinedFuture.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AggregateFutureState.java', 'guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFutureState.java', 'guava/src/com/google/common/util/concurrent/CollectionFuture.java', 'guava/src/com/google/common/util/concurrent/CombinedFuture.java']","@@ -46,6 +46,7 @@
 import static com.google.common.util.concurrent.TestPlatform.getDoneFromTimeoutOverload;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
+import static com.google.common.util.concurrent.testing.TestingExecutors.noOpScheduledExecutor;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.Executors.newSingleThreadExecutor;
 import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
@@ -2803,33 +2804,82 @@ public void testWhenAllSucceed() throws Exception {
 
   @AndroidIncompatible
   @GwtIncompatible
-  public void testWhenAllSucceed_releasesMemory() throws Exception {
+  public void testWhenAllSucceed_releasesInputFuturesUponSubmission() throws Exception {
     SettableFuture<Long> future1 = SettableFuture.create();
     SettableFuture<Long> future2 = SettableFuture.create();
     WeakReference<SettableFuture<Long>> future1Ref = new WeakReference<>(future1);
     WeakReference<SettableFuture<Long>> future2Ref = new WeakReference<>(future2);
 
-    AsyncCallable<Long> combiner =
-        new AsyncCallable<Long>() {
+    Callable<Long> combiner =
+        new Callable<Long>() {
           @Override
-          public ListenableFuture<Long> call() throws Exception {
-            return SettableFuture.create();
+          public Long call() {
+            throw new AssertionError();
           }
         };
 
     ListenableFuture<Long> unused =
-        whenAllSucceed(future1, future2).callAsync(combiner, directExecutor());
+        whenAllSucceed(future1, future2).call(combiner, noOpScheduledExecutor());
 
     future1.set(1L);
     future1 = null;
     future2.set(2L);
     future2 = null;
 
-    // Futures should be collected even if combiner future never finishes.
+    /*
+     * Futures should be collected even if combiner never runs. This is kind of a silly test, since
+     * the combiner is almost certain to hold its own reference to the futures, and a real app would
+     * hold a reference to the executor and thus to the combiner. What we really care about is that
+     * the futures are released once the combiner is done running. But we happen to provide this
+     * earlier cleanup at the moment, so we're testing it.
+     */
     GcFinalization.awaitClear(future1Ref);
     GcFinalization.awaitClear(future2Ref);
   }
 
+  @AndroidIncompatible
+  @GwtIncompatible
+  public void testWhenAllComplete_releasesInputFuturesUponCancellation() throws Exception {
+    SettableFuture<Long> future = SettableFuture.create();
+    WeakReference<SettableFuture<Long>> futureRef = new WeakReference<>(future);
+
+    Callable<Long> combiner =
+        new Callable<Long>() {
+          @Override
+          public Long call() {
+            throw new AssertionError();
+          }
+        };
+
+    ListenableFuture<Long> unused = whenAllComplete(future).call(combiner, noOpScheduledExecutor());
+
+    unused.cancel(false);
+    future = null;
+
+    // Future should be collected because whenAll*Complete* doesn't need to look at its result.
+    GcFinalization.awaitClear(futureRef);
+  }
+
+  @AndroidIncompatible
+  @GwtIncompatible
+  public void testWhenAllSucceed_releasesCallable() throws Exception {
+    AsyncCallable<Long> combiner =
+        new AsyncCallable<Long>() {
+          @Override
+          public ListenableFuture<Long> call() {
+            return SettableFuture.create();
+          }
+        };
+    WeakReference<AsyncCallable<Long>> combinerRef = new WeakReference<>(combiner);
+
+    ListenableFuture<Long> unused =
+        whenAllSucceed(immediateFuture(1L)).callAsync(combiner, directExecutor());
+
+    combiner = null;
+    // combiner should be collected even if the future it returns never completes.
+    GcFinalization.awaitClear(combinerRef);
+  }
+
   /*
    * TODO(cpovirk): maybe pass around TestFuture instances instead of
    * ListenableFuture instances
@@ -3463,6 +3513,24 @@ public void testSuccessfulAsList_logging_error() throws Exception {
     assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
   }
 
+  public void testSuccessfulAsList_failureLoggedEvenAfterOutputCancelled() throws Exception {
+    ListenableFuture<String> input = new CancelPanickingFuture<>();
+    ListenableFuture<List<String>> output = successfulAsList(input);
+    output.cancel(false);
+
+    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
+    assertThat(logged).hasSize(1);
+    assertThat(logged.get(0).getThrown()).hasMessageThat().isEqualTo(""You can't fire me, I quit."");
+  }
+
+  private static final class CancelPanickingFuture<V> extends AbstractFuture<V> {
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      setException(new Error(""You can't fire me, I quit.""));
+      return false;
+    }
+  }
+
   public void testNonCancellationPropagating_successful() throws Exception {
     SettableFuture<Foo> input = SettableFuture.create();
     ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);
@@ -3517,22 +3585,6 @@ public void testNonCancellationPropagating_doesNotPropagate() throws Exception {
     }
   }
 
-  @GwtIncompatible // used only in GwtIncompatible tests
-  private static final Function<Exception, TestException> mapper =
-      new Function<Exception, TestException>() {
-        @Override
-        public TestException apply(Exception from) {
-          if (from instanceof ExecutionException) {
-            return new TestException(from.getCause());
-          } else {
-            assertTrue(
-                ""got "" + from.getClass(),
-                from instanceof InterruptedException || from instanceof CancellationException);
-            return new TestException(from);
-          }
-        }
-      };
-
   @GwtIncompatible // used only in GwtIncompatible tests
   private interface MapperFunction extends Function<Throwable, Exception> {}
 , @@ -16,8 +16,11 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.ALL_INPUT_FUTURES_PROCESSED;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.logging.Level.SEVERE;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
@@ -26,270 +29,303 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
- * A future made up of a collection of sub-futures.
+ * A future whose value is derived from a collection of input futures.
  *
  * @param <InputT> the type of the individual inputs
  * @param <OutputT> the type of the output (i.e. this) future
  */
 @GwtCompatible
-abstract class AggregateFuture<InputT, OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
+abstract class AggregateFuture<InputT, OutputT> extends AggregateFutureState<OutputT> {
   private static final Logger logger = Logger.getLogger(AggregateFuture.class.getName());
 
+  /**
+   * The input futures. After {@link #init}, this field is read only by {@link #afterDone()} (to
+   * propagate cancellation) and {@link #toString()}. To access the futures' <i>values</i>, {@code
+   * AggregateFuture} attaches listeners that hold references to one or more inputs. And in the case
+   * of {@link CombinedFuture}, the user-supplied callback usually has its own references to inputs.
+   */
   /*
    * In certain circumstances, this field might theoretically not be visible to an afterDone() call
    * triggered by cancel(). For details, see the comments on the fields of TimeoutFuture.
    */
-  @NullableDecl private RunningState runningState;
+  @NullableDecl private ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures;
+
+  private final boolean allMustSucceed;
+  private final boolean collectsValues;
+
+  AggregateFuture(
+      ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,
+      boolean allMustSucceed,
+      boolean collectsValues) {
+    super(futures.size());
+    this.futures = checkNotNull(futures);
+    this.allMustSucceed = allMustSucceed;
+    this.collectsValues = collectsValues;
+  }
 
   @Override
   protected final void afterDone() {
     super.afterDone();
-    releaseResources();
-  }
-
-  protected final void releaseResources() {
-    RunningState localRunningState = runningState;
-    if (localRunningState != null) {
-      // Let go of the memory held by the running state
-      this.runningState = null;
-      ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures =
-          localRunningState.futures;
-      boolean wasInterrupted = wasInterrupted();
 
-      if (wasInterrupted) {
-        localRunningState.interruptTask();
-      }
+    ImmutableCollection<? extends Future<?>> localFutures = futures;
+    releaseResources(OUTPUT_FUTURE_DONE); // nulls out `futures`
 
-      if (isCancelled() & futures != null) {
-        for (ListenableFuture<?> future : futures) {
-          future.cancel(wasInterrupted);
-        }
+    if (isCancelled() & localFutures != null) {
+      boolean wasInterrupted = wasInterrupted();
+      for (Future<?> future : localFutures) {
+        future.cancel(wasInterrupted);
       }
     }
+    /*
+     * We don't call clearSeenExceptions() until processCompleted(). Prior to that, it may be needed
+     * again if some outstanding input fails.
+     */
   }
 
   @Override
-  protected String pendingToString() {
-    RunningState localRunningState = runningState;
-    if (localRunningState == null) {
-      return null;
-    }
-    ImmutableCollection<? extends ListenableFuture<? extends InputT>> localFutures =
-        localRunningState.futures;
+  protected final String pendingToString() {
+    ImmutableCollection<? extends Future<?>> localFutures = futures;
     if (localFutures != null) {
       return ""futures=["" + localFutures + ""]"";
     }
     return null;
   }
 
-  /** Must be called at the end of each sub-class's constructor. */
-  final void init(RunningState runningState) {
-    this.runningState = runningState;
-    runningState.init();
-  }
-
-  abstract class RunningState extends AggregateFutureState implements Runnable {
-    private ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures;
-    private final boolean allMustSucceed;
-    private final boolean collectsValues;
-
-    RunningState(
-        ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,
-        boolean allMustSucceed,
-        boolean collectsValues) {
-      super(futures.size());
-      this.futures = checkNotNull(futures);
-      this.allMustSucceed = allMustSucceed;
-      this.collectsValues = collectsValues;
-    }
-
-    /* Used in the !allMustSucceed case so we don't have to instantiate a listener. */
-    @Override
-    public final void run() {
-      decrementCountAndMaybeComplete();
+  /**
+   * Must be called at the end of each subclass's constructor. This method performs the ""real""
+   * initialization; we can't put this in the constructor because, in the case where futures are
+   * already complete, we would not initialize the subclass before calling {@link
+   * #collectValueFromNonCancelledFuture}. As this is called after the subclass is constructed,
+   * we're guaranteed to have properly initialized the subclass.
+   */
+  final void init() {
+    // Corner case: List is empty.
+    if (futures.isEmpty()) {
+      handleAllCompleted();
+      return;
     }
 
-    /**
-     * The ""real"" initialization; we can't put this in the constructor because, in the case where
-     * futures are already complete, we would not initialize the subclass before calling {@link
-     * #handleOneInputDone}. As this is called after the subclass is constructed, we're guaranteed
-     * to have properly initialized the subclass.
-     */
-    private void init() {
-      // Corner case: List is empty.
-      if (futures.isEmpty()) {
-        handleAllCompleted();
-        return;
-      }
-
-      // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll
-      // need to handle RejectedExecutionException
+    // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll
+    // need to handle RejectedExecutionException
 
-      if (allMustSucceed) {
-        // We need fail fast, so we have to keep track of which future failed so we can propagate
-        // the exception immediately
+    if (allMustSucceed) {
+      // We need fail fast, so we have to keep track of which future failed so we can propagate
+      // the exception immediately
 
-        // Register a listener on each Future in the list to update the state of this future.
-        // Note that if all the futures on the list are done prior to completing this loop, the last
-        // call to addListener() will callback to setOneValue(), transitively call our cleanup
-        // listener, and set this.futures to null.
-        // This is not actually a problem, since the foreach only needs this.futures to be non-null
-        // at the beginning of the loop.
-        int i = 0;
-        for (final ListenableFuture<? extends InputT> listenable : futures) {
-          final int index = i++;
-          listenable.addListener(
-              new Runnable() {
-                @Override
-                public void run() {
-                  try {
-                    handleOneInputDone(index, listenable);
-                  } finally {
-                    decrementCountAndMaybeComplete();
+      // Register a listener on each Future in the list to update the state of this future.
+      // Note that if all the futures on the list are done prior to completing this loop, the last
+      // call to addListener() will callback to setOneValue(), transitively call our cleanup
+      // listener, and set this.futures to null.
+      // This is not actually a problem, since the foreach only needs this.futures to be non-null
+      // at the beginning of the loop.
+      int i = 0;
+      for (final ListenableFuture<? extends InputT> future : futures) {
+        final int index = i++;
+        future.addListener(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  if (future.isCancelled()) {
+                    // Clear futures prior to cancelling children. This sets our own state but lets
+                    // the input futures keep running, as some of them may be used elsewhere.
+                    futures = null;
+                    cancel(false);
+                  } else {
+                    collectValueFromNonCancelledFuture(index, future);
                   }
+                } finally {
+                  /*
+                   * ""null"" means: There is no need to access `futures` again during
+                   * `processCompleted` because we're reading each value during a call to
+                   * handleOneInputDone.
+                   */
+                  decrementCountAndMaybeComplete(null);
                 }
-              },
-              directExecutor());
-        }
-      } else {
-        // We'll only call the callback when all futures complete, regardless of whether some failed
-        // Hold off on calling setOneValue until all complete, so we can share the same listener
-        for (ListenableFuture<? extends InputT> listenable : futures) {
-          listenable.addListener(this, directExecutor());
-        }
+              }
+            },
+            directExecutor());
+      }
+    } else {
+      /*
+       * We'll call the user callback or collect the values only when all inputs complete,
+       * regardless of whether some failed. This lets us avoid calling expensive methods like
+       * Future.get() when we don't need to (specifically, for whenAllComplete().call*()), and it
+       * lets all futures share the same listener.
+       *
+       * We store `localFutures` inside the listener because `this.futures` might be nulled out by
+       * the time the listener runs for the final future -- at which point we need to check all
+       * inputs for exceptions *if* we're collecting values. If we're not, then the listener doesn't
+       * need access to the futures again, so we can just pass `null`.
+       *
+       * TODO(b/112550045): Allocating a single, cheaper listener is (I think) only an optimization.
+       * If we make some other optimizations, this one will no longer be necessary. The optimization
+       * could actually hurt in some cases, as it forces us to keep all inputs in memory until the
+       * final input completes.
+       */
+      final ImmutableCollection<? extends Future<? extends InputT>> localFutures =
+          collectsValues ? futures : null;
+      Runnable listener =
+          new Runnable() {
+            @Override
+            public void run() {
+              decrementCountAndMaybeComplete(localFutures);
+            }
+          };
+      for (ListenableFuture<? extends InputT> future : futures) {
+        future.addListener(listener, directExecutor());
       }
     }
+  }
 
-    /**
-     * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the
-     * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the
-     * throwable did not cause this future to fail, and it is the first time we've seen that
-     * particular Throwable.
-     */
-    private void handleException(Throwable throwable) {
-      checkNotNull(throwable);
+  /**
+   * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the
+   * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the
+   * throwable did not cause this future to fail, and it is the first time we've seen that
+   * particular Throwable.
+   */
+  private void handleException(Throwable throwable) {
+    checkNotNull(throwable);
 
-      boolean completedWithFailure = false;
-      boolean firstTimeSeeingThisException = true;
-      if (allMustSucceed) {
-        // As soon as the first one fails, throw the exception up.
-        // The result of all other inputs is then ignored.
-        completedWithFailure = setException(throwable);
-        if (completedWithFailure) {
-          releaseResourcesAfterFailure();
-        } else {
-          // Go up the causal chain to see if we've already seen this cause; if we have, even if
-          // it's wrapped by a different exception, don't log it.
-          firstTimeSeeingThisException = addCausalChain(getOrInitSeenExceptions(), throwable);
+    if (allMustSucceed) {
+      // As soon as the first one fails, make that failure the result of the output future.
+      // The results of all other inputs are then ignored (except for logging any failures).
+      boolean completedWithFailure = setException(throwable);
+      if (!completedWithFailure) {
+        // Go up the causal chain to see if we've already seen this cause; if we have, even if
+        // it's wrapped by a different exception, don't log it.
+        boolean firstTimeSeeingThisException = addCausalChain(getOrInitSeenExceptions(), throwable);
+        if (firstTimeSeeingThisException) {
+          log(throwable);
+          return;
         }
       }
-
-      // | and & used because it's faster than the branch required for || and &&
-      if (throwable instanceof Error
-          | (allMustSucceed & !completedWithFailure & firstTimeSeeingThisException)) {
-        String message =
-            (throwable instanceof Error)
-                ? ""Input Future failed with Error""
-                : ""Got more than one input Future failure. Logging failures after the first"";
-        logger.log(Level.SEVERE, message, throwable);
-      }
     }
 
-    @Override
-    final void addInitialException(Set<Throwable> seen) {
-      if (!isCancelled()) {
-        // TODO(cpovirk): Think about whether we could/should use Verify to check this.
-        boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
-      }
+    /*
+     * TODO(cpovirk): Should whenAllComplete().call*() log errors, too? Currently, it doesn't call
+     * handleException() at all.
+     */
+    if (throwable instanceof Error) {
+      /*
+       * TODO(cpovirk): Do we really want to log this if we called setException(throwable) and it
+       * returned true? This was intentional (CL 46470009), but it seems odd compared to how we
+       * normally handle Error.
+       *
+       * Similarly, do we really want to log the same Error more than once?
+       */
+      log(throwable);
     }
+  }
 
-    /** Handles the input at the given index completing. */
-    private void handleOneInputDone(int index, Future<? extends InputT> future) {
-      // The only cases in which this Future should already be done are (a) if it was cancelled or
-      // (b) if an input failed and we propagated that immediately because of allMustSucceed.
-      checkState(
-          allMustSucceed || !isDone() || isCancelled(),
-          ""Future was done before all dependencies completed"");
+  private static void log(Throwable throwable) {
+    String message =
+        (throwable instanceof Error)
+            ? ""Input Future failed with Error""
+            : ""Got more than one input Future failure. Logging failures after the first"";
+    logger.log(SEVERE, message, throwable);
+  }
 
-      try {
-        checkState(future.isDone(), ""Tried to set value from future which is not done"");
-        if (allMustSucceed) {
-          if (future.isCancelled()) {
-            // clear running state prior to cancelling children, this sets our own state but lets
-            // the input futures keep running as some of them may be used elsewhere.
-            runningState = null;
-            cancel(false);
-          } else {
-            // We always get the result so that we can have fail-fast, even if we don't collect
-            InputT result = getDone(future);
-            if (collectsValues) {
-              collectOneValue(allMustSucceed, index, result);
-            }
-          }
-        } else if (collectsValues && !future.isCancelled()) {
-          collectOneValue(allMustSucceed, index, getDone(future));
-        }
-      } catch (ExecutionException e) {
-        handleException(e.getCause());
-      } catch (Throwable t) {
-        handleException(t);
-      }
+  @Override
+  final void addInitialException(Set<Throwable> seen) {
+    checkNotNull(seen);
+    if (!isCancelled()) {
+      // TODO(cpovirk): Think about whether we could/should use Verify to check this.
+      boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
     }
+  }
 
-    private void decrementCountAndMaybeComplete() {
-      int newRemaining = decrementRemainingAndGet();
-      checkState(newRemaining >= 0, ""Less than 0 remaining futures"");
-      if (newRemaining == 0) {
-        processCompleted();
-      }
+  /**
+   * Collects the result (success or failure) of one input future. The input must not have been
+   * cancelled. For details on when this is called, see {@link #collectOneValue}.
+   */
+  private void collectValueFromNonCancelledFuture(int index, Future<? extends InputT> future) {
+    try {
+      // We get the result, even if collectOneValue is a no-op, so that we can fail fast.
+      collectOneValue(index, getDone(future));
+    } catch (ExecutionException e) {
+      handleException(e.getCause());
+    } catch (Throwable t) {
+      handleException(t);
     }
+  }
+
+  private void decrementCountAndMaybeComplete(
+      @NullableDecl
+          ImmutableCollection<? extends Future<? extends InputT>>
+              futuresIfNeedToCollectAtCompletion) {
+    int newRemaining = decrementRemainingAndGet();
+    checkState(newRemaining >= 0, ""Less than 0 remaining futures"");
+    if (newRemaining == 0) {
+      processCompleted(futuresIfNeedToCollectAtCompletion);
+    }
+  }
 
-    private void processCompleted() {
-      // Collect the values if (a) our output requires collecting them and (b) we haven't been
-      // collecting them as we go. (We've collected them as we go only if we needed to fail fast)
-      if (collectsValues & !allMustSucceed) {
-        int i = 0;
-        for (ListenableFuture<? extends InputT> listenable : futures) {
-          handleOneInputDone(i++, listenable);
+  private void processCompleted(
+      @NullableDecl
+          ImmutableCollection<? extends Future<? extends InputT>>
+              futuresIfNeedToCollectAtCompletion) {
+    if (futuresIfNeedToCollectAtCompletion != null) {
+      int i = 0;
+      for (Future<? extends InputT> future : futuresIfNeedToCollectAtCompletion) {
+        if (!future.isCancelled()) {
+          collectValueFromNonCancelledFuture(i, future);
         }
+        i++;
       }
-      handleAllCompleted();
     }
-
-    /**
-     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes, so we
-     * free resources here as well for the allMustSucceed=true case (i.e. when a future fails, we
-     * immediately release resources we no longer need); additionally, the future will release its
-     * reference to {@link RunningState}, which should free all associated memory when all the
-     * futures complete and the listeners are released.
-     *
-     * <p>TODO(user): Write tests for memory retention
+    clearSeenExceptions();
+    handleAllCompleted();
+    /*
+     * Null out fields, including some used in handleAllCompleted() above (like
+     * `CollectionFuture.values`). This might be a no-op: If this future completed during
+     * handleAllCompleted(), they will already have been nulled out. But in the case of
+     * whenAll*().call*(), this future may be pending until the callback runs -- or even longer in
+     * the case of callAsync(), which waits for the callback's returned future to complete.
      */
-    @ForOverride
-    @OverridingMethodsMustInvokeSuper
-    void releaseResourcesAfterFailure() {
-      this.futures = null;
-    }
+    releaseResources(ALL_INPUT_FUTURES_PROCESSED);
+  }
 
-    /**
-     * Called only if {@code collectsValues} is true.
-     *
-     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise, called for
-     * each future when all futures complete.
+  /**
+   * Clears fields that are no longer needed after this future has completed -- or at least all its
+   * inputs have completed (more precisely, after {@link #handleAllCompleted()} has been called).
+   * Often called multiple times (that is, both when the inputs complete and when the output
+   * completes).
+   *
+   * <p>This is similar to our proposed {@code afterCommit} method but not quite the same. See the
+   * description of CL 265462958.
+   */
+  // TODO(user): Write more tests for memory retention.
+  @ForOverride
+  @OverridingMethodsMustInvokeSuper
+  void releaseResources(ReleaseResourcesReason reason) {
+    checkNotNull(reason);
+    /*
+     * All elements of `futures` are completed, or this future has already completed and read
+     * `futures` into a local variable (in preparation for propagating cancellation to them). In
+     * either case, no one needs to read `futures` for cancellation purposes later. (And
+     * cancellation purposes are the main reason to access `futures`, as discussed in its docs.)
      */
-    abstract void collectOneValue(
-        boolean allMustSucceed, int index, @NullableDecl InputT returnValue);
-
-    abstract void handleAllCompleted();
+    this.futures = null;
+  }
 
-    void interruptTask() {}
+  enum ReleaseResourcesReason {
+    OUTPUT_FUTURE_DONE,
+    ALL_INPUT_FUTURES_PROCESSED,
   }
 
+  /**
+   * If {@code allMustSucceed} is true, called as each future completes; otherwise, if {@code
+   * collectsValues} is true, called for each future when all futures complete.
+   */
+  abstract void collectOneValue(int index, @NullableDecl InputT returnValue);
+
+  abstract void handleAllCompleted();
+
   /** Adds the chain to the seen set, and returns whether all the chain was new to us. */
   private static boolean addCausalChain(Set<Throwable> seen, Throwable t) {
     for (; t != null; t = t.getCause()) {, @@ -37,9 +37,9 @@
  */
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
-abstract class AggregateFutureState {
+abstract class AggregateFutureState<OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
   // Lazily initialized the first time we see an exception; not released until all the input futures
-  // & this future completes. Released when the future releases the reference to the running state
+  // have completed and we have processed them all.
   private volatile Set<Throwable> seenExceptions = null;
 
   private volatile int remaining;
@@ -89,12 +89,27 @@
      * Thread2: calls setException(), which returns false, CASes seenExceptions to its exception,
      * and wrongly believes that its exception is new (leading it to logging it when it shouldn't)
      *
-     * Our solution is for threads to CAS seenExceptions from null to a Set population with _the
+     * Our solution is for threads to CAS seenExceptions from null to a Set populated with _the
      * initial exception_, no matter which thread does the work. This ensures that seenExceptions
      * always contains not just the current thread's exception but also the initial thread's.
      */
     Set<Throwable> seenExceptionsLocal = seenExceptions;
     if (seenExceptionsLocal == null) {
+      // TODO(cpovirk): Should we use a simpler (presumably cheaper) data structure?
+      /*
+       * Using weak references here could let us release exceptions earlier, but:
+       *
+       * 1. On Android, querying a WeakReference blocks if the GC is doing an otherwise-concurrent
+       * pass.
+       *
+       * 2. We would probably choose to compare exceptions using == instead of equals() (for
+       * consistency with how weak references are cleared). That's a behavior change -- arguably the
+       * removal of a feature.
+       *
+       * Fortunately, exceptions rarely contain references to expensive resources.
+       */
+
+      //
       seenExceptionsLocal = newConcurrentHashSet();
       /*
        * Other handleException() callers may see this as soon as we publish it. We need to populate
@@ -122,6 +137,10 @@ final int decrementRemainingAndGet() {
     return ATOMIC_HELPER.decrementAndGetRemainingCount(this);
   }
 
+  final void clearSeenExceptions() {
+    seenExceptions = null;
+  }
+
   private abstract static class AtomicHelper {
     /** Atomic compare-and-set of the {@link AggregateFutureState#seenExceptions} field. */
     abstract void compareAndSetSeenExceptions(
@@ -169,8 +188,7 @@ void compareAndSetSeenExceptions(
     @Override
     int decrementAndGetRemainingCount(AggregateFutureState state) {
       synchronized (state) {
-        state.remaining--;
-        return state.remaining;
+        return --state.remaining;
       }
     }
   }, @@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Lists.newArrayListWithCapacity;
 import static java.util.Collections.unmodifiableList;
 
@@ -29,83 +28,64 @@
 /** Aggregate future that collects (stores) results of each future. */
 @GwtCompatible(emulated = true)
 abstract class CollectionFuture<V, C> extends AggregateFuture<V, C> {
+  private List<Optional<V>> values;
 
-  abstract class CollectionFutureRunningState extends RunningState {
-    private List<Optional<V>> values;
+  CollectionFuture(
+      ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
+      boolean allMustSucceed) {
+    super(futures, allMustSucceed, true);
 
-    CollectionFutureRunningState(
-        ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
-        boolean allMustSucceed) {
-      super(futures, allMustSucceed, true);
-
-      this.values =
-          futures.isEmpty()
-              ? ImmutableList.<Optional<V>>of()
-              : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());
+    this.values =
+        futures.isEmpty()
+            ? ImmutableList.<Optional<V>>of()
+            : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());
 
-      // Populate the results list with null initially.
-      for (int i = 0; i < futures.size(); ++i) {
-        values.add(null);
-      }
+    // Populate the results list with null initially.
+    for (int i = 0; i < futures.size(); ++i) {
+      values.add(null);
     }
+  }
 
-    @Override
-    final void collectOneValue(boolean allMustSucceed, int index, @NullableDecl V returnValue) {
-      List<Optional<V>> localValues = values;
-
-      if (localValues != null) {
-        localValues.set(index, Optional.fromNullable(returnValue));
-      } else {
-        // Some other future failed or has been cancelled, causing this one to also be cancelled or
-        // have an exception set. This should only happen if allMustSucceed is true or if the output
-        // itself has been cancelled.
-        checkState(
-            allMustSucceed || isCancelled(), ""Future was done before all dependencies completed"");
-      }
-    }
-
-    @Override
-    final void handleAllCompleted() {
-      List<Optional<V>> localValues = values;
-      if (localValues != null) {
-        set(combine(localValues));
-      } else {
-        checkState(isDone());
-      }
+  @Override
+  final void collectOneValue(int index, @NullableDecl V returnValue) {
+    List<Optional<V>> localValues = values;
+    if (localValues != null) {
+      localValues.set(index, Optional.fromNullable(returnValue));
     }
+  }
 
-    @Override
-    void releaseResourcesAfterFailure() {
-      super.releaseResourcesAfterFailure();
-      this.values = null;
+  @Override
+  final void handleAllCompleted() {
+    List<Optional<V>> localValues = values;
+    if (localValues != null) {
+      set(combine(localValues));
     }
+  }
 
-    abstract C combine(List<Optional<V>> values);
+  @Override
+  void releaseResources(ReleaseResourcesReason reason) {
+    super.releaseResources(reason);
+    this.values = null;
   }
 
+  abstract C combine(List<Optional<V>> values);
+
   /** Used for {@link Futures#allAsList} and {@link Futures#successfulAsList}. */
   static final class ListFuture<V> extends CollectionFuture<V, List<V>> {
     ListFuture(
         ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
         boolean allMustSucceed) {
-      init(new ListFutureRunningState(futures, allMustSucceed));
+      super(futures, allMustSucceed);
+      init();
     }
 
-    private final class ListFutureRunningState extends CollectionFutureRunningState {
-      ListFutureRunningState(
-          ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
-          boolean allMustSucceed) {
-        super(futures, allMustSucceed);
-      }
-
-      @Override
-      public List<V> combine(List<Optional<V>> values) {
-        List<V> result = newArrayListWithCapacity(values.size());
-        for (Optional<V> element : values) {
-          result.add(element != null ? element.orNull() : null);
-        }
-        return unmodifiableList(result);
+    @Override
+    public List<V> combine(List<Optional<V>> values) {
+      List<V> result = newArrayListWithCapacity(values.size());
+      for (Optional<V> element : values) {
+        result.add(element != null ? element.orNull() : null);
       }
+      return unmodifiableList(result);
     }
   }
 }, @@ -15,7 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
@@ -30,64 +30,59 @@
 /** Aggregate future that computes its value by calling a callable. */
 @GwtCompatible
 final class CombinedFuture<V> extends AggregateFuture<Object, V> {
+  private CombinedFutureInterruptibleTask<?> task;
+
   CombinedFuture(
       ImmutableCollection<? extends ListenableFuture<?>> futures,
       boolean allMustSucceed,
       Executor listenerExecutor,
       AsyncCallable<V> callable) {
-    init(
-        new CombinedFutureRunningState(
-            futures,
-            allMustSucceed,
-            new AsyncCallableInterruptibleTask(callable, listenerExecutor)));
+    super(futures, allMustSucceed, false);
+    this.task = new AsyncCallableInterruptibleTask(callable, listenerExecutor);
+    init();
   }
 
   CombinedFuture(
       ImmutableCollection<? extends ListenableFuture<?>> futures,
       boolean allMustSucceed,
       Executor listenerExecutor,
       Callable<V> callable) {
-    init(
-        new CombinedFutureRunningState(
-            futures, allMustSucceed, new CallableInterruptibleTask(callable, listenerExecutor)));
+    super(futures, allMustSucceed, false);
+    this.task = new CallableInterruptibleTask(callable, listenerExecutor);
+    init();
   }
 
-  private final class CombinedFutureRunningState extends RunningState {
-    private CombinedFutureInterruptibleTask task;
-
-    CombinedFutureRunningState(
-        ImmutableCollection<? extends ListenableFuture<?>> futures,
-        boolean allMustSucceed,
-        CombinedFutureInterruptibleTask task) {
-      super(futures, allMustSucceed, false);
-      this.task = task;
-    }
+  @Override
+  void collectOneValue(int index, @NullableDecl Object returnValue) {}
 
-    @Override
-    void collectOneValue(boolean allMustSucceed, int index, @NullableDecl Object returnValue) {}
-
-    @Override
-    void handleAllCompleted() {
-      CombinedFutureInterruptibleTask localTask = task;
-      if (localTask != null) {
-        localTask.execute();
-      } else {
-        checkState(isDone());
-      }
+  @Override
+  void handleAllCompleted() {
+    CombinedFutureInterruptibleTask<?> localTask = task;
+    if (localTask != null) {
+      localTask.execute();
     }
+  }
 
-    @Override
-    void releaseResourcesAfterFailure() {
-      super.releaseResourcesAfterFailure();
+  @Override
+  void releaseResources(ReleaseResourcesReason reason) {
+    super.releaseResources(reason);
+    /*
+     * If the output future is done, then it won't need to interrupt the task later, so it can clear
+     * its reference to it.
+     *
+     * If the output future is *not* done, then the task field will be cleared after the task runs
+     * or after the output future is done, whichever comes first.
+     */
+    if (reason == OUTPUT_FUTURE_DONE) {
       this.task = null;
     }
+  }
 
-    @Override
-    void interruptTask() {
-      CombinedFutureInterruptibleTask localTask = task;
-      if (localTask != null) {
-        localTask.interruptTask();
-      }
+  @Override
+  protected void interruptTask() {
+    CombinedFutureInterruptibleTask<?> localTask = task;
+    if (localTask != null) {
+      localTask.interruptTask();
     }
   }
 
@@ -96,7 +91,7 @@ void interruptTask() {
     private final Executor listenerExecutor;
     boolean thrownByExecute = true;
 
-    public CombinedFutureInterruptibleTask(Executor listenerExecutor) {
+    CombinedFutureInterruptibleTask(Executor listenerExecutor) {
       this.listenerExecutor = checkNotNull(listenerExecutor);
     }
 
@@ -117,6 +112,19 @@ final void execute() {
 
     @Override
     final void afterRanInterruptibly(T result, Throwable error) {
+      /*
+       * The future no longer needs to interrupt this task, so it no longer needs a reference to it.
+       *
+       * TODO(cpovirk): It might be nice for our InterruptibleTask subclasses to null out their
+       *  `callable` fields automatically. That would make it less important for us to null out the
+       * reference to `task` here (though it's still nice to do so in case our reference to the
+       * executor keeps it alive). Ideally, nulling out `callable` would be the responsibility of
+       * InterruptibleTask itself so that its other subclasses also benefit. (Handling `callable` in
+       * InterruptibleTask itself might also eliminate some of the existing boilerplate for, e.g.,
+       * pendingToString().)
+       */
+      CombinedFuture.this.task = null;
+
       if (error != null) {
         if (error instanceof ExecutionException) {
           setException(error.getCause());
@@ -138,7 +146,7 @@ final void afterRanInterruptibly(T result, Throwable error) {
       extends CombinedFutureInterruptibleTask<ListenableFuture<V>> {
     private final AsyncCallable<V> callable;
 
-    public AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listenerExecutor) {
+    AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
       this.callable = checkNotNull(callable);
     }
@@ -157,9 +165,6 @@ public AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listen
     @Override
     void setValue(ListenableFuture<V> value) {
       setFuture(value);
-      // Eagerly release resources instead of waiting for afterDone. We are done with the inputs,
-      // but the actual future may not complete for arbitrarily long.
-      releaseResources();
     }
 
     @Override
@@ -172,7 +177,7 @@ String toPendingString() {
   private final class CallableInterruptibleTask extends CombinedFutureInterruptibleTask<V> {
     private final Callable<V> callable;
 
-    public CallableInterruptibleTask(Callable<V> callable, Executor listenerExecutor) {
+    CallableInterruptibleTask(Callable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
       this.callable = checkNotNull(callable);
     }, @@ -21,7 +21,7 @@
 import java.util.Set;
 
 /** Emulation of AggregateFutureState. */
-abstract class AggregateFutureState {
+abstract class AggregateFutureState<OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
   // Lazily initialized the first time we see an exception; not released until all the input futures
   // & this future completes. Released when the future releases the reference to the running state
   private Set<Throwable> seenExceptions = null;
@@ -44,4 +44,8 @@
   final int decrementRemainingAndGet() {
     return --remaining;
   }
+
+  final void clearSeenExceptions() {
+    seenExceptions = null;
+  }
 }, @@ -2016,6 +2016,33 @@ public void testSuccessfulAsList_emptyList() throws Exception {
   }
 }
 
+public void testSuccessfulAsList_failureLoggedEvenAfterOutputCancelled() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testSuccessfulAsList_failureLoggedEvenAfterOutputCancelled();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
 public void testSuccessfulAsList_logging_error() throws Exception {
   com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
   testCase.setUp();, @@ -46,6 +46,7 @@
 import static com.google.common.util.concurrent.TestPlatform.getDoneFromTimeoutOverload;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.getUninterruptibly;
+import static com.google.common.util.concurrent.testing.TestingExecutors.noOpScheduledExecutor;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.Executors.newSingleThreadExecutor;
 import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;
@@ -2803,33 +2804,82 @@ public void testWhenAllSucceed() throws Exception {
 
   @AndroidIncompatible
   @GwtIncompatible
-  public void testWhenAllSucceed_releasesMemory() throws Exception {
+  public void testWhenAllSucceed_releasesInputFuturesUponSubmission() throws Exception {
     SettableFuture<Long> future1 = SettableFuture.create();
     SettableFuture<Long> future2 = SettableFuture.create();
     WeakReference<SettableFuture<Long>> future1Ref = new WeakReference<>(future1);
     WeakReference<SettableFuture<Long>> future2Ref = new WeakReference<>(future2);
 
-    AsyncCallable<Long> combiner =
-        new AsyncCallable<Long>() {
+    Callable<Long> combiner =
+        new Callable<Long>() {
           @Override
-          public ListenableFuture<Long> call() throws Exception {
-            return SettableFuture.create();
+          public Long call() {
+            throw new AssertionError();
           }
         };
 
     ListenableFuture<Long> unused =
-        whenAllSucceed(future1, future2).callAsync(combiner, directExecutor());
+        whenAllSucceed(future1, future2).call(combiner, noOpScheduledExecutor());
 
     future1.set(1L);
     future1 = null;
     future2.set(2L);
     future2 = null;
 
-    // Futures should be collected even if combiner future never finishes.
+    /*
+     * Futures should be collected even if combiner never runs. This is kind of a silly test, since
+     * the combiner is almost certain to hold its own reference to the futures, and a real app would
+     * hold a reference to the executor and thus to the combiner. What we really care about is that
+     * the futures are released once the combiner is done running. But we happen to provide this
+     * earlier cleanup at the moment, so we're testing it.
+     */
     GcFinalization.awaitClear(future1Ref);
     GcFinalization.awaitClear(future2Ref);
   }
 
+  @AndroidIncompatible
+  @GwtIncompatible
+  public void testWhenAllComplete_releasesInputFuturesUponCancellation() throws Exception {
+    SettableFuture<Long> future = SettableFuture.create();
+    WeakReference<SettableFuture<Long>> futureRef = new WeakReference<>(future);
+
+    Callable<Long> combiner =
+        new Callable<Long>() {
+          @Override
+          public Long call() {
+            throw new AssertionError();
+          }
+        };
+
+    ListenableFuture<Long> unused = whenAllComplete(future).call(combiner, noOpScheduledExecutor());
+
+    unused.cancel(false);
+    future = null;
+
+    // Future should be collected because whenAll*Complete* doesn't need to look at its result.
+    GcFinalization.awaitClear(futureRef);
+  }
+
+  @AndroidIncompatible
+  @GwtIncompatible
+  public void testWhenAllSucceed_releasesCallable() throws Exception {
+    AsyncCallable<Long> combiner =
+        new AsyncCallable<Long>() {
+          @Override
+          public ListenableFuture<Long> call() {
+            return SettableFuture.create();
+          }
+        };
+    WeakReference<AsyncCallable<Long>> combinerRef = new WeakReference<>(combiner);
+
+    ListenableFuture<Long> unused =
+        whenAllSucceed(immediateFuture(1L)).callAsync(combiner, directExecutor());
+
+    combiner = null;
+    // combiner should be collected even if the future it returns never completes.
+    GcFinalization.awaitClear(combinerRef);
+  }
+
   /*
    * TODO(cpovirk): maybe pass around TestFuture instances instead of
    * ListenableFuture instances
@@ -3463,6 +3513,24 @@ public void testSuccessfulAsList_logging_error() throws Exception {
     assertThat(logged.get(0).getThrown()).isInstanceOf(MyError.class);
   }
 
+  public void testSuccessfulAsList_failureLoggedEvenAfterOutputCancelled() throws Exception {
+    ListenableFuture<String> input = new CancelPanickingFuture<>();
+    ListenableFuture<List<String>> output = successfulAsList(input);
+    output.cancel(false);
+
+    List<LogRecord> logged = aggregateFutureLogHandler.getStoredLogRecords();
+    assertThat(logged).hasSize(1);
+    assertThat(logged.get(0).getThrown()).hasMessageThat().isEqualTo(""You can't fire me, I quit."");
+  }
+
+  private static final class CancelPanickingFuture<V> extends AbstractFuture<V> {
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      setException(new Error(""You can't fire me, I quit.""));
+      return false;
+    }
+  }
+
   public void testNonCancellationPropagating_successful() throws Exception {
     SettableFuture<Foo> input = SettableFuture.create();
     ListenableFuture<Foo> wrapper = nonCancellationPropagating(input);
@@ -3517,22 +3585,6 @@ public void testNonCancellationPropagating_doesNotPropagate() throws Exception {
     }
   }
 
-  @GwtIncompatible // used only in GwtIncompatible tests
-  private static final Function<Exception, TestException> mapper =
-      new Function<Exception, TestException>() {
-        @Override
-        public TestException apply(Exception from) {
-          if (from instanceof ExecutionException) {
-            return new TestException(from.getCause());
-          } else {
-            assertTrue(
-                ""got "" + from.getClass(),
-                from instanceof InterruptedException || from instanceof CancellationException);
-            return new TestException(from);
-          }
-        }
-      };
-
   @GwtIncompatible // used only in GwtIncompatible tests
   private interface MapperFunction extends Function<Throwable, Exception> {}
 , @@ -16,8 +16,11 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.ALL_INPUT_FUTURES_PROCESSED;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.logging.Level.SEVERE;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
@@ -26,269 +29,303 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
-import java.util.logging.Level;
 import java.util.logging.Logger;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
- * A future made up of a collection of sub-futures.
+ * A future whose value is derived from a collection of input futures.
  *
  * @param <InputT> the type of the individual inputs
  * @param <OutputT> the type of the output (i.e. this) future
  */
 @GwtCompatible
-abstract class AggregateFuture<InputT, OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
+abstract class AggregateFuture<InputT, OutputT> extends AggregateFutureState<OutputT> {
   private static final Logger logger = Logger.getLogger(AggregateFuture.class.getName());
 
+  /**
+   * The input futures. After {@link #init}, this field is read only by {@link #afterDone()} (to
+   * propagate cancellation) and {@link #toString()}. To access the futures' <i>values</i>, {@code
+   * AggregateFuture} attaches listeners that hold references to one or more inputs. And in the case
+   * of {@link CombinedFuture}, the user-supplied callback usually has its own references to inputs.
+   */
   /*
    * In certain circumstances, this field might theoretically not be visible to an afterDone() call
    * triggered by cancel(). For details, see the comments on the fields of TimeoutFuture.
    */
-  private @Nullable RunningState runningState;
+  private @Nullable ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures;
+
+  private final boolean allMustSucceed;
+  private final boolean collectsValues;
+
+  AggregateFuture(
+      ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,
+      boolean allMustSucceed,
+      boolean collectsValues) {
+    super(futures.size());
+    this.futures = checkNotNull(futures);
+    this.allMustSucceed = allMustSucceed;
+    this.collectsValues = collectsValues;
+  }
 
   @Override
   protected final void afterDone() {
     super.afterDone();
-    releaseResources();
-  }
-
-  protected final void releaseResources() {
-    RunningState localRunningState = runningState;
-    if (localRunningState != null) {
-      // Let go of the memory held by the running state
-      this.runningState = null;
-      ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures =
-          localRunningState.futures;
-      boolean wasInterrupted = wasInterrupted();
 
-      if (wasInterrupted) {
-        localRunningState.interruptTask();
-      }
+    ImmutableCollection<? extends Future<?>> localFutures = futures;
+    releaseResources(OUTPUT_FUTURE_DONE); // nulls out `futures`
 
-      if (isCancelled() & futures != null) {
-        for (ListenableFuture<?> future : futures) {
-          future.cancel(wasInterrupted);
-        }
+    if (isCancelled() & localFutures != null) {
+      boolean wasInterrupted = wasInterrupted();
+      for (Future<?> future : localFutures) {
+        future.cancel(wasInterrupted);
       }
     }
+    /*
+     * We don't call clearSeenExceptions() until processCompleted(). Prior to that, it may be needed
+     * again if some outstanding input fails.
+     */
   }
 
   @Override
-  protected String pendingToString() {
-    RunningState localRunningState = runningState;
-    if (localRunningState == null) {
-      return null;
-    }
-    ImmutableCollection<? extends ListenableFuture<? extends InputT>> localFutures =
-        localRunningState.futures;
+  protected final String pendingToString() {
+    ImmutableCollection<? extends Future<?>> localFutures = futures;
     if (localFutures != null) {
       return ""futures=["" + localFutures + ""]"";
     }
     return null;
   }
 
-  /** Must be called at the end of each sub-class's constructor. */
-  final void init(RunningState runningState) {
-    this.runningState = runningState;
-    runningState.init();
-  }
-
-  abstract class RunningState extends AggregateFutureState implements Runnable {
-    private ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures;
-    private final boolean allMustSucceed;
-    private final boolean collectsValues;
-
-    RunningState(
-        ImmutableCollection<? extends ListenableFuture<? extends InputT>> futures,
-        boolean allMustSucceed,
-        boolean collectsValues) {
-      super(futures.size());
-      this.futures = checkNotNull(futures);
-      this.allMustSucceed = allMustSucceed;
-      this.collectsValues = collectsValues;
-    }
-
-    /* Used in the !allMustSucceed case so we don't have to instantiate a listener. */
-    @Override
-    public final void run() {
-      decrementCountAndMaybeComplete();
+  /**
+   * Must be called at the end of each subclass's constructor. This method performs the ""real""
+   * initialization; we can't put this in the constructor because, in the case where futures are
+   * already complete, we would not initialize the subclass before calling {@link
+   * #collectValueFromNonCancelledFuture}. As this is called after the subclass is constructed,
+   * we're guaranteed to have properly initialized the subclass.
+   */
+  final void init() {
+    // Corner case: List is empty.
+    if (futures.isEmpty()) {
+      handleAllCompleted();
+      return;
     }
 
-    /**
-     * The ""real"" initialization; we can't put this in the constructor because, in the case where
-     * futures are already complete, we would not initialize the subclass before calling {@link
-     * #handleOneInputDone}. As this is called after the subclass is constructed, we're guaranteed
-     * to have properly initialized the subclass.
-     */
-    private void init() {
-      // Corner case: List is empty.
-      if (futures.isEmpty()) {
-        handleAllCompleted();
-        return;
-      }
-
-      // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll
-      // need to handle RejectedExecutionException
+    // NOTE: If we ever want to use a custom executor here, have a look at CombinedFuture as we'll
+    // need to handle RejectedExecutionException
 
-      if (allMustSucceed) {
-        // We need fail fast, so we have to keep track of which future failed so we can propagate
-        // the exception immediately
+    if (allMustSucceed) {
+      // We need fail fast, so we have to keep track of which future failed so we can propagate
+      // the exception immediately
 
-        // Register a listener on each Future in the list to update the state of this future.
-        // Note that if all the futures on the list are done prior to completing this loop, the last
-        // call to addListener() will callback to setOneValue(), transitively call our cleanup
-        // listener, and set this.futures to null.
-        // This is not actually a problem, since the foreach only needs this.futures to be non-null
-        // at the beginning of the loop.
-        int i = 0;
-        for (final ListenableFuture<? extends InputT> listenable : futures) {
-          final int index = i++;
-          listenable.addListener(
-              new Runnable() {
-                @Override
-                public void run() {
-                  try {
-                    handleOneInputDone(index, listenable);
-                  } finally {
-                    decrementCountAndMaybeComplete();
+      // Register a listener on each Future in the list to update the state of this future.
+      // Note that if all the futures on the list are done prior to completing this loop, the last
+      // call to addListener() will callback to setOneValue(), transitively call our cleanup
+      // listener, and set this.futures to null.
+      // This is not actually a problem, since the foreach only needs this.futures to be non-null
+      // at the beginning of the loop.
+      int i = 0;
+      for (final ListenableFuture<? extends InputT> future : futures) {
+        final int index = i++;
+        future.addListener(
+            new Runnable() {
+              @Override
+              public void run() {
+                try {
+                  if (future.isCancelled()) {
+                    // Clear futures prior to cancelling children. This sets our own state but lets
+                    // the input futures keep running, as some of them may be used elsewhere.
+                    futures = null;
+                    cancel(false);
+                  } else {
+                    collectValueFromNonCancelledFuture(index, future);
                   }
+                } finally {
+                  /*
+                   * ""null"" means: There is no need to access `futures` again during
+                   * `processCompleted` because we're reading each value during a call to
+                   * handleOneInputDone.
+                   */
+                  decrementCountAndMaybeComplete(null);
                 }
-              },
-              directExecutor());
-        }
-      } else {
-        // We'll only call the callback when all futures complete, regardless of whether some failed
-        // Hold off on calling setOneValue until all complete, so we can share the same listener
-        for (ListenableFuture<? extends InputT> listenable : futures) {
-          listenable.addListener(this, directExecutor());
-        }
+              }
+            },
+            directExecutor());
+      }
+    } else {
+      /*
+       * We'll call the user callback or collect the values only when all inputs complete,
+       * regardless of whether some failed. This lets us avoid calling expensive methods like
+       * Future.get() when we don't need to (specifically, for whenAllComplete().call*()), and it
+       * lets all futures share the same listener.
+       *
+       * We store `localFutures` inside the listener because `this.futures` might be nulled out by
+       * the time the listener runs for the final future -- at which point we need to check all
+       * inputs for exceptions *if* we're collecting values. If we're not, then the listener doesn't
+       * need access to the futures again, so we can just pass `null`.
+       *
+       * TODO(b/112550045): Allocating a single, cheaper listener is (I think) only an optimization.
+       * If we make some other optimizations, this one will no longer be necessary. The optimization
+       * could actually hurt in some cases, as it forces us to keep all inputs in memory until the
+       * final input completes.
+       */
+      final ImmutableCollection<? extends Future<? extends InputT>> localFutures =
+          collectsValues ? futures : null;
+      Runnable listener =
+          new Runnable() {
+            @Override
+            public void run() {
+              decrementCountAndMaybeComplete(localFutures);
+            }
+          };
+      for (ListenableFuture<? extends InputT> future : futures) {
+        future.addListener(listener, directExecutor());
       }
     }
+  }
 
-    /**
-     * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the
-     * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the
-     * throwable did not cause this future to fail, and it is the first time we've seen that
-     * particular Throwable.
-     */
-    private void handleException(Throwable throwable) {
-      checkNotNull(throwable);
+  /**
+   * Fails this future with the given Throwable if {@link #allMustSucceed} is true. Also, logs the
+   * throwable if it is an {@link Error} or if {@link #allMustSucceed} is {@code true}, the
+   * throwable did not cause this future to fail, and it is the first time we've seen that
+   * particular Throwable.
+   */
+  private void handleException(Throwable throwable) {
+    checkNotNull(throwable);
 
-      boolean completedWithFailure = false;
-      boolean firstTimeSeeingThisException = true;
-      if (allMustSucceed) {
-        // As soon as the first one fails, throw the exception up.
-        // The result of all other inputs is then ignored.
-        completedWithFailure = setException(throwable);
-        if (completedWithFailure) {
-          releaseResourcesAfterFailure();
-        } else {
-          // Go up the causal chain to see if we've already seen this cause; if we have, even if
-          // it's wrapped by a different exception, don't log it.
-          firstTimeSeeingThisException = addCausalChain(getOrInitSeenExceptions(), throwable);
+    if (allMustSucceed) {
+      // As soon as the first one fails, make that failure the result of the output future.
+      // The results of all other inputs are then ignored (except for logging any failures).
+      boolean completedWithFailure = setException(throwable);
+      if (!completedWithFailure) {
+        // Go up the causal chain to see if we've already seen this cause; if we have, even if
+        // it's wrapped by a different exception, don't log it.
+        boolean firstTimeSeeingThisException = addCausalChain(getOrInitSeenExceptions(), throwable);
+        if (firstTimeSeeingThisException) {
+          log(throwable);
+          return;
         }
       }
-
-      // | and & used because it's faster than the branch required for || and &&
-      if (throwable instanceof Error
-          | (allMustSucceed & !completedWithFailure & firstTimeSeeingThisException)) {
-        String message =
-            (throwable instanceof Error)
-                ? ""Input Future failed with Error""
-                : ""Got more than one input Future failure. Logging failures after the first"";
-        logger.log(Level.SEVERE, message, throwable);
-      }
     }
 
-    @Override
-    final void addInitialException(Set<Throwable> seen) {
-      if (!isCancelled()) {
-        // TODO(cpovirk): Think about whether we could/should use Verify to check this.
-        boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
-      }
+    /*
+     * TODO(cpovirk): Should whenAllComplete().call*() log errors, too? Currently, it doesn't call
+     * handleException() at all.
+     */
+    if (throwable instanceof Error) {
+      /*
+       * TODO(cpovirk): Do we really want to log this if we called setException(throwable) and it
+       * returned true? This was intentional (CL 46470009), but it seems odd compared to how we
+       * normally handle Error.
+       *
+       * Similarly, do we really want to log the same Error more than once?
+       */
+      log(throwable);
     }
+  }
 
-    /** Handles the input at the given index completing. */
-    private void handleOneInputDone(int index, Future<? extends InputT> future) {
-      // The only cases in which this Future should already be done are (a) if it was cancelled or
-      // (b) if an input failed and we propagated that immediately because of allMustSucceed.
-      checkState(
-          allMustSucceed || !isDone() || isCancelled(),
-          ""Future was done before all dependencies completed"");
+  private static void log(Throwable throwable) {
+    String message =
+        (throwable instanceof Error)
+            ? ""Input Future failed with Error""
+            : ""Got more than one input Future failure. Logging failures after the first"";
+    logger.log(SEVERE, message, throwable);
+  }
 
-      try {
-        checkState(future.isDone(), ""Tried to set value from future which is not done"");
-        if (allMustSucceed) {
-          if (future.isCancelled()) {
-            // clear running state prior to cancelling children, this sets our own state but lets
-            // the input futures keep running as some of them may be used elsewhere.
-            runningState = null;
-            cancel(false);
-          } else {
-            // We always get the result so that we can have fail-fast, even if we don't collect
-            InputT result = getDone(future);
-            if (collectsValues) {
-              collectOneValue(allMustSucceed, index, result);
-            }
-          }
-        } else if (collectsValues && !future.isCancelled()) {
-          collectOneValue(allMustSucceed, index, getDone(future));
-        }
-      } catch (ExecutionException e) {
-        handleException(e.getCause());
-      } catch (Throwable t) {
-        handleException(t);
-      }
+  @Override
+  final void addInitialException(Set<Throwable> seen) {
+    checkNotNull(seen);
+    if (!isCancelled()) {
+      // TODO(cpovirk): Think about whether we could/should use Verify to check this.
+      boolean unused = addCausalChain(seen, tryInternalFastPathGetFailure());
     }
+  }
 
-    private void decrementCountAndMaybeComplete() {
-      int newRemaining = decrementRemainingAndGet();
-      checkState(newRemaining >= 0, ""Less than 0 remaining futures"");
-      if (newRemaining == 0) {
-        processCompleted();
-      }
+  /**
+   * Collects the result (success or failure) of one input future. The input must not have been
+   * cancelled. For details on when this is called, see {@link #collectOneValue}.
+   */
+  private void collectValueFromNonCancelledFuture(int index, Future<? extends InputT> future) {
+    try {
+      // We get the result, even if collectOneValue is a no-op, so that we can fail fast.
+      collectOneValue(index, getDone(future));
+    } catch (ExecutionException e) {
+      handleException(e.getCause());
+    } catch (Throwable t) {
+      handleException(t);
     }
+  }
+
+  private void decrementCountAndMaybeComplete(
+      @Nullable
+          ImmutableCollection<? extends Future<? extends InputT>>
+              futuresIfNeedToCollectAtCompletion) {
+    int newRemaining = decrementRemainingAndGet();
+    checkState(newRemaining >= 0, ""Less than 0 remaining futures"");
+    if (newRemaining == 0) {
+      processCompleted(futuresIfNeedToCollectAtCompletion);
+    }
+  }
 
-    private void processCompleted() {
-      // Collect the values if (a) our output requires collecting them and (b) we haven't been
-      // collecting them as we go. (We've collected them as we go only if we needed to fail fast)
-      if (collectsValues & !allMustSucceed) {
-        int i = 0;
-        for (ListenableFuture<? extends InputT> listenable : futures) {
-          handleOneInputDone(i++, listenable);
+  private void processCompleted(
+      @Nullable
+          ImmutableCollection<? extends Future<? extends InputT>>
+              futuresIfNeedToCollectAtCompletion) {
+    if (futuresIfNeedToCollectAtCompletion != null) {
+      int i = 0;
+      for (Future<? extends InputT> future : futuresIfNeedToCollectAtCompletion) {
+        if (!future.isCancelled()) {
+          collectValueFromNonCancelledFuture(i, future);
         }
+        i++;
       }
-      handleAllCompleted();
     }
-
-    /**
-     * Listeners implicitly keep a reference to {@link RunningState} as they're inner classes, so we
-     * free resources here as well for the allMustSucceed=true case (i.e. when a future fails, we
-     * immediately release resources we no longer need); additionally, the future will release its
-     * reference to {@link RunningState}, which should free all associated memory when all the
-     * futures complete and the listeners are released.
-     *
-     * <p>TODO(user): Write tests for memory retention
+    clearSeenExceptions();
+    handleAllCompleted();
+    /*
+     * Null out fields, including some used in handleAllCompleted() above (like
+     * `CollectionFuture.values`). This might be a no-op: If this future completed during
+     * handleAllCompleted(), they will already have been nulled out. But in the case of
+     * whenAll*().call*(), this future may be pending until the callback runs -- or even longer in
+     * the case of callAsync(), which waits for the callback's returned future to complete.
      */
-    @ForOverride
-    @OverridingMethodsMustInvokeSuper
-    void releaseResourcesAfterFailure() {
-      this.futures = null;
-    }
+    releaseResources(ALL_INPUT_FUTURES_PROCESSED);
+  }
 
-    /**
-     * Called only if {@code collectsValues} is true.
-     *
-     * <p>If {@code allMustSucceed} is true, called as each future completes; otherwise, called for
-     * each future when all futures complete.
+  /**
+   * Clears fields that are no longer needed after this future has completed -- or at least all its
+   * inputs have completed (more precisely, after {@link #handleAllCompleted()} has been called).
+   * Often called multiple times (that is, both when the inputs complete and when the output
+   * completes).
+   *
+   * <p>This is similar to our proposed {@code afterCommit} method but not quite the same. See the
+   * description of CL 265462958.
+   */
+  // TODO(user): Write more tests for memory retention.
+  @ForOverride
+  @OverridingMethodsMustInvokeSuper
+  void releaseResources(ReleaseResourcesReason reason) {
+    checkNotNull(reason);
+    /*
+     * All elements of `futures` are completed, or this future has already completed and read
+     * `futures` into a local variable (in preparation for propagating cancellation to them). In
+     * either case, no one needs to read `futures` for cancellation purposes later. (And
+     * cancellation purposes are the main reason to access `futures`, as discussed in its docs.)
      */
-    abstract void collectOneValue(boolean allMustSucceed, int index, @Nullable InputT returnValue);
-
-    abstract void handleAllCompleted();
+    this.futures = null;
+  }
 
-    void interruptTask() {}
+  enum ReleaseResourcesReason {
+    OUTPUT_FUTURE_DONE,
+    ALL_INPUT_FUTURES_PROCESSED,
   }
 
+  /**
+   * If {@code allMustSucceed} is true, called as each future completes; otherwise, if {@code
+   * collectsValues} is true, called for each future when all futures complete.
+   */
+  abstract void collectOneValue(int index, @Nullable InputT returnValue);
+
+  abstract void handleAllCompleted();
+
   /** Adds the chain to the seen set, and returns whether all the chain was new to us. */
   private static boolean addCausalChain(Set<Throwable> seen, Throwable t) {
     for (; t != null; t = t.getCause()) {, @@ -37,9 +37,9 @@
  */
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
-abstract class AggregateFutureState {
+abstract class AggregateFutureState<OutputT> extends AbstractFuture.TrustedFuture<OutputT> {
   // Lazily initialized the first time we see an exception; not released until all the input futures
-  // & this future completes. Released when the future releases the reference to the running state
+  // have completed and we have processed them all.
   private volatile Set<Throwable> seenExceptions = null;
 
   private volatile int remaining;
@@ -89,12 +89,27 @@
      * Thread2: calls setException(), which returns false, CASes seenExceptions to its exception,
      * and wrongly believes that its exception is new (leading it to logging it when it shouldn't)
      *
-     * Our solution is for threads to CAS seenExceptions from null to a Set population with _the
+     * Our solution is for threads to CAS seenExceptions from null to a Set populated with _the
      * initial exception_, no matter which thread does the work. This ensures that seenExceptions
      * always contains not just the current thread's exception but also the initial thread's.
      */
     Set<Throwable> seenExceptionsLocal = seenExceptions;
     if (seenExceptionsLocal == null) {
+      // TODO(cpovirk): Should we use a simpler (presumably cheaper) data structure?
+      /*
+       * Using weak references here could let us release exceptions earlier, but:
+       *
+       * 1. On Android, querying a WeakReference blocks if the GC is doing an otherwise-concurrent
+       * pass.
+       *
+       * 2. We would probably choose to compare exceptions using == instead of equals() (for
+       * consistency with how weak references are cleared). That's a behavior change -- arguably the
+       * removal of a feature.
+       *
+       * Fortunately, exceptions rarely contain references to expensive resources.
+       */
+
+      //
       seenExceptionsLocal = newConcurrentHashSet();
       /*
        * Other handleException() callers may see this as soon as we publish it. We need to populate
@@ -122,6 +137,10 @@ final int decrementRemainingAndGet() {
     return ATOMIC_HELPER.decrementAndGetRemainingCount(this);
   }
 
+  final void clearSeenExceptions() {
+    seenExceptions = null;
+  }
+
   private abstract static class AtomicHelper {
     /** Atomic compare-and-set of the {@link AggregateFutureState#seenExceptions} field. */
     abstract void compareAndSetSeenExceptions(
@@ -169,8 +188,7 @@ void compareAndSetSeenExceptions(
     @Override
     int decrementAndGetRemainingCount(AggregateFutureState state) {
       synchronized (state) {
-        state.remaining--;
-        return state.remaining;
+        return --state.remaining;
       }
     }
   }, @@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Lists.newArrayListWithCapacity;
 import static java.util.Collections.unmodifiableList;
 
@@ -29,83 +28,64 @@
 /** Aggregate future that collects (stores) results of each future. */
 @GwtCompatible(emulated = true)
 abstract class CollectionFuture<V, C> extends AggregateFuture<V, C> {
+  private List<Optional<V>> values;
 
-  abstract class CollectionFutureRunningState extends RunningState {
-    private List<Optional<V>> values;
+  CollectionFuture(
+      ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
+      boolean allMustSucceed) {
+    super(futures, allMustSucceed, true);
 
-    CollectionFutureRunningState(
-        ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
-        boolean allMustSucceed) {
-      super(futures, allMustSucceed, true);
-
-      this.values =
-          futures.isEmpty()
-              ? ImmutableList.<Optional<V>>of()
-              : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());
+    this.values =
+        futures.isEmpty()
+            ? ImmutableList.<Optional<V>>of()
+            : Lists.<Optional<V>>newArrayListWithCapacity(futures.size());
 
-      // Populate the results list with null initially.
-      for (int i = 0; i < futures.size(); ++i) {
-        values.add(null);
-      }
+    // Populate the results list with null initially.
+    for (int i = 0; i < futures.size(); ++i) {
+      values.add(null);
     }
+  }
 
-    @Override
-    final void collectOneValue(boolean allMustSucceed, int index, @Nullable V returnValue) {
-      List<Optional<V>> localValues = values;
-
-      if (localValues != null) {
-        localValues.set(index, Optional.fromNullable(returnValue));
-      } else {
-        // Some other future failed or has been cancelled, causing this one to also be cancelled or
-        // have an exception set. This should only happen if allMustSucceed is true or if the output
-        // itself has been cancelled.
-        checkState(
-            allMustSucceed || isCancelled(), ""Future was done before all dependencies completed"");
-      }
-    }
-
-    @Override
-    final void handleAllCompleted() {
-      List<Optional<V>> localValues = values;
-      if (localValues != null) {
-        set(combine(localValues));
-      } else {
-        checkState(isDone());
-      }
+  @Override
+  final void collectOneValue(int index, @Nullable V returnValue) {
+    List<Optional<V>> localValues = values;
+    if (localValues != null) {
+      localValues.set(index, Optional.fromNullable(returnValue));
     }
+  }
 
-    @Override
-    void releaseResourcesAfterFailure() {
-      super.releaseResourcesAfterFailure();
-      this.values = null;
+  @Override
+  final void handleAllCompleted() {
+    List<Optional<V>> localValues = values;
+    if (localValues != null) {
+      set(combine(localValues));
     }
+  }
 
-    abstract C combine(List<Optional<V>> values);
+  @Override
+  void releaseResources(ReleaseResourcesReason reason) {
+    super.releaseResources(reason);
+    this.values = null;
   }
 
+  abstract C combine(List<Optional<V>> values);
+
   /** Used for {@link Futures#allAsList} and {@link Futures#successfulAsList}. */
   static final class ListFuture<V> extends CollectionFuture<V, List<V>> {
     ListFuture(
         ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
         boolean allMustSucceed) {
-      init(new ListFutureRunningState(futures, allMustSucceed));
+      super(futures, allMustSucceed);
+      init();
     }
 
-    private final class ListFutureRunningState extends CollectionFutureRunningState {
-      ListFutureRunningState(
-          ImmutableCollection<? extends ListenableFuture<? extends V>> futures,
-          boolean allMustSucceed) {
-        super(futures, allMustSucceed);
-      }
-
-      @Override
-      public List<V> combine(List<Optional<V>> values) {
-        List<V> result = newArrayListWithCapacity(values.size());
-        for (Optional<V> element : values) {
-          result.add(element != null ? element.orNull() : null);
-        }
-        return unmodifiableList(result);
+    @Override
+    public List<V> combine(List<Optional<V>> values) {
+      List<V> result = newArrayListWithCapacity(values.size());
+      for (Optional<V> element : values) {
+        result.add(element != null ? element.orNull() : null);
       }
+      return unmodifiableList(result);
     }
   }
 }, @@ -15,7 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.util.concurrent.AggregateFuture.ReleaseResourcesReason.OUTPUT_FUTURE_DONE;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableCollection;
@@ -30,64 +30,59 @@
 /** Aggregate future that computes its value by calling a callable. */
 @GwtCompatible
 final class CombinedFuture<V> extends AggregateFuture<Object, V> {
+  private CombinedFutureInterruptibleTask<?> task;
+
   CombinedFuture(
       ImmutableCollection<? extends ListenableFuture<?>> futures,
       boolean allMustSucceed,
       Executor listenerExecutor,
       AsyncCallable<V> callable) {
-    init(
-        new CombinedFutureRunningState(
-            futures,
-            allMustSucceed,
-            new AsyncCallableInterruptibleTask(callable, listenerExecutor)));
+    super(futures, allMustSucceed, false);
+    this.task = new AsyncCallableInterruptibleTask(callable, listenerExecutor);
+    init();
   }
 
   CombinedFuture(
       ImmutableCollection<? extends ListenableFuture<?>> futures,
       boolean allMustSucceed,
       Executor listenerExecutor,
       Callable<V> callable) {
-    init(
-        new CombinedFutureRunningState(
-            futures, allMustSucceed, new CallableInterruptibleTask(callable, listenerExecutor)));
+    super(futures, allMustSucceed, false);
+    this.task = new CallableInterruptibleTask(callable, listenerExecutor);
+    init();
   }
 
-  private final class CombinedFutureRunningState extends RunningState {
-    private CombinedFutureInterruptibleTask task;
-
-    CombinedFutureRunningState(
-        ImmutableCollection<? extends ListenableFuture<?>> futures,
-        boolean allMustSucceed,
-        CombinedFutureInterruptibleTask task) {
-      super(futures, allMustSucceed, false);
-      this.task = task;
-    }
+  @Override
+  void collectOneValue(int index, @Nullable Object returnValue) {}
 
-    @Override
-    void collectOneValue(boolean allMustSucceed, int index, @Nullable Object returnValue) {}
-
-    @Override
-    void handleAllCompleted() {
-      CombinedFutureInterruptibleTask localTask = task;
-      if (localTask != null) {
-        localTask.execute();
-      } else {
-        checkState(isDone());
-      }
+  @Override
+  void handleAllCompleted() {
+    CombinedFutureInterruptibleTask<?> localTask = task;
+    if (localTask != null) {
+      localTask.execute();
     }
+  }
 
-    @Override
-    void releaseResourcesAfterFailure() {
-      super.releaseResourcesAfterFailure();
+  @Override
+  void releaseResources(ReleaseResourcesReason reason) {
+    super.releaseResources(reason);
+    /*
+     * If the output future is done, then it won't need to interrupt the task later, so it can clear
+     * its reference to it.
+     *
+     * If the output future is *not* done, then the task field will be cleared after the task runs
+     * or after the output future is done, whichever comes first.
+     */
+    if (reason == OUTPUT_FUTURE_DONE) {
       this.task = null;
     }
+  }
 
-    @Override
-    void interruptTask() {
-      CombinedFutureInterruptibleTask localTask = task;
-      if (localTask != null) {
-        localTask.interruptTask();
-      }
+  @Override
+  protected void interruptTask() {
+    CombinedFutureInterruptibleTask<?> localTask = task;
+    if (localTask != null) {
+      localTask.interruptTask();
     }
   }
 
@@ -96,7 +91,7 @@ void interruptTask() {
     private final Executor listenerExecutor;
     boolean thrownByExecute = true;
 
-    public CombinedFutureInterruptibleTask(Executor listenerExecutor) {
+    CombinedFutureInterruptibleTask(Executor listenerExecutor) {
       this.listenerExecutor = checkNotNull(listenerExecutor);
     }
 
@@ -117,6 +112,19 @@ final void execute() {
 
     @Override
     final void afterRanInterruptibly(T result, Throwable error) {
+      /*
+       * The future no longer needs to interrupt this task, so it no longer needs a reference to it.
+       *
+       * TODO(cpovirk): It might be nice for our InterruptibleTask subclasses to null out their
+       *  `callable` fields automatically. That would make it less important for us to null out the
+       * reference to `task` here (though it's still nice to do so in case our reference to the
+       * executor keeps it alive). Ideally, nulling out `callable` would be the responsibility of
+       * InterruptibleTask itself so that its other subclasses also benefit. (Handling `callable` in
+       * InterruptibleTask itself might also eliminate some of the existing boilerplate for, e.g.,
+       * pendingToString().)
+       */
+      CombinedFuture.this.task = null;
+
       if (error != null) {
         if (error instanceof ExecutionException) {
           setException(error.getCause());
@@ -138,7 +146,7 @@ final void afterRanInterruptibly(T result, Throwable error) {
       extends CombinedFutureInterruptibleTask<ListenableFuture<V>> {
     private final AsyncCallable<V> callable;
 
-    public AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listenerExecutor) {
+    AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
       this.callable = checkNotNull(callable);
     }
@@ -157,9 +165,6 @@ public AsyncCallableInterruptibleTask(AsyncCallable<V> callable, Executor listen
     @Override
     void setValue(ListenableFuture<V> value) {
       setFuture(value);
-      // Eagerly release resources instead of waiting for afterDone. We are done with the inputs,
-      // but the actual future may not complete for arbitrarily long.
-      releaseResources();
     }
 
     @Override
@@ -172,7 +177,7 @@ String toPendingString() {
   private final class CallableInterruptibleTask extends CombinedFutureInterruptibleTask<V> {
     private final Callable<V> callable;
 
-    public CallableInterruptibleTask(Callable<V> callable, Executor listenerExecutor) {
+    CallableInterruptibleTask(Callable<V> callable, Executor listenerExecutor) {
       super(listenerExecutor);
       this.callable = checkNotNull(callable);
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Release the input futures as soon as we submit the combiner task. But really, redo how we release resources in general.

This is a followup to CL 265489523, which ""only"" released the input futures as soon as the combiner task finished running (which had often happened even before that CL but hadn't if the combiner returned a Future that was still pending). That CL was good enough for practical purposes, but I wanted to better understand how we release resources.

This CL standardizes on AggregateFuture.releaseResources() as the way to null out all fields[*], merging logic from releaseResources(), releaseResourcesAfterFailure(), and AsyncCallableInterruptibleTask.setValue(...). As part of that, it merges AggregateFuture and AggregateFutureState/RunningState into a single object.

[*] OK, except seenExceptions, which gets its own handling. As a bonus, I believe that this CL clears seenExceptions earlier than it used to be cleared in the CombinedFuture case. Specifically, it clears it when all inputs are done, rather than when the combiner task has finished running.

It turns out that blindly nulling out fields is too aggressive, so we need to be careful in 2 cases:

1. CombinedFuture.releaseResources() can't null out `task` until the future is done or the task is done running. That's because it may need to interrupt the task. To handle this, I don't null out `task` in releaseResources() unless isDone(). To ensure that `task` still gets nulled out as soon as it's done running, I null it out directly in afterRanInterruptibly(). (OK, this is another exception to my claim that releaseResources() handles nulling out ""all"" fields....)

2. Even if the output future is done, processCompleted() sometimes needs access to the original futures in order to see whether any of them failed. To handle this, I store them in the listener and pass them through to processCompleted() (when necessary).

The changes to prod code are net negative in line count, at least ignoring the added comments. I've also added a couple tests, only one of which passed before this CL. And I think the model for when fields are nulled out is overall clearer after this CL. So hopefully this CL is a step forward, despite the complexity of the changes and the remaining complexity in the code. (I also included a few unrelated simplifications, like not bothering to check collectsValues before calling collectOneValue(...).)

(Aside: This CL's releaseResources() is like our proposed afterCommit() API but different. First, releaseResources() may be called even before set() or setAsync() in the CombinedFuture case. Second, CombinedFuture may rely on the fact that it's called twice in some cases: It's called once when all inputs complete, but it doesn't null out `task`, and then it can be called again if the output is cancelled, at which point it *does* null out `task`. But that probably doesn't matter too much because the task was probably handed to an executor in the meantime, so CombinedFuture is unlikely to hold the final reference to it. Anyway, for more discussion of afterCommit(), see https://github.com/google/guava/issues/2886)

[]

41a8adb81e2ebf27e9d85f70671ff8f97fd7721b",Moe Sync
3586,Kurt Alfred Kluever,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Let ListenableFuture implement thenable via a default interface method in J2CL

RELNOTES=Let ListenableFuture implement thenable via a default interface method in J2CL

f6bb300d5fe145486dbeb28c544867f562ddc185

-------

<p> Let ListenableFuture implement thenable via a default interface method in J2CL

***

f45705983f8dbaf48896b8ec783b4d56e7b1f184

-------

<p> Update Public Suffix data.

The copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

When that bug is not updated, the copy is updated 3 weeks before the
Estimated Week of Stable:

https://www.chromium.org/developers/calendar#TOC-Estimated-Stable-Dates

a793784ba71562cdabf41ba87aad849440b145a7",Moe Sync
3588,Kurt Alfred Kluever,"['android/guava/src/com/google/common/net/PercentEscaper.java', 'guava/src/com/google/common/net/PercentEscaper.java']","@@ -64,7 +64,7 @@
 
   /**
    * An array of flags where for any {@code char c} if {@code safeOctets[c]} is true then {@code c}
-   * should remain unmodified in the output. If {@code c > safeOctets.length} then it should be
+   * should remain unmodified in the output. If {@code c >= safeOctets.length} then it should be
    * escaped.
    */
   private final boolean[] safeOctets;, @@ -64,7 +64,7 @@
 
   /**
    * An array of flags where for any {@code char c} if {@code safeOctets[c]} is true then {@code c}
-   * should remain unmodified in the output. If {@code c > safeOctets.length} then it should be
+   * should remain unmodified in the output. If {@code c >= safeOctets.length} then it should be
    * escaped.
    */
   private final boolean[] safeOctets;, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Modify comment about safeOctets.length to be consistent with code.

f7012fc03d4a3c0337e6f45a7f81052bfa0718b9",Moe Sync
3597,Kurt Alfred Kluever,"['android/guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/Futures.java']","@@ -526,6 +526,8 @@ private O applyTransformation(I input) throws ExecutionException {
    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
    * successful.
    *
+   * <p>Any failures from the input futures will not be propagated to the returned future.
+   *
    * @since 20.0
    */
   @Beta
@@ -538,6 +540,8 @@ private O applyTransformation(I input) throws ExecutionException {
    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
    * successful.
    *
+   * <p>Any failures from the input futures will not be propagated to the returned future.
+   *
    * @since 20.0
    */
   @Beta, @@ -559,6 +559,8 @@ private O applyTransformation(I input) throws ExecutionException {
    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
    * successful.
    *
+   * <p>Any failures from the input futures will not be propagated to the returned future.
+   *
    * @since 20.0
    */
   @Beta
@@ -571,6 +573,8 @@ private O applyTransformation(I input) throws ExecutionException {
    * Creates a {@link FutureCombiner} that processes the completed futures whether or not they're
    * successful.
    *
+   * <p>Any failures from the input futures will not be propagated to the returned future.
+   *
    * @since 20.0
    */
   @Beta, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Explicitly document that whenAllComplete will swallow failures (in contrast to waiting for all futures to complete and then propagating the first failure).

98971ae01e62ed36f99c8bb5c4e897eac8cb1988",Moe Sync
3605,Colin Decker,"['android/guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AtomicLongMapTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/SimpleTimeLimiterTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/UninterruptibleFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractServiceTest.java', 'guava-tests/test/com/google/common/util/concurrent/AtomicLongMapTest.java', 'guava-tests/test/com/google/common/util/concurrent/ServiceManagerTest.java', 'guava-tests/test/com/google/common/util/concurrent/SimpleTimeLimiterTest.java', 'guava-tests/test/com/google/common/util/concurrent/UninterruptibleFutureTest.java']","@@ -42,7 +42,7 @@
  */
 public class AbstractServiceTest extends TestCase {
 
-  private static final long LONG_TIMEOUT_MILLIS = 2500;
+  private static final long LONG_TIMEOUT_MILLIS = 10000;
   private Thread executionThread;
   private Throwable thrownByExecutionThread;
 , @@ -25,11 +25,6 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
 import junit.framework.TestCase;
 
 /**
@@ -42,7 +37,7 @@
   private static final int ITERATIONS = 100;
   private static final int MAX_ADDEND = 100;
 
-  private Random random = new Random(301);
+  private final Random random = new Random(301);
 
   @GwtIncompatible // NullPointerTester
   public void testNulls() {
@@ -578,87 +573,4 @@ public void testSerialization() {
     AtomicLongMap<String> reserialized = SerializableTester.reserialize(map);
     assertEquals(map.asMap(), reserialized.asMap());
   }
-
-  @GwtIncompatible // threads
-  public void testModify_basher() throws InterruptedException {
-    int nTasks = 3000;
-    int nThreads = 100;
-    final int getsPerTask = 1000;
-    final int deltaRange = 10000;
-    final String key = ""key"";
-
-    final AtomicLong sum = new AtomicLong();
-    final AtomicLongMap<String> map = AtomicLongMap.create();
-
-    ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);
-    for (int i = 0; i < nTasks; i++) {
-      @SuppressWarnings(""unused"") // go/futurereturn-lsc
-      Future<?> possiblyIgnoredError =
-          threadPool.submit(
-              new Runnable() {
-                @Override
-                public void run() {
-                  int threadSum = 0;
-                  for (int j = 0; j < getsPerTask; j++) {
-                    long delta = random.nextInt(deltaRange);
-                    int behavior = random.nextInt(10);
-                    switch (behavior) {
-                      case 0:
-                        map.incrementAndGet(key);
-                        threadSum++;
-                        break;
-                      case 1:
-                        map.decrementAndGet(key);
-                        threadSum--;
-                        break;
-                      case 2:
-                        map.addAndGet(key, delta);
-                        threadSum += delta;
-                        break;
-                      case 3:
-                        map.getAndIncrement(key);
-                        threadSum++;
-                        break;
-                      case 4:
-                        map.getAndDecrement(key);
-                        threadSum--;
-                        break;
-                      case 5:
-                        map.getAndAdd(key, delta);
-                        threadSum += delta;
-                        break;
-                      case 6:
-                        long oldValue = map.put(key, delta);
-                        threadSum += delta - oldValue;
-                        break;
-                      case 7:
-                        oldValue = map.get(key);
-                        if (map.replace(key, oldValue, delta)) {
-                          threadSum += delta - oldValue;
-                        }
-                        break;
-                      case 8:
-                        oldValue = map.remove(key);
-                        threadSum -= oldValue;
-                        break;
-                      case 9:
-                        oldValue = map.get(key);
-                        if (map.remove(key, oldValue)) {
-                          threadSum -= oldValue;
-                        }
-                        break;
-                      default:
-                        throw new AssertionError();
-                    }
-                  }
-                  sum.addAndGet(threadSum);
-                }
-              });
-    }
-
-    threadPool.shutdown();
-    assertTrue(threadPool.awaitTermination(300, TimeUnit.SECONDS));
-
-    assertEquals(sum.get(), map.get(key));
-  }
 }, @@ -608,7 +608,7 @@ public void testTransitionRace() throws TimeoutException {
       }
       ServiceManager manager = new ServiceManager(services);
       manager.startAsync().awaitHealthy();
-      manager.stopAsync().awaitStopped(1, TimeUnit.SECONDS);
+      manager.stopAsync().awaitStopped(10, TimeUnit.SECONDS);
     }
   }
 , @@ -38,7 +38,7 @@
 public class SimpleTimeLimiterTest extends TestCase {
 
   private static final long DELAY_MS = 50;
-  private static final long ENOUGH_MS = 500;
+  private static final long ENOUGH_MS = 10000;
   private static final long NOT_ENOUGH_MS = 5;
 
   private static final String GOOD_CALLABLE_RESULT = ""good callable result"";, @@ -97,7 +97,7 @@ public void testRegularFutureInterrupted() throws ExecutionException {
 
     assertFalse(Thread.interrupted());
     try {
-      delayedFuture.get(10000, TimeUnit.MILLISECONDS);
+      delayedFuture.get(20000, TimeUnit.MILLISECONDS);
       fail(""expected to be interrupted"");
     } catch (InterruptedException expected) {
     } catch (TimeoutException e) {, @@ -42,7 +42,7 @@
  */
 public class AbstractServiceTest extends TestCase {
 
-  private static final long LONG_TIMEOUT_MILLIS = 2500;
+  private static final long LONG_TIMEOUT_MILLIS = 10000;
   private Thread executionThread;
   private Throwable thrownByExecutionThread;
 , @@ -25,11 +25,6 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
 import junit.framework.TestCase;
 
 /**
@@ -42,7 +37,7 @@
   private static final int ITERATIONS = 100;
   private static final int MAX_ADDEND = 100;
 
-  private Random random = new Random(301);
+  private final Random random = new Random(301);
 
   @GwtIncompatible // NullPointerTester
   public void testNulls() {
@@ -578,87 +573,4 @@ public void testSerialization() {
     AtomicLongMap<String> reserialized = SerializableTester.reserialize(map);
     assertEquals(map.asMap(), reserialized.asMap());
   }
-
-  @GwtIncompatible // threads
-  public void testModify_basher() throws InterruptedException {
-    int nTasks = 3000;
-    int nThreads = 100;
-    final int getsPerTask = 1000;
-    final int deltaRange = 10000;
-    final String key = ""key"";
-
-    final AtomicLong sum = new AtomicLong();
-    final AtomicLongMap<String> map = AtomicLongMap.create();
-
-    ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);
-    for (int i = 0; i < nTasks; i++) {
-      @SuppressWarnings(""unused"") // go/futurereturn-lsc
-      Future<?> possiblyIgnoredError =
-          threadPool.submit(
-              new Runnable() {
-                @Override
-                public void run() {
-                  int threadSum = 0;
-                  for (int j = 0; j < getsPerTask; j++) {
-                    long delta = random.nextInt(deltaRange);
-                    int behavior = random.nextInt(10);
-                    switch (behavior) {
-                      case 0:
-                        map.incrementAndGet(key);
-                        threadSum++;
-                        break;
-                      case 1:
-                        map.decrementAndGet(key);
-                        threadSum--;
-                        break;
-                      case 2:
-                        map.addAndGet(key, delta);
-                        threadSum += delta;
-                        break;
-                      case 3:
-                        map.getAndIncrement(key);
-                        threadSum++;
-                        break;
-                      case 4:
-                        map.getAndDecrement(key);
-                        threadSum--;
-                        break;
-                      case 5:
-                        map.getAndAdd(key, delta);
-                        threadSum += delta;
-                        break;
-                      case 6:
-                        long oldValue = map.put(key, delta);
-                        threadSum += delta - oldValue;
-                        break;
-                      case 7:
-                        oldValue = map.get(key);
-                        if (map.replace(key, oldValue, delta)) {
-                          threadSum += delta - oldValue;
-                        }
-                        break;
-                      case 8:
-                        oldValue = map.remove(key);
-                        threadSum -= oldValue;
-                        break;
-                      case 9:
-                        oldValue = map.get(key);
-                        if (map.remove(key, oldValue)) {
-                          threadSum -= oldValue;
-                        }
-                        break;
-                      default:
-                        throw new AssertionError();
-                    }
-                  }
-                  sum.addAndGet(threadSum);
-                }
-              });
-    }
-
-    threadPool.shutdown();
-    assertTrue(threadPool.awaitTermination(300, TimeUnit.SECONDS));
-
-    assertEquals(sum.get(), map.get(key));
-  }
 }, @@ -608,7 +608,7 @@ public void testTransitionRace() throws TimeoutException {
       }
       ServiceManager manager = new ServiceManager(services);
       manager.startAsync().awaitHealthy();
-      manager.stopAsync().awaitStopped(1, TimeUnit.SECONDS);
+      manager.stopAsync().awaitStopped(10, TimeUnit.SECONDS);
     }
   }
 , @@ -38,7 +38,7 @@
 public class SimpleTimeLimiterTest extends TestCase {
 
   private static final long DELAY_MS = 50;
-  private static final long ENOUGH_MS = 500;
+  private static final long ENOUGH_MS = 10000;
   private static final long NOT_ENOUGH_MS = 5;
 
   private static final String GOOD_CALLABLE_RESULT = ""good callable result"";, @@ -97,7 +97,7 @@ public void testRegularFutureInterrupted() throws ExecutionException {
 
     assertFalse(Thread.interrupted());
     try {
-      delayedFuture.get(10000, TimeUnit.MILLISECONDS);
+      delayedFuture.get(20000, TimeUnit.MILLISECONDS);
       fail(""expected to be interrupted"");
     } catch (InterruptedException expected) {
     } catch (TimeoutException e) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Combine ImmediateSuccessfulFuture into ImmediateFuture.

ImmediateFuture used to have other implementations, but we switched those to extend TrustedFuture instead.

d780cd5f2b0ccc2610c039c30c04e987771dd0a5

-------

<p> Rollback previous commit.

0812745bec6e345b232154d815ad242cbb4fda37

-------

<p> Roll forward previous rollback, but without making the type final.

4c984c649e1f4665a7dbee5f568cfa25def76727

-------

<p> Fix (and in one case, suppress) low-hanging rawtypes warnings.

It looks like at least some of these may once have been necessary for the Eclipse compiler (used by GWT). In fact, I had to revert one similar change because it broke a GWT build. I'm hoping that that means that the others are safe.

cabc402dbf3805f04e19ba9d72e7f8802ab6bb75

-------

<p> Increase various tests' timeouts.

25842ed29c2c13b949836082552c5fee0cdcb0d5",Moe Sync
3618,David P. Baker,"['android/guava/src/com/google/common/collect/ComputationException.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/MapMaker.java', 'guava/src/com/google/common/collect/ComputationException.java']","@@ -24,7 +24,15 @@
  *
  * @author Bob Lee
  * @since 2.0
+ * @deprecated This exception is no longer thrown by {@code com.google.common}. Previously, it was
+ *     thrown by {@link MapMaker} computing maps. When support for computing maps was removed from
+ *     {@code MapMaker}, it was added to {@code CacheBuilder}, which throws {@code
+ *     ExecutionException}, {@code UncheckedExecutionException}, and {@code ExecutionError}. Any
+ *     code that is still catching {@code ComputationException} may need to be updated to catch some
+ *     of those types instead. (Note that this type, though deprecated, is not planned to be removed
+ *     from Guava.)
  */
+@Deprecated
 @GwtCompatible
 public class ComputationException extends RuntimeException {
   /** Creates a new instance with the given cause. */, @@ -16,108 +16,18 @@
 
 package com.google.common.collect;
 
-import com.google.common.base.Function;
-import java.util.LinkedHashMap;
+import static com.google.common.base.Preconditions.checkArgument;
+
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 /**
- * MapMaker emulation. Since Javascript is single-threaded and have no references, this reduces to
- * the creation of expiring and computing maps.
+ * MapMaker emulation.
  *
  * @author Charles Fry
  */
 public final class MapMaker {
-
-  // TODO(fry,kak): ConcurrentHashMap never throws a CME when mutating the map during iteration, but
-  // this implementation (based on a LHM) does. This will all be replaced soon anyways, so leaving
-  // it as is for now.
-  private static class ComputingMap<K, V> extends LinkedHashMap<K, V>
-      implements ConcurrentMap<K, V> {
-    private final Function<? super K, ? extends V> computer;
-
-    ComputingMap(int initialCapacity) {
-      this(null, initialCapacity);
-    }
-
-    ComputingMap(Function<? super K, ? extends V> computer, int initialCapacity) {
-      super(initialCapacity, /* ignored loadFactor */ 0.75f, true);
-      this.computer = computer;
-    }
-
-    @Override
-    public V putIfAbsent(K key, V value) {
-      if (!containsKey(key)) {
-        return put(key, value);
-      } else {
-        return get(key);
-      }
-    }
-
-    @Override
-    public boolean remove(Object key, Object value) {
-      if (containsKey(key) && get(key).equals(value)) {
-        remove(key);
-        return true;
-      }
-      return false;
-    }
-
-    @Override
-    public boolean replace(K key, V oldValue, V newValue) {
-      if (containsKey(key) && get(key).equals(oldValue)) {
-        put(key, newValue);
-        return true;
-      }
-      return false;
-    }
-
-    @Override
-    public V replace(K key, V value) {
-      return containsKey(key) ? put(key, value) : null;
-    }
-
-    @Override
-    public V get(Object k) {
-      // from CustomConcurrentHashMap
-      V result = super.get(k);
-      if (result == null && computer != null) {
-        /*
-         * This cast isn't safe, but we can rely on the fact that K is almost always passed to
-         * Map.get(), and tools like IDEs and Findbugs can catch situations where this isn't the
-         * case.
-         *
-         * The alternative is to add an overloaded method, but the chances of a user calling get()
-         * instead of the new API and the risks inherent in adding a new API outweigh this little
-         * hole.
-         */
-        @SuppressWarnings(""unchecked"")
-        K key = (K) k;
-        result = compute(key);
-      }
-      return result;
-    }
-
-    private V compute(K key) {
-      // from MapMaker
-      V value;
-      try {
-        value = computer.apply(key);
-      } catch (Throwable t) {
-        throw new ComputationException(t);
-      }
-
-      if (value == null) {
-        String message = computer + "" returned null for key "" + key + ""."";
-        throw new NullPointerException(message);
-      }
-      put(key, value);
-      return value;
-    }
-  }
-
   private int initialCapacity = 16;
-  private boolean useCustomMap;
 
   public MapMaker() {}
 
@@ -130,21 +40,14 @@ public MapMaker initialCapacity(int initialCapacity) {
   }
 
   public MapMaker concurrencyLevel(int concurrencyLevel) {
-    if (concurrencyLevel < 1) {
-      throw new IllegalArgumentException(""GWT only supports a concurrency level of 1"");
-    }
+    checkArgument(
+        concurrencyLevel >= 1, ""concurrency level (%s) must be at least 1"", concurrencyLevel);
     // GWT technically only supports concurrencyLevel == 1, but we silently
     // ignore other positive values.
     return this;
   }
 
   public <K, V> ConcurrentMap<K, V> makeMap() {
-    return useCustomMap
-        ? new ComputingMap<K, V>(null, initialCapacity)
-        : new ConcurrentHashMap<K, V>(initialCapacity);
-  }
-
-  public <K, V> ConcurrentMap<K, V> makeComputingMap(Function<? super K, ? extends V> computer) {
-    return new ComputingMap<K, V>(computer, initialCapacity);
+    return new ConcurrentHashMap<K, V>(initialCapacity);
   }
 }, @@ -24,7 +24,15 @@
  *
  * @author Bob Lee
  * @since 2.0
+ * @deprecated This exception is no longer thrown by {@code com.google.common}. Previously, it was
+ *     thrown by {@link MapMaker} computing maps. When support for computing maps was removed from
+ *     {@code MapMaker}, it was added to {@code CacheBuilder}, which throws {@code
+ *     ExecutionException}, {@code UncheckedExecutionException}, and {@code ExecutionError}. Any
+ *     code that is still catching {@code ComputationException} may need to be updated to catch some
+ *     of those types instead. (Note that this type, though deprecated, is not planned to be removed
+ *     from Guava.)
  */
+@Deprecated
 @GwtCompatible
 public class ComputationException extends RuntimeException {
   /** Creates a new instance with the given cause. */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Export new AtomicLongMapBasherTest to open-source repo.

https://github.com/google/guava/pull/3605#discussion_r324303026

704c08989c9c2c21b4e2cb0ab285a7d84ee0fc3f

-------

<p> Add @LazyInit and @RetainedWith annotations to the lazily calculated ""entries"" field of ImmutableSetMultimap.

This field is lazily evaluated by entries() without holding a lock, but multiple concurrent calls to entries() will produce idempotent results at the cost of some performance.

996369d89362e0ec93f7dd6e9a6860aa08858c80

-------

<p> Let ListenableFuture implement thenable via a default interface method in J2CL.

This is a second attempt after problems in e0bac74571b81756c4acf767e3ad186b7473a4f8 were fixed.

44909d9d5fc5b394c710a6b8b0d6c3786c765af5

-------

<p> Add test for behavior described in #1900

7329a66694d59bb22e2589eb9a2f620c98a881f9

-------

<p> Undo test CL 9a50815df26be7416be0fac489e29feee7a3c220.

It produces a tiny diff between the common.base and common.collect copies of AbstractIterator.

c82f7916879a46539a1e53ac98dda90e9c5537b8

-------

<p> Add Splitter.splitToStream().

6c984121f74d5cea97ac1ffabfe98938bc7c96c4

-------

<p> Add comment explaining TABLE and MULTIPLIER in CharMatcher.Whitespace

Fixes #1661

5430b140cae37b078fd4dda9b1a57a025664cfe1

-------

<p> Rollback of adding Splitter.splitToStream().

*** Reason for rollback ***

My guess is that this change somehow upsets an allowed list of
one-definition violations.

3f49efe9f00a2ed9dd3bd1cde1d5d596833b7391

-------

<p> Rollback of change to let ListenableFuture implement thenable via a default interface method in J2CL.

38c9a029e6cc538bcc46b9ad23fe03a62739d433

-------

<p> Clean up leftovers from MapMaker.makeComputingMap:

- Remove makeComputingMap from the GWT emulation.
- Deprecate ComputationException.

0b93365c2440981c04a94f6e5596d3f723549ea3",Moe Sync
3621,David P. Baker,"['android/guava-testlib/src/com/google/common/collect/testing/testers/CollectionIteratorTester.java', 'guava-testlib/src/com/google/common/collect/testing/testers/CollectionIteratorTester.java']","@@ -19,9 +19,11 @@
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
 import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;
+import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.testing.AbstractCollectionTester;
@@ -66,6 +68,17 @@ public void testIterationOrdering() {
     assertEquals(""Different ordered iteration"", expected, iteratorElements);
   }
 
+  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
+  public void testIterator_nullElement() {
+    initCollectionWithNullElement();
+    List<E> iteratorElements = new ArrayList<E>();
+    for (E element : collection) { // uses iterator()
+      iteratorElements.add(element);
+    }
+    Helpers.assertEqualIgnoringOrder(asList(createArrayWithNullElement()), iteratorElements);
+  }
+
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
   @CollectionSize.Require(absent = ZERO)
   public void testIterator_removeAffectsBackingCollection() {, @@ -19,9 +19,11 @@
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static com.google.common.collect.testing.IteratorFeature.MODIFIABLE;
 import static com.google.common.collect.testing.IteratorFeature.UNMODIFIABLE;
+import static com.google.common.collect.testing.features.CollectionFeature.ALLOWS_NULL_VALUES;
 import static com.google.common.collect.testing.features.CollectionFeature.KNOWN_ORDER;
 import static com.google.common.collect.testing.features.CollectionFeature.SUPPORTS_ITERATOR_REMOVE;
 import static com.google.common.collect.testing.features.CollectionSize.ZERO;
+import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.testing.AbstractCollectionTester;
@@ -66,6 +68,17 @@ public void testIterationOrdering() {
     assertEquals(""Different ordered iteration"", expected, iteratorElements);
   }
 
+  @CollectionFeature.Require(ALLOWS_NULL_VALUES)
+  @CollectionSize.Require(absent = ZERO)
+  public void testIterator_nullElement() {
+    initCollectionWithNullElement();
+    List<E> iteratorElements = new ArrayList<E>();
+    for (E element : collection) { // uses iterator()
+      iteratorElements.add(element);
+    }
+    Helpers.assertEqualIgnoringOrder(asList(createArrayWithNullElement()), iteratorElements);
+  }
+
   @CollectionFeature.Require(SUPPORTS_ITERATOR_REMOVE)
   @CollectionSize.Require(absent = ZERO)
   public void testIterator_removeAffectsBackingCollection() {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Test iteration over a collection containing null.

f9675a07e0fa21ce705626cdcc95101b95f46531",Moe Sync
3623,David P. Baker,"['guava-gwt/test/com/google/common/base/SplitterTest_gwt.java', 'guava-tests/test/com/google/common/base/SplitterTest.java', 'guava/src/com/google/common/base/Splitter.java']","@@ -28,6 +28,11 @@ public void testCharacterSimpleSplitToList() throws Exception {
   testCase.testCharacterSimpleSplitToList();
 }
 
+public void testCharacterSimpleSplitToStream() throws Exception {
+  com.google.common.base.SplitterTest testCase = new com.google.common.base.SplitterTest();
+  testCase.testCharacterSimpleSplitToStream();
+}
+
 public void testCharacterSimpleSplitWithNoDelimiter() throws Exception {
   com.google.common.base.SplitterTest testCase = new com.google.common.base.SplitterTest();
   testCase.testCharacterSimpleSplitWithNoDelimiter();, @@ -16,6 +16,7 @@
 
 package com.google.common.base;
 
+import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -62,6 +63,12 @@ public void testCharacterSimpleSplitToList() {
     assertThat(letters).containsExactly(""a"", ""b"", ""c"").inOrder();
   }
 
+  public void testCharacterSimpleSplitToStream() {
+    String simple = ""a,b,c"";
+    List<String> letters = COMMA_SPLITTER.splitToStream(simple).collect(toImmutableList());
+    assertThat(letters).containsExactly(""a"", ""b"", ""c"").inOrder();
+  }
+
   public void testToString() {
     assertEquals(""[]"", COMMA_SPLITTER.split("""").toString());
     assertEquals(""[a, b, c]"", COMMA_SPLITTER.split(""a,b,c"").toString());, @@ -27,6 +27,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.regex.Pattern;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 /**
  * Extracts non-overlapping substrings from an input string, typically by recognizing appearances of
@@ -372,7 +374,7 @@ public Splitter trimResults(CharMatcher trimmer) {
   /**
    * Splits {@code sequence} into string components and makes them available through an {@link
    * Iterator}, which may be lazily evaluated. If you want an eagerly computed {@link List}, use
-   * {@link #splitToList(CharSequence)}.
+   * {@link #splitToList(CharSequence)}. Java 8 users may prefer {@link #splitToStream} instead.
    *
    * @param sequence the sequence of characters to split
    * @return an iteration over the segments split from the parameter
@@ -421,6 +423,21 @@ public String toString() {
     return Collections.unmodifiableList(result);
   }
 
+  /**
+   * Splits {@code sequence} into string components and makes them available through an {@link
+   * Stream}, which may be lazily evaluated. If you want an eagerly computed {@link List}, use
+   * {@link #splitToList(CharSequence)}.
+   *
+   * @param sequence the sequence of characters to split
+   * @return a stream over the segments split from the parameter
+   * @since NEXT
+   */
+  @Beta
+  public Stream<String> splitToStream(CharSequence sequence) {
+    // Can't use Streams.stream() from base
+    return StreamSupport.stream(split(sequence).spliterator(), false);
+  }
+
   /**
    * Returns a {@code MapSplitter} which splits entries based on this splitter, and splits entries
    * into keys and values using the specified separator., ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> s/a/an/

e2564c321bd3bc71cbb77a6af7ccac1be30e9b46

-------

<p> Add Splitter.splitToStream().

61affd0d3d70fdadf90100d54e1a83425b717f56",Moe Sync
3627,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava/src/com/google/common/util/concurrent/Futures.java']","@@ -35,6 +35,7 @@
 import static com.google.common.util.concurrent.Futures.lazyTransform;
 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
 import static com.google.common.util.concurrent.Futures.scheduleAsync;
+import static com.google.common.util.concurrent.Futures.submit;
 import static com.google.common.util.concurrent.Futures.submitAsync;
 import static com.google.common.util.concurrent.Futures.successfulAsList;
 import static com.google.common.util.concurrent.Futures.transform;
@@ -1937,6 +1938,82 @@ public void testSubmitAsync_asyncCallable_returnsInterruptedFuture() throws Inte
     assertThat(Thread.interrupted()).isFalse();
   }
 
+  public void testSubmit_callable_returnsValue() throws Exception {
+    Callable<Integer> callable =
+        new Callable<Integer>() {
+          @Override
+          public Integer call() {
+            return 42;
+          }
+        };
+    ListenableFuture<Integer> future = submit(callable, directExecutor());
+    assertThat(future.isDone()).isTrue();
+    assertThat(getDone(future)).isEqualTo(42);
+  }
+
+  public void testSubmit_callable_throwsException() {
+    final Exception exception = new Exception(""Exception for testing"");
+    Callable<Integer> callable =
+        new Callable<Integer>() {
+          @Override
+          public Integer call() throws Exception {
+            throw exception;
+          }
+        };
+    ListenableFuture<Integer> future = submit(callable, directExecutor());
+    try {
+      getDone(future);
+      fail();
+    } catch (ExecutionException expected) {
+      assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
+    }
+  }
+
+  public void testSubmit_runnable_completesAfterRun() throws Exception {
+    final List<Runnable> pendingRunnables = newArrayList();
+    final List<Runnable> executedRunnables = newArrayList();
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            executedRunnables.add(this);
+          }
+        };
+    Executor executor =
+        new Executor() {
+          @Override
+          public void execute(Runnable runnable) {
+            pendingRunnables.add(runnable);
+          }
+        };
+    ListenableFuture<Void> future = submit(runnable, executor);
+    assertThat(future.isDone()).isFalse();
+    assertThat(executedRunnables).isEmpty();
+    assertThat(pendingRunnables).hasSize(1);
+    pendingRunnables.remove(0).run();
+    assertThat(future.isDone()).isTrue();
+    assertThat(executedRunnables).containsExactly(runnable);
+    assertThat(pendingRunnables).isEmpty();
+  }
+
+  public void testSubmit_runnable_throwsException() throws Exception {
+    final RuntimeException exception = new RuntimeException(""Exception for testing"");
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            throw exception;
+          }
+        };
+    ListenableFuture<Void> future = submit(runnable, directExecutor());
+    try {
+      getDone(future);
+      fail();
+    } catch (ExecutionException expected) {
+      assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
+    }
+  }
+
   @GwtIncompatible // threads
 
   public void testScheduleAsync_asyncCallable_error() throws InterruptedException {, @@ -154,6 +154,33 @@ private Futures() {}
     return new ImmediateCancelledFuture<V>();
   }
 
+  /**
+   * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.
+   *
+   * @throws RejectedExecutionException if the task cannot be scheduled for execution
+   * @since NEXT
+   */
+  @Beta
+  public static <O> ListenableFuture<O> submit(Callable<O> callable, Executor executor) {
+    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
+    executor.execute(task);
+    return task;
+  }
+
+  /**
+   * Executes {@code runnable} on the specified {@code executor}, returning a {@code Future} that
+   * will complete after execution.
+   *
+   * @throws RejectedExecutionException if the task cannot be scheduled for execution
+   * @since NEXT
+   */
+  @Beta
+  public static ListenableFuture<Void> submit(Runnable runnable, Executor executor) {
+    TrustedListenableFutureTask<Void> task = TrustedListenableFutureTask.create(runnable, null);
+    executor.execute(task);
+    return task;
+  }
+
   /**
    * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.
    *, @@ -1908,6 +1908,114 @@ public void testSubmitAsync_asyncCallable_nullInsteadOfFuture() throws Exception
   }
 }
 
+public void testSubmit_callable_returnsValue() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testSubmit_callable_returnsValue();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
+public void testSubmit_callable_throwsException() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testSubmit_callable_throwsException();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
+public void testSubmit_runnable_completesAfterRun() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testSubmit_runnable_completesAfterRun();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
+public void testSubmit_runnable_throwsException() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testSubmit_runnable_throwsException();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
 public void testSuccessfulAsList() throws Exception {
   com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
   testCase.setUp();, @@ -35,6 +35,7 @@
 import static com.google.common.util.concurrent.Futures.lazyTransform;
 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
 import static com.google.common.util.concurrent.Futures.scheduleAsync;
+import static com.google.common.util.concurrent.Futures.submit;
 import static com.google.common.util.concurrent.Futures.submitAsync;
 import static com.google.common.util.concurrent.Futures.successfulAsList;
 import static com.google.common.util.concurrent.Futures.transform;
@@ -1937,6 +1938,82 @@ public void testSubmitAsync_asyncCallable_returnsInterruptedFuture() throws Inte
     assertThat(Thread.interrupted()).isFalse();
   }
 
+  public void testSubmit_callable_returnsValue() throws Exception {
+    Callable<Integer> callable =
+        new Callable<Integer>() {
+          @Override
+          public Integer call() {
+            return 42;
+          }
+        };
+    ListenableFuture<Integer> future = submit(callable, directExecutor());
+    assertThat(future.isDone()).isTrue();
+    assertThat(getDone(future)).isEqualTo(42);
+  }
+
+  public void testSubmit_callable_throwsException() {
+    final Exception exception = new Exception(""Exception for testing"");
+    Callable<Integer> callable =
+        new Callable<Integer>() {
+          @Override
+          public Integer call() throws Exception {
+            throw exception;
+          }
+        };
+    ListenableFuture<Integer> future = submit(callable, directExecutor());
+    try {
+      getDone(future);
+      fail();
+    } catch (ExecutionException expected) {
+      assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
+    }
+  }
+
+  public void testSubmit_runnable_completesAfterRun() throws Exception {
+    final List<Runnable> pendingRunnables = newArrayList();
+    final List<Runnable> executedRunnables = newArrayList();
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            executedRunnables.add(this);
+          }
+        };
+    Executor executor =
+        new Executor() {
+          @Override
+          public void execute(Runnable runnable) {
+            pendingRunnables.add(runnable);
+          }
+        };
+    ListenableFuture<Void> future = submit(runnable, executor);
+    assertThat(future.isDone()).isFalse();
+    assertThat(executedRunnables).isEmpty();
+    assertThat(pendingRunnables).hasSize(1);
+    pendingRunnables.remove(0).run();
+    assertThat(future.isDone()).isTrue();
+    assertThat(executedRunnables).containsExactly(runnable);
+    assertThat(pendingRunnables).isEmpty();
+  }
+
+  public void testSubmit_runnable_throwsException() throws Exception {
+    final RuntimeException exception = new RuntimeException(""Exception for testing"");
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            throw exception;
+          }
+        };
+    ListenableFuture<Void> future = submit(runnable, directExecutor());
+    try {
+      getDone(future);
+      fail();
+    } catch (ExecutionException expected) {
+      assertThat(expected).hasCauseThat().isSameInstanceAs(exception);
+    }
+  }
+
   @GwtIncompatible // threads
 
   public void testScheduleAsync_asyncCallable_error() throws InterruptedException {, @@ -156,6 +156,33 @@ private Futures() {}
     return new ImmediateCancelledFuture<V>();
   }
 
+  /**
+   * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.
+   *
+   * @throws RejectedExecutionException if the task cannot be scheduled for execution
+   * @since NEXT
+   */
+  @Beta
+  public static <O> ListenableFuture<O> submit(Callable<O> callable, Executor executor) {
+    TrustedListenableFutureTask<O> task = TrustedListenableFutureTask.create(callable);
+    executor.execute(task);
+    return task;
+  }
+
+  /**
+   * Executes {@code runnable} on the specified {@code executor}, returning a {@code Future} that
+   * will complete after execution.
+   *
+   * @throws RejectedExecutionException if the task cannot be scheduled for execution
+   * @since NEXT
+   */
+  @Beta
+  public static ListenableFuture<Void> submit(Runnable runnable, Executor executor) {
+    TrustedListenableFutureTask<Void> task = TrustedListenableFutureTask.create(runnable, null);
+    executor.execute(task);
+    return task;
+  }
+
   /**
    * Executes {@code callable} on the specified {@code executor}, returning a {@code Future}.
    *, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add Futures.submit().

RELNOTES=`util.concurrent`: Added `Futures.submit()`

479c41dab94cbc6a6a1bb952c56a90b89f793ecc",Moe Sync
3629,Chris Povirk,"['android/pom.xml', 'pom.xml']","@@ -264,7 +264,7 @@
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>2.3.2</version>
+        <version>2.3.3</version>
       </dependency>
       <dependency>
         <groupId>com.google.j2objc</groupId>, @@ -260,7 +260,7 @@
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>2.3.2</version>
+        <version>2.3.3</version>
       </dependency>
       <dependency>
         <groupId>com.google.j2objc</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update errorprone to 2.3.3

Fixes #3628

c24688d4f69cc00d11de6d183c28bdf0a86a032a",Moe Sync
3630,Chris Povirk,"['android/guava-tests/test/com/google/common/net/MediaTypeTest.java', 'android/guava/src/com/google/common/net/MediaType.java', 'guava-gwt/test/com/google/common/net/MediaTypeTest_gwt.java', 'guava-tests/test/com/google/common/net/MediaTypeTest.java', 'guava/src/com/google/common/net/MediaType.java']","@@ -148,6 +148,22 @@ public void testCreate_wildcardTypeDeclaredSubtype() {
     }
   }
 
+  public void testCreate_nonAsciiParameter() {
+    try {
+      MediaType.create(""…"", ""a"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testCreate_nonAsciiParameterValue() {
+    try {
+      MediaType.create(""a"", ""…"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testCreateApplicationType() {
     MediaType newType = MediaType.createApplicationType(""yams"");
     assertEquals(""application"", newType.type());
@@ -225,6 +241,26 @@ public void testWithParameters_invalidAttribute() {
     }
   }
 
+  public void testWithParameters_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    ImmutableListMultimap<String, String> parameters = ImmutableListMultimap.of(""…"", ""a"");
+    try {
+      mediaType.withParameters(parameters);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParameters_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    ImmutableListMultimap<String, String> parameters = ImmutableListMultimap.of(""a"", ""…"");
+    try {
+      mediaType.withParameters(parameters);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParameter() {
     assertEquals(
         MediaType.parse(""text/plain; a=1""), MediaType.parse(""text/plain"").withParameter(""a"", ""1""));
@@ -248,6 +284,24 @@ public void testWithParameter_invalidAttribute() {
     }
   }
 
+  public void testWithParameter_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameter(""…"", ""a"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParameter_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameter(""a"", ""…"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParametersIterable() {
     assertEquals(
         MediaType.parse(""text/plain""),
@@ -275,6 +329,24 @@ public void testWithParametersIterable_invalidAttribute() {
     }
   }
 
+  public void testWithParametersIterable_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameters(""…"", ImmutableSet.of(""a""));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParametersIterable_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameters(""a"", ImmutableSet.of(""…""));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParametersIterable_nullValue() {
     MediaType mediaType = MediaType.parse(""text/plain"");
     try {
@@ -507,10 +579,13 @@ public void testNullPointer() {
   public void testToString() {
     assertEquals(""text/plain"", MediaType.create(""text"", ""plain"").toString());
     assertEquals(
-        ""text/plain; something=\""cr@zy\""; something-else=\""crazy with spaces\"""",
+        ""text/plain; something=\""cr@zy\""; something-else=\""crazy with spaces\"";""
+            + "" and-another-thing=\""\""; normal-thing=foo"",
         MediaType.create(""text"", ""plain"")
             .withParameter(""something"", ""cr@zy"")
             .withParameter(""something-else"", ""crazy with spaces"")
+            .withParameter(""and-another-thing"", """")
+            .withParameter(""normal-thing"", ""foo"")
             .toString());
   }
 }, @@ -55,8 +55,8 @@
  * type or subtype value. A media type may not have wildcard type with a declared subtype. The
  * {@code *} character has no special meaning as part of a parameter. All values for type, subtype,
  * parameter attributes or parameter values must be valid according to RFCs <a
- * href=""http://www.ietf.org/rfc/rfc2045.txt"">2045</a> and <a
- * href=""http://www.ietf.org/rfc/rfc2046.txt"">2046</a>.
+ * href=""https://tools.ietf.org/html/rfc2045"">2045</a> and <a
+ * href=""https://tools.ietf.org/html/rfc2046"">2046</a>.
  *
  * <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)
  * are normalized to lowercase. The value of the {@code charset} parameter is normalized to
@@ -941,6 +941,8 @@ private static String normalizeToken(String token) {
   }
 
   private static String normalizeParameterValue(String attribute, String value) {
+    checkNotNull(value); // for GWT
+    checkArgument(ascii().matchesAllOf(value), ""parameter values must be ASCII: %s"", value);
     return CHARSET_ATTRIBUTE.equals(attribute) ? Ascii.toLowerCase(value) : value;
   }
 
@@ -1088,7 +1090,9 @@ private String computeToString() {
               new Function<String, String>() {
                 @Override
                 public String apply(String value) {
-                  return TOKEN_MATCHER.matchesAllOf(value) ? value : escapeAndQuote(value);
+                  return (TOKEN_MATCHER.matchesAllOf(value) && !value.isEmpty())
+                      ? value
+                      : escapeAndQuote(value);
                 }
               });
       PARAMETER_JOINER.appendTo(builder, quotedParameters.entries());, @@ -53,6 +53,16 @@ public void testCreate_invalidType() throws Exception {
   testCase.testCreate_invalidType();
 }
 
+public void testCreate_nonAsciiParameter() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testCreate_nonAsciiParameter();
+}
+
+public void testCreate_nonAsciiParameterValue() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testCreate_nonAsciiParameterValue();
+}
+
 public void testCreate_wildcardTypeDeclaredSubtype() throws Exception {
   com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
   testCase.testCreate_wildcardTypeDeclaredSubtype();
@@ -138,6 +148,16 @@ public void testWithParameter_invalidAttribute() throws Exception {
   testCase.testWithParameter_invalidAttribute();
 }
 
+public void testWithParameter_nonAsciiParameter() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParameter_nonAsciiParameter();
+}
+
+public void testWithParameter_nonAsciiParameterValue() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParameter_nonAsciiParameterValue();
+}
+
 public void testWithParameters() throws Exception {
   com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
   testCase.testWithParameters();
@@ -153,6 +173,16 @@ public void testWithParametersIterable_invalidAttribute() throws Exception {
   testCase.testWithParametersIterable_invalidAttribute();
 }
 
+public void testWithParametersIterable_nonAsciiParameter() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParametersIterable_nonAsciiParameter();
+}
+
+public void testWithParametersIterable_nonAsciiParameterValue() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParametersIterable_nonAsciiParameterValue();
+}
+
 public void testWithParametersIterable_nullValue() throws Exception {
   com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
   testCase.testWithParametersIterable_nullValue();
@@ -163,6 +193,16 @@ public void testWithParameters_invalidAttribute() throws Exception {
   testCase.testWithParameters_invalidAttribute();
 }
 
+public void testWithParameters_nonAsciiParameter() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParameters_nonAsciiParameter();
+}
+
+public void testWithParameters_nonAsciiParameterValue() throws Exception {
+  com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
+  testCase.testWithParameters_nonAsciiParameterValue();
+}
+
 public void testWithoutParameters() throws Exception {
   com.google.common.net.MediaTypeTest testCase = new com.google.common.net.MediaTypeTest();
   testCase.testWithoutParameters();, @@ -148,6 +148,22 @@ public void testCreate_wildcardTypeDeclaredSubtype() {
     }
   }
 
+  public void testCreate_nonAsciiParameter() {
+    try {
+      MediaType.create(""…"", ""a"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testCreate_nonAsciiParameterValue() {
+    try {
+      MediaType.create(""a"", ""…"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testCreateApplicationType() {
     MediaType newType = MediaType.createApplicationType(""yams"");
     assertEquals(""application"", newType.type());
@@ -225,6 +241,26 @@ public void testWithParameters_invalidAttribute() {
     }
   }
 
+  public void testWithParameters_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    ImmutableListMultimap<String, String> parameters = ImmutableListMultimap.of(""…"", ""a"");
+    try {
+      mediaType.withParameters(parameters);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParameters_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    ImmutableListMultimap<String, String> parameters = ImmutableListMultimap.of(""a"", ""…"");
+    try {
+      mediaType.withParameters(parameters);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParameter() {
     assertEquals(
         MediaType.parse(""text/plain; a=1""), MediaType.parse(""text/plain"").withParameter(""a"", ""1""));
@@ -248,6 +284,24 @@ public void testWithParameter_invalidAttribute() {
     }
   }
 
+  public void testWithParameter_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameter(""…"", ""a"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParameter_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameter(""a"", ""…"");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParametersIterable() {
     assertEquals(
         MediaType.parse(""text/plain""),
@@ -275,6 +329,24 @@ public void testWithParametersIterable_invalidAttribute() {
     }
   }
 
+  public void testWithParametersIterable_nonAsciiParameter() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameters(""…"", ImmutableSet.of(""a""));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  public void testWithParametersIterable_nonAsciiParameterValue() {
+    MediaType mediaType = MediaType.parse(""text/plain"");
+    try {
+      mediaType.withParameters(""a"", ImmutableSet.of(""…""));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   public void testWithParametersIterable_nullValue() {
     MediaType mediaType = MediaType.parse(""text/plain"");
     try {
@@ -507,10 +579,13 @@ public void testNullPointer() {
   public void testToString() {
     assertEquals(""text/plain"", MediaType.create(""text"", ""plain"").toString());
     assertEquals(
-        ""text/plain; something=\""cr@zy\""; something-else=\""crazy with spaces\"""",
+        ""text/plain; something=\""cr@zy\""; something-else=\""crazy with spaces\"";""
+            + "" and-another-thing=\""\""; normal-thing=foo"",
         MediaType.create(""text"", ""plain"")
             .withParameter(""something"", ""cr@zy"")
             .withParameter(""something-else"", ""crazy with spaces"")
+            .withParameter(""and-another-thing"", """")
+            .withParameter(""normal-thing"", ""foo"")
             .toString());
   }
 }, @@ -55,8 +55,8 @@
  * type or subtype value. A media type may not have wildcard type with a declared subtype. The
  * {@code *} character has no special meaning as part of a parameter. All values for type, subtype,
  * parameter attributes or parameter values must be valid according to RFCs <a
- * href=""http://www.ietf.org/rfc/rfc2045.txt"">2045</a> and <a
- * href=""http://www.ietf.org/rfc/rfc2046.txt"">2046</a>.
+ * href=""https://tools.ietf.org/html/rfc2045"">2045</a> and <a
+ * href=""https://tools.ietf.org/html/rfc2046"">2046</a>.
  *
  * <p>All portions of the media type that are case-insensitive (type, subtype, parameter attributes)
  * are normalized to lowercase. The value of the {@code charset} parameter is normalized to
@@ -941,6 +941,8 @@ private static String normalizeToken(String token) {
   }
 
   private static String normalizeParameterValue(String attribute, String value) {
+    checkNotNull(value); // for GWT
+    checkArgument(ascii().matchesAllOf(value), ""parameter values must be ASCII: %s"", value);
     return CHARSET_ATTRIBUTE.equals(attribute) ? Ascii.toLowerCase(value) : value;
   }
 
@@ -1088,7 +1090,9 @@ private String computeToString() {
               new Function<String, String>() {
                 @Override
                 public String apply(String value) {
-                  return TOKEN_MATCHER.matchesAllOf(value) ? value : escapeAndQuote(value);
+                  return (TOKEN_MATCHER.matchesAllOf(value) && !value.isEmpty())
+                      ? value
+                      : escapeAndQuote(value);
                 }
               });
       PARAMETER_JOINER.appendTo(builder, quotedParameters.entries());, ",NaN,MOE sync
3634,Chris Povirk,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -266,6 +266,12 @@ private ReferrerPolicyValues() {}
    * @since 20.0
    */
   public static final String X_WEBKIT_CSP_REPORT_ONLY = ""X-WebKit-CSP-Report-Only"";
+  /**
+   * The HTTP Cross-Origin-Opener-Policy header field name.
+   *
+   * @since NEXT
+   */
+  public static final String CROSS_ORIGIN_OPENER_POLICY = ""Cross-Origin-Opener-Policy"";
   /** The HTTP {@code ETag} header field name. */
   public static final String ETAG = ""ETag"";
   /** The HTTP {@code Expires} header field name. */, @@ -266,6 +266,12 @@ private ReferrerPolicyValues() {}
    * @since 20.0
    */
   public static final String X_WEBKIT_CSP_REPORT_ONLY = ""X-WebKit-CSP-Report-Only"";
+  /**
+   * The HTTP Cross-Origin-Opener-Policy header field name.
+   *
+   * @since NEXT
+   */
+  public static final String CROSS_ORIGIN_OPENER_POLICY = ""Cross-Origin-Opener-Policy"";
   /** The HTTP {@code ETag} header field name. */
   public static final String ETAG = ""ETag"";
   /** The HTTP {@code Expires} header field name. */, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add missing @since 20.0.

52ba7eb195ad4c1f8095d99216610df39ce4e644

-------

<p> Add constant for the Cross-Origin-Opener-Policy header.

[]

RELNOTES=Adds constant for the Cross-Origin-Opener-Policy header.

aa77f3ce06cfb78c8ecea8d97c8b0d1beefe2466",Moe Sync
3635,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/Callables.java', 'android/guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'guava-gwt/test/com/google/common/util/concurrent/testModule.gwt.xml', 'guava/src/com/google/common/util/concurrent/Callables.java', 'guava/src/com/google/common/util/concurrent/MoreExecutors.java']","@@ -129,9 +129,10 @@ public void run() {
   /** Tries to set name of the given {@link Thread}, returns true if successful. */
   @GwtIncompatible // threads
   private static boolean trySetName(final String threadName, Thread currentThread) {
-    // In AppEngine, this will always fail. Should we test for that explicitly using
-    // MoreExecutors.isAppEngine? More generally, is there a way to see if we have the modifyThread
-    // permission without catching an exception?
+    /*
+     * setName should usually succeed, but the security manager can prohibit it. Is there a way to
+     * see if we have the modifyThread permission without catching an exception?
+     */
     try {
       currentThread.setName(threadName);
       return true;, @@ -739,15 +739,17 @@ public void run() {
   /**
    * Returns a default thread factory used to create new threads.
    *
-   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,
-   * returns {@link Executors#defaultThreadFactory()}.
+   * <p>When running on AppEngine with access to <a
+   * href=""https://cloud.google.com/appengine/docs/standard/java/javadoc/"">AppEngine legacy
+   * APIs</a>, this method returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,
+   * it returns {@link Executors#defaultThreadFactory()}.
    *
    * @since 14.0
    */
   @Beta
   @GwtIncompatible // concurrency
   public static ThreadFactory platformThreadFactory() {
-    if (!isAppEngine()) {
+    if (!isAppEngineWithApiClasses()) {
       return Executors.defaultThreadFactory();
     }
     try {
@@ -772,10 +774,15 @@ public static ThreadFactory platformThreadFactory() {
   }
 
   @GwtIncompatible // TODO
-  private static boolean isAppEngine() {
+  private static boolean isAppEngineWithApiClasses() {
     if (System.getProperty(""com.google.appengine.runtime.environment"") == null) {
       return false;
     }
+    try {
+      Class.forName(""com.google.appengine.api.utils.SystemProperty"");
+    } catch (ClassNotFoundException e) {
+      return false;
+    }
     try {
       // If the current environment is null, we're not inside AppEngine.
       return Class.forName(""com.google.apphosting.api.ApiProxy"")
@@ -833,10 +840,6 @@ static Thread newThread(String name, Runnable runnable) {
   static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {
     checkNotNull(executor);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try
-      return executor;
-    }
     return new Executor() {
       @Override
       public void execute(Runnable command) {
@@ -862,10 +865,6 @@ static ExecutorService renamingDecorator(
       final ExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try.
-      return service;
-    }
     return new WrappingExecutorService(service) {
       @Override
       protected <T> Callable<T> wrapTask(Callable<T> callable) {
@@ -896,10 +895,6 @@ static ScheduledExecutorService renamingDecorator(
       final ScheduledExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try.
-      return service;
-    }
     return new WrappingScheduledExecutorService(service) {
       @Override
       protected <T> Callable<T> wrapTask(Callable<T> callable) {, @@ -9,6 +9,7 @@
   <inherits name=""com.google.common.testing.Testing""/>
   <inherits name=""com.google.common.util.concurrent.Concurrent""/>
   <inherits name=""com.google.common.truth.Truth""/>
+  <inherits name=""activation.Activation""/>
   <entry-point class=""com.google.common.util.concurrent.TestModuleEntryPoint""/>
    
   <source path=""""/>, @@ -129,9 +129,10 @@ public void run() {
   /** Tries to set name of the given {@link Thread}, returns true if successful. */
   @GwtIncompatible // threads
   private static boolean trySetName(final String threadName, Thread currentThread) {
-    // In AppEngine, this will always fail. Should we test for that explicitly using
-    // MoreExecutors.isAppEngine? More generally, is there a way to see if we have the modifyThread
-    // permission without catching an exception?
+    /*
+     * setName should usually succeed, but the security manager can prohibit it. Is there a way to
+     * see if we have the modifyThread permission without catching an exception?
+     */
     try {
       currentThread.setName(threadName);
       return true;, @@ -814,15 +814,17 @@ public void run() {
   /**
    * Returns a default thread factory used to create new threads.
    *
-   * <p>On AppEngine, returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,
-   * returns {@link Executors#defaultThreadFactory()}.
+   * <p>When running on AppEngine with access to <a
+   * href=""https://cloud.google.com/appengine/docs/standard/java/javadoc/"">AppEngine legacy
+   * APIs</a>, this method returns {@code ThreadManager.currentRequestThreadFactory()}. Otherwise,
+   * it returns {@link Executors#defaultThreadFactory()}.
    *
    * @since 14.0
    */
   @Beta
   @GwtIncompatible // concurrency
   public static ThreadFactory platformThreadFactory() {
-    if (!isAppEngine()) {
+    if (!isAppEngineWithApiClasses()) {
       return Executors.defaultThreadFactory();
     }
     try {
@@ -847,10 +849,15 @@ public static ThreadFactory platformThreadFactory() {
   }
 
   @GwtIncompatible // TODO
-  private static boolean isAppEngine() {
+  private static boolean isAppEngineWithApiClasses() {
     if (System.getProperty(""com.google.appengine.runtime.environment"") == null) {
       return false;
     }
+    try {
+      Class.forName(""com.google.appengine.api.utils.SystemProperty"");
+    } catch (ClassNotFoundException e) {
+      return false;
+    }
     try {
       // If the current environment is null, we're not inside AppEngine.
       return Class.forName(""com.google.apphosting.api.ApiProxy"")
@@ -908,10 +915,6 @@ static Thread newThread(String name, Runnable runnable) {
   static Executor renamingDecorator(final Executor executor, final Supplier<String> nameSupplier) {
     checkNotNull(executor);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try
-      return executor;
-    }
     return new Executor() {
       @Override
       public void execute(Runnable command) {
@@ -937,10 +940,6 @@ static ExecutorService renamingDecorator(
       final ExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try.
-      return service;
-    }
     return new WrappingExecutorService(service) {
       @Override
       protected <T> Callable<T> wrapTask(Callable<T> callable) {
@@ -971,10 +970,6 @@ static ScheduledExecutorService renamingDecorator(
       final ScheduledExecutorService service, final Supplier<String> nameSupplier) {
     checkNotNull(service);
     checkNotNull(nameSupplier);
-    if (isAppEngine()) {
-      // AppEngine doesn't support thread renaming, so don't even try.
-      return service;
-    }
     return new WrappingScheduledExecutorService(service) {
       @Override
       protected <T> Callable<T> wrapTask(Callable<T> callable) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Check the array indexes in Quantiles.ScaleAndIndexes is non empty.

Fixes #3210
Fixes #3211

823a432ddaa2d274b539e12ed2bb46e5be0658ee

-------

<p> Simplify some code.

Fixes #3580

e2362def3408478a4a74d24671aef39171a1e93f

-------

<p> Document the JDK 9+ alternative to `Iterators#forEnumeration`

Fixes #3382

e432be553038b4c67f22abb8c27f82ab6d480f3d

-------

<p> Add a MIME type MPEG-DASH (mpd files)

Fixes #2677

RELNOTES=`net`: Added the `MediaType` constant for MPEG-DASH.

579ccf6c0181097be7b895ec145f04502234ef0e

-------

<p> Fix the logic that decides whether to use currentRequestThreadFactory() under App Engine.

While there, also support thread renaming under App Engine.

Fixes https://github.com/google/guava/issues/3598
Relevant to https://github.com/google/guava/issues/3606
(also, the CL in which I experimented with https://github.com/google/guava/issues/3569 before backing it out)

7bd4b2351c1483f34e7192768b4f3e7a10447c33",Moe Sync
3636,Chris Povirk,"['android/guava-tests/test/com/google/common/math/QuantilesTest.java', 'android/guava/src/com/google/common/math/Quantiles.java', 'guava-tests/test/com/google/common/math/QuantilesTest.java', 'guava/src/com/google/common/math/Quantiles.java']","@@ -290,6 +290,18 @@ public void testScale_indexes_varargs_compute_integerCollection() {
             8, SIXTEEN_SQUARES_DECILE_8);
   }
 
+  public void testScale_indexes_varargs_compute_indexOrderIsMaintained() {
+    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
+        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
+        .containsExactly(
+            0, SIXTEEN_SQUARES_MIN,
+            10, SIXTEEN_SQUARES_MAX,
+            5, SIXTEEN_SQUARES_MEDIAN,
+            1, SIXTEEN_SQUARES_DECILE_1,
+            8, SIXTEEN_SQUARES_DECILE_8)
+        .inOrder();
+  }
+
   public void testScale_indexes_varargs_compute_doubleVarargs() {
     double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
     assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset)), @@ -27,7 +27,7 @@
 import com.google.common.primitives.Ints;
 import java.math.RoundingMode;
 import java.util.Collection;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
@@ -331,8 +331,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles (with any associated lost of precision), and which will not be mutated by
      *     this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(Collection<? extends Number> dataset) {
       return computeInPlace(Doubles.toArray(dataset));
@@ -343,8 +345,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will not
      *     be mutated by this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(double... dataset) {
       return computeInPlace(dataset.clone());
@@ -356,8 +360,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles (with any associated lost of precision), and which will not be mutated by
      *     this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(long... dataset) {
       return computeInPlace(longsToDoubles(dataset));
@@ -368,8 +374,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles, and which will not be mutated by this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(int... dataset) {
       return computeInPlace(intsToDoubles(dataset));
@@ -380,13 +388,15 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, and which will
      *     be arbitrarily reordered by this method call
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order that the indexes were passed to the
+     *     {@code indexes} method.
      */
     public Map<Integer, Double> computeInPlace(double... dataset) {
       checkArgument(dataset.length > 0, ""Cannot calculate quantiles of an empty dataset"");
       if (containsNaN(dataset)) {
-        Map<Integer, Double> nanMap = new HashMap<>();
+        Map<Integer, Double> nanMap = new LinkedHashMap<>();
         for (int index : indexes) {
           nanMap.put(index, NaN);
         }
@@ -425,7 +435,7 @@ private ScaleAndIndexes(int scale, int[] indexes) {
       sort(requiredSelections, 0, requiredSelectionsCount);
       selectAllInPlace(
           requiredSelections, 0, requiredSelectionsCount - 1, dataset, 0, dataset.length - 1);
-      Map<Integer, Double> ret = new HashMap<>();
+      Map<Integer, Double> ret = new LinkedHashMap<>();
       for (int i = 0; i < indexes.length; i++) {
         int quotient = quotients[i];
         int remainder = remainders[i];, @@ -290,6 +290,18 @@ public void testScale_indexes_varargs_compute_integerCollection() {
             8, SIXTEEN_SQUARES_DECILE_8);
   }
 
+  public void testScale_indexes_varargs_compute_indexOrderIsMaintained() {
+    assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(SIXTEEN_SQUARES_INTEGERS))
+        .comparingValuesUsing(QUANTILE_CORRESPONDENCE)
+        .containsExactly(
+            0, SIXTEEN_SQUARES_MIN,
+            10, SIXTEEN_SQUARES_MAX,
+            5, SIXTEEN_SQUARES_MEDIAN,
+            1, SIXTEEN_SQUARES_DECILE_1,
+            8, SIXTEEN_SQUARES_DECILE_8)
+        .inOrder();
+  }
+
   public void testScale_indexes_varargs_compute_doubleVarargs() {
     double[] dataset = Doubles.toArray(SIXTEEN_SQUARES_DOUBLES);
     assertThat(Quantiles.scale(10).indexes(0, 10, 5, 1, 8, 1).compute(dataset)), @@ -27,7 +27,7 @@
 import com.google.common.primitives.Ints;
 import java.math.RoundingMode;
 import java.util.Collection;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 /**
@@ -331,8 +331,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles (with any associated lost of precision), and which will not be mutated by
      *     this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(Collection<? extends Number> dataset) {
       return computeInPlace(Doubles.toArray(dataset));
@@ -343,8 +345,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will not
      *     be mutated by this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(double... dataset) {
       return computeInPlace(dataset.clone());
@@ -356,8 +360,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles (with any associated lost of precision), and which will not be mutated by
      *     this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(long... dataset) {
       return computeInPlace(longsToDoubles(dataset));
@@ -368,8 +374,10 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, which will be
      *     cast to doubles, and which will not be mutated by this call (it is copied instead)
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order they were passed to the {@code
+     *     indexes} method.
      */
     public Map<Integer, Double> compute(int... dataset) {
       return computeInPlace(intsToDoubles(dataset));
@@ -380,13 +388,15 @@ private ScaleAndIndexes(int scale, int[] indexes) {
      *
      * @param dataset the dataset to do the calculation on, which must be non-empty, and which will
      *     be arbitrarily reordered by this method call
-     * @return an unmodifiable map of results: the keys will be the specified quantile indexes, and
-     *     the values the corresponding quantile values
+     * @return an unmodifiable, ordered map of results: the keys will be the specified quantile
+     *     indexes, and the values the corresponding quantile values. When iterating, entries in the
+     *     map are ordered by quantile index in the same order that the indexes were passed to the
+     *     {@code indexes} method.
      */
     public Map<Integer, Double> computeInPlace(double... dataset) {
       checkArgument(dataset.length > 0, ""Cannot calculate quantiles of an empty dataset"");
       if (containsNaN(dataset)) {
-        Map<Integer, Double> nanMap = new HashMap<>();
+        Map<Integer, Double> nanMap = new LinkedHashMap<>();
         for (int index : indexes) {
           nanMap.put(index, NaN);
         }
@@ -425,7 +435,7 @@ private ScaleAndIndexes(int scale, int[] indexes) {
       sort(requiredSelections, 0, requiredSelectionsCount);
       selectAllInPlace(
           requiredSelections, 0, requiredSelectionsCount - 1, dataset, 0, dataset.length - 1);
-      Map<Integer, Double> ret = new HashMap<>();
+      Map<Integer, Double> ret = new LinkedHashMap<>();
       for (int i = 0; i < indexes.length; i++) {
         int quotient = quotients[i];
         int remainder = remainders[i];, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add testlib readme.

Fixes #3453

3b0f1e580b4e0bde8fd4806c832389d0aade4063

-------

<p> Change Quantiles' compute() methods for multiple indexes to return a map with entries in the order in which the indexes were provided in the call to indexes().

Fixes https://github.com/google/guava/pull/2989

RELNOTES=`math`: `Quantiles` `compute()` methods which return a `Map` now return a map with entries in the same order in which the indexes were provided.

6a2d070ac268c138d6ad039605de54f535d5f5f3",Moe Sync
3637,Chris Povirk,"['android/guava/src/com/google/common/base/MoreObjects.java', 'guava/src/com/google/common/base/MoreObjects.java']","@@ -47,6 +47,9 @@
    * lazy evaluation of the fallback instance, using {@link Optional#or(Supplier)
    * first.or(supplier)}.
    *
+   * <p><b>Java 9 users:</b> use {@code java.util.Objects.requireNonNullElse(first, second)}
+   * instead.
+   *
    * @return {@code first} if it is non-null; otherwise {@code second} if it is non-null
    * @throws NullPointerException if both {@code first} and {@code second} are null
    * @since 18.0 (since 3.0 as {@code Objects.firstNonNull()})., @@ -47,6 +47,9 @@
    * lazy evaluation of the fallback instance, using {@link Optional#or(Supplier)
    * first.or(supplier)}.
    *
+   * <p><b>Java 9 users:</b> use {@code java.util.Objects.requireNonNullElse(first, second)}
+   * instead.
+   *
    * @return {@code first} if it is non-null; otherwise {@code second} if it is non-null
    * @throws NullPointerException if both {@code first} and {@code second} are null
    * @since 18.0 (since 3.0 as {@code Objects.firstNonNull()})., ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Bump version, which went out of date since the previous CL was created.

90f4a1c88941d1d68ec2fc68397a5e11fefa7355

-------

<p> Use if statement instead of for statement for a single item.

Fixes #3633

020621e474e228b4b9c12dbd24badd9590b0af8e

-------

<p> Upgrade maven source plugin from 2.1.2 to 3.1.0

Fixes https://github.com/google/guava/pull/3466

e87b8807798808d5a526a6fd2f49b484bb4a846a

-------

<p> Document the JDK 9+ alternative to `MoreObjects#firstNonNull`

Fixes https://github.com/google/guava/pull/3383

145da12d85b536d6f2a527e1ccf2430147fa6b83",Moe Sync
3640,Chris Povirk,"['android/guava/src/com/google/common/primitives/Doubles.java', 'android/guava/src/com/google/common/primitives/Floats.java', 'android/guava/src/com/google/common/primitives/Ints.java', 'android/guava/src/com/google/common/primitives/Longs.java', 'guava/src/com/google/common/primitives/Doubles.java', 'guava/src/com/google/common/primitives/Floats.java', 'guava/src/com/google/common/primitives/Ints.java', 'guava/src/com/google/common/primitives/Longs.java']","@@ -687,6 +687,7 @@ public String toString() {
    * @param string the string representation of a {@code double} value
    * @return the floating point value represented by {@code string}, or {@code null} if {@code
    *     string} has a length of zero or cannot be parsed as a {@code double} value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta, @@ -646,6 +646,7 @@ public String toString() {
    * @param string the string representation of a {@code float} value
    * @return the floating point value represented by {@code string}, or {@code null} if {@code
    *     string} has a length of zero or cannot be parsed as a {@code float} value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta, @@ -697,6 +697,7 @@ public String toString() {
    * @param string the string representation of an integer value
    * @return the integer value represented by {@code string}, or {@code null} if {@code string} has
    *     a length of zero or cannot be parsed as an integer value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 11.0
    */
   @Beta
@@ -722,6 +723,7 @@ public static Integer tryParse(String string) {
    *     {@code string} has a length of zero or cannot be parsed as an integer value
    * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
    *     Character.MAX_RADIX}
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
   @Beta, @@ -357,6 +357,7 @@ static int digit(char c) {
    * @param string the string representation of a long value
    * @return the long value represented by {@code string}, or {@code null} if {@code string} has a
    *     length of zero or cannot be parsed as a long value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta
@@ -382,6 +383,7 @@ public static Long tryParse(String string) {
    *     {@code string} has a length of zero or cannot be parsed as a long value
    * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
    *     Character.MAX_RADIX}
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
   @Beta, @@ -694,6 +694,7 @@ public String toString() {
    * @param string the string representation of a {@code double} value
    * @return the floating point value represented by {@code string}, or {@code null} if {@code
    *     string} has a length of zero or cannot be parsed as a {@code double} value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta, @@ -646,6 +646,7 @@ public String toString() {
    * @param string the string representation of a {@code float} value
    * @return the floating point value represented by {@code string}, or {@code null} if {@code
    *     string} has a length of zero or cannot be parsed as a {@code float} value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta, @@ -704,6 +704,7 @@ public String toString() {
    * @param string the string representation of an integer value
    * @return the integer value represented by {@code string}, or {@code null} if {@code string} has
    *     a length of zero or cannot be parsed as an integer value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 11.0
    */
   @Beta
@@ -728,6 +729,7 @@ public String toString() {
    *     {@code string} has a length of zero or cannot be parsed as an integer value
    * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
    *     Character.MAX_RADIX}
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
   @Beta, @@ -359,6 +359,7 @@ static int digit(char c) {
    * @param string the string representation of a long value
    * @return the long value represented by {@code string}, or {@code null} if {@code string} has a
    *     length of zero or cannot be parsed as a long value
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 14.0
    */
   @Beta
@@ -383,6 +384,7 @@ static int digit(char c) {
    *     {@code string} has a length of zero or cannot be parsed as a long value
    * @throws IllegalArgumentException if {@code radix < Character.MIN_RADIX} or {@code radix >
    *     Character.MAX_RADIX}
+   * @throws NullPointerException if {@code string} is {@code null}
    * @since 19.0
    */
   @Beta, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Change tryParse methods to explicitly document that they throw NPE if the input is null.

This is to hopefully reduce the chance of confusion based on the fact that the methods say that they do not throw an exception ""if parsing fails"".

Fixes https://github.com/google/guava/issues/1259

995c07eb95d5e5fac35f3f1219dbb4e4bed83d11",Moe Sync
3644,Chris Povirk,"['android/guava/src/com/google/common/collect/EnumMultiset.java', 'guava/src/com/google/common/collect/EnumMultiset.java']","@@ -125,7 +125,7 @@ public int size() {
 
   @Override
   public int count(@NullableDecl Object element) {
-    if (element == null || !isActuallyE(element)) {
+    if (!isActuallyE(element)) {
       return 0;
     }
     Enum<?> e = (Enum<?>) element;
@@ -157,7 +157,7 @@ public int add(E element, int occurrences) {
   @CanIgnoreReturnValue
   @Override
   public int remove(@NullableDecl Object element, int occurrences) {
-    if (element == null || !isActuallyE(element)) {
+    if (!isActuallyE(element)) {
       return 0;
     }
     Enum<?> e = (Enum<?>) element;, @@ -126,7 +126,7 @@ public int size() {
 
   @Override
   public int count(@Nullable Object element) {
-    if (element == null || !isActuallyE(element)) {
+    if (!isActuallyE(element)) {
       return 0;
     }
     Enum<?> e = (Enum<?>) element;
@@ -158,7 +158,7 @@ public int add(E element, int occurrences) {
   @CanIgnoreReturnValue
   @Override
   public int remove(@Nullable Object element, int occurrences) {
-    if (element == null || !isActuallyE(element)) {
+    if (!isActuallyE(element)) {
       return 0;
     }
     Enum<?> e = (Enum<?>) element;, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove duplicate null check from EnumMultiset.

Fixes https://github.com/google/guava/pull/3559

079d1732c6740da9d499b2ff4c94fb37b1b66b57",Moe Sync
3648,Nick,"['android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedSortedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ValueGraphTest.java', 'android/guava/src/com/google/common/collect/AbstractMultiset.java', 'android/guava/src/com/google/common/collect/HashBiMap.java', 'android/guava/src/com/google/common/graph/MapIteratorCache.java', 'android/guava/src/com/google/common/graph/MapRetrievalCache.java', 'guava-tests/test/com/google/common/graph/AbstractNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedSortedNetworkTest.java', 'guava-tests/test/com/google/common/graph/ValueGraphTest.java', 'guava/src/com/google/common/collect/AbstractMultiset.java', 'guava/src/com/google/common/collect/HashBiMap.java', 'guava/src/com/google/common/graph/MapIteratorCache.java', 'guava/src/com/google/common/graph/MapRetrievalCache.java']","@@ -22,14 +22,20 @@
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.graph.TestUtil.sanityCheckSet;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -678,4 +684,64 @@ public void removeEdge_queryAfterRemoval() {
       assertEdgeNotInGraphErrorMessage(e);
     }
   }
+
+  @Test
+  public void concurrentIteration() throws Exception {
+    addEdge(1, 2, ""foo"");
+    addEdge(3, 4, ""bar"");
+    addEdge(5, 6, ""baz"");
+
+    int threadCount = 20;
+    ExecutorService executor = newFixedThreadPool(threadCount);
+    final CyclicBarrier barrier = new CyclicBarrier(threadCount);
+    ImmutableList.Builder<Future<?>> futures = ImmutableList.builder();
+    for (int i = 0; i < threadCount; i++) {
+      futures.add(
+          executor.submit(
+              new Callable<Object>() {
+                @Override
+                public Object call() throws Exception {
+                  barrier.await();
+                  Integer first = network.nodes().iterator().next();
+                  for (Integer node : network.nodes()) {
+                    Set<Integer> unused = network.successors(node);
+                  }
+                  /*
+                   * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
+                   * we read one of the fields declared in that class.
+                   */
+                  Set<Integer> unused = network.successors(first);
+                  return null;
+                }
+              }));
+    }
+
+    /*
+     * It's unlikely that any operations would fail by throwing an exception, but let's check them
+     * just to be safe.
+     *
+     * The real purpose of this test is to produce a TSAN failure if MapIteratorCache is unsafe for
+     * reads from multiple threads -- unsafe, in fact, even in the absence of a concurrent write.
+     * The specific problem we had was unsafe reads of lastEntryReturnedBySomeIterator. (To fix the
+     * problem, we've since marked that field as volatile.)
+     *
+     * When MapIteratorCache is used from Immutable* classes, the TSAN failure doesn't indicate a
+     * real problem: The Entry objects are ImmutableMap entries, whose fields are all final and thus
+     * safe to read even when the Entry object is unsafely published. But with a mutable graph, the
+     * Entry object is likely to have a non-final value field, which is not safe to read when
+     * unsafely published. (The Entry object might even be newly created by each iterator.next()
+     * call, so we can't assume that writes to the Entry have been safely published by some other
+     * synchronization actions.)
+     *
+     * All that said: I haven't actually managed to make this particular test produce a TSAN error
+     * for the field accesses in MapIteratorCache. This teset *has* found other TSAN errors,
+     * including in MapRetrievalCache, so I'm not sure why this one is different. I did at least
+     * confirm that my change to MapIteratorCache fixes the TSAN error in the (larger) test it was
+     * originally reported in.
+     */
+    for (Future<?> future : futures.build()) {
+      future.get();
+    }
+    executor.shutdown();
+  }
 }, @@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.graph;
+
+import static com.google.common.graph.ElementOrder.sorted;
+
+import com.google.common.collect.Ordering;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed sorted graph
+ * (parallel and self-loop edges are not allowed).
+ *
+ * <p>The main purpose of this class is to run the inherited {@link #concurrentIteration} test
+ * against a sorted graph so as to cover {@link MapRetrievalCache}.
+ */
+@RunWith(JUnit4.class)
+public class ConfigurableSimpleDirectedSortedNetworkTest
+    extends ConfigurableSimpleDirectedNetworkTest {
+
+  @Override
+  public MutableNetwork<Integer, String> createGraph() {
+    return NetworkBuilder.directed()
+        .allowsParallelEdges(false)
+        .allowsSelfLoops(false)
+        .edgeOrder(sorted(Ordering.natural()))
+        .nodeOrder(sorted(Ordering.natural()))
+        .build();
+  }
+
+  @Override
+  public void addEdge_nodesNotInGraph() {
+    /*
+     * Skip this test because the expected ordering is different here than in the superclass because
+     * of sorting.
+     *
+     * TODO(cpovirk): Implement this to check for the proper order.
+     */
+  }
+}, @@ -19,8 +19,15 @@
 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.ImmutableList;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -330,4 +337,43 @@ public void equivalence_considersEdgeValue() {
     otherGraph.putEdgeValue(1, 2, ""valueB"");
     assertThat(graph).isNotEqualTo(otherGraph); // values differ
   }
+
+  @Test
+  public void concurrentIteration() throws Exception {
+    graph = ValueGraphBuilder.directed().build();
+    graph.putEdgeValue(1, 2, ""A"");
+    graph.putEdgeValue(3, 4, ""B"");
+    graph.putEdgeValue(5, 6, ""C"");
+
+    int threadCount = 20;
+    ExecutorService executor = newFixedThreadPool(threadCount);
+    final CyclicBarrier barrier = new CyclicBarrier(threadCount);
+    ImmutableList.Builder<Future<?>> futures = ImmutableList.builder();
+    for (int i = 0; i < threadCount; i++) {
+      futures.add(
+          executor.submit(
+              new Callable<Object>() {
+                @Override
+                public Object call() throws Exception {
+                  barrier.await();
+                  Integer first = graph.nodes().iterator().next();
+                  for (Integer node : graph.nodes()) {
+                    Set<Integer> unused = graph.successors(node);
+                  }
+                  /*
+                   * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
+                   * we read one of the fields declared in that class.
+                   */
+                  Set<Integer> unused = graph.successors(first);
+                  return null;
+                }
+              }));
+    }
+
+    // For more about this test, see the equivalent in AbstractNetworkTest.
+    for (Future<?> future : futures.build()) {
+      future.get();
+    }
+    executor.shutdown();
+  }
 }, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -124,7 +125,7 @@ public final boolean retainAll(Collection<?> elementsToRetain) {
 
   // Views
 
-  @MonotonicNonNullDecl private transient Set<E> elementSet;
+  @LazyInit @MonotonicNonNullDecl private transient Set<E> elementSet;
 
   @Override
   public Set<E> elementSet() {
@@ -158,7 +159,7 @@ public final boolean retainAll(Collection<?> elementsToRetain) {
 
   abstract Iterator<E> elementIterator();
 
-  @MonotonicNonNullDecl private transient Set<Entry<E>> entrySet;
+  @LazyInit @MonotonicNonNullDecl private transient Set<Entry<E>> entrySet;
 
   @Override
   public Set<Entry<E>> entrySet() {, @@ -20,6 +20,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Objects;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.IOException;
 import java.io.ObjectInputStream;
@@ -899,7 +900,7 @@ public V setValue(V value) {
     }
   }
 
-  @MonotonicNonNullDecl @RetainedWith private transient BiMap<V, K> inverse;
+  @LazyInit @MonotonicNonNullDecl @RetainedWith private transient BiMap<V, K> inverse;
 
   @Override
   public BiMap<V, K> inverse() {, @@ -44,28 +44,34 @@
 class MapIteratorCache<K, V> {
   private final Map<K, V> backingMap;
 
-  // Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
-  // the entry was returned by the iterator, except through the setValue operation on the map entry""
-  // As such, this field must be cleared before every map mutation.
-  @NullableDecl private transient Entry<K, V> entrySetCache;
+  /*
+   * Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
+   * the entry was returned by the iterator, except through the setValue operation on the map entry""
+   * As such, this field must be cleared before every map mutation.
+   *
+   * Note about volatile: volatile doesn't make it safe to read from a mutable graph in one thread
+   * while writing to it in another. All it does is help with _reading_ from multiple threads
+   * concurrently. For more information, see AbstractNetworkTest.concurrentIteration.
+   */
+  @NullableDecl private transient volatile Entry<K, V> cacheEntry;
 
   MapIteratorCache(Map<K, V> backingMap) {
     this.backingMap = checkNotNull(backingMap);
   }
 
   @CanIgnoreReturnValue
-  public V put(@NullableDecl K key, @NullableDecl V value) {
+  public final V put(@NullableDecl K key, @NullableDecl V value) {
     clearCache();
     return backingMap.put(key, value);
   }
 
   @CanIgnoreReturnValue
-  public V remove(@NullableDecl Object key) {
+  public final V remove(@NullableDecl Object key) {
     clearCache();
     return backingMap.remove(key);
   }
 
-  public void clear() {
+  public final void clear() {
     clearCache();
     backingMap.clear();
   }
@@ -98,7 +104,7 @@ public boolean hasNext() {
           @Override
           public K next() {
             Entry<K, V> entry = entryIterator.next(); // store local reference for thread-safety
-            entrySetCache = entry;
+            cacheEntry = entry;
             return entry.getKey();
           }
         };
@@ -119,7 +125,7 @@ public boolean contains(@NullableDecl Object key) {
   // Internal methods ('protected' is still package-visible, but treat as only subclass-visible)
 
   protected V getIfCached(@NullableDecl Object key) {
-    Entry<K, V> entry = entrySetCache; // store local reference for thread-safety
+    Entry<K, V> entry = cacheEntry; // store local reference for thread-safety
 
     // Check cache. We use == on purpose because it's cheaper and a cache miss is ok.
     if (entry != null && entry.getKey() == key) {
@@ -129,6 +135,6 @@ protected V getIfCached(@NullableDecl Object key) {
   }
 
   protected void clearCache() {
-    entrySetCache = null;
+    cacheEntry = null;
   }
 }, @@ -26,8 +26,9 @@
  * @author James Sexton
  */
 class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
-  @NullableDecl private transient CacheEntry<K, V> cacheEntry1;
-  @NullableDecl private transient CacheEntry<K, V> cacheEntry2;
+  // See the note about volatile in the superclass.
+  @NullableDecl private transient volatile CacheEntry<K, V> cacheEntry1;
+  @NullableDecl private transient volatile CacheEntry<K, V> cacheEntry2;
 
   MapRetrievalCache(Map<K, V> backingMap) {
     super(backingMap);, @@ -22,14 +22,20 @@
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.graph.TestUtil.sanityCheckSet;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -685,4 +691,64 @@ public void removeEdge_queryAfterRemoval() {
       assertEdgeNotInGraphErrorMessage(e);
     }
   }
+
+  @Test
+  public void concurrentIteration() throws Exception {
+    addEdge(1, 2, ""foo"");
+    addEdge(3, 4, ""bar"");
+    addEdge(5, 6, ""baz"");
+
+    int threadCount = 20;
+    ExecutorService executor = newFixedThreadPool(threadCount);
+    final CyclicBarrier barrier = new CyclicBarrier(threadCount);
+    ImmutableList.Builder<Future<?>> futures = ImmutableList.builder();
+    for (int i = 0; i < threadCount; i++) {
+      futures.add(
+          executor.submit(
+              new Callable<Object>() {
+                @Override
+                public Object call() throws Exception {
+                  barrier.await();
+                  Integer first = network.nodes().iterator().next();
+                  for (Integer node : network.nodes()) {
+                    Set<Integer> unused = network.successors(node);
+                  }
+                  /*
+                   * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
+                   * we read one of the fields declared in that class.
+                   */
+                  Set<Integer> unused = network.successors(first);
+                  return null;
+                }
+              }));
+    }
+
+    /*
+     * It's unlikely that any operations would fail by throwing an exception, but let's check them
+     * just to be safe.
+     *
+     * The real purpose of this test is to produce a TSAN failure if MapIteratorCache is unsafe for
+     * reads from multiple threads -- unsafe, in fact, even in the absence of a concurrent write.
+     * The specific problem we had was unsafe reads of lastEntryReturnedBySomeIterator. (To fix the
+     * problem, we've since marked that field as volatile.)
+     *
+     * When MapIteratorCache is used from Immutable* classes, the TSAN failure doesn't indicate a
+     * real problem: The Entry objects are ImmutableMap entries, whose fields are all final and thus
+     * safe to read even when the Entry object is unsafely published. But with a mutable graph, the
+     * Entry object is likely to have a non-final value field, which is not safe to read when
+     * unsafely published. (The Entry object might even be newly created by each iterator.next()
+     * call, so we can't assume that writes to the Entry have been safely published by some other
+     * synchronization actions.)
+     *
+     * All that said: I haven't actually managed to make this particular test produce a TSAN error
+     * for the field accesses in MapIteratorCache. This teset *has* found other TSAN errors,
+     * including in MapRetrievalCache, so I'm not sure why this one is different. I did at least
+     * confirm that my change to MapIteratorCache fixes the TSAN error in the (larger) test it was
+     * originally reported in.
+     */
+    for (Future<?> future : futures.build()) {
+      future.get();
+    }
+    executor.shutdown();
+  }
 }, @@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.graph;
+
+import static com.google.common.graph.ElementOrder.sorted;
+
+import com.google.common.collect.Ordering;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed sorted graph
+ * (parallel and self-loop edges are not allowed).
+ *
+ * <p>The main purpose of this class is to run the inherited {@link #concurrentIteration} test
+ * against a sorted graph so as to cover {@link MapRetrievalCache}.
+ */
+@RunWith(JUnit4.class)
+public class ConfigurableSimpleDirectedSortedNetworkTest
+    extends ConfigurableSimpleDirectedNetworkTest {
+
+  @Override
+  public MutableNetwork<Integer, String> createGraph() {
+    return NetworkBuilder.directed()
+        .allowsParallelEdges(false)
+        .allowsSelfLoops(false)
+        .edgeOrder(sorted(Ordering.natural()))
+        .nodeOrder(sorted(Ordering.natural()))
+        .build();
+  }
+
+  @Override
+  public void addEdge_nodesNotInGraph() {
+    /*
+     * Skip this test because the expected ordering is different here than in the superclass because
+     * of sorting.
+     *
+     * TODO(cpovirk): Implement this to check for the proper order.
+     */
+  }
+}, @@ -20,9 +20,16 @@
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth8.assertThat;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.ImmutableList;
 import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
 import org.junit.After;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -390,4 +397,43 @@ public void equivalence_considersEdgeValue() {
     otherGraph.putEdgeValue(1, 2, ""valueB"");
     assertThat(graph).isNotEqualTo(otherGraph); // values differ
   }
+
+  @Test
+  public void concurrentIteration() throws Exception {
+    graph = ValueGraphBuilder.directed().build();
+    graph.putEdgeValue(1, 2, ""A"");
+    graph.putEdgeValue(3, 4, ""B"");
+    graph.putEdgeValue(5, 6, ""C"");
+
+    int threadCount = 20;
+    ExecutorService executor = newFixedThreadPool(threadCount);
+    final CyclicBarrier barrier = new CyclicBarrier(threadCount);
+    ImmutableList.Builder<Future<?>> futures = ImmutableList.builder();
+    for (int i = 0; i < threadCount; i++) {
+      futures.add(
+          executor.submit(
+              new Callable<Object>() {
+                @Override
+                public Object call() throws Exception {
+                  barrier.await();
+                  Integer first = graph.nodes().iterator().next();
+                  for (Integer node : graph.nodes()) {
+                    Set<Integer> unused = graph.successors(node);
+                  }
+                  /*
+                   * Also look up an earlier node so that, if the graph is using MapRetrievalCache,
+                   * we read one of the fields declared in that class.
+                   */
+                  Set<Integer> unused = graph.successors(first);
+                  return null;
+                }
+              }));
+    }
+
+    // For more about this test, see the equivalent in AbstractNetworkTest.
+    for (Future<?> future : futures.build()) {
+      future.get();
+    }
+    executor.shutdown();
+  }
 }, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -124,7 +125,7 @@ public final boolean retainAll(Collection<?> elementsToRetain) {
 
   // Views
 
-  private transient @MonotonicNonNull Set<E> elementSet;
+  @LazyInit @MonotonicNonNull private transient Set<E> elementSet;
 
   @Override
   public Set<E> elementSet() {
@@ -158,7 +159,7 @@ public final boolean retainAll(Collection<?> elementsToRetain) {
 
   abstract Iterator<E> elementIterator();
 
-  private transient @MonotonicNonNull Set<Entry<E>> entrySet;
+  @LazyInit @MonotonicNonNull private transient Set<Entry<E>> entrySet;
 
   @Override
   public Set<Entry<E>> entrySet() {, @@ -25,6 +25,7 @@
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps.IteratorBasedAbstractMap;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
@@ -559,7 +560,7 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
     }
   }
 
-  @MonotonicNonNull @RetainedWith private transient BiMap<V, K> inverse;
+  @LazyInit @MonotonicNonNull @RetainedWith private transient BiMap<V, K> inverse;
 
   @Override
   public BiMap<V, K> inverse() {, @@ -44,28 +44,34 @@
 class MapIteratorCache<K, V> {
   private final Map<K, V> backingMap;
 
-  // Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
-  // the entry was returned by the iterator, except through the setValue operation on the map entry""
-  // As such, this field must be cleared before every map mutation.
-  private transient @Nullable Entry<K, V> entrySetCache;
+  /*
+   * Per JDK: ""the behavior of a map entry is undefined if the backing map has been modified after
+   * the entry was returned by the iterator, except through the setValue operation on the map entry""
+   * As such, this field must be cleared before every map mutation.
+   *
+   * Note about volatile: volatile doesn't make it safe to read from a mutable graph in one thread
+   * while writing to it in another. All it does is help with _reading_ from multiple threads
+   * concurrently. For more information, see AbstractNetworkTest.concurrentIteration.
+   */
+  private transient volatile @Nullable Entry<K, V> cacheEntry;
 
   MapIteratorCache(Map<K, V> backingMap) {
     this.backingMap = checkNotNull(backingMap);
   }
 
   @CanIgnoreReturnValue
-  public V put(@Nullable K key, @Nullable V value) {
+  public final V put(@Nullable K key, @Nullable V value) {
     clearCache();
     return backingMap.put(key, value);
   }
 
   @CanIgnoreReturnValue
-  public V remove(@Nullable Object key) {
+  public final V remove(@Nullable Object key) {
     clearCache();
     return backingMap.remove(key);
   }
 
-  public void clear() {
+  public final void clear() {
     clearCache();
     backingMap.clear();
   }
@@ -98,7 +104,7 @@ public boolean hasNext() {
           @Override
           public K next() {
             Entry<K, V> entry = entryIterator.next(); // store local reference for thread-safety
-            entrySetCache = entry;
+            cacheEntry = entry;
             return entry.getKey();
           }
         };
@@ -119,7 +125,7 @@ public boolean contains(@Nullable Object key) {
   // Internal methods ('protected' is still package-visible, but treat as only subclass-visible)
 
   protected V getIfCached(@Nullable Object key) {
-    Entry<K, V> entry = entrySetCache; // store local reference for thread-safety
+    Entry<K, V> entry = cacheEntry; // store local reference for thread-safety
 
     // Check cache. We use == on purpose because it's cheaper and a cache miss is ok.
     if (entry != null && entry.getKey() == key) {
@@ -129,6 +135,6 @@ protected V getIfCached(@Nullable Object key) {
   }
 
   protected void clearCache() {
-    entrySetCache = null;
+    cacheEntry = null;
   }
 }, @@ -26,8 +26,9 @@
  * @author James Sexton
  */
 class MapRetrievalCache<K, V> extends MapIteratorCache<K, V> {
-  private transient @Nullable CacheEntry<K, V> cacheEntry1;
-  private transient @Nullable CacheEntry<K, V> cacheEntry2;
+  // See the note about volatile in the superclass.
+  private transient volatile @Nullable CacheEntry<K, V> cacheEntry1;
+  private transient volatile @Nullable CacheEntry<K, V> cacheEntry2;
 
   MapRetrievalCache(Map<K, V> backingMap) {
     super(backingMap);, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Address TSAN errors:

1. Suppress safe racy init in AbstractMultiset and HashBiMap. All the classes that are stored in the newly annotated fields have only final fields (except HashBiMap.Inverse, which inherits AbstractBiMap's keySet and values fields, which are themselves @LazyInit), so they are safe to read racily.

2. Mark some graph ""cache"" fields as volatile. These fields are an optimization: When the user accesses an entry through iteration (and sometimes through get(...)), the graph stores the entry in a field. That way, if the user then queries it again (such as to look up the value associated with a key during iteration), the graph doesn't have to perform a potentially mildly expensive lookup. But this caching isn't implemented in a thread-safe way. It *ought* to be safe to initialize a graph in one thread, safely publish it, and then read it concurrently from other threads. But because of the racy reads of the cached entry fields, I don't think this is guaranteed to be safe.

RELNOTES=`graph`: Fixed data race.

07eba15451f7d0dc10ab8328a6d595ab1e68abac",Moe Sync
3650,Nick,"['guava/src/com/google/common/base/Platform.java', 'guava/src/com/google/common/collect/Platform.java', 'guava/src/com/google/common/primitives/Platform.java']","@@ -111,12 +111,5 @@ static void checkGwtRpcEnabled() {
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
-    logger.log(
-        java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
-            + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
-            + "" can identify which type by looking at the class name in the attached stack trace."",
-        new Throwable());
-
   }
 }, @@ -32,9 +32,6 @@
  */
 @GwtCompatible(emulated = true)
 final class Platform {
-  private static final java.util.logging.Logger logger =
-      java.util.logging.Logger.getLogger(Platform.class.getName());
-
   /** Returns the platform preferred implementation of a map based on a hash table. */
   static <K, V> Map<K, V> newHashMapWithExpectedSize(int expectedSize) {
     return Maps.newHashMapWithExpectedSize(expectedSize);
@@ -128,13 +125,6 @@ static void checkGwtRpcEnabled() {
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
-    logger.log(
-        java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
-            + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
-            + "" can identify which type by looking at the class name in the attached stack trace."",
-        new Throwable());
-
   }
 
   private Platform() {}, @@ -22,9 +22,6 @@
 /** Methods factored out so that they can be emulated differently in GWT. */
 @GwtCompatible(emulated = true)
 final class Platform {
-  private static final java.util.logging.Logger logger =
-      java.util.logging.Logger.getLogger(Platform.class.getName());
-
   private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
 
   static void checkGwtRpcEnabled() {
@@ -38,13 +35,6 @@ static void checkGwtRpcEnabled() {
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
-    logger.log(
-        java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
-            + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
-            + "" can identify which type by looking at the class name in the attached stack trace."",
-        new Throwable());
-
   }
 
   private Platform() {}, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Require tokens to be non-empty.

Followup to CL 272190935.

Fixes https://github.com/google/guava/issues/3626 (again :))

b080067280ab22f262880d222c0a75d043962f4f

-------

<p> Log warnings for users who send Guava types over GWT-RPC.

I've left this change out of the Android branch. For starters, it's not necessary there, since we don't support GWT. But normally we'd include it anyway to minimize diffs. However, doing so increases the number of classes retained after running Proguard (thanks, I assume, to the Logger field). There are other ways of getting around this, but for a temporary feature, the diffs seem tolerable.

RELNOTES=***Warning to users of GWT-RPC:*** The first Guava release of 2020 will [remove support for GWT-serializing Guava types](https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ). To test ahead of time with GWT-RPC support for Guava types disabled, set the `guava.gwt.emergency_reenable_rpc` system property to `false`.

750db498a0108802f3de1905a2a56d956cd9cda3

-------

<p> Steam -> Stream in the names of certain locals in ByteStream.

0ee31e21a41be3f87831446374e323c7f08f0011

-------

<p> [OpenSearch] Add MediaType for ""application/opensearchdescription+xml""

RELNOTES=Add MediaType for ""application/opensearchdescription+xml""

6be97d88570e0990fbe5a91326620df9f2a09853

-------

<p> Revert previous CL:

============
Log warnings for users who send Guava types over GWT-RPC.

I've left this change out of the Android branch. For starters, it's not necessary there, since we don't support GWT. But normally we'd include it anyway to minimize diffs. However, doing so increases the number of classes retained after running Proguard (thanks, I assume, to the Logger field). There are other ways of getting around this, but for a temporary feature, the diffs seem tolerable.

82838c5a9a161937c4ac91f3abd3bf7a26202f53",Moe Sync
3654,Nick,"['android/guava/src/com/google/common/cache/CacheBuilder.java', 'android/guava/src/com/google/common/cache/ReferenceEntry.java', 'guava/src/com/google/common/cache/CacheBuilder.java', 'guava/src/com/google/common/cache/ReferenceEntry.java']","@@ -662,6 +662,7 @@ Strength getValueStrength() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getExpireAfterWriteNanos() {
     return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;
   }
@@ -701,6 +702,7 @@ long getExpireAfterWriteNanos() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getExpireAfterAccessNanos() {
     return (expireAfterAccessNanos == UNSET_INT)
         ? DEFAULT_EXPIRATION_NANOS
@@ -743,6 +745,7 @@ long getExpireAfterAccessNanos() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getRefreshNanos() {
     return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;
   }, @@ -64,6 +64,7 @@
    */
 
   /** Returns the time that this entry was last accessed, in ns. */
+  @SuppressWarnings(""GoodTime"")
   long getAccessTime();
 
   /** Sets the entry access time in ns. */
@@ -88,6 +89,7 @@
    * expired from the head of the list.
    */
 
+  @SuppressWarnings(""GoodTime"")
   /** Returns the time that this entry was last written, in ns. */
   long getWriteTime();
 , @@ -693,6 +693,7 @@ Strength getValueStrength() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getExpireAfterWriteNanos() {
     return (expireAfterWriteNanos == UNSET_INT) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos;
   }
@@ -767,6 +768,7 @@ long getExpireAfterWriteNanos() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getExpireAfterAccessNanos() {
     return (expireAfterAccessNanos == UNSET_INT)
         ? DEFAULT_EXPIRATION_NANOS
@@ -845,6 +847,7 @@ long getExpireAfterAccessNanos() {
     return this;
   }
 
+  @SuppressWarnings(""GoodTime"") // nanos internally, should be Duration
   long getRefreshNanos() {
     return (refreshNanos == UNSET_INT) ? DEFAULT_REFRESH_NANOS : refreshNanos;
   }, @@ -64,6 +64,7 @@
    */
 
   /** Returns the time that this entry was last accessed, in ns. */
+  @SuppressWarnings(""GoodTime"")
   long getAccessTime();
 
   /** Sets the entry access time in ns. */
@@ -88,6 +89,7 @@
    * expired from the head of the list.
    */
 
+  @SuppressWarnings(""GoodTime"")
   /** Returns the time that this entry was last written, in ns. */
   long getWriteTime();
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> switch to an internal annotation for ignoring JRE
requirements

Fixes #3652

RELNOTES=Removed dependency on `animal-sniffer-annotations`.

3324ce6af9d672b4a1e4431ebaf84b0e22d7ca86

-------

<p> Rename package-private Duration APIs:
  saturatedToNanos() -> toNanosSaturated()
  saturatedToMillis() -> toMillisSaturated()

#goodtime

f3a053ea12ae808ddd52094d36fcd88fe95881f2

-------

<p> Suppress more GoodTime errors.

9e885c85265c3686aa876acebe6bb6bda18de1f3",Moe Sync
3656,Kurt Alfred Kluever,['README.md'],"@@ -86,7 +86,7 @@ removing things again, but officially, we're leaving our options open in case
 of surprises (like, say, a serious security problem).
 
 3. Guava has one dependency that is needed at runtime:
-`com.google.guava:failureaccess:1.0`
+`com.google.guava:failureaccess:1.0.1`
 
 4. Serialized forms of ALL objects are subject to change unless noted
 otherwise. Do not persist these and assume they can be read by a, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Log warnings for users who send Guava types over GWT-RPC.

(Roll forward CL 273803350, which was rolled back in CL 273825377. This time with updates to one-definition whitelist.)

[]

09a11ae36f186ba1ed5b0cd4d9eef2733028c496

-------

<p> update failureaccess version to match docs with code

Fixes #3653

dc01afd344fdf669f28e9e806dc8864622152177",Moe Sync
3657,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/math/StatsAccumulatorTest.java', 'android/guava-tests/test/com/google/common/math/StatsTest.java', 'android/guava-tests/test/com/google/common/math/StatsTesting.java', 'android/guava/src/com/google/common/math/Stats.java', 'android/guava/src/com/google/common/math/StatsAccumulator.java', 'guava-tests/test/com/google/common/math/StatsAccumulatorTest.java', 'guava-tests/test/com/google/common/math/StatsTest.java', 'guava-tests/test/com/google/common/math/StatsTesting.java', 'guava/src/com/google/common/math/Stats.java', 'guava/src/com/google/common/math/StatsAccumulator.java']","@@ -76,6 +76,7 @@
   private StatsAccumulator manyValuesAccumulatorByRepeatedAdd;
   private StatsAccumulator manyValuesAccumulatorByAddAndAddAll;
   private StatsAccumulator manyValuesAccumulatorByAddAllStats;
+  private StatsAccumulator manyValuesAccumulatorByAddAllStatsAccumulator;
   private StatsAccumulator integerManyValuesAccumulatorByAddAllIterable;
   private StatsAccumulator longManyValuesAccumulatorByAddAllIterator;
   private StatsAccumulator longManyValuesAccumulatorByAddAllVarargs;
@@ -130,6 +131,12 @@ protected void setUp() throws Exception {
     manyValuesAccumulatorByAddAllStats.addAll(
         Stats.of(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));
 
+    manyValuesAccumulatorByAddAllStatsAccumulator = new StatsAccumulator();
+    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(
+        statsAccumulatorOf(MANY_VALUES.subList(0, MANY_VALUES.size() / 2)));
+    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(
+        statsAccumulatorOf(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));
+
     integerManyValuesAccumulatorByAddAllIterable = new StatsAccumulator();
     integerManyValuesAccumulatorByAddAllIterable.addAll(INTEGER_MANY_VALUES);
 
@@ -140,6 +147,12 @@ protected void setUp() throws Exception {
     longManyValuesAccumulatorByAddAllVarargs.addAll(Longs.toArray(LONG_MANY_VALUES));
   }
 
+  private static StatsAccumulator statsAccumulatorOf(Iterable<? extends Number> values) {
+    StatsAccumulator accumulator = new StatsAccumulator();
+    accumulator.addAll(values);
+    return accumulator;
+  }
+
   public void testCount() {
     assertThat(emptyAccumulator.count()).isEqualTo(0);
     assertThat(emptyAccumulatorByAddAllEmptyIterable.count()).isEqualTo(0);
@@ -154,6 +167,7 @@ public void testCount() {
     assertThat(manyValuesAccumulatorByRepeatedAdd.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(manyValuesAccumulatorByAddAndAddAll.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(manyValuesAccumulatorByAddAllStats.count()).isEqualTo(MANY_VALUES_COUNT);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(integerManyValuesAccumulatorByAddAllIterable.count())
         .isEqualTo(StatsTesting.INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.count())
@@ -213,6 +227,9 @@ public void testMean() {
     assertThat(manyValuesAccumulatorByAddAllStats.mean())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.mean())
+        .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_MEAN);
     // For datasets of many double values created from an iterable, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -252,13 +269,13 @@ public void testMean() {
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(longManyValuesAccumulatorByAddAllIterator.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
   }
 
@@ -290,14 +307,17 @@ public void testSum() {
     assertThat(manyValuesAccumulatorByAddAllStats.sum())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sum())
         .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
   }
 
@@ -343,6 +363,9 @@ public void testPopulationVariance() {
     assertThat(manyValuesAccumulatorByAddAllStats.populationVariance())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationVariance())
+        .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
     // For datasets of many double values created from an iterator, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -371,13 +394,13 @@ public void testPopulationVariance() {
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
   }
 
@@ -425,14 +448,17 @@ public void testPopulationStandardDeviation() {
     assertThat(manyValuesAccumulatorByAddAllStats.populationStandardDeviation())
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationStandardDeviation())
         .isWithin(ALLOWED_ERROR)
+        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(longManyValuesAccumulatorByAddAllIterator.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
   }
 
@@ -486,14 +512,17 @@ public void testSampleVariance() {
     assertThat(manyValuesAccumulatorByAddAllStats.sampleVariance())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleVariance())
         .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(longManyValuesAccumulatorByAddAllIterator.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
   }
 
@@ -547,14 +576,17 @@ public void testSampleStandardDeviation() {
     assertThat(manyValuesAccumulatorByAddAllStats.sampleStandardDeviation())
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleStandardDeviation())
         .isWithin(ALLOWED_ERROR)
+        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(longManyValuesAccumulatorByAddAllIterator.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
   }
 
@@ -574,28 +606,17 @@ public void testMax() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(oneValueAccumulator.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(twoValuesAccumulator.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(twoValuesAccumulatorByAddAllStats.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllIterable.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllIterator.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllVarargs.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByRepeatedAdd.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAndAddAll.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllStats.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
+    assertThat(oneValueAccumulator.max()).isEqualTo(ONE_VALUE);
+    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isEqualTo(ONE_VALUE);
+    assertThat(twoValuesAccumulator.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(twoValuesAccumulatorByAddAllStats.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllIterable.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllIterator.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByRepeatedAdd.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAndAddAll.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllStats.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.max()).isEqualTo(MANY_VALUES_MAX);
     // For datasets of many double values created from an array, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -616,22 +637,16 @@ public void testMax() {
             .that(maxByAddAllStats)
             .isPositiveInfinity();
       } else {
-        assertWithMessage(""max of "" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+        assertWithMessage(""max of "" + values).that(max).isEqualTo(MANY_VALUES_MAX);
         assertWithMessage(""max by addAll(Stats) of "" + values)
             .that(maxByAddAllStats)
-            .isWithin(ALLOWED_ERROR)
-            .of(MANY_VALUES_MAX);
+            .isEqualTo(MANY_VALUES_MAX);
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(longManyValuesAccumulatorByAddAllIterator.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
-    assertThat(longManyValuesAccumulatorByAddAllVarargs.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
+        .isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(longManyValuesAccumulatorByAddAllIterator.max()).isEqualTo(LONG_MANY_VALUES_MAX);
+    assertThat(longManyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(LONG_MANY_VALUES_MAX);
   }
 
   public void testMin() {
@@ -650,28 +665,17 @@ public void testMin() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(oneValueAccumulator.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(twoValuesAccumulator.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(twoValuesAccumulatorByAddAllStats.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllIterable.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllIterator.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllVarargs.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByRepeatedAdd.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAndAddAll.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllStats.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
+    assertThat(oneValueAccumulator.min()).isEqualTo(ONE_VALUE);
+    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isEqualTo(ONE_VALUE);
+    assertThat(twoValuesAccumulator.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(twoValuesAccumulatorByAddAllStats.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllIterable.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllIterator.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByRepeatedAdd.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAndAddAll.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllStats.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.min()).isEqualTo(MANY_VALUES_MIN);
     // For datasets of many double values created by adding elements individually, we test many
     // combinations of finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -692,21 +696,15 @@ public void testMin() {
             .that(minByAddAllStats)
             .isNegativeInfinity();
       } else {
-        assertWithMessage(""min of "" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+        assertWithMessage(""min of "" + values).that(min).isEqualTo(MANY_VALUES_MIN);
         assertWithMessage(""min by addAll(Stats) of "" + values)
             .that(minByAddAllStats)
-            .isWithin(ALLOWED_ERROR)
-            .of(MANY_VALUES_MIN);
+            .isEqualTo(MANY_VALUES_MIN);
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(longManyValuesAccumulatorByAddAllIterator.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
-    assertThat(longManyValuesAccumulatorByAddAllVarargs.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
+        .isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(longManyValuesAccumulatorByAddAllIterator.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+    assertThat(longManyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(LONG_MANY_VALUES_MIN);
   }
 }, @@ -145,19 +145,19 @@ public void testMean() {
         .isWithin(ALLOWED_ERROR * Double.MAX_VALUE)
         .of(LARGE_VALUES_MEAN);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(LARGE_INTEGER_VALUES_STATS.mean())
         .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE)
         .of(LARGE_INTEGER_VALUES_MEAN);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(LARGE_LONG_VALUES_STATS.mean())
         .isWithin(ALLOWED_ERROR * Long.MAX_VALUE)
@@ -182,16 +182,16 @@ public void testSum() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
   }
 
@@ -236,19 +236,19 @@ public void testPopulationVariance() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(LARGE_INTEGER_VALUES_STATS.populationVariance())
         .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE * Integer.MAX_VALUE)
         .of(LARGE_INTEGER_VALUES_POPULATION_VARIANCE);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(LARGE_LONG_VALUES_STATS.populationVariance())
         .isWithin(ALLOWED_ERROR * Long.MAX_VALUE * Long.MAX_VALUE)
@@ -283,16 +283,16 @@ public void testPopulationStandardDeviation() {
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
   }
 
@@ -328,16 +328,16 @@ public void testSampleVariance() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
   }
 
@@ -373,16 +373,16 @@ public void testSampleStandardDeviation() {
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
   }
 
@@ -397,13 +397,13 @@ public void testMax() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(ONE_VALUE_STATS.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
+    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);
     assertThat(Stats.of(POSITIVE_INFINITY).max()).isPositiveInfinity();
     assertThat(Stats.of(NEGATIVE_INFINITY).max()).isNegativeInfinity();
     assertThat(Stats.of(NaN).max()).isNaN();
-    assertThat(TWO_VALUES_STATS.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(MANY_VALUES_STATS_VARARGS.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
-    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);
     // For datasets of many double values created from an iterator, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -413,22 +413,14 @@ public void testMax() {
       } else if (values.hasAnyPositiveInfinity()) {
         assertWithMessage(""max of "" + values).that(max).isPositiveInfinity();
       } else {
-        assertWithMessage(""max of "" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+        assertWithMessage(""max of "" + values).that(max).isEqualTo(MANY_VALUES_MAX);
       }
     }
-    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
-    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
-    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);
+    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);
   }
 
   public void testMin() {
@@ -442,14 +434,14 @@ public void testMin() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(ONE_VALUE_STATS.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
+    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);
     assertThat(Stats.of(POSITIVE_INFINITY).min()).isPositiveInfinity();
     assertThat(Stats.of(NEGATIVE_INFINITY).min()).isNegativeInfinity();
     assertThat(Stats.of(NaN).min()).isNaN();
-    assertThat(TWO_VALUES_STATS.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_VARARGS.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);
     // For datasets of many double values created from an accumulator snapshot, we test many
     // combinations of finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -461,21 +453,13 @@ public void testMin() {
       } else if (values.hasAnyNegativeInfinity()) {
         assertWithMessage(""min of "" + values).that(min).isNegativeInfinity();
       } else {
-        assertWithMessage(""min of "" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+        assertWithMessage(""min of "" + values).that(min).isEqualTo(MANY_VALUES_MIN);
       }
     }
-    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
-    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
+    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);
   }
 
   public void testEqualsAndHashCode() {
@@ -558,14 +542,16 @@ public void testMeanOf() {
     assertThat(Stats.meanOf(MANY_VALUES)).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(MANY_VALUES.iterator())).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(INTEGER_MANY_VALUES))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(Ints.toArray(INTEGER_MANY_VALUES)))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
-    assertThat(Stats.meanOf(LONG_MANY_VALUES)).isWithin(ALLOWED_ERROR).of(LONG_MANY_VALUES_MEAN);
+    assertThat(Stats.meanOf(LONG_MANY_VALUES))
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
+        .of(LONG_MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(Longs.toArray(LONG_MANY_VALUES)))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
   }
 , @@ -222,28 +222,29 @@ public String toString() {
   static final Stats MANY_VALUES_STATS_VARARGS = Stats.of(1.1, -44.44, 33.33, 555.555, -2.2);
   static final Stats MANY_VALUES_STATS_ITERABLE = Stats.of(MANY_VALUES);
   static final Stats MANY_VALUES_STATS_ITERATOR = Stats.of(MANY_VALUES.iterator());
-  static final Stats MANY_VALUES_STATS_SNAPSHOT;
+  static final Stats MANY_VALUES_STATS_SNAPSHOT = buildManyValuesStatsSnapshot();
   static final Stats LARGE_VALUES_STATS = Stats.of(LARGE_VALUES);
   static final Stats OTHER_MANY_VALUES_STATS = Stats.of(OTHER_MANY_VALUES);
   static final Stats INTEGER_MANY_VALUES_STATS_VARARGS =
       Stats.of(Ints.toArray(INTEGER_MANY_VALUES));
   static final Stats INTEGER_MANY_VALUES_STATS_ITERABLE = Stats.of(INTEGER_MANY_VALUES);
   static final Stats LARGE_INTEGER_VALUES_STATS = Stats.of(LARGE_INTEGER_VALUES);
   static final Stats LONG_MANY_VALUES_STATS_ITERATOR = Stats.of(LONG_MANY_VALUES.iterator());
-  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT;
+  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT = buildLongManyValuesStatsSnapshot();
   static final Stats LARGE_LONG_VALUES_STATS = Stats.of(LARGE_LONG_VALUES);
 
-  static {
+  private static Stats buildManyValuesStatsSnapshot() {
     StatsAccumulator accumulator = new StatsAccumulator();
     accumulator.addAll(MANY_VALUES);
-    MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();
+    Stats stats = accumulator.snapshot();
     accumulator.add(999.999); // should do nothing to the snapshot
+    return stats;
   }
 
-  static {
+  private static Stats buildLongManyValuesStatsSnapshot() {
     StatsAccumulator accumulator = new StatsAccumulator();
     accumulator.addAll(LONG_MANY_VALUES);
-    LONG_MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
   static final ImmutableList<Stats> ALL_STATS =
@@ -275,42 +276,43 @@ public String toString() {
       createPairedStatsOf(ImmutableList.of(ONE_VALUE), ImmutableList.of(OTHER_ONE_VALUE));
   static final PairedStats TWO_VALUES_PAIRED_STATS =
       createPairedStatsOf(TWO_VALUES, OTHER_TWO_VALUES);
-  static final PairedStats MANY_VALUES_PAIRED_STATS;
+  static final PairedStats MANY_VALUES_PAIRED_STATS = buildManyValuesPairedStats();
   static final PairedStats DUPLICATE_MANY_VALUES_PAIRED_STATS =
       createPairedStatsOf(MANY_VALUES, OTHER_MANY_VALUES);
-  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS;
-  static final PairedStats VERTICAL_VALUES_PAIRED_STATS;
-  static final PairedStats CONSTANT_VALUES_PAIRED_STATS;
+  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS = buildHorizontalValuesPairedStats();
+  static final PairedStats VERTICAL_VALUES_PAIRED_STATS = buildVerticalValuesPairedStats();
+  static final PairedStats CONSTANT_VALUES_PAIRED_STATS = buildConstantValuesPairedStats();
 
-  static {
+  private static PairedStats buildManyValuesPairedStats() {
     PairedStatsAccumulator accumulator =
         createFilledPairedStatsAccumulator(MANY_VALUES, OTHER_MANY_VALUES);
-    MANY_VALUES_PAIRED_STATS = accumulator.snapshot();
+    PairedStats stats = accumulator.snapshot();
     accumulator.add(99.99, 9999.9999); // should do nothing to the snapshot
+    return stats;
   }
 
-  static {
+  private static PairedStats buildHorizontalValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (double x : MANY_VALUES) {
       accumulator.add(x, OTHER_ONE_VALUE);
     }
-    HORIZONTAL_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
-  static {
+  private static PairedStats buildVerticalValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (double y : OTHER_MANY_VALUES) {
       accumulator.add(ONE_VALUE, y);
     }
-    VERTICAL_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
-  static {
+  private static PairedStats buildConstantValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (int i = 0; i < MANY_VALUES_COUNT; ++i) {
       accumulator.add(ONE_VALUE, OTHER_ONE_VALUE);
     }
-    CONSTANT_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
   static final ImmutableList<PairedStats> ALL_PAIRED_STATS =, @@ -103,7 +103,8 @@ public static Stats of(Iterable<? extends Number> values) {
   }
 
   /**
-   * Returns statistics over a dataset containing the given values.
+   * Returns statistics over a dataset containing the given values. The iterator will be completely
+   * consumed by this method.
    *
    * @param values a series of values, which will be converted to {@code double} values (this may
    *     cause loss of precision), @@ -136,27 +136,47 @@ public void addAll(Stats values) {
     if (values.count() == 0) {
       return;
     }
+    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());
+  }
+
+  /**
+   * Adds the given statistics to the dataset, as if the individual values used to compute the
+   * statistics had been added directly.
+   *
+   * @since NEXT
+   */
+  public void addAll(StatsAccumulator values) {
+    if (values.count() == 0) {
+      return;
+    }
+    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());
+  }
 
+  private void merge(
+      long otherCount,
+      double otherMean,
+      double otherSumOfSquaresOfDeltas,
+      double otherMin,
+      double otherMax) {
     if (count == 0) {
-      count = values.count();
-      mean = values.mean();
-      sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();
-      min = values.min();
-      max = values.max();
+      count = otherCount;
+      mean = otherMean;
+      sumOfSquaresOfDeltas = otherSumOfSquaresOfDeltas;
+      min = otherMin;
+      max = otherMax;
     } else {
-      count += values.count();
-      if (isFinite(mean) && isFinite(values.mean())) {
+      count += otherCount;
+      if (isFinite(mean) && isFinite(otherMean)) {
         // This is a generalized version of the calculation in add(double) above.
-        double delta = values.mean() - mean;
-        mean += delta * values.count() / count;
-        sumOfSquaresOfDeltas +=
-            values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();
+        double delta = otherMean - mean;
+        mean += delta * otherCount / count;
+        sumOfSquaresOfDeltas += otherSumOfSquaresOfDeltas + delta * (otherMean - mean) * otherCount;
       } else {
-        mean = calculateNewMeanNonFinite(mean, values.mean());
+        mean = calculateNewMeanNonFinite(mean, otherMean);
         sumOfSquaresOfDeltas = NaN;
       }
-      min = Math.min(min, values.min());
-      max = Math.max(max, values.max());
+      min = Math.min(min, otherMin);
+      max = Math.max(max, otherMax);
     }
   }
 , @@ -36,13 +36,20 @@
 import static com.google.common.math.StatsTesting.MANY_VALUES_MEAN;
 import static com.google.common.math.StatsTesting.MANY_VALUES_MIN;
 import static com.google.common.math.StatsTesting.MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_COUNT;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MAX;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MEAN;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MIN;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_POPULATION_VARIANCE;
 import static com.google.common.math.StatsTesting.ONE_VALUE;
 import static com.google.common.math.StatsTesting.OTHER_ONE_VALUE;
 import static com.google.common.math.StatsTesting.TWO_VALUES;
 import static com.google.common.math.StatsTesting.TWO_VALUES_MAX;
 import static com.google.common.math.StatsTesting.TWO_VALUES_MEAN;
 import static com.google.common.math.StatsTesting.TWO_VALUES_MIN;
 import static com.google.common.math.StatsTesting.TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS;
+import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStreamPart1;
+import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStreamPart2;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static java.lang.Math.sqrt;
@@ -76,6 +83,7 @@
   private StatsAccumulator manyValuesAccumulatorByRepeatedAdd;
   private StatsAccumulator manyValuesAccumulatorByAddAndAddAll;
   private StatsAccumulator manyValuesAccumulatorByAddAllStats;
+  private StatsAccumulator manyValuesAccumulatorByAddAllStatsAccumulator;
   private StatsAccumulator integerManyValuesAccumulatorByAddAllIterable;
   private StatsAccumulator longManyValuesAccumulatorByAddAllIterator;
   private StatsAccumulator longManyValuesAccumulatorByAddAllVarargs;
@@ -130,6 +138,12 @@ protected void setUp() throws Exception {
     manyValuesAccumulatorByAddAllStats.addAll(
         Stats.of(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));
 
+    manyValuesAccumulatorByAddAllStatsAccumulator = new StatsAccumulator();
+    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(
+        statsAccumulatorOf(MANY_VALUES.subList(0, MANY_VALUES.size() / 2)));
+    manyValuesAccumulatorByAddAllStatsAccumulator.addAll(
+        statsAccumulatorOf(MANY_VALUES.subList(MANY_VALUES.size() / 2, MANY_VALUES.size())));
+
     integerManyValuesAccumulatorByAddAllIterable = new StatsAccumulator();
     integerManyValuesAccumulatorByAddAllIterable.addAll(INTEGER_MANY_VALUES);
 
@@ -140,6 +154,12 @@ protected void setUp() throws Exception {
     longManyValuesAccumulatorByAddAllVarargs.addAll(Longs.toArray(LONG_MANY_VALUES));
   }
 
+  private static StatsAccumulator statsAccumulatorOf(Iterable<? extends Number> values) {
+    StatsAccumulator accumulator = new StatsAccumulator();
+    accumulator.addAll(values);
+    return accumulator;
+  }
+
   public void testCount() {
     assertThat(emptyAccumulator.count()).isEqualTo(0);
     assertThat(emptyAccumulatorByAddAllEmptyIterable.count()).isEqualTo(0);
@@ -154,6 +174,7 @@ public void testCount() {
     assertThat(manyValuesAccumulatorByRepeatedAdd.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(manyValuesAccumulatorByAddAndAddAll.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(manyValuesAccumulatorByAddAllStats.count()).isEqualTo(MANY_VALUES_COUNT);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.count()).isEqualTo(MANY_VALUES_COUNT);
     assertThat(integerManyValuesAccumulatorByAddAllIterable.count())
         .isEqualTo(StatsTesting.INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.count())
@@ -213,6 +234,9 @@ public void testMean() {
     assertThat(manyValuesAccumulatorByAddAllStats.mean())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.mean())
+        .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_MEAN);
     // For datasets of many double values created from an iterable, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -252,13 +276,13 @@ public void testMean() {
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(longManyValuesAccumulatorByAddAllIterator.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
   }
 
@@ -290,14 +314,17 @@ public void testSum() {
     assertThat(manyValuesAccumulatorByAddAllStats.sum())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sum())
         .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sum())
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
   }
 
@@ -343,6 +370,9 @@ public void testPopulationVariance() {
     assertThat(manyValuesAccumulatorByAddAllStats.populationVariance())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationVariance())
+        .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
     // For datasets of many double values created from an iterator, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -371,13 +401,13 @@ public void testPopulationVariance() {
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllIterator.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(longManyValuesAccumulatorByAddAllVarargs.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
   }
 
@@ -425,14 +455,17 @@ public void testPopulationStandardDeviation() {
     assertThat(manyValuesAccumulatorByAddAllStats.populationStandardDeviation())
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.populationStandardDeviation())
         .isWithin(ALLOWED_ERROR)
+        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.populationStandardDeviation())
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(longManyValuesAccumulatorByAddAllIterator.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
   }
 
@@ -486,14 +519,17 @@ public void testSampleVariance() {
     assertThat(manyValuesAccumulatorByAddAllStats.sampleVariance())
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleVariance())
         .isWithin(ALLOWED_ERROR)
+        .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleVariance())
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(longManyValuesAccumulatorByAddAllIterator.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
   }
 
@@ -547,14 +583,17 @@ public void testSampleStandardDeviation() {
     assertThat(manyValuesAccumulatorByAddAllStats.sampleStandardDeviation())
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
-    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.sampleStandardDeviation())
         .isWithin(ALLOWED_ERROR)
+        .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
+    assertThat(integerManyValuesAccumulatorByAddAllIterable.sampleStandardDeviation())
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(longManyValuesAccumulatorByAddAllIterator.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
     assertThat(longManyValuesAccumulatorByAddAllVarargs.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
   }
 
@@ -574,28 +613,17 @@ public void testMax() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(oneValueAccumulator.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(twoValuesAccumulator.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(twoValuesAccumulatorByAddAllStats.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllIterable.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllIterator.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllVarargs.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByRepeatedAdd.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAndAddAll.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
-    assertThat(manyValuesAccumulatorByAddAllStats.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MAX);
+    assertThat(oneValueAccumulator.max()).isEqualTo(ONE_VALUE);
+    assertThat(oneValueAccumulatorByAddAllEmptyStats.max()).isEqualTo(ONE_VALUE);
+    assertThat(twoValuesAccumulator.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(twoValuesAccumulatorByAddAllStats.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllIterable.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllIterator.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByRepeatedAdd.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAndAddAll.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllStats.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.max()).isEqualTo(MANY_VALUES_MAX);
     // For datasets of many double values created from an array, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -616,22 +644,16 @@ public void testMax() {
             .that(maxByAddAllStats)
             .isPositiveInfinity();
       } else {
-        assertWithMessage(""max of "" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+        assertWithMessage(""max of "" + values).that(max).isEqualTo(MANY_VALUES_MAX);
         assertWithMessage(""max by addAll(Stats) of "" + values)
             .that(maxByAddAllStats)
-            .isWithin(ALLOWED_ERROR)
-            .of(MANY_VALUES_MAX);
+            .isEqualTo(MANY_VALUES_MAX);
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(longManyValuesAccumulatorByAddAllIterator.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
-    assertThat(longManyValuesAccumulatorByAddAllVarargs.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
+        .isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(longManyValuesAccumulatorByAddAllIterator.max()).isEqualTo(LONG_MANY_VALUES_MAX);
+    assertThat(longManyValuesAccumulatorByAddAllVarargs.max()).isEqualTo(LONG_MANY_VALUES_MAX);
   }
 
   public void testMin() {
@@ -650,28 +672,17 @@ public void testMin() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(oneValueAccumulator.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
-    assertThat(twoValuesAccumulator.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(twoValuesAccumulatorByAddAllStats.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllIterable.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllIterator.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllVarargs.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByRepeatedAdd.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAndAddAll.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
-    assertThat(manyValuesAccumulatorByAddAllStats.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(MANY_VALUES_MIN);
+    assertThat(oneValueAccumulator.min()).isEqualTo(ONE_VALUE);
+    assertThat(oneValueAccumulatorByAddAllEmptyStats.min()).isEqualTo(ONE_VALUE);
+    assertThat(twoValuesAccumulator.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(twoValuesAccumulatorByAddAllStats.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllIterable.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllIterator.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByRepeatedAdd.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAndAddAll.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllStats.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(manyValuesAccumulatorByAddAllStatsAccumulator.min()).isEqualTo(MANY_VALUES_MIN);
     // For datasets of many double values created by adding elements individually, we test many
     // combinations of finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -692,21 +703,54 @@ public void testMin() {
             .that(minByAddAllStats)
             .isNegativeInfinity();
       } else {
-        assertWithMessage(""min of "" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+        assertWithMessage(""min of "" + values).that(min).isEqualTo(MANY_VALUES_MIN);
         assertWithMessage(""min by addAll(Stats) of "" + values)
             .that(minByAddAllStats)
-            .isWithin(ALLOWED_ERROR)
-            .of(MANY_VALUES_MIN);
+            .isEqualTo(MANY_VALUES_MIN);
       }
     }
     assertThat(integerManyValuesAccumulatorByAddAllIterable.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(longManyValuesAccumulatorByAddAllIterator.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
-    assertThat(longManyValuesAccumulatorByAddAllVarargs.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
+        .isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(longManyValuesAccumulatorByAddAllIterator.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+    assertThat(longManyValuesAccumulatorByAddAllVarargs.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+  }
+
+  public void testAddAllPrimitiveDoubleStream() {
+    StatsAccumulator accumulator = new StatsAccumulator();
+    accumulator.addAll(megaPrimitiveDoubleStreamPart1());
+    accumulator.addAll(megaPrimitiveDoubleStreamPart2());
+    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(accumulator.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testAddAllPrimitiveIntStream() {
+    StatsAccumulator accumulator = new StatsAccumulator();
+    accumulator.addAll(megaPrimitiveDoubleStreamPart1().mapToInt(x -> (int) x));
+    accumulator.addAll(megaPrimitiveDoubleStreamPart2().mapToInt(x -> (int) x));
+    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(accumulator.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testAddAllPrimitiveLongStream() {
+    StatsAccumulator accumulator = new StatsAccumulator();
+    accumulator.addAll(megaPrimitiveDoubleStreamPart1().mapToLong(x -> (long) x));
+    accumulator.addAll(megaPrimitiveDoubleStreamPart2().mapToLong(x -> (long) x));
+    assertThat(accumulator.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(accumulator.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(accumulator.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(accumulator.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(accumulator.max()).isEqualTo(MEGA_STREAM_MAX);
   }
 }, @@ -16,6 +16,7 @@
 
 package com.google.common.math;
 
+import static com.google.common.math.Stats.toStats;
 import static com.google.common.math.StatsTesting.ALLOWED_ERROR;
 import static com.google.common.math.StatsTesting.ALL_MANY_VALUES;
 import static com.google.common.math.StatsTesting.ALL_STATS;
@@ -55,6 +56,11 @@
 import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_SNAPSHOT;
 import static com.google.common.math.StatsTesting.MANY_VALUES_STATS_VARARGS;
 import static com.google.common.math.StatsTesting.MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_COUNT;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MAX;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MEAN;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_MIN;
+import static com.google.common.math.StatsTesting.MEGA_STREAM_POPULATION_VARIANCE;
 import static com.google.common.math.StatsTesting.ONE_VALUE;
 import static com.google.common.math.StatsTesting.ONE_VALUE_STATS;
 import static com.google.common.math.StatsTesting.TWO_VALUES;
@@ -63,6 +69,7 @@
 import static com.google.common.math.StatsTesting.TWO_VALUES_MIN;
 import static com.google.common.math.StatsTesting.TWO_VALUES_STATS;
 import static com.google.common.math.StatsTesting.TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS;
+import static com.google.common.math.StatsTesting.megaPrimitiveDoubleStream;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static java.lang.Double.NEGATIVE_INFINITY;
@@ -77,6 +84,7 @@
 import com.google.common.primitives.Longs;
 import com.google.common.testing.EqualsTester;
 import com.google.common.testing.SerializableTester;
+import java.math.BigDecimal;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.DoubleSummaryStatistics;
@@ -147,19 +155,19 @@ public void testMean() {
         .isWithin(ALLOWED_ERROR * Double.MAX_VALUE)
         .of(LARGE_VALUES_MEAN);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(LARGE_INTEGER_VALUES_STATS.mean())
         .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE)
         .of(LARGE_INTEGER_VALUES_MEAN);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.mean())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
     assertThat(LARGE_LONG_VALUES_STATS.mean())
         .isWithin(ALLOWED_ERROR * Long.MAX_VALUE)
@@ -184,16 +192,16 @@ public void testSum() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_MEAN * MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sum())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT);
   }
 
@@ -238,19 +246,19 @@ public void testPopulationVariance() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT);
     assertThat(LARGE_INTEGER_VALUES_STATS.populationVariance())
         .isWithin(ALLOWED_ERROR * Integer.MAX_VALUE * Integer.MAX_VALUE)
         .of(LARGE_INTEGER_VALUES_POPULATION_VARIANCE);
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT);
     assertThat(LARGE_LONG_VALUES_STATS.populationVariance())
         .isWithin(ALLOWED_ERROR * Long.MAX_VALUE * Long.MAX_VALUE)
@@ -285,16 +293,16 @@ public void testPopulationStandardDeviation() {
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.populationStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT));
   }
 
@@ -330,16 +338,16 @@ public void testSampleVariance() {
         .isWithin(ALLOWED_ERROR)
         .of(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleVariance())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS)
         .of(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1));
   }
 
@@ -375,16 +383,16 @@ public void testSampleStandardDeviation() {
         .isWithin(ALLOWED_ERROR)
         .of(sqrt(MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (MANY_VALUES_COUNT - 1)));
     assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (INTEGER_MANY_VALUES_COUNT - 1)));
     assertThat(LONG_MANY_VALUES_STATS_ITERATOR.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
     assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.sampleStandardDeviation())
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS))
         .of(sqrt(LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / (LONG_MANY_VALUES_COUNT - 1)));
   }
 
@@ -399,13 +407,13 @@ public void testMax() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(ONE_VALUE_STATS.max()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
+    assertThat(ONE_VALUE_STATS.max()).isEqualTo(ONE_VALUE);
     assertThat(Stats.of(POSITIVE_INFINITY).max()).isPositiveInfinity();
     assertThat(Stats.of(NEGATIVE_INFINITY).max()).isNegativeInfinity();
     assertThat(Stats.of(NaN).max()).isNaN();
-    assertThat(TWO_VALUES_STATS.max()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MAX);
-    assertThat(MANY_VALUES_STATS_VARARGS.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
-    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+    assertThat(TWO_VALUES_STATS.max()).isEqualTo(TWO_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_VARARGS.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(MANY_VALUES_MAX);
     // For datasets of many double values created from an iterator, we test many combinations of
     // finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -415,22 +423,14 @@ public void testMax() {
       } else if (values.hasAnyPositiveInfinity()) {
         assertWithMessage(""max of "" + values).that(max).isPositiveInfinity();
       } else {
-        assertWithMessage(""max of "" + values).that(max).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
+        assertWithMessage(""max of "" + values).that(max).isEqualTo(MANY_VALUES_MAX);
       }
     }
-    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MAX);
-    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MAX);
-    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
-    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MAX);
+    assertThat(MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(MANY_VALUES_MAX);
+    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.max()).isEqualTo(INTEGER_MANY_VALUES_MAX);
+    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.max()).isEqualTo(LONG_MANY_VALUES_MAX);
+    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.max()).isEqualTo(LONG_MANY_VALUES_MAX);
   }
 
   public void testMin() {
@@ -444,14 +444,14 @@ public void testMin() {
       fail(""Expected IllegalStateException"");
     } catch (IllegalStateException expected) {
     }
-    assertThat(ONE_VALUE_STATS.min()).isWithin(ALLOWED_ERROR).of(ONE_VALUE);
+    assertThat(ONE_VALUE_STATS.min()).isEqualTo(ONE_VALUE);
     assertThat(Stats.of(POSITIVE_INFINITY).min()).isPositiveInfinity();
     assertThat(Stats.of(NEGATIVE_INFINITY).min()).isNegativeInfinity();
     assertThat(Stats.of(NaN).min()).isNaN();
-    assertThat(TWO_VALUES_STATS.min()).isWithin(ALLOWED_ERROR).of(TWO_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_VARARGS.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
-    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+    assertThat(TWO_VALUES_STATS.min()).isEqualTo(TWO_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_VARARGS.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(MANY_VALUES_MIN);
+    assertThat(MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(MANY_VALUES_MIN);
     // For datasets of many double values created from an accumulator snapshot, we test many
     // combinations of finite and non-finite values:
     for (ManyValues values : ALL_MANY_VALUES) {
@@ -463,21 +463,68 @@ public void testMin() {
       } else if (values.hasAnyNegativeInfinity()) {
         assertWithMessage(""min of "" + values).that(min).isNegativeInfinity();
       } else {
-        assertWithMessage(""min of "" + values).that(min).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MIN);
+        assertWithMessage(""min of "" + values).that(min).isEqualTo(MANY_VALUES_MIN);
       }
     }
-    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(INTEGER_MANY_VALUES_MIN);
-    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
-    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min())
-        .isWithin(ALLOWED_ERROR)
-        .of(LONG_MANY_VALUES_MIN);
+    assertThat(INTEGER_MANY_VALUES_STATS_VARARGS.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(INTEGER_MANY_VALUES_STATS_ITERABLE.min()).isEqualTo(INTEGER_MANY_VALUES_MIN);
+    assertThat(LONG_MANY_VALUES_STATS_ITERATOR.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+    assertThat(LONG_MANY_VALUES_STATS_SNAPSHOT.min()).isEqualTo(LONG_MANY_VALUES_MIN);
+  }
+
+  public void testOfPrimitiveDoubleStream() {
+    Stats stats = Stats.of(megaPrimitiveDoubleStream());
+    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(stats.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testOfPrimitiveIntStream() {
+    Stats stats = Stats.of(megaPrimitiveDoubleStream().mapToInt(x -> (int) x));
+    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(stats.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testOfPrimitiveLongStream() {
+    Stats stats = Stats.of(megaPrimitiveDoubleStream().mapToLong(x -> (long) x));
+    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(stats.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testBoxedDoubleStreamToStats() {
+    Stats stats = megaPrimitiveDoubleStream().boxed().collect(toStats());
+    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(stats.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);
+  }
+
+  public void testBoxedBigDecimalStreamToStats() {
+    Stats stats = megaPrimitiveDoubleStream().mapToObj(BigDecimal::valueOf).collect(toStats());
+    assertThat(stats.count()).isEqualTo(MEGA_STREAM_COUNT);
+    assertThat(stats.mean()).isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT).of(MEGA_STREAM_MEAN);
+    assertThat(stats.populationVariance())
+        .isWithin(ALLOWED_ERROR * MEGA_STREAM_COUNT)
+        .of(MEGA_STREAM_POPULATION_VARIANCE);
+    assertThat(stats.min()).isEqualTo(MEGA_STREAM_MIN);
+    assertThat(stats.max()).isEqualTo(MEGA_STREAM_MAX);
   }
 
   public void testEqualsAndHashCode() {
@@ -560,14 +607,16 @@ public void testMeanOf() {
     assertThat(Stats.meanOf(MANY_VALUES)).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(MANY_VALUES.iterator())).isWithin(ALLOWED_ERROR).of(MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(INTEGER_MANY_VALUES))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(Ints.toArray(INTEGER_MANY_VALUES)))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * INTEGER_MANY_VALUES_MEAN)
         .of(INTEGER_MANY_VALUES_MEAN);
-    assertThat(Stats.meanOf(LONG_MANY_VALUES)).isWithin(ALLOWED_ERROR).of(LONG_MANY_VALUES_MEAN);
+    assertThat(Stats.meanOf(LONG_MANY_VALUES))
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
+        .of(LONG_MANY_VALUES_MEAN);
     assertThat(Stats.meanOf(Longs.toArray(LONG_MANY_VALUES)))
-        .isWithin(ALLOWED_ERROR)
+        .isWithin(ALLOWED_ERROR * LONG_MANY_VALUES_MEAN)
         .of(LONG_MANY_VALUES_MEAN);
   }
 , @@ -31,6 +31,7 @@
 import com.google.common.primitives.Ints;
 import java.math.BigInteger;
 import java.util.List;
+import java.util.stream.DoubleStream;
 
 /**
  * Inputs, expected outputs, and helper methods for tests of {@link StatsAccumulator}, {@link
@@ -211,6 +212,34 @@ public String toString() {
           .divide(BigInteger.valueOf(16L))
           .doubleValue();
 
+  /**
+   * Returns a stream of a million primitive doubles. The stream is parallel, which should cause
+   * {@code collect} calls to run in multi-threaded mode, so testing the combiner as well as the
+   * supplier and accumulator.
+   */
+  static DoubleStream megaPrimitiveDoubleStream() {
+    return DoubleStream.iterate(0.0, x -> x + 1.0).limit(MEGA_STREAM_COUNT).parallel();
+  }
+
+  /** Returns a stream containing half the values from {@link #megaPrimitiveDoubleStream}. */
+  static DoubleStream megaPrimitiveDoubleStreamPart1() {
+    return DoubleStream.iterate(0.0, x -> x + 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();
+  }
+
+  /**
+   * Returns a stream containing the values from {@link #megaPrimitiveDoubleStream} not in {@link
+   * #megaPrimitiveDoubleStreamPart1()}.
+   */
+  static DoubleStream megaPrimitiveDoubleStreamPart2() {
+    return DoubleStream.iterate(999_999.0, x -> x - 2.0).limit(MEGA_STREAM_COUNT / 2).parallel();
+  }
+
+  static final long MEGA_STREAM_COUNT = 1_000_000;
+  static final double MEGA_STREAM_MEAN = 999_999.0 / 2;
+  static final double MEGA_STREAM_POPULATION_VARIANCE = 999_999.0 * 1_000_001.0 / 12;
+  static final double MEGA_STREAM_MIN = 0.0;
+  static final double MEGA_STREAM_MAX = 999_999.0;
+
   // Stats instances:
 
   static final Stats EMPTY_STATS_VARARGS = Stats.of();
@@ -222,28 +251,29 @@ public String toString() {
   static final Stats MANY_VALUES_STATS_VARARGS = Stats.of(1.1, -44.44, 33.33, 555.555, -2.2);
   static final Stats MANY_VALUES_STATS_ITERABLE = Stats.of(MANY_VALUES);
   static final Stats MANY_VALUES_STATS_ITERATOR = Stats.of(MANY_VALUES.iterator());
-  static final Stats MANY_VALUES_STATS_SNAPSHOT;
+  static final Stats MANY_VALUES_STATS_SNAPSHOT = buildManyValuesStatsSnapshot();
   static final Stats LARGE_VALUES_STATS = Stats.of(LARGE_VALUES);
   static final Stats OTHER_MANY_VALUES_STATS = Stats.of(OTHER_MANY_VALUES);
   static final Stats INTEGER_MANY_VALUES_STATS_VARARGS =
       Stats.of(Ints.toArray(INTEGER_MANY_VALUES));
   static final Stats INTEGER_MANY_VALUES_STATS_ITERABLE = Stats.of(INTEGER_MANY_VALUES);
   static final Stats LARGE_INTEGER_VALUES_STATS = Stats.of(LARGE_INTEGER_VALUES);
   static final Stats LONG_MANY_VALUES_STATS_ITERATOR = Stats.of(LONG_MANY_VALUES.iterator());
-  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT;
+  static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT = buildLongManyValuesStatsSnapshot();
   static final Stats LARGE_LONG_VALUES_STATS = Stats.of(LARGE_LONG_VALUES);
 
-  static {
+  private static Stats buildManyValuesStatsSnapshot() {
     StatsAccumulator accumulator = new StatsAccumulator();
     accumulator.addAll(MANY_VALUES);
-    MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();
+    Stats stats = accumulator.snapshot();
     accumulator.add(999.999); // should do nothing to the snapshot
+    return stats;
   }
 
-  static {
+  private static Stats buildLongManyValuesStatsSnapshot() {
     StatsAccumulator accumulator = new StatsAccumulator();
     accumulator.addAll(LONG_MANY_VALUES);
-    LONG_MANY_VALUES_STATS_SNAPSHOT = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
   static final ImmutableList<Stats> ALL_STATS =
@@ -275,42 +305,43 @@ public String toString() {
       createPairedStatsOf(ImmutableList.of(ONE_VALUE), ImmutableList.of(OTHER_ONE_VALUE));
   static final PairedStats TWO_VALUES_PAIRED_STATS =
       createPairedStatsOf(TWO_VALUES, OTHER_TWO_VALUES);
-  static final PairedStats MANY_VALUES_PAIRED_STATS;
+  static final PairedStats MANY_VALUES_PAIRED_STATS = buildManyValuesPairedStats();
   static final PairedStats DUPLICATE_MANY_VALUES_PAIRED_STATS =
       createPairedStatsOf(MANY_VALUES, OTHER_MANY_VALUES);
-  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS;
-  static final PairedStats VERTICAL_VALUES_PAIRED_STATS;
-  static final PairedStats CONSTANT_VALUES_PAIRED_STATS;
+  static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS = buildHorizontalValuesPairedStats();
+  static final PairedStats VERTICAL_VALUES_PAIRED_STATS = buildVerticalValuesPairedStats();
+  static final PairedStats CONSTANT_VALUES_PAIRED_STATS = buildConstantValuesPairedStats();
 
-  static {
+  private static PairedStats buildManyValuesPairedStats() {
     PairedStatsAccumulator accumulator =
         createFilledPairedStatsAccumulator(MANY_VALUES, OTHER_MANY_VALUES);
-    MANY_VALUES_PAIRED_STATS = accumulator.snapshot();
+    PairedStats stats = accumulator.snapshot();
     accumulator.add(99.99, 9999.9999); // should do nothing to the snapshot
+    return stats;
   }
 
-  static {
+  private static PairedStats buildHorizontalValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (double x : MANY_VALUES) {
       accumulator.add(x, OTHER_ONE_VALUE);
     }
-    HORIZONTAL_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
-  static {
+  private static PairedStats buildVerticalValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (double y : OTHER_MANY_VALUES) {
       accumulator.add(ONE_VALUE, y);
     }
-    VERTICAL_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
-  static {
+  private static PairedStats buildConstantValuesPairedStats() {
     PairedStatsAccumulator accumulator = new PairedStatsAccumulator();
     for (int i = 0; i < MANY_VALUES_COUNT; ++i) {
       accumulator.add(ONE_VALUE, OTHER_ONE_VALUE);
     }
-    CONSTANT_VALUES_PAIRED_STATS = accumulator.snapshot();
+    return accumulator.snapshot();
   }
 
   static final ImmutableList<PairedStats> ALL_PAIRED_STATS =, @@ -32,6 +32,10 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.Iterator;
+import java.util.stream.Collector;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -103,7 +107,8 @@ public static Stats of(Iterable<? extends Number> values) {
   }
 
   /**
-   * Returns statistics over a dataset containing the given values.
+   * Returns statistics over a dataset containing the given values. The iterator will be completely
+   * consumed by this method.
    *
    * @param values a series of values, which will be converted to {@code double} values (this may
    *     cause loss of precision)
@@ -148,6 +153,78 @@ public static Stats of(long... values) {
     return acummulator.snapshot();
   }
 
+  /**
+   * Returns statistics over a dataset containing the given values. The stream will be completely
+   * consumed by this method.
+   *
+   * <p>If you have a {@code Stream<Double>} rather than a {@code DoubleStream}, you should collect
+   * the values using {@link #toStats()} instead.
+   *
+   * @param values a series of values
+   * @since NEXT
+   */
+  public static Stats of(DoubleStream values) {
+    return values
+        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)
+        .snapshot();
+  }
+
+  /**
+   * Returns statistics over a dataset containing the given values. The stream will be completely
+   * consumed by this method.
+   *
+   * <p>If you have a {@code Stream<Integer>} rather than an {@code IntStream}, you should collect
+   * the values using {@link #toStats()} instead.
+   *
+   * @param values a series of values
+   * @since NEXT
+   */
+  public static Stats of(IntStream values) {
+    return values
+        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)
+        .snapshot();
+  }
+
+  /**
+   * Returns statistics over a dataset containing the given values. The stream will be completely
+   * consumed by this method.
+   *
+   * <p>If you have a {@code Stream<Long>} rather than a {@code LongStream}, you should collect the
+   * values using {@link #toStats()} instead.
+   *
+   * @param values a series of values, which will be converted to {@code double} values (this may
+   *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
+   * @since NEXT
+   */
+  public static Stats of(LongStream values) {
+    return values
+        .collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll)
+        .snapshot();
+  }
+
+  /**
+   * Returns a {@link Collector} which accumulates statistics from a {@link java.util.stream.Stream}
+   * of any type of boxed {@link Number} into a {@link Stats}. Use by calling {@code
+   * boxedNumericStream.collect(toStats())}. The numbers will be converted to {@code double} values
+   * (which may cause loss of precision).
+   *
+   * <p>If you have any of the primitive streams {@code DoubleStream}, {@code IntStream}, or {@code
+   * LongStream}, you should use the factory method {@link #of} instead.
+   *
+   * @since NEXT
+   */
+  public static Collector<Number, StatsAccumulator, Stats> toStats() {
+    return Collector.of(
+        StatsAccumulator::new,
+        (a, x) -> a.add(x.doubleValue()),
+        (l, r) -> {
+          l.addAll(r);
+          return l;
+        },
+        StatsAccumulator::snapshot,
+        Collector.Characteristics.UNORDERED);
+  }
+
   /** Returns the number of values. */
   public long count() {
     return count;, @@ -23,6 +23,9 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import java.util.Iterator;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
 
 /**
  * A mutable object which accumulates double values and tracks some basic statistics over all the
@@ -128,6 +131,37 @@ public void addAll(long... values) {
     }
   }
 
+  /**
+   * Adds the given values to the dataset. The stream will be completely consumed by this method.
+   *
+   * @param values a series of values
+   * @since NEXT
+   */
+  public void addAll(DoubleStream values) {
+    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));
+  }
+
+  /**
+   * Adds the given values to the dataset. The stream will be completely consumed by this method.
+   *
+   * @param values a series of values
+   * @since NEXT
+   */
+  public void addAll(IntStream values) {
+    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));
+  }
+
+  /**
+   * Adds the given values to the dataset. The stream will be completely consumed by this method.
+   *
+   * @param values a series of values, which will be converted to {@code double} values (this may
+   *     cause loss of precision for longs of magnitude over 2^53 (slightly over 9e15))
+   * @since NEXT
+   */
+  public void addAll(LongStream values) {
+    addAll(values.collect(StatsAccumulator::new, StatsAccumulator::add, StatsAccumulator::addAll));
+  }
+
   /**
    * Adds the given statistics to the dataset, as if the individual values used to compute the
    * statistics had been added directly.
@@ -136,27 +170,47 @@ public void addAll(Stats values) {
     if (values.count() == 0) {
       return;
     }
+    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());
+  }
+
+  /**
+   * Adds the given statistics to the dataset, as if the individual values used to compute the
+   * statistics had been added directly.
+   *
+   * @since NEXT
+   */
+  public void addAll(StatsAccumulator values) {
+    if (values.count() == 0) {
+      return;
+    }
+    merge(values.count(), values.mean(), values.sumOfSquaresOfDeltas(), values.min(), values.max());
+  }
 
+  private void merge(
+      long otherCount,
+      double otherMean,
+      double otherSumOfSquaresOfDeltas,
+      double otherMin,
+      double otherMax) {
     if (count == 0) {
-      count = values.count();
-      mean = values.mean();
-      sumOfSquaresOfDeltas = values.sumOfSquaresOfDeltas();
-      min = values.min();
-      max = values.max();
+      count = otherCount;
+      mean = otherMean;
+      sumOfSquaresOfDeltas = otherSumOfSquaresOfDeltas;
+      min = otherMin;
+      max = otherMax;
     } else {
-      count += values.count();
-      if (isFinite(mean) && isFinite(values.mean())) {
+      count += otherCount;
+      if (isFinite(mean) && isFinite(otherMean)) {
         // This is a generalized version of the calculation in add(double) above.
-        double delta = values.mean() - mean;
-        mean += delta * values.count() / count;
-        sumOfSquaresOfDeltas +=
-            values.sumOfSquaresOfDeltas() + delta * (values.mean() - mean) * values.count();
+        double delta = otherMean - mean;
+        mean += delta * otherCount / count;
+        sumOfSquaresOfDeltas += otherSumOfSquaresOfDeltas + delta * (otherMean - mean) * otherCount;
       } else {
-        mean = calculateNewMeanNonFinite(mean, values.mean());
+        mean = calculateNewMeanNonFinite(mean, otherMean);
         sumOfSquaresOfDeltas = NaN;
       }
-      min = Math.min(min, values.min());
-      max = Math.max(max, values.max());
+      min = Math.min(min, otherMin);
+      max = Math.max(max, otherMax);
     }
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add Stream support to Stats and StatsAccumulator.

This adds:
 - A static method Stats.toStats() that returns a Collector<Number, StatsAccumulator, Stats>.
 - Stats.of overloads and StatsAccumulator.addAll overloads that take DoubleStream, IntStream, and LongStream.
 - A StatsAccumulator.addAll overload that takes StatsAccumulator.

(In passing, this also improves the tests in a couple of ways. It removes the use of static initializer blocks in StatsTesting, which is contrary to best practice. And it fixes some tolerances on the assertions: the min() and max() ones should use exact equality, and the ones with INTEGER_MANY_VALUES and LONG_MANY_VALUES should scale up the tolerance to match the order of magnitude of the values. This latter change fixes the ErrorProne warnings that, in some cases, the tolerance was actually less than the difference between the expected value and the next nearest double. It just happened that everything was close enough before.)

RELNOTES=Add Stream support to Stats and StatsAccumulator.

a59e12a3cdfb3d6cd11343aa5bd7aa3de27ed30d",Moe Sync
3658,Kurt Alfred Kluever,"['android/guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/Converter.java']","@@ -484,7 +484,7 @@ public String toString() {
    * ""pass-through type"".
    */
   private static final class IdentityConverter<T> extends Converter<T, T> implements Serializable {
-    static final IdentityConverter INSTANCE = new IdentityConverter();
+    static final IdentityConverter<?> INSTANCE = new IdentityConverter<>();
 
     @Override
     protected T doForward(T t) {, @@ -482,7 +482,7 @@ public String toString() {
    * ""pass-through type"".
    */
   private static final class IdentityConverter<T> extends Converter<T, T> implements Serializable {
-    static final IdentityConverter INSTANCE = new IdentityConverter();
+    static final IdentityConverter<?> INSTANCE = new IdentityConverter<>();
 
     @Override
     protected T doForward(T t) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Resolve some rawtypes warnings in Converter

4e37244fb859e1f99ce3356ffab5b2e8333ad268",Moe Sync
3664,Kurt Alfred Kluever,"['android/guava/src/com/google/common/io/ByteStreams.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -816,7 +816,8 @@ public static void skipFully(InputStream in, long n) throws IOException {
    */
   static long skipUpTo(InputStream in, final long n) throws IOException {
     long totalSkipped = 0;
-    byte[] buf = createBuffer();
+    // A buffer is allocated if skipSafely does not skip any bytes.
+    byte[] buf = null;
 
     while (totalSkipped < n) {
       long remaining = n - totalSkipped;
@@ -825,7 +826,13 @@ static long skipUpTo(InputStream in, final long n) throws IOException {
       if (skipped == 0) {
         // Do a buffered read since skipSafely could return 0 repeatedly, for example if
         // in.available() always returns 0 (the default).
-        int skip = (int) Math.min(remaining, buf.length);
+        int skip = (int) Math.min(remaining, BUFFER_SIZE);
+        if (buf == null) {
+          // Allocate a buffer bounded by the maximum size that can be requested, for
+          // example an array of BUFFER_SIZE is unnecessary when the value of remaining
+          // is smaller.
+          buf = new byte[skip];
+        }
         if ((skipped = in.read(buf, 0, skip)) == -1) {
           // Reached EOF
           break;, @@ -816,7 +816,8 @@ public static void skipFully(InputStream in, long n) throws IOException {
    */
   static long skipUpTo(InputStream in, final long n) throws IOException {
     long totalSkipped = 0;
-    byte[] buf = createBuffer();
+    // A buffer is allocated if skipSafely does not skip any bytes.
+    byte[] buf = null;
 
     while (totalSkipped < n) {
       long remaining = n - totalSkipped;
@@ -825,7 +826,13 @@ static long skipUpTo(InputStream in, final long n) throws IOException {
       if (skipped == 0) {
         // Do a buffered read since skipSafely could return 0 repeatedly, for example if
         // in.available() always returns 0 (the default).
-        int skip = (int) Math.min(remaining, buf.length);
+        int skip = (int) Math.min(remaining, BUFFER_SIZE);
+        if (buf == null) {
+          // Allocate a buffer bounded by the maximum size that can be requested, for
+          // example an array of BUFFER_SIZE is unnecessary when the value of remaining
+          // is smaller.
+          buf = new byte[skip];
+        }
         if ((skipped = in.read(buf, 0, skip)) == -1) {
           // Reached EOF
           break;, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix ByteStreams.skipUpTo to avoid making unnecessary allocations.

- Fixes https://github.com/google/guava/issues/3662
- Closes https://github.com/google/guava/issues/3663

cb0ac2bf8a3a95862b1209fe11a35403554ca611",Moe Sync
3666,Colin Decker,"['android/guava/pom.xml', 'guava/pom.xml']","@@ -173,7 +173,7 @@
   </build>
   <profiles>
     <profile>
-      <id>srczip</id>
+      <id>srczip-parent</id>
       <activation>
         <file>
           <exists>${java.home}/../src.zip</exists>
@@ -190,5 +190,23 @@
         </dependency>
       </dependencies>
     </profile>
+    <profile>
+      <id>srczip-base</id>
+      <activation>
+        <file>
+          <exists>${java.home}/src.zip</exists>
+        </file>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>jdk</groupId>
+          <artifactId>srczip</artifactId>
+          <version>999</version>
+          <scope>system</scope>
+          <systemPath>${java.home}/src.zip</systemPath>
+          <optional>true</optional>
+        </dependency>
+      </dependencies>
+    </profile>
   </profiles>
 </project>, @@ -173,7 +173,7 @@
   </build>
   <profiles>
     <profile>
-      <id>srczip</id>
+      <id>srczip-parent</id>
       <activation>
         <file>
           <exists>${java.home}/../src.zip</exists>
@@ -190,5 +190,23 @@
         </dependency>
       </dependencies>
     </profile>
+    <profile>
+      <id>srczip-base</id>
+      <activation>
+        <file>
+          <exists>${java.home}/src.zip</exists>
+        </file>
+      </activation>
+      <dependencies>
+        <dependency>
+          <groupId>jdk</groupId>
+          <artifactId>srczip</artifactId>
+          <version>999</version>
+          <scope>system</scope>
+          <systemPath>${java.home}/src.zip</systemPath>
+          <optional>true</optional>
+        </dependency>
+      </dependencies>
+    </profile>
   </profiles>
 </project>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix ImmutableList#of Javadoc

Fixes #3561

a14d317807e63770c5e57a4307cd1e69ea233ba0

-------

<p> Attempt to fix inheriting Javadoc from the JDK again.

It's currently missing:
https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedInteger.html#equals-java.lang.Object-

But I haven't managed to reproduce the problem locally.

I'm trying this on the theory that java.home might be pointing to the JDK (the top-level directory in which src.zip lives) rather than the JRE (a subdirectory).

Note that JDK11 has src.zip in a lib/ subdirectory. I tried adding it to a Java 11 build of Guava, but things blew up because the JDK contains module declarations, which naturally are incompatible with our -source 8. Possibly the right fix there is to avoid -source 8 in favor of the approach I used for jimfs in CL 272937179 -- except that maybe I already tried that and it wasn't sufficient? I'm happy to punt on that for now, especially since I just tried removing -source 8 and got a bunch of ""too many module declarations found"" errors :)

4c83832db7e6ae8d0cd351fac7fe28f4116ef0de",Moe Sync
3668,Colin Decker,"['android/pom.xml', 'guava-gwt/pom.xml', 'pom.xml']","@@ -122,11 +122,6 @@
         <plugin>
           <artifactId>maven-jar-plugin</artifactId>
           <version>3.0.2</version>
-          <configuration>
-            <excludes>
-              <exclude>**/ForceGuavaCompilation*</exclude>
-            </excludes>
-          </configuration>
         </plugin>
         <plugin>
           <artifactId>maven-source-plugin</artifactId>
@@ -138,11 +133,6 @@
               <goals><goal>jar</goal></goals>
             </execution>
           </executions>
-          <configuration>
-            <excludes>
-              <exclude>**/ForceGuavaCompilation*</exclude>
-            </excludes>
-          </configuration>
         </plugin>
         <plugin>
           <groupId>org.codehaus.mojo</groupId>, @@ -109,15 +109,39 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <excludes>
+            <!-- Yes, we want to exclude this 3 times: -->
+            <!-- 1. Don't compile it (since that requires a *non-test* dep on gwt-user. -->
+            <exclude>**/ForceGuavaCompilation*</exclude>
+          </excludes>
+        </configuration>
       </plugin>
       <plugin>
         <artifactId>maven-jar-plugin</artifactId>
+        <configuration>
+          <excludes>
+            <!-- 2. Don't include the source in the jar (since that would let users depend on it from GWT client code, which is compiled from source). -->
+            <exclude>**/ForceGuavaCompilation*</exclude>
+          </excludes>
+        </configuration>
       </plugin>
       <plugin>
         <artifactId>maven-source-plugin</artifactId>
+        <configuration>
+          <excludes>
+            <!-- 3. Don't include it in the source jar (since it's really more of a ""test"" than it is production code). -->
+            <exclude>**/ForceGuavaCompilation*</exclude>
+          </excludes>
+        </configuration>
       </plugin>
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <!-- No meaningful public classes, just sources for the GWT compiler, some internal serialization classes, and dummy entry-point class to force compilation. -->
+          <!-- And soon, the serialization classes will be going away, and the entry point won't compile after we move gwt-user to test scope. -->
+          <skip>true</skip>
+        </configuration>
       </plugin>
       <!-- Disable ""normal"" testing, which doesn't work for GWT tests. -->
       <plugin>, @@ -123,11 +123,6 @@
         <plugin>
           <artifactId>maven-jar-plugin</artifactId>
           <version>3.0.2</version>
-          <configuration>
-            <excludes>
-              <exclude>**/ForceGuavaCompilation*</exclude>
-            </excludes>
-          </configuration>
         </plugin>
         <plugin>
           <artifactId>maven-source-plugin</artifactId>
@@ -139,11 +134,6 @@
               <goals><goal>jar</goal></goals>
             </execution>
           </executions>
-          <configuration>
-            <excludes>
-              <exclude>**/ForceGuavaCompilation*</exclude>
-            </excludes>
-          </configuration>
         </plugin>
         <plugin>
           <groupId>org.codehaus.mojo</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add ElementOrder.stable().

e5f03e5f8f94cb15cc931eda2f17121af5c4a864

-------

<p> Use int[] for entries and byte[]/short[]/int[] for hashtable

The entries array containing the hash and next index was reduced from a long[]
to int[]. This is achieved by storing only the bits of the hash not covered by
the hashtable mask; the bits covered by the hashtable mask are implied-by and
can be inferred-from the hashtable bucket index. By ensuring that next pointers
are always less than or equal to the hashtable mask, everything needed can be
packed into an int[]. Inferring the missing hash bits from the hashtable bucket
index is only required for rehashing (the hashtable bucket chains must be
walked) and is the source of the slowdown for unsized instances.

The hashtable is created as a byte[]/short[]/int[] based on size, stored as an
Object, and cast to the correct type using instanceof checks.

Android performance impact varies but stays within +/-15% (average: 3% better).
JVM performance impact generally stays within +/-15% but unsized instances are
up to 42% worse (average: 5% worse).

CompactHashSet Android memory usage:
byte[] sizes (1-255): 14-48% better (average: 43% better)
short[] sizes (256-65535): 24-40% better (average: 38% better)
int[] sizes (65536+): 0-25% better (average: 22% better)

CompactHashMap Android memory usage:
byte[] sizes (1-255): 10-40% better (average: 34% better)
short[] sizes (255-65535): 19-33% better (average: 31% better)
int[] sizes (65536+): 0-20% better (average: 18% better)

Effects on CompactHashSetProGuard:
12817 bytes => 14189 bytes (+11%)
3 classes => 3 classes (0%)
39 methods => 44 methods (+13%)

Effects on CompactHashMapProGuard:
19133 bytes => 21883 bytes (+14%)
11 classes => 11 classes (0%)
75 methods => 83 methods (+11%)

d1ebe51111e9c54be3ccf4ac3fbf5bbd02805b07

-------

<p> Fix Javadoc errors (and sometimes warnings).

These are mostly (perhaps entirely) problems new with Java 11's javadoc (or at least with Java 9+).

cc2f4e68bd5a68309d0cd875ee55afea1ed3774f

-------

<p> Make inheriting Javadoc from the JDK work under JDK11.

131e1b69dc7b193985691c1bb1bbbb5bb4bc027e

-------

<p> Prepare to move gwt-user to test scope after we remove GWT-RPC support.

When we do that, we'll no longer be able to compile ForceGuavaCompilationEntryPoint as part of the normal javac compile or build its Javadoc (because of the ""missing"" dependency).
(ForceGuavaCompilationEntryPoint lives under the main (i.e., non-test) sources because we want to ensure that our prod code compiles without any dependencies added by our tests.)

So exclude it from the javac compile, and turn off building Javadoc altogether. (Javadoc already isn't useful for guava-gwt, since it covers only ForceGuavaCompilationEntryPoint and the internal serialization classes. Once the serialization classes go away and ForceGuavaCompilationEntryPoint is hidden, we would get an error from Javadoc because it wouldn't find *any* sources.)

Removing ForceGuavaCompilationEntryPoint from the javac compile is fine: I've verified that the GWT compiler still runs and identifies any GWT compilation errors. And I've diffed the resulting GWT jars.

While here, I moved some GWT-specific configuration into the guava-gwt pom.xml.

Relevant to https://github.com/google/truth/issues/637

bb737f0dbeb8d246be046c97f50bf3a9992048f4",Moe Sync
3674,Colin Decker,['README.md'],"@@ -21,8 +21,8 @@ Guava's Maven group ID is `com.google.guava` and its artifact ID is `guava`.
 Guava provides two different ""flavors"": one for use on a (Java 8+) JRE and one
 for use on Android or Java 7 or by any library that wants to be compatible with
 either of those. These flavors are specified in the Maven version field as
-either `28.1-jre` or `28.1-android`. For more about depending on
-Guava, see [using Guava in your build].
+either `28.1-jre` or `28.1-android`. For more about depending on Guava, see
+[using Guava in your build].
 
 To add a dependency on Guava using Maven, use the following:
 
@@ -72,7 +72,8 @@ flavor.
 ## Learn about Guava
 
 -   Our users' guide, [Guava Explained]
-- [A nice collection](http://www.tfnico.com/presentations/google-guava) of other helpful links
+-   [A nice collection](http://www.tfnico.com/presentations/google-guava) of
+    other helpful links
 
 ## Links
 
@@ -84,36 +85,34 @@ flavor.
 
 ## IMPORTANT WARNINGS
 
-1. APIs marked with the `@Beta` annotation at the class or method level
-are subject to change. They can be modified in any way, or even
-removed, at any time. If your code is a library itself (i.e. it is
-used on the CLASSPATH of users outside your own control), you should
-not use beta APIs, unless you [repackage] them. **If your
-code is a library, we strongly recommend using the [Guava Beta Checker] to
-ensure that you do not use any `@Beta` APIs!**
+1.  APIs marked with the `@Beta` annotation at the class or method level are
+    subject to change. They can be modified in any way, or even removed, at any
+    time. If your code is a library itself (i.e. it is used on the CLASSPATH of
+    users outside your own control), you should not use beta APIs, unless you
+    [repackage] them. **If your code is a library, we strongly recommend using
+    the [Guava Beta Checker] to ensure that you do not use any `@Beta` APIs!**
 
 2.  APIs without `@Beta` will remain binary-compatible for the indefinite
-future. (Previously, we sometimes removed such APIs after a deprecation period.
-The last release to remove non-`@Beta` APIs was Guava 21.0.) Even `@Deprecated`
-APIs will remain (again, unless they are `@Beta`). We have no plans to start
-removing things again, but officially, we're leaving our options open in case
-of surprises (like, say, a serious security problem).
+    future. (Previously, we sometimes removed such APIs after a deprecation
+    period. The last release to remove non-`@Beta` APIs was Guava 21.0.) Even
+    `@Deprecated` APIs will remain (again, unless they are `@Beta`). We have no
+    plans to start removing things again, but officially, we're leaving our
+    options open in case of surprises (like, say, a serious security problem).
 
 3.  Guava has one dependency that is needed at runtime:
-`com.google.guava:failureaccess:1.0.1`
+    `com.google.guava:failureaccess:1.0.1`
 
 4.  Serialized forms of ALL objects are subject to change unless noted
-otherwise. Do not persist these and assume they can be read by a
-future version of the library.
+    otherwise. Do not persist these and assume they can be read by a future
+    version of the library.
 
-5. Our classes are not designed to protect against a malicious caller.
-You should not use them for communication between trusted and
-untrusted code.
+5.  Our classes are not designed to protect against a malicious caller. You
+    should not use them for communication between trusted and untrusted code.
 
-6. For the mainline flavor, we unit-test the libraries using only OpenJDK 1.8 on
-Linux. Some features, especially in `com.google.common.io`, may not work
-correctly in other environments. For the Android flavor, our unit tests run on
-API level 15 (Ice Cream Sandwich).
+6.  For the mainline flavor, we unit-test the libraries using only OpenJDK 1.8
+    on Linux. Some features, especially in `com.google.common.io`, may not work
+    correctly in other environments. For the Android flavor, our unit tests run
+    on API level 15 (Ice Cream Sandwich).
 
 [guava-snapshot-api-docs]: https://google.github.io/guava/releases/snapshot-jre/api/docs/
 [guava-snapshot-api-diffs]: https://google.github.io/guava/releases/snapshot-jre/api/diffs/, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Rollback

*** Reason for rollback ***

Didn't work: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedInteger.html#equals-java.lang.Object-

*** Original change description ***

Attempt to fix inheriting Javadoc from the JDK again.

It's currently missing:
https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/primitives/UnsignedInteger.html#equals-java.lang.Object-

But I haven't managed to reproduce the problem locally.

I'm trying this on the theory that java.home might be pointing to the JDK (the top-level directory in which src.zip lives) rather than the JRE (a subdirectory).

Note that JDK11 has src.zip in a lib/ subdirectory. I tried adding it to a Ja...

***

5b6537baac6ae0569b9411e578c8d37f75cc716a

-------

<p> Update 'adding Guava to your build using Gradle' snippet

The notation with brackets - () - and double quotes - "" - is valid
in both Gradle's Groovy and Kotlin DSL.

The ""compile"" configuration is already discouraged since some time and
officially deprecated with Gradle 6.

Fixes #3673

f4866c6d50df1551a75986b1bb5d34b9245634d1

-------

<p> Format README.md.

c850b5742a68be52b5d08a7fdf544627088beb4d",Moe Sync
3675,David P. Baker,"['android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureFallbackAtomicHelperTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'android/guava/src/com/google/common/util/concurrent/CombinedFuture.java', 'guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureFallbackAtomicHelperTest.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureTest.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'guava/src/com/google/common/util/concurrent/CombinedFuture.java']","@@ -39,7 +39,7 @@
  * </ul>
  *
  * To force selection of our fallback strategies we load {@link AbstractFuture} (and all of {@code
- * com.google.common.util.concurrent} in degenerate class loaders which make certain platform
+ * com.google.common.util.concurrent}) in degenerate class loaders which make certain platform
  * classes unavailable. Then we construct a test suite so we can run the normal AbstractFutureTest
  * test methods in these degenerate classloaders.
  */, @@ -290,8 +290,8 @@ public String pendingToString() {
     testFuture3.setFuture(testFuture2);
     assertThat(testFuture3.toString())
         .matches(
-            ""[^\\[]+\\[status=PENDING, info=\\[setFuture=""
-                + ""\\[[^\\[]+\\[status=PENDING, info=\\[cause=\\[Someday...\\]\\]\\]\\]\\]\\]"");
+            ""[^\\[]+\\[status=PENDING, setFuture=\\[[^\\[]+\\[status=PENDING,""
+                + "" info=\\[cause=\\[Someday...]]]]]"");
     testFuture2.set(""result string"");
     assertThat(testFuture3.toString())
         .matches(""[^\\[]+\\[status=SUCCESS, result=\\[result string\\]\\]"");
@@ -886,7 +886,7 @@ public void testSetFutureSelf_cancel() {
   public void testSetFutureSelf_toString() {
     SettableFuture<String> orig = SettableFuture.create();
     orig.setFuture(orig);
-    assertThat(orig.toString()).contains(""[status=PENDING, info=[setFuture=[this future]]]"");
+    assertThat(orig.toString()).contains(""[status=PENDING, setFuture=[this future]]"");
   }
 
   public void testSetSelf_toString() {, @@ -799,26 +799,23 @@ public void testTransformAsync_functionToString() throws Exception {
     final CountDownLatch functionCalled = new CountDownLatch(1);
     final CountDownLatch functionBlocking = new CountDownLatch(1);
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            functionCalled.countDown();
-            functionBlocking.await();
-            return immediateFuture(null);
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                functionCalled.countDown();
+                functionBlocking.await();
+                return immediateFuture(null);
+              }
+            });
 
     ExecutorService executor = Executors.newSingleThreadExecutor();
     try {
       ListenableFuture<?> output =
           Futures.transformAsync(immediateFuture(null), function, executor);
       functionCalled.await();
-      assertThat(output.toString()).contains(""Called my toString"");
+      assertThat(output.toString()).contains(function.toString());
     } finally {
       functionBlocking.countDown();
       executor.shutdown();
@@ -1171,27 +1168,24 @@ public void testCatchingAsync_functionToString() throws Exception {
     final CountDownLatch functionCalled = new CountDownLatch(1);
     final CountDownLatch functionBlocking = new CountDownLatch(1);
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            functionCalled.countDown();
-            functionBlocking.await();
-            return immediateFuture(null);
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                functionCalled.countDown();
+                functionBlocking.await();
+                return immediateFuture(null);
+              }
+            });
 
     ExecutorService executor = Executors.newSingleThreadExecutor();
     try {
       ListenableFuture<?> output =
           Futures.catchingAsync(
               immediateFailedFuture(new RuntimeException()), Throwable.class, function, executor);
       functionCalled.await();
-      assertThat(output.toString()).contains(""Called my toString"");
+      assertThat(output.toString()).contains(function.toString());
     } finally {
       functionBlocking.countDown();
       executor.shutdown();
@@ -1201,17 +1195,14 @@ public String toString() {
   public void testCatchingAsync_futureToString() throws Exception {
     final SettableFuture<Object> toReturn = SettableFuture.create();
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            return toReturn;
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                return toReturn;
+              }
+            });
 
     ListenableFuture<?> output =
         Futures.catchingAsync(
@@ -2590,25 +2581,66 @@ public String call() throws Exception {
     unused = whenAllComplete(asList(futures)).call(combiner, directExecutor());
   }
 
+  @GwtIncompatible // threads
+
   public void testWhenAllComplete_asyncResult() throws Exception {
-    final SettableFuture<Integer> futureInteger = SettableFuture.create();
-    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
+    SettableFuture<Integer> futureInteger = SettableFuture.create();
+    SettableFuture<Boolean> futureBoolean = SettableFuture.create();
+
+    final ExecutorService executor = newSingleThreadExecutor();
+    final CountDownLatch callableBlocking = new CountDownLatch(1);
+    final SettableFuture<String> resultOfCombiner = SettableFuture.create();
     AsyncCallable<String> combiner =
-        new AsyncCallable<String>() {
-          @Override
-          public ListenableFuture<String> call() throws Exception {
-            return immediateFuture(
-                createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncCallable<String>() {
+              @Override
+              public ListenableFuture<String> call() throws Exception {
+                // Make this executor terminate after this task so that the test can tell when
+                // futureResult has received resultOfCombiner.
+                executor.shutdown();
+                callableBlocking.await();
+                return resultOfCombiner;
+              }
+            });
 
     ListenableFuture<String> futureResult =
-        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
+        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, executor);
+
+    // Waiting on backing futures
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" info=\\[futures=\\[\\S+SettableFuture@\\w+\\[status=PENDING],""
+                + "" \\S+SettableFuture@\\w+\\[status=PENDING]]]]"");
     Integer integerPartial = 1;
     futureInteger.set(integerPartial);
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" info=\\[futures=\\[\\S+SettableFuture@\\w+\\[status=SUCCESS, result=\\[1]],""
+                + "" \\S+SettableFuture@\\w+\\[status=PENDING]]]]"");
+
+    // Backing futures complete
     Boolean booleanPartial = true;
     futureBoolean.set(booleanPartial);
-    assertEquals(createCombinedResult(integerPartial, booleanPartial), getDone(futureResult));
+    // Once the backing futures are done there's a (brief) moment where we know nothing
+    assertThat(futureResult.toString()).matches(""\\S+CombinedFuture@\\w+\\[status=PENDING]"");
+    callableBlocking.countDown();
+    // Need to wait for resultFuture to be returned.
+    assertTrue(executor.awaitTermination(10, SECONDS));
+    // But once the async function has returned a future we can include that in the toString
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" setFuture=\\[\\S+SettableFuture@\\w+\\[status=PENDING]]]"");
+
+    // Future complete
+    resultOfCombiner.set(createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
+    String expectedResult = createCombinedResult(integerPartial, booleanPartial);
+    assertEquals(expectedResult, futureResult.get());
+    assertThat(futureResult.toString())
+        .matches(""\\S+CombinedFuture@\\w+\\[status=SUCCESS, result=\\["" + expectedResult + ""]]"");
   }
 
   public void testWhenAllComplete_asyncError() throws Exception {
@@ -3894,4 +3926,34 @@ public void execute(Runnable runnable) {
       }
     };
   }
+
+  private static <I, O> AsyncFunction<I, O> tagged(
+      final String toString, final AsyncFunction<I, O> function) {
+    return new AsyncFunction<I, O>() {
+      @Override
+      public ListenableFuture<O> apply(I input) throws Exception {
+        return function.apply(input);
+      }
+
+      @Override
+      public String toString() {
+        return toString;
+      }
+    };
+  }
+
+  private static <V> AsyncCallable<V> tagged(
+      final String toString, final AsyncCallable<V> callable) {
+    return new AsyncCallable<V>() {
+      @Override
+      public ListenableFuture<V> call() throws Exception {
+        return callable.call();
+      }
+
+      @Override
+      public String toString() {
+        return toString;
+      }
+    };
+  }
 }, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.base.Strings;
 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
 import com.google.common.util.concurrent.internal.InternalFutures;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -1064,46 +1065,62 @@ public String toString() {
     } else if (isDone()) {
       addDoneString(builder);
     } else {
-      String pendingDescription;
-      try {
-        pendingDescription = pendingToString();
-      } catch (RuntimeException e) {
-        // Don't call getMessage or toString() on the exception, in case the exception thrown by the
-        // subclass is implemented with bugs similar to the subclass.
-        pendingDescription = ""Exception thrown from implementation: "" + e.getClass();
-      }
-      // The future may complete during or before the call to getPendingToString, so we use null
-      // as a signal that we should try checking if the future is done again.
-      if (pendingDescription != null && !pendingDescription.isEmpty()) {
-        builder.append(""PENDING, info=["").append(pendingDescription).append(""]"");
-      } else if (isDone()) {
-        addDoneString(builder);
-      } else {
-        builder.append(""PENDING"");
-      }
+      addPendingString(builder); // delegates to addDoneString if future completes mid-way
     }
     return builder.append(""]"").toString();
   }
 
   /**
    * Provide a human-readable explanation of why this future has not yet completed.
    *
-   * @return null if an explanation cannot be provided because the future is done.
+   * @return null if an explanation cannot be provided (e.g. because the future is done).
    * @since 23.0
    */
   @NullableDecl
   protected String pendingToString() {
-    Object localValue = value;
-    if (localValue instanceof SetFuture) {
-      return ""setFuture=["" + userObjectToString(((SetFuture) localValue).future) + ""]"";
-    } else if (this instanceof ScheduledFuture) {
+    // TODO(diamondm) consider moving this into addPendingString so it's always in the output
+    if (this instanceof ScheduledFuture) {
       return ""remaining delay=[""
           + ((ScheduledFuture) this).getDelay(TimeUnit.MILLISECONDS)
           + "" ms]"";
     }
     return null;
   }
 
+  private void addPendingString(StringBuilder builder) {
+    // Be careful not to append to the builder with anything that might be invalidated
+
+    String pendingDescription;
+    try {
+      pendingDescription = Strings.emptyToNull(pendingToString());
+    } catch (RuntimeException e) {
+      // Don't call getMessage or toString() on the exception, in case the exception thrown by the
+      // subclass is implemented with bugs similar to the subclass.
+      pendingDescription = ""Exception thrown from implementation: "" + e.getClass();
+    }
+
+    String setFutureString = null;
+    Object localValue = value;
+    if (localValue instanceof SetFuture) {
+      setFutureString = userObjectToString(((SetFuture) localValue).future);
+    }
+
+    // The future may complete before we reach this point, so we check once more to see if the
+    // future is done
+    if (isDone()) {
+      addDoneString(builder);
+      return;
+    }
+
+    builder.append(""PENDING"");
+    if (pendingDescription != null) {
+      builder.append("", info=["").append(pendingDescription).append(""]"");
+    }
+    if (setFutureString != null) {
+      builder.append("", setFuture=["").append(setFutureString).append(""]"");
+    }
+  }
+
   private void addDoneString(StringBuilder builder) {
     try {
       V value = getUninterruptibly(this);, @@ -90,9 +90,9 @@ protected final void afterDone() {
   protected final String pendingToString() {
     ImmutableCollection<? extends Future<?>> localFutures = futures;
     if (localFutures != null) {
-      return ""futures=["" + localFutures + ""]"";
+      return ""futures="" + localFutures;
     }
-    return null;
+    return super.pendingToString();
   }
 
   /**, @@ -105,7 +105,7 @@ final void execute() {
         listenerExecutor.execute(this);
       } catch (RejectedExecutionException e) {
         if (thrownByExecute) {
-          setException(e);
+          CombinedFuture.this.setException(e);
         }
       }
     }
@@ -127,11 +127,11 @@ final void afterRanInterruptibly(T result, Throwable error) {
 
       if (error != null) {
         if (error instanceof ExecutionException) {
-          setException(error.getCause());
+          CombinedFuture.this.setException(error.getCause());
         } else if (error instanceof CancellationException) {
           cancel(false);
         } else {
-          setException(error);
+          CombinedFuture.this.setException(error);
         }
       } else {
         setValue(result);
@@ -164,7 +164,7 @@ final void afterRanInterruptibly(T result, Throwable error) {
 
     @Override
     void setValue(ListenableFuture<V> value) {
-      setFuture(value);
+      CombinedFuture.this.setFuture(value);
     }
 
     @Override, @@ -3069,33 +3069,6 @@ public void testWhenAllComplete_asyncError() throws Exception {
   }
 }
 
-public void testWhenAllComplete_asyncResult() throws Exception {
-  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
-  testCase.setUp();
-  Throwable failure = null;
-  try {
-    testCase.testWhenAllComplete_asyncResult();
-  } catch (Throwable t) {
-    failure = t;
-  }
-  try {
-    testCase.tearDown();
-  } catch (Throwable t) {
-    if (failure == null) {
-      failure = t;
-    }
-  }
-  if (failure instanceof Exception) {
-    throw (Exception) failure;
-  }
-  if (failure instanceof Error) {
-    throw (Error) failure;
-  }
-  if (failure != null) {
-    throw new RuntimeException(failure);
-  }
-}
-
 public void testWhenAllComplete_runnableError() throws Exception {
   com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
   testCase.setUp();, @@ -39,7 +39,7 @@
  * </ul>
  *
  * To force selection of our fallback strategies we load {@link AbstractFuture} (and all of {@code
- * com.google.common.util.concurrent} in degenerate class loaders which make certain platform
+ * com.google.common.util.concurrent}) in degenerate class loaders which make certain platform
  * classes unavailable. Then we construct a test suite so we can run the normal AbstractFutureTest
  * test methods in these degenerate classloaders.
  */, @@ -290,8 +290,8 @@ public String pendingToString() {
     testFuture3.setFuture(testFuture2);
     assertThat(testFuture3.toString())
         .matches(
-            ""[^\\[]+\\[status=PENDING, info=\\[setFuture=""
-                + ""\\[[^\\[]+\\[status=PENDING, info=\\[cause=\\[Someday...\\]\\]\\]\\]\\]\\]"");
+            ""[^\\[]+\\[status=PENDING, setFuture=\\[[^\\[]+\\[status=PENDING,""
+                + "" info=\\[cause=\\[Someday...]]]]]"");
     testFuture2.set(""result string"");
     assertThat(testFuture3.toString())
         .matches(""[^\\[]+\\[status=SUCCESS, result=\\[result string\\]\\]"");
@@ -886,7 +886,7 @@ public void testSetFutureSelf_cancel() {
   public void testSetFutureSelf_toString() {
     SettableFuture<String> orig = SettableFuture.create();
     orig.setFuture(orig);
-    assertThat(orig.toString()).contains(""[status=PENDING, info=[setFuture=[this future]]]"");
+    assertThat(orig.toString()).contains(""[status=PENDING, setFuture=[this future]]"");
   }
 
   public void testSetSelf_toString() {, @@ -799,26 +799,23 @@ public void testTransformAsync_functionToString() throws Exception {
     final CountDownLatch functionCalled = new CountDownLatch(1);
     final CountDownLatch functionBlocking = new CountDownLatch(1);
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            functionCalled.countDown();
-            functionBlocking.await();
-            return immediateFuture(null);
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                functionCalled.countDown();
+                functionBlocking.await();
+                return immediateFuture(null);
+              }
+            });
 
     ExecutorService executor = Executors.newSingleThreadExecutor();
     try {
       ListenableFuture<?> output =
           Futures.transformAsync(immediateFuture(null), function, executor);
       functionCalled.await();
-      assertThat(output.toString()).contains(""Called my toString"");
+      assertThat(output.toString()).contains(function.toString());
     } finally {
       functionBlocking.countDown();
       executor.shutdown();
@@ -1171,27 +1168,24 @@ public void testCatchingAsync_functionToString() throws Exception {
     final CountDownLatch functionCalled = new CountDownLatch(1);
     final CountDownLatch functionBlocking = new CountDownLatch(1);
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            functionCalled.countDown();
-            functionBlocking.await();
-            return immediateFuture(null);
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                functionCalled.countDown();
+                functionBlocking.await();
+                return immediateFuture(null);
+              }
+            });
 
     ExecutorService executor = Executors.newSingleThreadExecutor();
     try {
       ListenableFuture<?> output =
           Futures.catchingAsync(
               immediateFailedFuture(new RuntimeException()), Throwable.class, function, executor);
       functionCalled.await();
-      assertThat(output.toString()).contains(""Called my toString"");
+      assertThat(output.toString()).contains(function.toString());
     } finally {
       functionBlocking.countDown();
       executor.shutdown();
@@ -1201,17 +1195,14 @@ public String toString() {
   public void testCatchingAsync_futureToString() throws Exception {
     final SettableFuture<Object> toReturn = SettableFuture.create();
     AsyncFunction<Object, Object> function =
-        new AsyncFunction<Object, Object>() {
-          @Override
-          public ListenableFuture<Object> apply(Object input) throws Exception {
-            return toReturn;
-          }
-
-          @Override
-          public String toString() {
-            return ""Called my toString"";
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncFunction<Object, Object>() {
+              @Override
+              public ListenableFuture<Object> apply(Object input) throws Exception {
+                return toReturn;
+              }
+            });
 
     ListenableFuture<?> output =
         Futures.catchingAsync(
@@ -2590,25 +2581,66 @@ public String call() throws Exception {
     unused = whenAllComplete(asList(futures)).call(combiner, directExecutor());
   }
 
+  @GwtIncompatible // threads
+
   public void testWhenAllComplete_asyncResult() throws Exception {
-    final SettableFuture<Integer> futureInteger = SettableFuture.create();
-    final SettableFuture<Boolean> futureBoolean = SettableFuture.create();
+    SettableFuture<Integer> futureInteger = SettableFuture.create();
+    SettableFuture<Boolean> futureBoolean = SettableFuture.create();
+
+    final ExecutorService executor = newSingleThreadExecutor();
+    final CountDownLatch callableBlocking = new CountDownLatch(1);
+    final SettableFuture<String> resultOfCombiner = SettableFuture.create();
     AsyncCallable<String> combiner =
-        new AsyncCallable<String>() {
-          @Override
-          public ListenableFuture<String> call() throws Exception {
-            return immediateFuture(
-                createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
-          }
-        };
+        tagged(
+            ""Called my toString"",
+            new AsyncCallable<String>() {
+              @Override
+              public ListenableFuture<String> call() throws Exception {
+                // Make this executor terminate after this task so that the test can tell when
+                // futureResult has received resultOfCombiner.
+                executor.shutdown();
+                callableBlocking.await();
+                return resultOfCombiner;
+              }
+            });
 
     ListenableFuture<String> futureResult =
-        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, directExecutor());
+        whenAllComplete(futureInteger, futureBoolean).callAsync(combiner, executor);
+
+    // Waiting on backing futures
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" info=\\[futures=\\[\\S+SettableFuture@\\w+\\[status=PENDING],""
+                + "" \\S+SettableFuture@\\w+\\[status=PENDING]]]]"");
     Integer integerPartial = 1;
     futureInteger.set(integerPartial);
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" info=\\[futures=\\[\\S+SettableFuture@\\w+\\[status=SUCCESS, result=\\[1]],""
+                + "" \\S+SettableFuture@\\w+\\[status=PENDING]]]]"");
+
+    // Backing futures complete
     Boolean booleanPartial = true;
     futureBoolean.set(booleanPartial);
-    assertEquals(createCombinedResult(integerPartial, booleanPartial), getDone(futureResult));
+    // Once the backing futures are done there's a (brief) moment where we know nothing
+    assertThat(futureResult.toString()).matches(""\\S+CombinedFuture@\\w+\\[status=PENDING]"");
+    callableBlocking.countDown();
+    // Need to wait for resultFuture to be returned.
+    assertTrue(executor.awaitTermination(10, SECONDS));
+    // But once the async function has returned a future we can include that in the toString
+    assertThat(futureResult.toString())
+        .matches(
+            ""\\S+CombinedFuture@\\w+\\[status=PENDING,""
+                + "" setFuture=\\[\\S+SettableFuture@\\w+\\[status=PENDING]]]"");
+
+    // Future complete
+    resultOfCombiner.set(createCombinedResult(getDone(futureInteger), getDone(futureBoolean)));
+    String expectedResult = createCombinedResult(integerPartial, booleanPartial);
+    assertEquals(expectedResult, futureResult.get());
+    assertThat(futureResult.toString())
+        .matches(""\\S+CombinedFuture@\\w+\\[status=SUCCESS, result=\\["" + expectedResult + ""]]"");
   }
 
   public void testWhenAllComplete_asyncError() throws Exception {
@@ -3894,4 +3926,34 @@ public void execute(Runnable runnable) {
       }
     };
   }
+
+  private static <I, O> AsyncFunction<I, O> tagged(
+      final String toString, final AsyncFunction<I, O> function) {
+    return new AsyncFunction<I, O>() {
+      @Override
+      public ListenableFuture<O> apply(I input) throws Exception {
+        return function.apply(input);
+      }
+
+      @Override
+      public String toString() {
+        return toString;
+      }
+    };
+  }
+
+  private static <V> AsyncCallable<V> tagged(
+      final String toString, final AsyncCallable<V> callable) {
+    return new AsyncCallable<V>() {
+      @Override
+      public ListenableFuture<V> call() throws Exception {
+        return callable.call();
+      }
+
+      @Override
+      public String toString() {
+        return toString;
+      }
+    };
+  }
 }, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.base.Strings;
 import com.google.common.util.concurrent.internal.InternalFutureFailureAccess;
 import com.google.common.util.concurrent.internal.InternalFutures;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -1064,45 +1065,61 @@ public String toString() {
     } else if (isDone()) {
       addDoneString(builder);
     } else {
-      String pendingDescription;
-      try {
-        pendingDescription = pendingToString();
-      } catch (RuntimeException e) {
-        // Don't call getMessage or toString() on the exception, in case the exception thrown by the
-        // subclass is implemented with bugs similar to the subclass.
-        pendingDescription = ""Exception thrown from implementation: "" + e.getClass();
-      }
-      // The future may complete during or before the call to getPendingToString, so we use null
-      // as a signal that we should try checking if the future is done again.
-      if (pendingDescription != null && !pendingDescription.isEmpty()) {
-        builder.append(""PENDING, info=["").append(pendingDescription).append(""]"");
-      } else if (isDone()) {
-        addDoneString(builder);
-      } else {
-        builder.append(""PENDING"");
-      }
+      addPendingString(builder); // delegates to addDoneString if future completes mid-way
     }
     return builder.append(""]"").toString();
   }
 
   /**
    * Provide a human-readable explanation of why this future has not yet completed.
    *
-   * @return null if an explanation cannot be provided because the future is done.
+   * @return null if an explanation cannot be provided (e.g. because the future is done).
    * @since 23.0
    */
   protected @Nullable String pendingToString() {
-    Object localValue = value;
-    if (localValue instanceof SetFuture) {
-      return ""setFuture=["" + userObjectToString(((SetFuture) localValue).future) + ""]"";
-    } else if (this instanceof ScheduledFuture) {
+    // TODO(diamondm) consider moving this into addPendingString so it's always in the output
+    if (this instanceof ScheduledFuture) {
       return ""remaining delay=[""
           + ((ScheduledFuture) this).getDelay(TimeUnit.MILLISECONDS)
           + "" ms]"";
     }
     return null;
   }
 
+  private void addPendingString(StringBuilder builder) {
+    // Be careful not to append to the builder with anything that might be invalidated
+
+    String pendingDescription;
+    try {
+      pendingDescription = Strings.emptyToNull(pendingToString());
+    } catch (RuntimeException e) {
+      // Don't call getMessage or toString() on the exception, in case the exception thrown by the
+      // subclass is implemented with bugs similar to the subclass.
+      pendingDescription = ""Exception thrown from implementation: "" + e.getClass();
+    }
+
+    String setFutureString = null;
+    Object localValue = value;
+    if (localValue instanceof SetFuture) {
+      setFutureString = userObjectToString(((SetFuture) localValue).future);
+    }
+
+    // The future may complete before we reach this point, so we check once more to see if the
+    // future is done
+    if (isDone()) {
+      addDoneString(builder);
+      return;
+    }
+
+    builder.append(""PENDING"");
+    if (pendingDescription != null) {
+      builder.append("", info=["").append(pendingDescription).append(""]"");
+    }
+    if (setFutureString != null) {
+      builder.append("", setFuture=["").append(setFutureString).append(""]"");
+    }
+  }
+
   private void addDoneString(StringBuilder builder) {
     try {
       V value = getUninterruptibly(this);, @@ -90,9 +90,9 @@ protected final void afterDone() {
   protected final String pendingToString() {
     ImmutableCollection<? extends Future<?>> localFutures = futures;
     if (localFutures != null) {
-      return ""futures=["" + localFutures + ""]"";
+      return ""futures="" + localFutures;
     }
-    return null;
+    return super.pendingToString();
   }
 
   /**, @@ -105,7 +105,7 @@ final void execute() {
         listenerExecutor.execute(this);
       } catch (RejectedExecutionException e) {
         if (thrownByExecute) {
-          setException(e);
+          CombinedFuture.this.setException(e);
         }
       }
     }
@@ -127,11 +127,11 @@ final void afterRanInterruptibly(T result, Throwable error) {
 
       if (error != null) {
         if (error instanceof ExecutionException) {
-          setException(error.getCause());
+          CombinedFuture.this.setException(error.getCause());
         } else if (error instanceof CancellationException) {
           cancel(false);
         } else {
-          setException(error);
+          CombinedFuture.this.setException(error);
         }
       } else {
         setValue(result);
@@ -164,7 +164,7 @@ final void afterRanInterruptibly(T result, Throwable error) {
 
     @Override
     void setValue(ListenableFuture<V> value) {
-      setFuture(value);
+      CombinedFuture.this.setFuture(value);
     }
 
     @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Move the SetFuture check into AbstractFuture.toString() and out of pendingToString(), so that even if the latter is overriden we can include the SetFuture detail.

This is useful for futures that initially do some of their own work, but then delegate to setFuture(), as FutureCombiner.callAsync() does.

68bdc31a5cc1ff0dfb3af4003703d93d09ef6485",MOE Sync 2019-10-29
3677,David P. Baker,"['android/guava/src/com/google/common/primitives/UnsignedBytes.java', 'guava/src/com/google/common/primitives/UnsignedBytes.java']","@@ -121,11 +121,11 @@ public static int compare(byte a, byte b) {
   }
 
   /**
-   * Returns the least value present in {@code array}.
+   * Returns the least value present in {@code array}, treating values as unsigned.
    *
    * @param array a <i>nonempty</i> array of {@code byte} values
    * @return the value present in {@code array} that is less than or equal to every other value in
-   *     the array
+   *     the array according to {@link #compare}
    * @throws IllegalArgumentException if {@code array} is empty
    */
   public static byte min(byte... array) {
@@ -141,11 +141,11 @@ public static byte min(byte... array) {
   }
 
   /**
-   * Returns the greatest value present in {@code array}.
+   * Returns the greatest value present in {@code array}, treating values as unsigned.
    *
    * @param array a <i>nonempty</i> array of {@code byte} values
    * @return the value present in {@code array} that is greater than or equal to every other value
-   *     in the array
+   *     in the array according to {@link #compare}
    * @throws IllegalArgumentException if {@code array} is empty
    */
   public static byte max(byte... array) {, @@ -121,11 +121,11 @@ public static int compare(byte a, byte b) {
   }
 
   /**
-   * Returns the least value present in {@code array}.
+   * Returns the least value present in {@code array}, treating values as unsigned.
    *
    * @param array a <i>nonempty</i> array of {@code byte} values
    * @return the value present in {@code array} that is less than or equal to every other value in
-   *     the array
+   *     the array according to {@link #compare}
    * @throws IllegalArgumentException if {@code array} is empty
    */
   public static byte min(byte... array) {
@@ -141,11 +141,11 @@ public static byte min(byte... array) {
   }
 
   /**
-   * Returns the greatest value present in {@code array}.
+   * Returns the greatest value present in {@code array}, treating values as unsigned.
    *
    * @param array a <i>nonempty</i> array of {@code byte} values
    * @return the value present in {@code array} that is greater than or equal to every other value
-   *     in the array
+   *     in the array according to {@link #compare}
    * @throws IllegalArgumentException if {@code array} is empty
    */
   public static byte max(byte... array) {, ","This code has been reviewed and submitted internally. Feel free to discuss on the PR and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix toString exception handling change from 957c37116fb2cc52b2f8b405871b65a84917f2ca.

This is not an ideal code fix but it restores the previous functionality and adds a test that verifies the exception handling logic.

82b7589dfbfc5f2b6f68d6a6a1bb34e4633f4f3c

-------

<p> Handle StackOverflowError from both pendingToString and appendUserObject.

Adds a bunch of tests to validate error handling in toString code
- Verify that a future completing during the toString call results in a done formatted string
- Verify that an exception thrown by pendingToString doesn't cause toString to fail
- Verify that cycles don't cause toString to fail
- Verify that deep chains of SetFuture don't cause toString to fail

RELNOTES=Catch StackOverflowError in AbstractFuture.toString to prevent long chains of futures from failing toString calls.

29981d416d6b4214e65360ad3d932ba0881a4c8f

-------

<p> Update Documentation

Fixes #3507

8a0d6bb345341fc0ba91781070da5b522d4b714b",MOE Sync 2019-10-31
3684,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java', 'android/guava-tests/test/com/google/common/collect/ForwardingMapTest.java', 'guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java', 'guava-tests/test/com/google/common/collect/ForwardingMapTest.java']","@@ -20,8 +20,8 @@
 import static com.google.common.collect.MapMakerInternalMap.Strength.WEAK;
 import static com.google.common.testing.SerializableTester.reserializeAndAssert;
 import static java.util.Arrays.asList;
+import static org.mockito.ArgumentMatchers.isA;
 import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 , @@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import static java.lang.reflect.Modifier.STATIC;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -231,10 +231,10 @@ public void testStandardEntrySet() throws InvocationTargetException {
 
     // These are the methods specified by StandardEntrySet
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsKey(anyObject());
-    verify(map, atLeast(0)).get(anyObject());
+    verify(map, atLeast(0)).containsKey(any());
+    verify(map, atLeast(0)).get(any());
     verify(map, atLeast(0)).isEmpty();
-    verify(map, atLeast(0)).remove(anyObject());
+    verify(map, atLeast(0)).remove(any());
     verify(map, atLeast(0)).size();
     verifyNoMoreInteractions(map);
   }
@@ -259,9 +259,9 @@ public void testStandardKeySet() throws InvocationTargetException {
 
     // These are the methods specified by StandardKeySet
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsKey(anyObject());
+    verify(map, atLeast(0)).containsKey(any());
     verify(map, atLeast(0)).isEmpty();
-    verify(map, atLeast(0)).remove(anyObject());
+    verify(map, atLeast(0)).remove(any());
     verify(map, atLeast(0)).size();
     verify(map, atLeast(0)).entrySet();
     verifyNoMoreInteractions(map);
@@ -287,7 +287,7 @@ public void testStandardValues() throws InvocationTargetException {
 
     // These are the methods specified by StandardValues
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsValue(anyObject());
+    verify(map, atLeast(0)).containsValue(any());
     verify(map, atLeast(0)).isEmpty();
     verify(map, atLeast(0)).size();
     verify(map, atLeast(0)).entrySet();, @@ -20,8 +20,8 @@
 import static com.google.common.collect.MapMakerInternalMap.Strength.WEAK;
 import static com.google.common.testing.SerializableTester.reserializeAndAssert;
 import static java.util.Arrays.asList;
+import static org.mockito.ArgumentMatchers.isA;
 import static org.mockito.Mockito.eq;
-import static org.mockito.Mockito.isA;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 , @@ -17,7 +17,7 @@
 package com.google.common.collect;
 
 import static java.lang.reflect.Modifier.STATIC;
-import static org.mockito.Mockito.anyObject;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
@@ -231,10 +231,10 @@ public void testStandardEntrySet() throws InvocationTargetException {
 
     // These are the methods specified by StandardEntrySet
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsKey(anyObject());
-    verify(map, atLeast(0)).get(anyObject());
+    verify(map, atLeast(0)).containsKey(any());
+    verify(map, atLeast(0)).get(any());
     verify(map, atLeast(0)).isEmpty();
-    verify(map, atLeast(0)).remove(anyObject());
+    verify(map, atLeast(0)).remove(any());
     verify(map, atLeast(0)).size();
     verifyNoMoreInteractions(map);
   }
@@ -259,9 +259,9 @@ public void testStandardKeySet() throws InvocationTargetException {
 
     // These are the methods specified by StandardKeySet
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsKey(anyObject());
+    verify(map, atLeast(0)).containsKey(any());
     verify(map, atLeast(0)).isEmpty();
-    verify(map, atLeast(0)).remove(anyObject());
+    verify(map, atLeast(0)).remove(any());
     verify(map, atLeast(0)).size();
     verify(map, atLeast(0)).entrySet();
     verifyNoMoreInteractions(map);
@@ -287,7 +287,7 @@ public void testStandardValues() throws InvocationTargetException {
 
     // These are the methods specified by StandardValues
     verify(map, atLeast(0)).clear();
-    verify(map, atLeast(0)).containsValue(anyObject());
+    verify(map, atLeast(0)).containsValue(any());
     verify(map, atLeast(0)).isEmpty();
     verify(map, atLeast(0)).size();
     verify(map, atLeast(0)).entrySet();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add @SuppressWarnings(""DoNotMock"") to mocked com.google.common types

@DoNotMock will be added to these types. This change suppresses warnings for current cases where these types are mocked.

13ed6d3846bb3765b19ec06819a215ae93644b6c

-------

<p> Add GraphBuilder.incidentEdgeOrder().

2c1db61cfae457a58554f4390c3907f18f406b6a

-------

<p> Remove usages of deprecated CharMatcher functions

Fixes #3565

213ec90d8647412c4d25870fbc1c8bb3a44798ff

-------

<p> Have ImmutableGraph.Builder set incidentEdgeOrder to stable().

c43a2bf57ccc089bb64f2704321e175a611cdc4b

-------

<p> Migrate org.mockito.Matchers#any* to org.mockito.ArgumentMatchers

The former is deprecated and replaced by the latter in Mockito 2. However, there is a
functional difference: ArgumentMatchers will reject `null` and check the type
if the matcher specified a type (e.g. `any(Class)` or `anyInt()`). `any()` will
remain to accept anything.

All remaining `any(Class)` references are migrated to `nulllable(Class)` to maintain the functionality of Mockito 1.
All remaining `anyString()` references are migrated to `nullable(String.class)` to maintain the functionality of Mockito 1.

3e96e06575ea0bb1e8be61ce2edd57ac9427c71d",MOE Sync 2019-11-06
3686,Kurt Alfred Kluever,"['android/pom.xml', 'pom.xml']","@@ -17,7 +17,7 @@
     <truth.version>0.44</truth.version>
     <animal.sniffer.version>1.18</animal.sniffer.version>
     <maven-javadoc-plugin.version>3.1.0</maven-javadoc-plugin.version>
-    <maven-source-plugin.version>3.1.0</maven-source-plugin.version>
+    <maven-source-plugin.version>3.2.0</maven-source-plugin.version>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
   </properties>
   <issueManagement>
@@ -121,7 +121,7 @@
         </plugin>
         <plugin>
           <artifactId>maven-jar-plugin</artifactId>
-          <version>3.0.2</version>
+          <version>3.2.0</version>
         </plugin>
         <plugin>
           <artifactId>maven-source-plugin</artifactId>, @@ -17,7 +17,7 @@
     <truth.version>0.44</truth.version>
     <animal.sniffer.version>1.18</animal.sniffer.version>
     <maven-javadoc-plugin.version>3.1.0</maven-javadoc-plugin.version>
-    <maven-source-plugin.version>3.1.0</maven-source-plugin.version>
+    <maven-source-plugin.version>3.2.0</maven-source-plugin.version>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
   </properties>
   <issueManagement>
@@ -122,7 +122,7 @@
         </plugin>
         <plugin>
           <artifactId>maven-jar-plugin</artifactId>
-          <version>3.0.2</version>
+          <version>3.2.0</version>
         </plugin>
         <plugin>
           <artifactId>maven-source-plugin</artifactId>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Upgrade maven source plugin from 3.1.0 to 3.2.0
Upgrade maven jar plugin from 3.0.2 to the latest 3.2.0
Maven source and jar plugins both introduced build reproducibility in 3.2.0

See https://github.com/google/guava/pull/3534
See https://github.com/google/guava/pull/3681

5f14dfb3b249c4b153892ecf74627c76c13b501d",MOE Sync 2019-11-07
3690,Kurt Alfred Kluever,"['android/guava/src/com/google/common/util/concurrent/AtomicDouble.java', 'guava/src/com/google/common/util/concurrent/AtomicDouble.java']","@@ -42,10 +42,8 @@
  *
  * <p>It is possible to write a more scalable updater, at the cost of giving up strict atomicity.
  * See for example <a
- * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html"">
- * DoubleAdder</a> and <a
- * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html"">
- * DoubleMaxUpdater</a>.
+ * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java.base/java/util/concurrent/atomic/DoubleAdder.html"">
+ * DoubleAdder</a>.
  *
  * @author Doug Lea
  * @author Martin Buchholz, @@ -44,10 +44,8 @@
  *
  * <p>It is possible to write a more scalable updater, at the cost of giving up strict atomicity.
  * See for example <a
- * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleAdder.html"">
- * DoubleAdder</a> and <a
- * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/jsr166edocs/jsr166e/DoubleMaxUpdater.html"">
- * DoubleMaxUpdater</a>.
+ * href=""http://gee.cs.oswego.edu/dl/jsr166/dist/docs/java.base/java/util/concurrent/atomic/DoubleAdder.html"">
+ * DoubleAdder</a>.
  *
  * @author Doug Lea
  * @author Martin Buchholz, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Simplify some range constraints.

Fixes https://github.com/google/guava/pull/3607.

88ef8691008d0c8c65f06a8eeb6a4e253a7a4868

-------

<p> Add javadoc in attempt to help readers differentiate Futures.allAsList() vs Futures.successfulAsList().

980e6e68b72c1adb89b01862b12fdf554b1d5f33

-------

<p> Fix broken links in AtomicDouble.

See https://github.com/google/guava/pull/3689

6c501c499020db010dd96918c26b3a07a655a1dd",MOE Sync 2019-11-07
3695,Chris Povirk,"['guava-gwt/pom.xml', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/ListenableFuture.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Thenable.java', 'guava-gwt/src/com/google/common/util/concurrent/Concurrent.gwt.xml']","@@ -54,6 +54,11 @@
       <artifactId>guava</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.elemental2</groupId>
+      <artifactId>elemental2-promise</artifactId>
+      <version>1.0.0-RC1</version>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava-testlib</artifactId>, @@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2007 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import elemental2.promise.IThenable;
+import elemental2.promise.Promise;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Future;
+import jsinterop.annotations.JsMethod;
+
+/**
+ * Java super source for ListenableFuture, implementing a structural thenable via a default method.
+ * For restrictions, please refer to the documentation of the then() method.
+ *
+ * <p>This class is not (explicitly) implementing IThenable<V> because ""then"" is overloaded there
+ * and the single parameter version would need to be marked native, which does not seem to be
+ * feasible in interfaces (see ""subclassing a class with overloaded methods"" in jsinterop
+ * documentation).
+ */
+public interface ListenableFuture<V> extends Future<V>, Thenable<V> {
+  void addListener(Runnable listener, Executor executor);
+
+  /** Note that this method is not expected to be overridden. */
+  @JsMethod
+  @Override
+  default <R> IThenable<R> then(
+      IThenable.ThenOnFulfilledCallbackFn<? super V, ? extends R> onFulfilled,
+      IThenable.ThenOnRejectedCallbackFn<? extends R> onRejected) {
+    return new Promise<V>(
+            (resolve, reject) -> {
+              Futures.addCallback(
+                  this,
+                  new FutureCallback<V>() {
+                    @Override
+                    public void onSuccess(V value) {
+                      resolve.onInvoke(value);
+                    }
+
+                    @Override
+                    public void onFailure(Throwable throwable) {
+                      reject.onInvoke(throwable.getBackingJsObject());
+                    }
+                  },
+                  MoreExecutors.directExecutor());
+            })
+        .then(onFulfilled, onRejected);
+  }
+
+  // TODO(b/141673833): If this would work, it would allow us to implement IThenable properly:
+  // default <R> Promise<R> then(IThenable.ThenOnFulfilledCallbackFn<? super V, ? extends R>
+  // onFulfilled) {
+  //   return then(onFulfilled, null);
+  // }
+}, @@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import elemental2.promise.IThenable;
+import jsinterop.annotations.JsPackage;
+import jsinterop.annotations.JsType;
+
+/**
+ * Subset of the elemental2 IThenable interface without the single-parameter overload, which allows
+ * us to implement it using a default implementation in J2cl ListenableFuture.
+ */
+@JsType(isNative = true, namespace = JsPackage.GLOBAL)
+interface Thenable<T> {
+  <V> IThenable<V> then(
+      IThenable.ThenOnFulfilledCallbackFn<? super T, ? extends V> onFulfilled,
+      IThenable.ThenOnRejectedCallbackFn<? extends V> onRejected);
+}, @@ -17,6 +17,7 @@
   <inherits name=""com.google.common.annotations.Annotations""/>
   <inherits name=""com.google.common.base.Base""/>
   <inherits name=""com.google.common.collect.Collect""/>
+  <inherits name=""elemental2.promise.Promise""/>
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Roll forward CL 269313299.

*** Original change description ***

Let ListenableFuture implement thenable via a default interface method in J2CL

639d873cc139a32b270ba5a11a7ceb87cf8460c0",MOE Sync 2019-11-11
3698,Chris Povirk,"['android/guava-tests/test/com/google/common/net/InetAddressesTest.java', 'guava-tests/test/com/google/common/net/InetAddressesTest.java']","@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.NullPointerTester;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
@@ -39,77 +40,77 @@ public void testNulls() {
   }
 
   public void testForStringBogusInput() {
-    String[] bogusInputs = {
-      """",
-      ""016.016.016.016"",
-      ""016.016.016"",
-      ""016.016"",
-      ""016"",
-      ""000.000.000.000"",
-      ""000"",
-      ""0x0a.0x0a.0x0a.0x0a"",
-      ""0x0a.0x0a.0x0a"",
-      ""0x0a.0x0a"",
-      ""0x0a"",
-      ""42.42.42.42.42"",
-      ""42.42.42"",
-      ""42.42"",
-      ""42"",
-      ""42..42.42"",
-      ""42..42.42.42"",
-      ""42.42.42.42."",
-      ""42.42.42.42..."",
-      "".42.42.42.42"",
-      ""...42.42.42.42"",
-      ""42.42.42.-0"",
-      ""42.42.42.+0"",
-      ""."",
-      ""..."",
-      ""bogus"",
-      ""bogus.com"",
-      ""192.168.0.1.com"",
-      ""12345.67899.-54321.-98765"",
-      ""257.0.0.0"",
-      ""42.42.42.-42"",
-      ""3ffe::1.net"",
-      ""3ffe::1::1"",
-      ""1::2::3::4:5"",
-      ""::7:6:5:4:3:2:"", // should end with "":0""
-      "":6:5:4:3:2:1::"", // should begin with ""0:""
-      ""2001::db:::1"",
-      ""FEDC:9878"",
-      ""+1.+2.+3.4"",
-      ""1.2.3.4e0"",
-      ""::7:6:5:4:3:2:1:0"", // too many parts
-      ""7:6:5:4:3:2:1:0::"", // too many parts
-      ""9:8:7:6:5:4:3::2:1"", // too many parts
-      ""0:1:2:3::4:5:6:7"", // :: must remove at least one 0.
-      ""3ffe:0:0:0:0:0:0:0:1"", // too many parts (9 instead of 8)
-      ""3ffe::10000"", // hextet exceeds 16 bits
-      ""3ffe::goog"",
-      ""3ffe::-0"",
-      ""3ffe::+0"",
-      ""3ffe::-1"",
-      "":"",
-      "":::"",
-      ""::1.2.3"",
-      ""::1.2.3.4.5"",
-      ""::1.2.3.4:"",
-      ""1.2.3.4::"",
-      ""2001:db8::1:"",
-      "":2001:db8::1"",
-      "":1:2:3:4:5:6:7"",
-      ""1:2:3:4:5:6:7:"",
-      "":1:2:3:4:5:6:""
-    };
-
-    for (int i = 0; i < bogusInputs.length; i++) {
+    ImmutableSet<String> bogusInputs =
+        ImmutableSet.of(
+            """",
+            ""016.016.016.016"",
+            ""016.016.016"",
+            ""016.016"",
+            ""016"",
+            ""000.000.000.000"",
+            ""000"",
+            ""0x0a.0x0a.0x0a.0x0a"",
+            ""0x0a.0x0a.0x0a"",
+            ""0x0a.0x0a"",
+            ""0x0a"",
+            ""42.42.42.42.42"",
+            ""42.42.42"",
+            ""42.42"",
+            ""42"",
+            ""42..42.42"",
+            ""42..42.42.42"",
+            ""42.42.42.42."",
+            ""42.42.42.42..."",
+            "".42.42.42.42"",
+            ""...42.42.42.42"",
+            ""42.42.42.-0"",
+            ""42.42.42.+0"",
+            ""."",
+            ""..."",
+            ""bogus"",
+            ""bogus.com"",
+            ""192.168.0.1.com"",
+            ""12345.67899.-54321.-98765"",
+            ""257.0.0.0"",
+            ""42.42.42.-42"",
+            ""3ffe::1.net"",
+            ""3ffe::1::1"",
+            ""1::2::3::4:5"",
+            ""::7:6:5:4:3:2:"", // should end with "":0""
+            "":6:5:4:3:2:1::"", // should begin with ""0:""
+            ""2001::db:::1"",
+            ""FEDC:9878"",
+            ""+1.+2.+3.4"",
+            ""1.2.3.4e0"",
+            ""::7:6:5:4:3:2:1:0"", // too many parts
+            ""7:6:5:4:3:2:1:0::"", // too many parts
+            ""9:8:7:6:5:4:3::2:1"", // too many parts
+            ""0:1:2:3::4:5:6:7"", // :: must remove at least one 0.
+            ""3ffe:0:0:0:0:0:0:0:1"", // too many parts (9 instead of 8)
+            ""3ffe::10000"", // hextet exceeds 16 bits
+            ""3ffe::goog"",
+            ""3ffe::-0"",
+            ""3ffe::+0"",
+            ""3ffe::-1"",
+            "":"",
+            "":::"",
+            ""::1.2.3"",
+            ""::1.2.3.4.5"",
+            ""::1.2.3.4:"",
+            ""1.2.3.4::"",
+            ""2001:db8::1:"",
+            "":2001:db8::1"",
+            "":1:2:3:4:5:6:7"",
+            ""1:2:3:4:5:6:7:"",
+            "":1:2:3:4:5:6:"");
+
+    for (String bogusInput : bogusInputs) {
       try {
-        InetAddresses.forString(bogusInputs[i]);
-        fail(""IllegalArgumentException expected for '"" + bogusInputs[i] + ""'"");
+        InetAddresses.forString(bogusInput);
+        fail(""IllegalArgumentException expected for '"" + bogusInput + ""'"");
       } catch (IllegalArgumentException expected) {
       }
-      assertFalse(InetAddresses.isInetAddress(bogusInputs[i]));
+      assertFalse(InetAddresses.isInetAddress(bogusInput));
     }
   }
 
@@ -141,23 +142,21 @@ public void testForStringIPv6Input() throws UnknownHostException {
   }
 
   public void testForStringIPv6EightColons() throws UnknownHostException {
-    String[] eightColons = {
-      ""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"",
-    };
+    ImmutableSet<String> eightColons =
+        ImmutableSet.of(""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"");
 
-    for (int i = 0; i < eightColons.length; i++) {
+    for (String ipString : eightColons) {
       InetAddress ipv6Addr = null;
       // Shouldn't hit DNS, because it's an IP string literal.
-      ipv6Addr = InetAddress.getByName(eightColons[i]);
-      assertEquals(ipv6Addr, InetAddresses.forString(eightColons[i]));
-      assertTrue(InetAddresses.isInetAddress(eightColons[i]));
+      ipv6Addr = InetAddress.getByName(ipString);
+      assertEquals(ipv6Addr, InetAddresses.forString(ipString));
+      assertTrue(InetAddresses.isInetAddress(ipString));
     }
   }
 
   public void testConvertDottedQuadToHex() throws UnknownHostException {
-    String[] ipStrings = {
-      ""7::0.128.0.127"", ""7::0.128.0.128"", ""7::128.128.0.127"", ""7::0.128.128.127""
-    };
+    ImmutableSet<String> ipStrings =
+        ImmutableSet.of(""7::0.128.0.127"", ""7::0.128.0.128"", ""7::128.128.0.127"", ""7::0.128.128.127"");
 
     for (String ipString : ipStrings) {
       // Shouldn't hit DNS, because it's an IP string literal.
@@ -315,34 +314,30 @@ public void testForUriStringBad() {
   }
 
   public void testCompatIPv4Addresses() {
-    String[] nonCompatAddresses = {
-      ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> nonCompatAddresses = ImmutableSet.of(""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < nonCompatAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonCompatAddresses[i]);
+    for (String nonCompatAddress : nonCompatAddresses) {
+      InetAddress ip = InetAddresses.forString(nonCompatAddress);
       assertFalse(InetAddresses.isCompatIPv4Address((Inet6Address) ip));
       try {
         InetAddresses.getCompatIPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonCompatAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonCompatAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
 
-    String[] validCompatAddresses = {
-      ""::1.2.3.4"", ""::102:304"",
-    };
+    ImmutableSet<String> validCompatAddresses = ImmutableSet.of(""::1.2.3.4"", ""::102:304"");
     String compatStr = ""1.2.3.4"";
     InetAddress compat = InetAddresses.forString(compatStr);
 
-    for (int i = 0; i < validCompatAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(validCompatAddresses[i]);
-      assertTrue(""checking '"" + validCompatAddresses[i] + ""'"", ip instanceof Inet6Address);
+    for (String validCompatAddress : validCompatAddresses) {
+      InetAddress ip = InetAddresses.forString(validCompatAddress);
+      assertTrue(""checking '"" + validCompatAddress + ""'"", ip instanceof Inet6Address);
       assertTrue(
-          ""checking '"" + validCompatAddresses[i] + ""'"",
+          ""checking '"" + validCompatAddress + ""'"",
           InetAddresses.isCompatIPv4Address((Inet6Address) ip));
       assertEquals(
-          ""checking '"" + validCompatAddresses[i] + ""'"",
+          ""checking '"" + validCompatAddress + ""'"",
           compat,
           InetAddresses.getCompatIPv4Address((Inet6Address) ip));
     }
@@ -389,16 +384,14 @@ public void testMappedIPv4Addresses() throws UnknownHostException {
   }
 
   public void test6to4Addresses() {
-    String[] non6to4Addresses = {
-      ""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> non6to4Addresses = ImmutableSet.of(""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < non6to4Addresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(non6to4Addresses[i]);
+    for (String non6to4Address : non6to4Addresses) {
+      InetAddress ip = InetAddresses.forString(non6to4Address);
       assertFalse(InetAddresses.is6to4Address((Inet6Address) ip));
       try {
         InetAddresses.get6to4IPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + non6to4Addresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + non6to4Address + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
@@ -413,16 +406,14 @@ public void test6to4Addresses() {
   }
 
   public void testTeredoAddresses() {
-    String[] nonTeredoAddresses = {
-      ""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> nonTeredoAddresses = ImmutableSet.of(""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < nonTeredoAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonTeredoAddresses[i]);
+    for (String nonTeredoAddress : nonTeredoAddresses) {
+      InetAddress ip = InetAddresses.forString(nonTeredoAddress);
       assertFalse(InetAddresses.isTeredoAddress((Inet6Address) ip));
       try {
         InetAddresses.getTeredoInfo((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonTeredoAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonTeredoAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
@@ -457,37 +448,39 @@ public void testTeredoAddress_nullServer() {
 
   public void testIsatapAddresses() {
     InetAddress ipv4 = InetAddresses.forString(""1.2.3.4"");
-    String[] validIsatapAddresses = {
-      ""2001:db8::5efe:102:304"",
-      ""2001:db8::100:5efe:102:304"", // Private Multicast? Not likely.
-      ""2001:db8::200:5efe:102:304"",
-      ""2001:db8::300:5efe:102:304"" // Public Multicast? Also unlikely.
-    };
-    String[] nonIsatapAddresses = {
-      ""::1.2.3.4"",
-      ""3ffe::1"",
-      ""::"",
-      ""::1"",
-      ""2001:db8::0040:5efe:102:304"",
-      ""2001:db8::5ffe:102:304"",
-      ""2001:db8::5eff:102:304"",
-      ""2001:0:102:203:200:5efe:506:708"", // Teredo address; not ISATAP
-    };
-
-    for (int i = 0; i < validIsatapAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(validIsatapAddresses[i]);
+    ImmutableSet<String> validIsatapAddresses =
+        ImmutableSet.of(
+            ""2001:db8::5efe:102:304"",
+            ""2001:db8::100:5efe:102:304"", // Private Multicast? Not likely.
+            ""2001:db8::200:5efe:102:304"",
+            ""2001:db8::300:5efe:102:304"" // Public Multicast? Also unlikely.
+            );
+    ImmutableSet<String> nonIsatapAddresses =
+        ImmutableSet.of(
+            ""::1.2.3.4"",
+            ""3ffe::1"",
+            ""::"",
+            ""::1"",
+            ""2001:db8::0040:5efe:102:304"",
+            ""2001:db8::5ffe:102:304"",
+            ""2001:db8::5eff:102:304"",
+            ""2001:0:102:203:200:5efe:506:708"" // Teredo address; not ISATAP
+            );
+
+    for (String validIsatapAddress : validIsatapAddresses) {
+      InetAddress ip = InetAddresses.forString(validIsatapAddress);
       assertTrue(InetAddresses.isIsatapAddress((Inet6Address) ip));
       assertEquals(
-          ""checking '"" + validIsatapAddresses[i] + ""'"",
+          ""checking '"" + validIsatapAddress + ""'"",
           ipv4,
           InetAddresses.getIsatapIPv4Address((Inet6Address) ip));
     }
-    for (int i = 0; i < nonIsatapAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonIsatapAddresses[i]);
+    for (String nonIsatapAddress : nonIsatapAddresses) {
+      InetAddress ip = InetAddresses.forString(nonIsatapAddress);
       assertFalse(InetAddresses.isIsatapAddress((Inet6Address) ip));
       try {
         InetAddresses.getIsatapIPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonIsatapAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonIsatapAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }, @@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.NullPointerTester;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
@@ -39,77 +40,77 @@ public void testNulls() {
   }
 
   public void testForStringBogusInput() {
-    String[] bogusInputs = {
-      """",
-      ""016.016.016.016"",
-      ""016.016.016"",
-      ""016.016"",
-      ""016"",
-      ""000.000.000.000"",
-      ""000"",
-      ""0x0a.0x0a.0x0a.0x0a"",
-      ""0x0a.0x0a.0x0a"",
-      ""0x0a.0x0a"",
-      ""0x0a"",
-      ""42.42.42.42.42"",
-      ""42.42.42"",
-      ""42.42"",
-      ""42"",
-      ""42..42.42"",
-      ""42..42.42.42"",
-      ""42.42.42.42."",
-      ""42.42.42.42..."",
-      "".42.42.42.42"",
-      ""...42.42.42.42"",
-      ""42.42.42.-0"",
-      ""42.42.42.+0"",
-      ""."",
-      ""..."",
-      ""bogus"",
-      ""bogus.com"",
-      ""192.168.0.1.com"",
-      ""12345.67899.-54321.-98765"",
-      ""257.0.0.0"",
-      ""42.42.42.-42"",
-      ""3ffe::1.net"",
-      ""3ffe::1::1"",
-      ""1::2::3::4:5"",
-      ""::7:6:5:4:3:2:"", // should end with "":0""
-      "":6:5:4:3:2:1::"", // should begin with ""0:""
-      ""2001::db:::1"",
-      ""FEDC:9878"",
-      ""+1.+2.+3.4"",
-      ""1.2.3.4e0"",
-      ""::7:6:5:4:3:2:1:0"", // too many parts
-      ""7:6:5:4:3:2:1:0::"", // too many parts
-      ""9:8:7:6:5:4:3::2:1"", // too many parts
-      ""0:1:2:3::4:5:6:7"", // :: must remove at least one 0.
-      ""3ffe:0:0:0:0:0:0:0:1"", // too many parts (9 instead of 8)
-      ""3ffe::10000"", // hextet exceeds 16 bits
-      ""3ffe::goog"",
-      ""3ffe::-0"",
-      ""3ffe::+0"",
-      ""3ffe::-1"",
-      "":"",
-      "":::"",
-      ""::1.2.3"",
-      ""::1.2.3.4.5"",
-      ""::1.2.3.4:"",
-      ""1.2.3.4::"",
-      ""2001:db8::1:"",
-      "":2001:db8::1"",
-      "":1:2:3:4:5:6:7"",
-      ""1:2:3:4:5:6:7:"",
-      "":1:2:3:4:5:6:""
-    };
-
-    for (int i = 0; i < bogusInputs.length; i++) {
+    ImmutableSet<String> bogusInputs =
+        ImmutableSet.of(
+            """",
+            ""016.016.016.016"",
+            ""016.016.016"",
+            ""016.016"",
+            ""016"",
+            ""000.000.000.000"",
+            ""000"",
+            ""0x0a.0x0a.0x0a.0x0a"",
+            ""0x0a.0x0a.0x0a"",
+            ""0x0a.0x0a"",
+            ""0x0a"",
+            ""42.42.42.42.42"",
+            ""42.42.42"",
+            ""42.42"",
+            ""42"",
+            ""42..42.42"",
+            ""42..42.42.42"",
+            ""42.42.42.42."",
+            ""42.42.42.42..."",
+            "".42.42.42.42"",
+            ""...42.42.42.42"",
+            ""42.42.42.-0"",
+            ""42.42.42.+0"",
+            ""."",
+            ""..."",
+            ""bogus"",
+            ""bogus.com"",
+            ""192.168.0.1.com"",
+            ""12345.67899.-54321.-98765"",
+            ""257.0.0.0"",
+            ""42.42.42.-42"",
+            ""3ffe::1.net"",
+            ""3ffe::1::1"",
+            ""1::2::3::4:5"",
+            ""::7:6:5:4:3:2:"", // should end with "":0""
+            "":6:5:4:3:2:1::"", // should begin with ""0:""
+            ""2001::db:::1"",
+            ""FEDC:9878"",
+            ""+1.+2.+3.4"",
+            ""1.2.3.4e0"",
+            ""::7:6:5:4:3:2:1:0"", // too many parts
+            ""7:6:5:4:3:2:1:0::"", // too many parts
+            ""9:8:7:6:5:4:3::2:1"", // too many parts
+            ""0:1:2:3::4:5:6:7"", // :: must remove at least one 0.
+            ""3ffe:0:0:0:0:0:0:0:1"", // too many parts (9 instead of 8)
+            ""3ffe::10000"", // hextet exceeds 16 bits
+            ""3ffe::goog"",
+            ""3ffe::-0"",
+            ""3ffe::+0"",
+            ""3ffe::-1"",
+            "":"",
+            "":::"",
+            ""::1.2.3"",
+            ""::1.2.3.4.5"",
+            ""::1.2.3.4:"",
+            ""1.2.3.4::"",
+            ""2001:db8::1:"",
+            "":2001:db8::1"",
+            "":1:2:3:4:5:6:7"",
+            ""1:2:3:4:5:6:7:"",
+            "":1:2:3:4:5:6:"");
+
+    for (String bogusInput : bogusInputs) {
       try {
-        InetAddresses.forString(bogusInputs[i]);
-        fail(""IllegalArgumentException expected for '"" + bogusInputs[i] + ""'"");
+        InetAddresses.forString(bogusInput);
+        fail(""IllegalArgumentException expected for '"" + bogusInput + ""'"");
       } catch (IllegalArgumentException expected) {
       }
-      assertFalse(InetAddresses.isInetAddress(bogusInputs[i]));
+      assertFalse(InetAddresses.isInetAddress(bogusInput));
     }
   }
 
@@ -141,23 +142,21 @@ public void testForStringIPv6Input() throws UnknownHostException {
   }
 
   public void testForStringIPv6EightColons() throws UnknownHostException {
-    String[] eightColons = {
-      ""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"",
-    };
+    ImmutableSet<String> eightColons =
+        ImmutableSet.of(""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"");
 
-    for (int i = 0; i < eightColons.length; i++) {
+    for (String ipString : eightColons) {
       InetAddress ipv6Addr = null;
       // Shouldn't hit DNS, because it's an IP string literal.
-      ipv6Addr = InetAddress.getByName(eightColons[i]);
-      assertEquals(ipv6Addr, InetAddresses.forString(eightColons[i]));
-      assertTrue(InetAddresses.isInetAddress(eightColons[i]));
+      ipv6Addr = InetAddress.getByName(ipString);
+      assertEquals(ipv6Addr, InetAddresses.forString(ipString));
+      assertTrue(InetAddresses.isInetAddress(ipString));
     }
   }
 
   public void testConvertDottedQuadToHex() throws UnknownHostException {
-    String[] ipStrings = {
-      ""7::0.128.0.127"", ""7::0.128.0.128"", ""7::128.128.0.127"", ""7::0.128.128.127""
-    };
+    ImmutableSet<String> ipStrings =
+        ImmutableSet.of(""7::0.128.0.127"", ""7::0.128.0.128"", ""7::128.128.0.127"", ""7::0.128.128.127"");
 
     for (String ipString : ipStrings) {
       // Shouldn't hit DNS, because it's an IP string literal.
@@ -315,34 +314,30 @@ public void testForUriStringBad() {
   }
 
   public void testCompatIPv4Addresses() {
-    String[] nonCompatAddresses = {
-      ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> nonCompatAddresses = ImmutableSet.of(""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < nonCompatAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonCompatAddresses[i]);
+    for (String nonCompatAddress : nonCompatAddresses) {
+      InetAddress ip = InetAddresses.forString(nonCompatAddress);
       assertFalse(InetAddresses.isCompatIPv4Address((Inet6Address) ip));
       try {
         InetAddresses.getCompatIPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonCompatAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonCompatAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
 
-    String[] validCompatAddresses = {
-      ""::1.2.3.4"", ""::102:304"",
-    };
+    ImmutableSet<String> validCompatAddresses = ImmutableSet.of(""::1.2.3.4"", ""::102:304"");
     String compatStr = ""1.2.3.4"";
     InetAddress compat = InetAddresses.forString(compatStr);
 
-    for (int i = 0; i < validCompatAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(validCompatAddresses[i]);
-      assertTrue(""checking '"" + validCompatAddresses[i] + ""'"", ip instanceof Inet6Address);
+    for (String validCompatAddress : validCompatAddresses) {
+      InetAddress ip = InetAddresses.forString(validCompatAddress);
+      assertTrue(""checking '"" + validCompatAddress + ""'"", ip instanceof Inet6Address);
       assertTrue(
-          ""checking '"" + validCompatAddresses[i] + ""'"",
+          ""checking '"" + validCompatAddress + ""'"",
           InetAddresses.isCompatIPv4Address((Inet6Address) ip));
       assertEquals(
-          ""checking '"" + validCompatAddresses[i] + ""'"",
+          ""checking '"" + validCompatAddress + ""'"",
           compat,
           InetAddresses.getCompatIPv4Address((Inet6Address) ip));
     }
@@ -389,16 +384,14 @@ public void testMappedIPv4Addresses() throws UnknownHostException {
   }
 
   public void test6to4Addresses() {
-    String[] non6to4Addresses = {
-      ""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> non6to4Addresses = ImmutableSet.of(""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < non6to4Addresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(non6to4Addresses[i]);
+    for (String non6to4Address : non6to4Addresses) {
+      InetAddress ip = InetAddresses.forString(non6to4Address);
       assertFalse(InetAddresses.is6to4Address((Inet6Address) ip));
       try {
         InetAddresses.get6to4IPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + non6to4Addresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + non6to4Address + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
@@ -413,16 +406,14 @@ public void test6to4Addresses() {
   }
 
   public void testTeredoAddresses() {
-    String[] nonTeredoAddresses = {
-      ""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"",
-    };
+    ImmutableSet<String> nonTeredoAddresses = ImmutableSet.of(""::1.2.3.4"", ""3ffe::1"", ""::"", ""::1"");
 
-    for (int i = 0; i < nonTeredoAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonTeredoAddresses[i]);
+    for (String nonTeredoAddress : nonTeredoAddresses) {
+      InetAddress ip = InetAddresses.forString(nonTeredoAddress);
       assertFalse(InetAddresses.isTeredoAddress((Inet6Address) ip));
       try {
         InetAddresses.getTeredoInfo((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonTeredoAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonTeredoAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }
@@ -457,37 +448,39 @@ public void testTeredoAddress_nullServer() {
 
   public void testIsatapAddresses() {
     InetAddress ipv4 = InetAddresses.forString(""1.2.3.4"");
-    String[] validIsatapAddresses = {
-      ""2001:db8::5efe:102:304"",
-      ""2001:db8::100:5efe:102:304"", // Private Multicast? Not likely.
-      ""2001:db8::200:5efe:102:304"",
-      ""2001:db8::300:5efe:102:304"" // Public Multicast? Also unlikely.
-    };
-    String[] nonIsatapAddresses = {
-      ""::1.2.3.4"",
-      ""3ffe::1"",
-      ""::"",
-      ""::1"",
-      ""2001:db8::0040:5efe:102:304"",
-      ""2001:db8::5ffe:102:304"",
-      ""2001:db8::5eff:102:304"",
-      ""2001:0:102:203:200:5efe:506:708"", // Teredo address; not ISATAP
-    };
-
-    for (int i = 0; i < validIsatapAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(validIsatapAddresses[i]);
+    ImmutableSet<String> validIsatapAddresses =
+        ImmutableSet.of(
+            ""2001:db8::5efe:102:304"",
+            ""2001:db8::100:5efe:102:304"", // Private Multicast? Not likely.
+            ""2001:db8::200:5efe:102:304"",
+            ""2001:db8::300:5efe:102:304"" // Public Multicast? Also unlikely.
+            );
+    ImmutableSet<String> nonIsatapAddresses =
+        ImmutableSet.of(
+            ""::1.2.3.4"",
+            ""3ffe::1"",
+            ""::"",
+            ""::1"",
+            ""2001:db8::0040:5efe:102:304"",
+            ""2001:db8::5ffe:102:304"",
+            ""2001:db8::5eff:102:304"",
+            ""2001:0:102:203:200:5efe:506:708"" // Teredo address; not ISATAP
+            );
+
+    for (String validIsatapAddress : validIsatapAddresses) {
+      InetAddress ip = InetAddresses.forString(validIsatapAddress);
       assertTrue(InetAddresses.isIsatapAddress((Inet6Address) ip));
       assertEquals(
-          ""checking '"" + validIsatapAddresses[i] + ""'"",
+          ""checking '"" + validIsatapAddress + ""'"",
           ipv4,
           InetAddresses.getIsatapIPv4Address((Inet6Address) ip));
     }
-    for (int i = 0; i < nonIsatapAddresses.length; i++) {
-      InetAddress ip = InetAddresses.forString(nonIsatapAddresses[i]);
+    for (String nonIsatapAddress : nonIsatapAddresses) {
+      InetAddress ip = InetAddresses.forString(nonIsatapAddress);
       assertFalse(InetAddresses.isIsatapAddress((Inet6Address) ip));
       try {
         InetAddresses.getIsatapIPv4Address((Inet6Address) ip);
-        fail(""IllegalArgumentException expected for '"" + nonIsatapAddresses[i] + ""'"");
+        fail(""IllegalArgumentException expected for '"" + nonIsatapAddress + ""'"");
       } catch (IllegalArgumentException expected) {
       }
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Migrate from arrays to ImmutableSets in InetAddressesTest.

b827d92dbdd949550ecdf975111e4e0a4a4c7740",MOE Sync 2019-11-13
3699,Chris Povirk,"['android/guava-tests/test/com/google/common/net/InetAddressesTest.java', 'guava-tests/test/com/google/common/net/InetAddressesTest.java']","@@ -125,18 +125,16 @@ public void test3ff31() {
 
   public void testForStringIPv4Input() throws UnknownHostException {
     String ipStr = ""192.168.0.1"";
-    InetAddress ipv4Addr = null;
     // Shouldn't hit DNS, because it's an IP string literal.
-    ipv4Addr = InetAddress.getByName(ipStr);
+    InetAddress ipv4Addr = InetAddress.getByName(ipStr);
     assertEquals(ipv4Addr, InetAddresses.forString(ipStr));
     assertTrue(InetAddresses.isInetAddress(ipStr));
   }
 
   public void testForStringIPv6Input() throws UnknownHostException {
     String ipStr = ""3ffe::1"";
-    InetAddress ipv6Addr = null;
     // Shouldn't hit DNS, because it's an IP string literal.
-    ipv6Addr = InetAddress.getByName(ipStr);
+    InetAddress ipv6Addr = InetAddress.getByName(ipStr);
     assertEquals(ipv6Addr, InetAddresses.forString(ipStr));
     assertTrue(InetAddresses.isInetAddress(ipStr));
   }
@@ -146,9 +144,8 @@ public void testForStringIPv6EightColons() throws UnknownHostException {
         ImmutableSet.of(""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"");
 
     for (String ipString : eightColons) {
-      InetAddress ipv6Addr = null;
       // Shouldn't hit DNS, because it's an IP string literal.
-      ipv6Addr = InetAddress.getByName(ipString);
+      InetAddress ipv6Addr = InetAddress.getByName(ipString);
       assertEquals(ipv6Addr, InetAddresses.forString(ipString));
       assertTrue(InetAddresses.isInetAddress(ipString));
     }, @@ -125,18 +125,16 @@ public void test3ff31() {
 
   public void testForStringIPv4Input() throws UnknownHostException {
     String ipStr = ""192.168.0.1"";
-    InetAddress ipv4Addr = null;
     // Shouldn't hit DNS, because it's an IP string literal.
-    ipv4Addr = InetAddress.getByName(ipStr);
+    InetAddress ipv4Addr = InetAddress.getByName(ipStr);
     assertEquals(ipv4Addr, InetAddresses.forString(ipStr));
     assertTrue(InetAddresses.isInetAddress(ipStr));
   }
 
   public void testForStringIPv6Input() throws UnknownHostException {
     String ipStr = ""3ffe::1"";
-    InetAddress ipv6Addr = null;
     // Shouldn't hit DNS, because it's an IP string literal.
-    ipv6Addr = InetAddress.getByName(ipStr);
+    InetAddress ipv6Addr = InetAddress.getByName(ipStr);
     assertEquals(ipv6Addr, InetAddresses.forString(ipStr));
     assertTrue(InetAddresses.isInetAddress(ipStr));
   }
@@ -146,9 +144,8 @@ public void testForStringIPv6EightColons() throws UnknownHostException {
         ImmutableSet.of(""::7:6:5:4:3:2:1"", ""::7:6:5:4:3:2:0"", ""7:6:5:4:3:2:1::"", ""0:6:5:4:3:2:1::"");
 
     for (String ipString : eightColons) {
-      InetAddress ipv6Addr = null;
       // Shouldn't hit DNS, because it's an IP string literal.
-      ipv6Addr = InetAddress.getByName(ipString);
+      InetAddress ipv6Addr = InetAddress.getByName(ipString);
       assertEquals(ipv6Addr, InetAddresses.forString(ipString));
       assertTrue(InetAddresses.isInetAddress(ipString));
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Clean up some unnecessary initializations.

df0d13f964c729a3e0311f0b9db7e42fea70945e",MOE Sync 2019-11-13
3703,Chris Povirk,"['android/guava/src/com/google/common/net/InetAddresses.java', 'guava/src/com/google/common/net/InetAddresses.java']","@@ -976,12 +976,12 @@ private static InetAddress fromBigInteger(BigInteger address, boolean isIpv6) {
 
     // Check the extra bytes in the BigInteger are all zero.
     for (int i = 0; i < srcPos; i++) {
-      checkArgument(
-          addressBytes[i] == 0x00,
-          String.format(
-              ""BigInteger cannot be converted to InetAddress because it has more than %d""
-                  + "" bytes: %s"",
-              numBytes, address));
+      if (addressBytes[i] != 0x00) {
+        throw formatIllegalArgumentException(
+            ""BigInteger cannot be converted to InetAddress because it has more than %d""
+                + "" bytes: %s"",
+            numBytes, address);
+      }
     }
 
     // Copy the bytes into the least significant positions., @@ -971,12 +971,12 @@ private static InetAddress fromBigInteger(BigInteger address, boolean isIpv6) {
 
     // Check the extra bytes in the BigInteger are all zero.
     for (int i = 0; i < srcPos; i++) {
-      checkArgument(
-          addressBytes[i] == 0x00,
-          String.format(
-              ""BigInteger cannot be converted to InetAddress because it has more than %d""
-                  + "" bytes: %s"",
-              numBytes, address));
+      if (addressBytes[i] != 0x00) {
+        throw formatIllegalArgumentException(
+            ""BigInteger cannot be converted to InetAddress because it has more than %d""
+                + "" bytes: %s"",
+            numBytes, address);
+      }
     }
 
     // Copy the bytes into the least significant positions., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Move the big integer conversion code into InetAddresses

RELNOTES=Add toBigInteger and fromIpv4BigInteger/fromIpv6BigInteger to InetAddresses for manipulating InetAddresses as BigIntegers

a544e97d10572d0a71c481e2b833ad19a3a7de4f

-------

<p> Add support for scope IDs to InetAddresses.isInetAddress().

Fixes https://github.com/google/guava/issues/2587

1d3780724431da91b28bbf50fcb13f27459f4710

-------

<p> Format with Locale.ROOT.

This guarantees that the message matches across locales, including hi-IN, which we test with under Maven:
https://travis-ci.org/google/guava/jobs/611945191
https://github.com/google/guava/blob/cc6cff2df9d66d4d9cd18f378cb75d03f7002852/pom.xml#L212

b29efa54b23b3cb28f4e150d045b83b8196d9050",MOE Sync 2019-11-14
3704,Chris Povirk,"['android/guava/src/com/google/common/net/InetAddresses.java', 'guava/src/com/google/common/net/InetAddresses.java']","@@ -826,8 +826,13 @@ public static boolean isMappedIPv4Address(String ipString) {
    *
    * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,
    * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.
-   * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29
-   * bits).
+   * This function does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits
+   * into 29 bits):
+   *
+   * <ul>
+   *   <li>If the IPv6 address contains an embedded IPv4 address, the function hashes that.
+   *   <li>Otherwise, it hashes the upper 64 bits of the IPv6 address.
+   * </ul>
    *
    * <p>A ""coerced"" IPv4 address is equivalent to itself.
    *
@@ -864,7 +869,6 @@ public static Inet4Address getCoercedIPv4Address(InetAddress ip) {
     if (hasEmbeddedIPv4ClientAddress(ip6)) {
       addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();
     } else {
-
       // Just extract the high 64 bits (assuming the rest is user-modifiable).
       addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();
     }, @@ -821,8 +821,13 @@ public static boolean isMappedIPv4Address(String ipString) {
    *
    * <p>HACK: As long as applications continue to use IPv4 addresses for indexing into tables,
    * accounting, et cetera, it may be necessary to <b>coerce</b> IPv6 addresses into IPv4 addresses.
-   * This function does so by hashing the upper 64 bits into {@code 224.0.0.0/3} (64 bits into 29
-   * bits).
+   * This function does so by hashing 64 bits of the IPv6 address into {@code 224.0.0.0/3} (64 bits
+   * into 29 bits):
+   *
+   * <ul>
+   *   <li>If the IPv6 address contains an embedded IPv4 address, the function hashes that.
+   *   <li>Otherwise, it hashes the upper 64 bits of the IPv6 address.
+   * </ul>
    *
    * <p>A ""coerced"" IPv4 address is equivalent to itself.
    *
@@ -859,7 +864,6 @@ public static Inet4Address getCoercedIPv4Address(InetAddress ip) {
     if (hasEmbeddedIPv4ClientAddress(ip6)) {
       addressAsLong = getEmbeddedIPv4ClientAddress(ip6).hashCode();
     } else {
-
       // Just extract the high 64 bits (assuming the rest is user-modifiable).
       addressAsLong = ByteBuffer.wrap(ip6.getAddress(), 0, 8).getLong();
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use Truth assertions instead of JUnit assertions in InetAddressesTest.

Make assertions stronger if possible (check object equality instead of reference equality).

79e2c4efcbebf40ad651fddb107273b960874841

-------

<p> Correct documentation of getCoercedIPv4Address.

848d95b7e9e998cf9d8c952aeaf661902c364eb5",MOE Sync 2019-11-14
3710,Nick,['pom.xml'],"@@ -247,7 +247,7 @@
       <dependency>
         <groupId>org.checkerframework</groupId>
         <artifactId>checker-qual</artifactId>
-        <version>2.8.1</version>
+        <version>2.10.0</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> checker-qual 2.10.0

Fixes #3706

8f2ec6330b05f156985dd0c9dc2acebbb8a711c2",MOE Sync 2019-11-18
3711,Nick,"['android/guava-tests/test/com/google/common/math/LongMathTest.java', 'android/pom.xml', 'guava-tests/test/com/google/common/math/LongMathTest.java', 'pom.xml']","@@ -25,7 +25,7 @@
 import static com.google.common.math.MathTesting.NONZERO_LONG_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_INTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_LONG_CANDIDATES;
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.math.BigInteger.valueOf;
 import static java.math.RoundingMode.FLOOR;
 import static java.math.RoundingMode.UNNECESSARY;
@@ -950,6 +950,6 @@ public void testIsPrimeThrowsOnNegative() {
   }
 
   private static void failFormat(String template, Object... args) {
-    assert_().fail(template, args);
+    assertWithMessage(template, args).fail();
   }
 }, @@ -14,7 +14,7 @@
   <properties>
     <!-- Override this with -Dtest.include=""**/SomeTest.java"" on the CLI -->
     <test.include>%regex[.*.class]</test.include>
-    <truth.version>0.44</truth.version>
+    <truth.version>1.0</truth.version>
     <animal.sniffer.version>1.18</animal.sniffer.version>
     <maven-javadoc-plugin.version>3.1.0</maven-javadoc-plugin.version>
     <maven-source-plugin.version>3.2.0</maven-source-plugin.version>, @@ -25,7 +25,7 @@
 import static com.google.common.math.MathTesting.NONZERO_LONG_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_INTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_LONG_CANDIDATES;
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.math.BigInteger.valueOf;
 import static java.math.RoundingMode.FLOOR;
 import static java.math.RoundingMode.UNNECESSARY;
@@ -950,6 +950,6 @@ public void testIsPrimeThrowsOnNegative() {
   }
 
   private static void failFormat(String template, Object... args) {
-    assert_().fail(template, args);
+    assertWithMessage(template, args).fail();
   }
 }, @@ -14,7 +14,7 @@
   <properties>
     <!-- Override this with -Dtest.include=""**/SomeTest.java"" on the CLI -->
     <test.include>%regex[.*.class]</test.include>
-    <truth.version>0.44</truth.version>
+    <truth.version>1.0</truth.version>
     <animal.sniffer.version>1.18</animal.sniffer.version>
     <maven-javadoc-plugin.version>3.1.0</maven-javadoc-plugin.version>
     <maven-source-plugin.version>3.2.0</maven-source-plugin.version>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Public Suffix data.

The [] copy is updated whenever Chrome's copy is updated, which is
typically every 6 weeks. Star the following to watch Chrome's updates:

https://bugs.chromium.org/p/chromium/issues/detail?id=610495

When that bug is not updated, the [] copy is updated 3 weeks before the
Estimated Week of Stable:

https://www.chromium.org/developers/calendar#TOC-Estimated-Stable-Dates

For this update, []

d6c3cd99a466583651a7058505371fab8b76e554

-------

<p> Update to Truth 1.0

e6225a652e1a4651541fdeed15a400cdcba29b7a",MOE Sync 2019-11-19
3715,Nick,['futures/failureaccess/pom.xml'],"@@ -15,7 +15,7 @@
     Contains
     com.google.common.util.concurrent.internal.InternalFutureFailureAccess and
     InternalFutures. Most users will never need to use this artifact. Its
-    classes is conceptually a part of Guava, but they're in this separate
+    classes are conceptually a part of Guava, but they're in this separate
     artifact so that Android libraries can use them without pulling in all of
     Guava (just as they can use ListenableFuture by depending on the
     listenablefuture artifact)., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> subject verb agreement

2367571b5cbbd17788a497e395f3e4590c4ec38e",MOE Sync 2019-11-20
3723,Nick,"['guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/ListenableFuture.java', 'guava-gwt/src-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/Thenable.java']","@@ -19,6 +19,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import jsinterop.annotations.JsMethod;
+import jsinterop.annotations.JsOptional;
 
 /**
  * Java super source for ListenableFuture, implementing a structural thenable via a default method.
@@ -37,7 +38,7 @@
   @Override
   default <R> IThenable<R> then(
       IThenable.ThenOnFulfilledCallbackFn<? super V, ? extends R> onFulfilled,
-      IThenable.ThenOnRejectedCallbackFn<? extends R> onRejected) {
+      @JsOptional IThenable.ThenOnRejectedCallbackFn<? extends R> onRejected) {
     return new Promise<V>(
             (resolve, reject) -> {
               Futures.addCallback(, @@ -17,6 +17,7 @@
 package com.google.common.util.concurrent;
 
 import elemental2.promise.IThenable;
+import jsinterop.annotations.JsOptional;
 import jsinterop.annotations.JsPackage;
 import jsinterop.annotations.JsType;
 
@@ -28,5 +29,5 @@
 interface Thenable<T> {
   <V> IThenable<V> then(
       IThenable.ThenOnFulfilledCallbackFn<? super T, ? extends V> onFulfilled,
-      IThenable.ThenOnRejectedCallbackFn<? extends V> onRejected);
+      @JsOptional IThenable.ThenOnRejectedCallbackFn<? extends V> onRejected);
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use internal fast path for getting failure without allocating a wrapper ExecutionException

Also fix GWT AbstractFuture so that it respects the trusted interface. (More motivation for https://github.com/google/guava/issues/2934)

RELNOTES=N/A

736b09299f7ce844fdf28c5675eb126ea6b43e02

-------

<p> Support incidentEdgeOrder for directed Graphs

fd2255edf013f6592b83ee17432d0997d8db74d5

-------

<p> Add @JsOptional annotations to the 2nd parameter of the 'then' method, since the second parameter is actually optional. This satisfies JsCompiler type checking.

73be65bd36e498f133549ddc24523176152aa8dc",MOE Sync 2019-11-27
3726,Nick,"['android/guava/src/com/google/common/collect/AbstractTable.java', 'guava/src/com/google/common/collect/AbstractTable.java']","@@ -16,6 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.AbstractSet;
@@ -106,7 +107,7 @@ public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     }
   }
 
-  @MonotonicNonNullDecl private transient Set<Cell<R, C, V>> cellSet;
+  @LazyInit @MonotonicNonNullDecl private transient Set<Cell<R, C, V>> cellSet;
 
   @Override
   public Set<Cell<R, C, V>> cellSet() {
@@ -162,7 +163,7 @@ public int size() {
     }
   }
 
-  @MonotonicNonNullDecl private transient Collection<V> values;
+  @LazyInit @MonotonicNonNullDecl private transient Collection<V> values;
 
   @Override
   public Collection<V> values() {, @@ -16,6 +16,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.AbstractSet;
@@ -107,7 +108,7 @@ public void putAll(Table<? extends R, ? extends C, ? extends V> table) {
     }
   }
 
-  private transient @MonotonicNonNull Set<Cell<R, C, V>> cellSet;
+  @LazyInit private transient @MonotonicNonNull Set<Cell<R, C, V>> cellSet;
 
   @Override
   public Set<Cell<R, C, V>> cellSet() {
@@ -170,7 +171,7 @@ public int size() {
     }
   }
 
-  private transient @MonotonicNonNull Collection<V> values;
+  @LazyInit private transient @MonotonicNonNull Collection<V> values;
 
   @Override
   public Collection<V> values() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make incidentEdges() return edges in insertion order

df2c5527d5fe4a50135239f0b6b516058a37c5fa

-------

<p> AbstractNetwork: fix bug in AbstractNetwork.hasEdgeConnecting() causing it to throw if either endpoint was not in the graph.

RELNOTES=Fix bug in AbstractNetwork.hasEdgeConnecting() causing it to throw if either endpoint was not in the graph.  Originally reported as GitHub issue #3721.

8e0f821430acaa5b77c5c2c05380e3d29f18e410

-------

<p> Refactor AbstractGraphTest to allow for tests with ImmutableGraph.

Reason: ImmutableGraph implementations are undertested compared to MutableGraph implementations. The current tests didn't catch a bug I deliberately introduced in [] Also, it would be nice to be able to share the incident edge order tests.

Note about design: I started out by making an AbstractGraphTest subclass for mutable graphs. However, that would lead to a duplication of all 7 subclasses and most of their tests. The issue is that directed/undirected and mutable/immutable are orthogonal and we also want to test allowSelfLoops=true/false and incidentEdgeOrder=unordered/stable. The proposed solution is somewhat unconventional, but at least allows us to share much more code between the tests.

a6d0db50f6d678839f17c82a76341bb0d3d60b29

-------

<p> Merge AbstractXGraphTest and ConfigurableSimpleXGraphTest, thus removing one layer from the AbstractGraphTest tree.

Reason: Nobody in [] is using these abstract test classes (even though they are designed for general purpose graphs). However, even though they aren't used, these classes add a layer of complexity to an already complex class tree that is going to become more complex with the addition of ImmutableGraph tests and stable incident edge order tests.

ce50502b9bd6fbd909abed1afd1de2976246eef9

-------

<p> Make the AbstractGraphTest tree more sane with only leaf nodes non-abstract and merge the tests for with and without self-loops.

f5ac328e048606d0b40c7e0b1b55bccd6ff177eb

-------

<p> Merge StandardMutableDirectedGraphTest and its variant with stable order.

This is in preparation for adding an Immutable version that also needs tests for the stable order.

a0ebd7b6d2789a168df5e3e0a224513dfe1257ee

-------

<p> Add StandardImmutableDirectedGraphTest

033535490cf36040b4c2aba6a94e9b0f3e59564e

-------

<p> Annotate benign race in AbstractTable so as to avoid TSAN issues.

a4c3bcd7d1c8438d02d368a18c46c1b39f27e80d",MOE Sync 2019-12-01
3732,Colin Decker,"['android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardImmutableDirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardMutableDirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardMutableUndirectedGraphTest.java', 'android/guava/src/com/google/common/graph/DirectedGraphConnections.java', 'android/guava/src/com/google/common/graph/ImmutableGraph.java', 'android/guava/src/com/google/common/graph/ImmutableValueGraph.java', 'guava-tests/test/com/google/common/graph/AbstractGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardImmutableDirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardMutableDirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardMutableUndirectedGraphTest.java', 'guava/src/com/google/common/graph/DirectedGraphConnections.java', 'guava/src/com/google/common/graph/ImmutableGraph.java', 'guava/src/com/google/common/graph/ImmutableValueGraph.java']","@@ -25,7 +25,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
@@ -81,25 +80,18 @@
    * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable
    * graph implementations, this method should replace {@link #graph} with a new graph that includes
    * this node.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
-  abstract boolean addNode(Integer n);
+  abstract void addNode(Integer n);
 
   /**
    * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable
    * graph implementations, this method should replace {@link #graph} with a new graph that includes
    * this edge.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
-  abstract boolean putEdge(Integer n1, Integer n2);
+  abstract void putEdge(Integer n1, Integer n2);
 
-  @CanIgnoreReturnValue
-  final boolean putEdge(EndpointPair<Integer> endpoints) {
-    return putEdge(endpoints.nodeU(), endpoints.nodeV());
+  final void putEdge(EndpointPair<Integer> endpoints) {
+    putEdge(endpoints.nodeU(), endpoints.nodeV());
   }
 
   final boolean graphIsMutable() {, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -34,12 +33,14 @@
         new Object[][] {
           {false, ElementOrder.unordered()},
           {true, ElementOrder.unordered()},
-          // TODO(b/142723300): Add ElementOrder.stable() once it is supported
+          {false, ElementOrder.stable()},
+          {true, ElementOrder.stable()}
         });
   }
 
   private final boolean allowsSelfLoops;
   private final ElementOrder<Integer> incidentEdgeOrder;
+  private ImmutableGraph.Builder<Integer> graphBuilder;
 
   public StandardImmutableDirectedGraphTest(
       boolean allowsSelfLoops, ElementOrder<Integer> incidentEdgeOrder) {
@@ -59,28 +60,23 @@ boolean allowsSelfLoops() {
 
   @Override
   public Graph<Integer> createGraph() {
-    return GraphBuilder.directed()
-        .allowsSelfLoops(allowsSelfLoops())
-        .incidentEdgeOrder(incidentEdgeOrder)
-        .immutable()
-        .build();
+    graphBuilder =
+        GraphBuilder.directed()
+            .allowsSelfLoops(allowsSelfLoops())
+            .incidentEdgeOrder(incidentEdgeOrder)
+            .immutable();
+    return graphBuilder.build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    MutableGraph<Integer> mutableGraph = Graphs.copyOf(graph);
-    boolean somethingChanged = mutableGraph.addNode(n);
-    graph = ImmutableGraph.copyOf(mutableGraph);
-    return somethingChanged;
+  final void addNode(Integer n) {
+    graphBuilder.addNode(n);
+    graph = graphBuilder.build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    MutableGraph<Integer> mutableGraph = Graphs.copyOf(graph);
-    boolean somethingChanged = mutableGraph.putEdge(n1, n2);
-    graph = ImmutableGraph.copyOf(mutableGraph);
-    return somethingChanged;
+  final void putEdge(Integer n1, Integer n2) {
+    graphBuilder.putEdge(n1, n2);
+    graph = graphBuilder.build();
   }
 }, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -66,15 +65,13 @@ boolean allowsSelfLoops() {
         .build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    return graphAsMutableGraph.addNode(n);
+  final void addNode(Integer n) {
+    graphAsMutableGraph.addNode(n);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    return graphAsMutableGraph.putEdge(n1, n2);
+  final void putEdge(Integer n1, Integer n2) {
+    graphAsMutableGraph.putEdge(n1, n2);
   }
 }, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -52,15 +51,13 @@ boolean allowsSelfLoops() {
     return GraphBuilder.undirected().allowsSelfLoops(allowsSelfLoops()).build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    return graphAsMutableGraph.addNode(n);
+  final void addNode(Integer n) {
+    graphAsMutableGraph.addNode(n);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    return graphAsMutableGraph.putEdge(n1, n2);
+  final void putEdge(Integer n1, Integer n2) {
+    graphAsMutableGraph.putEdge(n1, n2);
   }
 }, @@ -16,6 +16,7 @@
 
 package com.google.common.graph;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
@@ -25,7 +26,7 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.UnmodifiableIterator;
 import java.util.AbstractSet;
@@ -175,21 +176,55 @@ private DirectedGraphConnections(
   }
 
   static <N, V> DirectedGraphConnections<N, V> ofImmutable(
-      Set<N> predecessors, Map<N, V> successorValues) {
+      N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
     Map<N, Object> adjacentNodeValues = new HashMap<>();
-    adjacentNodeValues.putAll(successorValues);
-    for (N predecessor : predecessors) {
-      Object value = adjacentNodeValues.put(predecessor, PRED);
-      if (value != null) {
-        adjacentNodeValues.put(predecessor, new PredAndSucc(value));
+    ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder =
+        ImmutableList.builder();
+    int predecessorCount = 0;
+    int successorCount = 0;
+
+    for (EndpointPair<N> incidentEdge : incidentEdges) {
+      if (incidentEdge.nodeU().equals(thisNode) && incidentEdge.nodeV().equals(thisNode)) {
+        // incidentEdge is a self-loop
+
+        adjacentNodeValues.put(thisNode, new PredAndSucc(successorNodeToValueFn.apply(thisNode)));
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred<>(thisNode));
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Succ<>(thisNode));
+        predecessorCount++;
+        successorCount++;
+      } else if (incidentEdge.nodeV().equals(thisNode)) { // incidentEdge is an inEdge
+        N predecessor = incidentEdge.nodeU();
+
+        Object existingValue = adjacentNodeValues.put(predecessor, PRED);
+        if (existingValue != null) {
+          adjacentNodeValues.put(predecessor, new PredAndSucc(existingValue));
+        }
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred<>(predecessor));
+        predecessorCount++;
+      } else { // incidentEdge is an outEdge
+        checkArgument(incidentEdge.nodeU().equals(thisNode));
+
+        N successor = incidentEdge.nodeV();
+        V value = successorNodeToValueFn.apply(successor);
+
+        Object existingValue = adjacentNodeValues.put(successor, value);
+        if (existingValue != null) {
+          checkArgument(existingValue == PRED);
+          adjacentNodeValues.put(successor, new PredAndSucc(value));
+        }
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Succ<>(successor));
+        successorCount++;
       }
     }
+
     return new DirectedGraphConnections<>(
-        /* adjacentNodeValues = */ ImmutableMap.copyOf(adjacentNodeValues),
-        // TODO(b/142723300): Pass in an ImmutableList here with the ordered node connections
-        /* orderedNodeConnections = */ null,
-        /* predecessorCount = */ predecessors.size(),
-        /* successorCount = */ successorValues.size());
+        adjacentNodeValues,
+        orderedNodeConnectionsBuilder.build(),
+        predecessorCount,
+        successorCount);
   }
 
   @Override, @@ -84,11 +84,12 @@
     return nodeConnections.build();
   }
 
+  @SuppressWarnings(""unchecked"")
   private static <N> GraphConnections<N, Presence> connectionsOf(Graph<N> graph, N node) {
-    Function<Object, Presence> edgeValueFn = Functions.constant(Presence.EDGE_EXISTS);
+    Function<N, Presence> edgeValueFn =
+        (Function<N, Presence>) Functions.constant(Presence.EDGE_EXISTS);
     return graph.isDirected()
-        ? DirectedGraphConnections.ofImmutable(
-            graph.predecessors(node), Maps.asMap(graph.successors(node), edgeValueFn))
+        ? DirectedGraphConnections.ofImmutable(node, graph.incidentEdges(node), edgeValueFn)
         : UndirectedGraphConnections.ofImmutable(
             Maps.asMap(graph.adjacentNodes(node), edgeValueFn));
   }, @@ -94,7 +94,7 @@ public V apply(N successorNode) {
         };
     return graph.isDirected()
         ? DirectedGraphConnections.ofImmutable(
-            graph.predecessors(node), Maps.asMap(graph.successors(node), successorNodeToValueFn))
+            node, graph.incidentEdges(node), successorNodeToValueFn)
         : UndirectedGraphConnections.ofImmutable(
             Maps.asMap(graph.adjacentNodes(node), successorNodeToValueFn));
   }, @@ -25,7 +25,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.HashSet;
 import java.util.Set;
 import org.junit.After;
@@ -81,25 +80,18 @@
    * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable
    * graph implementations, this method should replace {@link #graph} with a new graph that includes
    * this node.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
-  abstract boolean addNode(Integer n);
+  abstract void addNode(Integer n);
 
   /**
    * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable
    * graph implementations, this method should replace {@link #graph} with a new graph that includes
    * this edge.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
    */
-  @CanIgnoreReturnValue
-  abstract boolean putEdge(Integer n1, Integer n2);
+  abstract void putEdge(Integer n1, Integer n2);
 
-  @CanIgnoreReturnValue
-  final boolean putEdge(EndpointPair<Integer> endpoints) {
-    return putEdge(endpoints.nodeU(), endpoints.nodeV());
+  final void putEdge(EndpointPair<Integer> endpoints) {
+    putEdge(endpoints.nodeU(), endpoints.nodeV());
   }
 
   final boolean graphIsMutable() {, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -34,12 +33,14 @@
         new Object[][] {
           {false, ElementOrder.unordered()},
           {true, ElementOrder.unordered()},
-          // TODO(b/142723300): Add ElementOrder.stable() once it is supported
+          {false, ElementOrder.stable()},
+          {true, ElementOrder.stable()}
         });
   }
 
   private final boolean allowsSelfLoops;
   private final ElementOrder<Integer> incidentEdgeOrder;
+  private ImmutableGraph.Builder<Integer> graphBuilder;
 
   public StandardImmutableDirectedGraphTest(
       boolean allowsSelfLoops, ElementOrder<Integer> incidentEdgeOrder) {
@@ -59,28 +60,23 @@ boolean allowsSelfLoops() {
 
   @Override
   public Graph<Integer> createGraph() {
-    return GraphBuilder.directed()
-        .allowsSelfLoops(allowsSelfLoops())
-        .incidentEdgeOrder(incidentEdgeOrder)
-        .immutable()
-        .build();
+    graphBuilder =
+        GraphBuilder.directed()
+            .allowsSelfLoops(allowsSelfLoops())
+            .incidentEdgeOrder(incidentEdgeOrder)
+            .immutable();
+    return graphBuilder.build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    MutableGraph<Integer> mutableGraph = Graphs.copyOf(graph);
-    boolean somethingChanged = mutableGraph.addNode(n);
-    graph = ImmutableGraph.copyOf(mutableGraph);
-    return somethingChanged;
+  final void addNode(Integer n) {
+    graphBuilder.addNode(n);
+    graph = graphBuilder.build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    MutableGraph<Integer> mutableGraph = Graphs.copyOf(graph);
-    boolean somethingChanged = mutableGraph.putEdge(n1, n2);
-    graph = ImmutableGraph.copyOf(mutableGraph);
-    return somethingChanged;
+  final void putEdge(Integer n1, Integer n2) {
+    graphBuilder.putEdge(n1, n2);
+    graph = graphBuilder.build();
   }
 }, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -66,15 +65,13 @@ boolean allowsSelfLoops() {
         .build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    return graphAsMutableGraph.addNode(n);
+  final void addNode(Integer n) {
+    graphAsMutableGraph.addNode(n);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    return graphAsMutableGraph.putEdge(n1, n2);
+  final void putEdge(Integer n1, Integer n2) {
+    graphAsMutableGraph.putEdge(n1, n2);
   }
 }, @@ -16,7 +16,6 @@
 
 package com.google.common.graph;
 
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.Collection;
 import org.junit.runner.RunWith;
@@ -52,15 +51,13 @@ boolean allowsSelfLoops() {
     return GraphBuilder.undirected().allowsSelfLoops(allowsSelfLoops()).build();
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean addNode(Integer n) {
-    return graphAsMutableGraph.addNode(n);
+  final void addNode(Integer n) {
+    graphAsMutableGraph.addNode(n);
   }
 
-  @CanIgnoreReturnValue
   @Override
-  final boolean putEdge(Integer n1, Integer n2) {
-    return graphAsMutableGraph.putEdge(n1, n2);
+  final void putEdge(Integer n1, Integer n2) {
+    graphAsMutableGraph.putEdge(n1, n2);
   }
 }, @@ -16,6 +16,7 @@
 
 package com.google.common.graph;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.graph.GraphConstants.INNER_CAPACITY;
@@ -25,7 +26,7 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.UnmodifiableIterator;
 import java.util.AbstractSet;
@@ -175,21 +176,55 @@ private DirectedGraphConnections(
   }
 
   static <N, V> DirectedGraphConnections<N, V> ofImmutable(
-      Set<N> predecessors, Map<N, V> successorValues) {
+      N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
     Map<N, Object> adjacentNodeValues = new HashMap<>();
-    adjacentNodeValues.putAll(successorValues);
-    for (N predecessor : predecessors) {
-      Object value = adjacentNodeValues.put(predecessor, PRED);
-      if (value != null) {
-        adjacentNodeValues.put(predecessor, new PredAndSucc(value));
+    ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder =
+        ImmutableList.builder();
+    int predecessorCount = 0;
+    int successorCount = 0;
+
+    for (EndpointPair<N> incidentEdge : incidentEdges) {
+      if (incidentEdge.nodeU().equals(thisNode) && incidentEdge.nodeV().equals(thisNode)) {
+        // incidentEdge is a self-loop
+
+        adjacentNodeValues.put(thisNode, new PredAndSucc(successorNodeToValueFn.apply(thisNode)));
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred<>(thisNode));
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Succ<>(thisNode));
+        predecessorCount++;
+        successorCount++;
+      } else if (incidentEdge.nodeV().equals(thisNode)) { // incidentEdge is an inEdge
+        N predecessor = incidentEdge.nodeU();
+
+        Object existingValue = adjacentNodeValues.put(predecessor, PRED);
+        if (existingValue != null) {
+          adjacentNodeValues.put(predecessor, new PredAndSucc(existingValue));
+        }
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Pred<>(predecessor));
+        predecessorCount++;
+      } else { // incidentEdge is an outEdge
+        checkArgument(incidentEdge.nodeU().equals(thisNode));
+
+        N successor = incidentEdge.nodeV();
+        V value = successorNodeToValueFn.apply(successor);
+
+        Object existingValue = adjacentNodeValues.put(successor, value);
+        if (existingValue != null) {
+          checkArgument(existingValue == PRED);
+          adjacentNodeValues.put(successor, new PredAndSucc(value));
+        }
+
+        orderedNodeConnectionsBuilder.add(new NodeConnection.Succ<>(successor));
+        successorCount++;
       }
     }
+
     return new DirectedGraphConnections<>(
-        /* adjacentNodeValues = */ ImmutableMap.copyOf(adjacentNodeValues),
-        // TODO(b/142723300): Pass in an ImmutableList here with the ordered node connections
-        /* orderedNodeConnections = */ null,
-        /* predecessorCount = */ predecessors.size(),
-        /* successorCount = */ successorValues.size());
+        adjacentNodeValues,
+        orderedNodeConnectionsBuilder.build(),
+        predecessorCount,
+        successorCount);
   }
 
   @Override, @@ -84,11 +84,12 @@
     return nodeConnections.build();
   }
 
+  @SuppressWarnings(""unchecked"")
   private static <N> GraphConnections<N, Presence> connectionsOf(Graph<N> graph, N node) {
-    Function<Object, Presence> edgeValueFn = Functions.constant(Presence.EDGE_EXISTS);
+    Function<N, Presence> edgeValueFn =
+        (Function<N, Presence>) Functions.constant(Presence.EDGE_EXISTS);
     return graph.isDirected()
-        ? DirectedGraphConnections.ofImmutable(
-            graph.predecessors(node), Maps.asMap(graph.successors(node), edgeValueFn))
+        ? DirectedGraphConnections.ofImmutable(node, graph.incidentEdges(node), edgeValueFn)
         : UndirectedGraphConnections.ofImmutable(
             Maps.asMap(graph.adjacentNodes(node), edgeValueFn));
   }, @@ -94,7 +94,7 @@ public V apply(N successorNode) {
         };
     return graph.isDirected()
         ? DirectedGraphConnections.ofImmutable(
-            graph.predecessors(node), Maps.asMap(graph.successors(node), successorNodeToValueFn))
+            node, graph.incidentEdges(node), successorNodeToValueFn)
         : UndirectedGraphConnections.ofImmutable(
             Maps.asMap(graph.adjacentNodes(node), successorNodeToValueFn));
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Use ""IPv4"" instead of ""Ipv4"" for consistency.

This CL goes against the style guide, but we should be consistent within the file. We could instead rename the existing, lightly used methods to match the style guide, but I don't think this will be the best use of someone's time.

4a627d3ea2ac16e7e970f78939df6a163335df1c

-------

<p> Add @SuppressWarnings(""GoodTime"") to GWT supersource for LocalCache operating in primitive millis.

95e7e1af8ef059e874f4c00230b010f651322e71

-------

<p> The Graph tests now consistently call graphAsMutableGraph.foo() when testing foo(), rather than proxy methods

1fc1f11779159183f0b4daeb388c6def36a4a2e3

-------

<p> Make equally named putEdge() method adjacent

9a1f2e28f76a623501e8178262359202055139c2

-------

<p> Support stable incident edge order for directed Immutable[Value]Graphs.

2608ca43cf15c4b2a7ad21a900550358f5e6fc76",MOE Sync 2019-12-06
3734,Colin Decker,"['android/guava/src/com/google/common/base/CaseFormat.java', 'guava/src/com/google/common/base/CaseFormat.java']","@@ -135,7 +135,7 @@ String convert(CaseFormat format, String s) {
     while ((j = wordBoundary.indexIn(s, ++j)) != -1) {
       if (i == 0) {
         // include some extra space for separators
-        out = new StringBuilder(s.length() + 4 * wordSeparator.length());
+        out = new StringBuilder(s.length() + 4 * format.wordSeparator.length());
         out.append(format.normalizeFirstWord(s.substring(i, j)));
       } else {
         out.append(format.normalizeWord(s.substring(i, j)));, @@ -135,7 +135,7 @@ String convert(CaseFormat format, String s) {
     while ((j = wordBoundary.indexIn(s, ++j)) != -1) {
       if (i == 0) {
         // include some extra space for separators
-        out = new StringBuilder(s.length() + 4 * wordSeparator.length());
+        out = new StringBuilder(s.length() + 4 * format.wordSeparator.length());
         out.append(format.normalizeFirstWord(s.substring(i, j)));
       } else {
         out.append(format.normalizeWord(s.substring(i, j)));, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add @DoNotMock to several com.google.common types

Relnotes:
  - Add @DoNotMock to several com.google.common types.

dbd97473cab26185e48620b7916159915621bb14

-------

<p> Add @DoNotMock to ListenableFuture

Remove @DoNotMock from AbstractFuture, as it is now covered by @DoNotMock on ListenableFuture

RELNOTES=N/A

ad9d3eae25e3f7a8bb07a0b00105ec4426beab88

-------

<p> Fix small error with how CaseFormat calculates the StringBuilder size when converting one format to another.

Fixes https://github.com/google/guava/pull/3730

0dc680192f18b7664f900304576736c1914d14ba",MOE Sync 2019-12-09
3739,Kurt Alfred Kluever,"['android/guava/src/com/google/common/hash/HashFunction.java', 'guava/src/com/google/common/hash/HashFunction.java']","@@ -16,7 +16,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -117,7 +116,6 @@
  * @since 11.0
  */
 @Beta
-@DoNotMock(""Use a real instance from Hashing"")
 @Immutable
 public interface HashFunction {
   /**, @@ -16,7 +16,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.primitives.Ints;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -117,7 +116,6 @@
  * @since 11.0
  */
 @Beta
-@DoNotMock(""Use a real instance from Hashing"")
 @Immutable
 public interface HashFunction {
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove @DoNotMock from HashFunction.

Users need some kind of way to, e.g., easily produce collisions in cases in which collisions should be rare.
Maybe we can provide a better way to do this, but for now, let's at least not forbid using mocking frameworks.

c9ae0d314031ac9521d57aab8743ddba0c5f4717",MOE Sync 2019-12-16
3740,Kurt Alfred Kluever,"['android/guava/src/com/google/common/io/ByteStreams.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -901,6 +902,8 @@ private static long skipSafely(InputStream in, long n) throws IOException {
    * @param len an int specifying the number of bytes to read
    * @return the number of bytes read
    * @throws IOException if an I/O error occurs
+   * @throws IndexOutOfBoundsException if {@code off} is negative, if {@code len} is negative, or if
+   *     {@code off + len} is greater than {@code b.length}
    */
   @Beta
   @CanIgnoreReturnValue
@@ -910,8 +913,9 @@ public static int read(InputStream in, byte[] b, int off, int len) throws IOExce
     checkNotNull(in);
     checkNotNull(b);
     if (len < 0) {
-      throw new IndexOutOfBoundsException(""len is negative"");
+      throw new IndexOutOfBoundsException(String.format(""len (%s) cannot be negative"", len));
     }
+    checkPositionIndexes(off, off + len, b.length);
     int total = 0;
     while (total < len) {
       int result = in.read(b, off + total, len - total);, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
+import static com.google.common.base.Preconditions.checkPositionIndexes;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -901,6 +902,8 @@ private static long skipSafely(InputStream in, long n) throws IOException {
    * @param len an int specifying the number of bytes to read
    * @return the number of bytes read
    * @throws IOException if an I/O error occurs
+   * @throws IndexOutOfBoundsException if {@code off} is negative, if {@code len} is negative, or if
+   *     {@code off + len} is greater than {@code b.length}
    */
   @Beta
   @CanIgnoreReturnValue
@@ -910,8 +913,9 @@ public static int read(InputStream in, byte[] b, int off, int len) throws IOExce
     checkNotNull(in);
     checkNotNull(b);
     if (len < 0) {
-      throw new IndexOutOfBoundsException(""len is negative"");
+      throw new IndexOutOfBoundsException(String.format(""len (%s) cannot be negative"", len));
     }
+    checkPositionIndexes(off, off + len, b.length);
     int total = 0;
     while (total < len) {
       int result = in.read(b, off + total, len - total);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Format the Javadoc of ByteStreams.read() with @throw tags.

Fixes https://github.com/google/guava/pull/3735

907ec2ea8655ba1c69d8b003c3e51689ec02b864",MOE Sync 2019-12-17
3741,Kurt Alfred Kluever,"['android/guava/src/com/google/common/io/FileBackedOutputStream.java', 'guava/src/com/google/common/io/FileBackedOutputStream.java']","@@ -17,6 +17,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -31,6 +32,17 @@
  * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
  * once the data reaches a configurable size.
  *
+ * <p>Temporary files created by this stream may live in the local filesystem until either:
+ *
+ * <ul>
+ *   <li>{@link #reset} is called (removing the data in this stream and deleting the file), or...
+ *   <li>this stream (or, more precisely, its {@link #asByteSource} view) is finalized during
+ *       garbage collection, <strong>AND</strong> this stream was not constructed with {@linkplain
+ *       #FileBackedOutputStream(int) the 1-arg constructor} or the {@linkplain
+ *       #FileBackedOutputStream(int, boolean) 2-arg constructor} passing {@code false} in the
+ *       second parameter.
+ * </ul>
+ *
  * <p>This class is thread-safe.
  *
  * @author Chris Nokleberg
@@ -39,14 +51,20 @@
 @Beta
 @GwtIncompatible
 public final class FileBackedOutputStream extends OutputStream {
-
   private final int fileThreshold;
   private final boolean resetOnFinalize;
   private final ByteSource source;
+  @NullableDecl private final File parentDirectory;
 
+  @GuardedBy(""this"")
   private OutputStream out;
+
+  @GuardedBy(""this"")
   private MemoryOutput memory;
-  @NullableDecl private File file;
+
+  @GuardedBy(""this"")
+  @NullableDecl
+  private File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
   private static class MemoryOutput extends ByteArrayOutputStream {
@@ -81,11 +99,17 @@ public FileBackedOutputStream(int fileThreshold) {
    *
    * @param fileThreshold the number of bytes before the stream should switch to buffering to a file
    * @param resetOnFinalize if true, the {@link #reset} method will be called when the {@link
-   *     ByteSource} returned by {@link #asByteSource} is finalized
+   *     ByteSource} returned by {@link #asByteSource} is finalized.
    */
   public FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize) {
+    this(fileThreshold, resetOnFinalize, null);
+  }
+
+  private FileBackedOutputStream(
+      int fileThreshold, boolean resetOnFinalize, @NullableDecl File parentDirectory) {
     this.fileThreshold = fileThreshold;
     this.resetOnFinalize = resetOnFinalize;
+    this.parentDirectory = parentDirectory;
     memory = new MemoryOutput();
     out = memory;
 
@@ -191,9 +215,10 @@ public synchronized void flush() throws IOException {
    * Checks if writing {@code len} bytes would go over threshold, and switches to file buffering if
    * so.
    */
+  @GuardedBy(""this"")
   private void update(int len) throws IOException {
     if (file == null && (memory.getCount() + len > fileThreshold)) {
-      File temp = File.createTempFile(""FileBackedOutputStream"", null);
+      File temp = File.createTempFile(""FileBackedOutputStream"", null, parentDirectory);
       if (resetOnFinalize) {
         // Finalizers are not guaranteed to be called on system shutdown;
         // this is insurance., @@ -17,6 +17,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -31,6 +32,17 @@
  * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
  * once the data reaches a configurable size.
  *
+ * <p>Temporary files created by this stream may live in the local filesystem until either:
+ *
+ * <ul>
+ *   <li>{@link #reset} is called (removing the data in this stream and deleting the file), or...
+ *   <li>this stream (or, more precisely, its {@link #asByteSource} view) is finalized during
+ *       garbage collection, <strong>AND</strong> this stream was not constructed with {@linkplain
+ *       #FileBackedOutputStream(int) the 1-arg constructor} or the {@linkplain
+ *       #FileBackedOutputStream(int, boolean) 2-arg constructor} passing {@code false} in the
+ *       second parameter.
+ * </ul>
+ *
  * <p>This class is thread-safe.
  *
  * @author Chris Nokleberg
@@ -39,14 +51,20 @@
 @Beta
 @GwtIncompatible
 public final class FileBackedOutputStream extends OutputStream {
-
   private final int fileThreshold;
   private final boolean resetOnFinalize;
   private final ByteSource source;
+  @Nullable private final File parentDirectory;
 
+  @GuardedBy(""this"")
   private OutputStream out;
+
+  @GuardedBy(""this"")
   private MemoryOutput memory;
-  private @Nullable File file;
+
+  @GuardedBy(""this"")
+  @Nullable
+  private File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
   private static class MemoryOutput extends ByteArrayOutputStream {
@@ -81,11 +99,17 @@ public FileBackedOutputStream(int fileThreshold) {
    *
    * @param fileThreshold the number of bytes before the stream should switch to buffering to a file
    * @param resetOnFinalize if true, the {@link #reset} method will be called when the {@link
-   *     ByteSource} returned by {@link #asByteSource} is finalized
+   *     ByteSource} returned by {@link #asByteSource} is finalized.
    */
   public FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize) {
+    this(fileThreshold, resetOnFinalize, null);
+  }
+
+  private FileBackedOutputStream(
+      int fileThreshold, boolean resetOnFinalize, @Nullable File parentDirectory) {
     this.fileThreshold = fileThreshold;
     this.resetOnFinalize = resetOnFinalize;
+    this.parentDirectory = parentDirectory;
     memory = new MemoryOutput();
     out = memory;
 
@@ -191,9 +215,10 @@ public synchronized void flush() throws IOException {
    * Checks if writing {@code len} bytes would go over threshold, and switches to file buffering if
    * so.
    */
+  @GuardedBy(""this"")
   private void update(int len) throws IOException {
     if (file == null && (memory.getCount() + len > fileThreshold)) {
-      File temp = File.createTempFile(""FileBackedOutputStream"", null);
+      File temp = File.createTempFile(""FileBackedOutputStream"", null, parentDirectory);
       if (resetOnFinalize) {
         // Finalizers are not guaranteed to be called on system shutdown;
         // this is insurance., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Actually map Thenable helper interface to JS IThenable. The name is different to avoid a clash with elemental2 IThenable.

8207e996f569381719eff09ee836509136734cc0

-------

<p> Use Error Prone's @GuardedBy enforcement to make sure that mutable state is appropriately synchronized.

f6d239520285c399978597c4a6665bf41fe8395d",MOE Sync 2019-12-18
3743,Kurt Alfred Kluever,['android/guava-tests/benchmark/com/google/common/collect/MapsMemoryBenchmark.java'],"@@ -46,7 +46,7 @@
     ""LinkedHashMapImpl"",
     ""ConcurrentHashMapImpl"",
     ""CompactHashMapImpl"",
-    // ""CompactLinkedHashMapImpl"",
+    ""CompactLinkedHashMapImpl"",
     ""ImmutableMapImpl"",
     ""TreeMapImpl"",
     ""ImmutableSortedMapImpl"",, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Expand Android access to Compact*Hash*

Also rename newCompactHashMapWithExpectedSize(int) to newCompactHashMap(int) to
match newCompactHashSet(int).

b2723ea162d6c4d7df62722e87f609f70478840a",MOE Sync 2019-12-20
3747,Chris Povirk,"['android/guava-tests/benchmark/com/google/common/cache/ChainBenchmark.java', 'android/guava-tests/benchmark/com/google/common/cache/SegmentBenchmark.java', 'android/guava-tests/test/com/google/common/collect/MapMakerInternalMapTest.java', 'guava-tests/benchmark/com/google/common/cache/ChainBenchmark.java', 'guava-tests/benchmark/com/google/common/cache/SegmentBenchmark.java', 'guava-tests/test/com/google/common/collect/MapMakerInternalMapTest.java']","@@ -35,6 +35,7 @@
   private ReferenceEntry<Object, Object> head;
   private ReferenceEntry<Object, Object> chain;
 
+  @SuppressWarnings(""GuardedBy"")
   @BeforeExperiment
   void setUp() {
     LocalCache<Object, Object> cache =
@@ -43,17 +44,22 @@ void setUp() {
     chain = null;
     for (int i = 0; i < length; i++) {
       Object key = new Object();
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       chain = segment.newEntry(key, cache.hash(key), chain);
       if (i == 0) {
         head = chain;
       }
     }
   }
 
+  @SuppressWarnings(""GuardedBy"")
   @Benchmark
   int time(int reps) {
     int dummy = 0;
     for (int i = 0; i < reps; i++) {
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       segment.removeEntryFromChain(chain, head);
       dummy += segment.count;
     }, @@ -50,11 +50,14 @@ void setUp() {
     checkState(segment.table.length() == capacity);
   }
 
+  @SuppressWarnings(""GuardedBy"")
   @Benchmark
   int time(int reps) {
     int dummy = 0;
     AtomicReferenceArray<ReferenceEntry<Object, Object>> oldTable = segment.table;
     for (int i = 0; i < reps; i++) {
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       segment.expand();
       segment.table = oldTable;
       dummy += segment.count;, @@ -604,6 +604,7 @@ public void testSegmentRemoveValue() {
     assertNull(segment.get(key, hash));
   }
 
+  @SuppressWarnings(""GuardedBy"")
   public void testExpand() {
     MapMakerInternalMap<Object, Object, ?, ?> map =
         makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
@@ -629,6 +630,8 @@ public void testExpand() {
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
+        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
+        // held
         segment.expand();
       }
       assertEquals(i, segment.table.length());
@@ -687,6 +690,7 @@ public void testRemoveFromChain() {
     assertNull(newFirst.getNext());
   }
 
+  @SuppressWarnings(""GuardedBy"")
   public void testExpand_cleanup() {
     MapMakerInternalMap<Object, Object, ?, ?> map =
         makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
@@ -719,6 +723,8 @@ public void testExpand_cleanup() {
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
+        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
+        // held
         segment.expand();
       }
       assertEquals(i, segment.table.length());, @@ -35,6 +35,7 @@
   private ReferenceEntry<Object, Object> head;
   private ReferenceEntry<Object, Object> chain;
 
+  @SuppressWarnings(""GuardedBy"")
   @BeforeExperiment
   void setUp() {
     LocalCache<Object, Object> cache =
@@ -43,17 +44,22 @@ void setUp() {
     chain = null;
     for (int i = 0; i < length; i++) {
       Object key = new Object();
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       chain = segment.newEntry(key, cache.hash(key), chain);
       if (i == 0) {
         head = chain;
       }
     }
   }
 
+  @SuppressWarnings(""GuardedBy"")
   @Benchmark
   int time(int reps) {
     int dummy = 0;
     for (int i = 0; i < reps; i++) {
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       segment.removeEntryFromChain(chain, head);
       dummy += segment.count;
     }, @@ -50,11 +50,14 @@ void setUp() {
     checkState(segment.table.length() == capacity);
   }
 
+  @SuppressWarnings(""GuardedBy"")
   @Benchmark
   int time(int reps) {
     int dummy = 0;
     AtomicReferenceArray<ReferenceEntry<Object, Object>> oldTable = segment.table;
     for (int i = 0; i < reps; i++) {
+      // TODO(b/145386688): This access should be guarded by 'this.segment', which is not currently
+      // held
       segment.expand();
       segment.table = oldTable;
       dummy += segment.count;, @@ -604,6 +604,7 @@ public void testSegmentRemoveValue() {
     assertNull(segment.get(key, hash));
   }
 
+  @SuppressWarnings(""GuardedBy"")
   public void testExpand() {
     MapMakerInternalMap<Object, Object, ?, ?> map =
         makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
@@ -629,6 +630,8 @@ public void testExpand() {
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
+        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
+        // held
         segment.expand();
       }
       assertEquals(i, segment.table.length());
@@ -687,6 +690,7 @@ public void testRemoveFromChain() {
     assertNull(newFirst.getNext());
   }
 
+  @SuppressWarnings(""GuardedBy"")
   public void testExpand_cleanup() {
     MapMakerInternalMap<Object, Object, ?, ?> map =
         makeMap(createMapMaker().concurrencyLevel(1).initialCapacity(1));
@@ -719,6 +723,8 @@ public void testExpand_cleanup() {
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
+        // TODO(b/145386688): This access should be guarded by 'segment', which is not currently
+        // held
         segment.expand();
       }
       assertEquals(i, segment.table.length());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make Compact(Linked)HashMap fall back to a java.util.LinkedHashMap if hash flooding is detected, just as the immutable collections do.

5dffec12c07ea23bcba653198036e55df27792f0

-------

<p> Fix Maven test failures from CL 286604248:
- Make ""abstract"" class abstract. (And make its constructor package-private while we're at it.)
- Add a dummy test method (similar to what FilteredCollectionsTest already has).

These should fix:
- warning(junit.framework.TestSuite$1): Class com.google.common.collect.AbstractHashFloodingTest has no public constructor TestCase(String name) or TestCase()
- warning(junit.framework.TestSuite$1): No tests found in com.google.common.collect.ImmutableBiMapTest

https://travis-ci.org/google/guava/jobs/628734577

(Also, address a review comment: https://github.com/google/guava/pull/3746/files/40d75c94d568935159ce838c61940430fce54249#r360917786)

8ccd51880e63c487af858c6de57a2d37eb2cf4ac

-------

<p> Add @SuppressWarnings for new violations of the GuardedBy checker.

98736425927413862c058d11f1aaeae53bbe0f91",MOE Sync 2019-12-23
3748,Chris Povirk,['guava/src/com/google/common/collect/ImmutableTable.java'],"@@ -32,6 +32,7 @@
 import java.util.Spliterator;
 import java.util.function.BinaryOperator;
 import java.util.function.Function;
+import java.util.function.Supplier;
 import java.util.stream.Collector;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -68,11 +69,11 @@
     checkNotNull(columnFunction, ""columnFunction"");
     checkNotNull(valueFunction, ""valueFunction"");
     return Collector.of(
-        () -> new ImmutableTable.Builder<R, C, V>(),
+        (Supplier<Builder<R, C, V>>) Builder::new,
         (builder, t) ->
             builder.put(rowFunction.apply(t), columnFunction.apply(t), valueFunction.apply(t)),
-        (b1, b2) -> b1.combine(b2),
-        b -> b.build());
+        Builder::combine,
+        Builder::build);
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> refactor: Lambda can be replaced method reference

Fixes #3745

1d8ab4f96855dcb9a7cd3990a671f4e5696faa4e",MOE Sync 2019-12-23
3752,Chris Povirk,"['android/guava/src/com/google/common/collect/CompactHashMap.java', 'android/guava/src/com/google/common/collect/CompactLinkedHashMap.java', 'guava/src/com/google/common/collect/CompactHashMap.java', 'guava/src/com/google/common/collect/CompactLinkedHashMap.java']","@@ -196,7 +196,7 @@ void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Expected size must be >= 0"");
 
     // Save expectedSize for use in allocArrays()
-    this.metadata = Math.max(1, Math.min(CompactHashing.MAX_SIZE, expectedSize));
+    this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
   }
 
   /** Returns whether arrays need to be allocated. */, @@ -22,7 +22,6 @@
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import org.checkerframework.checker.nullness.compatqual.MonotonicNonNullDecl;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
@@ -78,7 +77,7 @@
    * <p>A node with ""prev"" pointer equal to {@code ENDPOINT} is the first node in the linked list,
    * and a node with ""next"" pointer equal to {@code ENDPOINT} is the last node.
    */
-  @VisibleForTesting @MonotonicNonNullDecl transient long[] links;
+  @VisibleForTesting @NullableDecl transient long[] links;
 
   /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;, @@ -200,7 +200,7 @@ void init(int expectedSize) {
     Preconditions.checkArgument(expectedSize >= 0, ""Expected size must be >= 0"");
 
     // Save expectedSize for use in allocArrays()
-    this.metadata = Math.max(1, Math.min(CompactHashing.MAX_SIZE, expectedSize));
+    this.metadata = Ints.constrainToRange(expectedSize, 1, CompactHashing.MAX_SIZE);
   }
 
   /** Returns whether arrays need to be allocated. */, @@ -27,7 +27,6 @@
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -83,7 +82,7 @@
    * <p>A node with ""prev"" pointer equal to {@code ENDPOINT} is the first node in the linked list,
    * and a node with ""next"" pointer equal to {@code ENDPOINT} is the last node.
    */
-  @VisibleForTesting transient long @MonotonicNonNull [] links;
+  @VisibleForTesting transient long @Nullable [] links;
 
   /** Pointer to the first node in the linked list, or {@code ENDPOINT} if there are no entries. */
   private transient int firstEntry;, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct @Nullable and use Ints.constrainToRange()

5d9fc397a80618ea90786f026962f208b979bece",MOE Sync 2019-12-24
3753,Chris Povirk,['guava-gwt/test/com/google/common/util/concurrent/testModule.gwt.xml'],"@@ -9,7 +9,6 @@
   <inherits name=""com.google.common.testing.Testing""/>
   <inherits name=""com.google.common.util.concurrent.Concurrent""/>
   <inherits name=""com.google.common.truth.Truth""/>
-  <inherits name=""activation.Activation""/>
   <entry-point class=""com.google.common.util.concurrent.TestModuleEntryPoint""/>
    
   <source path=""""/>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix external GWT breakage from CL 272446666.

a950b04670789853d923be2d96079a91d3f8995d",MOE Sync 2019-12-26
3755,Chris Povirk,['guava-gwt/test/com/google/common/collect/AbstractHashFloodingTest_gwt.java'],"@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2008 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.common.collect;
-public class AbstractHashFloodingTest_gwt extends com.google.gwt.junit.client.GWTTestCase {
-@Override public String getModuleName() {
-  return ""com.google.common.collect.testModule"";
-}
-}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Stop classifying AbstractHashFloodingTest as a test to be run directly.

When it's classified as a test to be run directly, our custom infrastructure generates AbstractHashFloodingTest_gwt, and Maven tries to run it, failing with:
  No tests found in com.google.common.collect.AbstractHashFloodingTest_gwt

Ideally, our infrastructure would recognize that an abstract class could never be run directly, at which point we wouldn't need to manually classify tests like this. But I don't remember seeing this problem in a long time, so we probably won't bother.

55e4929f978eec17a829fb0a7c6f338710720b19",MOE Sync 2019-12-26
3757,Chris Povirk,"['android/guava-tests/test/com/google/common/collect/SynchronizedDequeTest.java', 'android/guava-tests/test/com/google/common/collect/SynchronizedQueueTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedDequeTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedQueueTest.java']","@@ -263,8 +263,8 @@ public void testHoldsLockOnAllOperations() {
     create().add(""foo"");
     create().addAll(ImmutableList.of(""foo""));
     create().clear();
-    create().contains(""foo"");
-    create().containsAll(ImmutableList.of(""foo""));
+    boolean unused = create().contains(""foo"");
+    boolean unused2 = create().containsAll(ImmutableList.of(""foo""));
     create().equals(new ArrayDeque<>(ImmutableList.of(""foo"")));
     create().hashCode();
     create().isEmpty();, @@ -161,8 +161,8 @@ public void testHoldsLockOnAllOperations() {
     create().add(""foo"");
     create().addAll(ImmutableList.of(""foo""));
     create().clear();
-    create().contains(""foo"");
-    create().containsAll(ImmutableList.of(""foo""));
+    boolean unused = create().contains(""foo"");
+    boolean unused2 = create().containsAll(ImmutableList.of(""foo""));
     create().equals(new ArrayDeque<>(ImmutableList.of(""foo"")));
     create().hashCode();
     create().isEmpty();, @@ -263,8 +263,8 @@ public void testHoldsLockOnAllOperations() {
     create().add(""foo"");
     create().addAll(ImmutableList.of(""foo""));
     create().clear();
-    create().contains(""foo"");
-    create().containsAll(ImmutableList.of(""foo""));
+    boolean unused = create().contains(""foo"");
+    boolean unused2 = create().containsAll(ImmutableList.of(""foo""));
     create().equals(new ArrayDeque<>(ImmutableList.of(""foo"")));
     create().hashCode();
     create().isEmpty();, @@ -162,8 +162,8 @@ public void testHoldsLockOnAllOperations() {
     create().add(""foo"");
     create().addAll(ImmutableList.of(""foo""));
     create().clear();
-    create().contains(""foo"");
-    create().containsAll(ImmutableList.of(""foo""));
+    boolean unused = create().contains(""foo"");
+    boolean unused2 = create().containsAll(ImmutableList.of(""foo""));
     create().equals(new ArrayDeque<>(ImmutableList.of(""foo"")));
     create().hashCode();
     create().isEmpty();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Assign the result of contains() and containsAll() to a variable.

This satisfies the CheckReturnValue checker.
[]

d99aad23b74bf91eb3084b2b40625e787e758ff3",MOE Sync 2019-12-27
3758,Nick,"['android/guava/src/com/google/common/math/Stats.java', 'android/guava/src/com/google/common/util/concurrent/AbstractService.java', 'guava/src/com/google/common/math/Stats.java', 'guava/src/com/google/common/util/concurrent/AbstractService.java']","@@ -170,8 +170,8 @@ public long count() {
    * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
    * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.
    *
-   * <p>If you only want to calculate the mean, use {#meanOf} instead of creating a {@link Stats}
-   * instance.
+   * <p>If you only want to calculate the mean, use {@link #meanOf} instead of creating a {@link
+   * Stats} instance.
    *
    * @throws IllegalStateException if the dataset is empty
    */, @@ -216,7 +216,7 @@ protected AbstractService() {}
    *
    * <p>If {@link #stopAsync} is called on a {@link State#STARTING} service, this method is not
    * invoked immediately. Instead, it will be deferred until after the service is {@link
-   * State#RUNNING}. Services that need to cancel startup work can override {#link #doCancelStart}.
+   * State#RUNNING}. Services that need to cancel startup work can override {@link #doCancelStart}.
    */
   @ForOverride
   protected abstract void doStop();, @@ -246,8 +246,8 @@ public long count() {
    * If it contains {@link Double#NEGATIVE_INFINITY} and finite values only or {@link
    * Double#NEGATIVE_INFINITY} only, the result is {@link Double#NEGATIVE_INFINITY}.
    *
-   * <p>If you only want to calculate the mean, use {#meanOf} instead of creating a {@link Stats}
-   * instance.
+   * <p>If you only want to calculate the mean, use {@link #meanOf} instead of creating a {@link
+   * Stats} instance.
    *
    * @throws IllegalStateException if the dataset is empty
    */, @@ -216,7 +216,7 @@ protected AbstractService() {}
    *
    * <p>If {@link #stopAsync} is called on a {@link State#STARTING} service, this method is not
    * invoked immediately. Instead, it will be deferred until after the service is {@link
-   * State#RUNNING}. Services that need to cancel startup work can override {#link #doCancelStart}.
+   * State#RUNNING}. Services that need to cancel startup work can override {@link #doCancelStart}.
    */
   @ForOverride
   protected abstract void doStop();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix instances of {#foo} in Javadoc.

31b05b7c67b4a6fe620dc14f33cc9818f7ee107c",MOE Sync 2020-01-02
3763,David P. Baker,"['android/guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java', 'android/guava-tests/test/com/google/common/collect/SynchronizedMapTest.java', 'guava-testlib/src/com/google/common/collect/testing/MapInterfaceTest.java', 'guava-tests/test/com/google/common/collect/ImmutableSetTest.java', 'guava-tests/test/com/google/common/collect/SynchronizedMapTest.java']","@@ -301,10 +301,10 @@ public void testContainsKey() {
     }
     assertTrue(map.containsKey(map.keySet().iterator().next()));
     if (allowsNullKeys) {
-      map.containsKey(null);
+      boolean unused = map.containsKey(null);
     } else {
       try {
-        map.containsKey(null);
+        boolean unused2 = map.containsKey(null);
       } catch (NullPointerException optional) {
       }
     }
@@ -323,10 +323,10 @@ public void testContainsValue() {
     assertFalse(map.containsValue(unmappedValue));
     assertTrue(map.containsValue(map.values().iterator().next()));
     if (allowsNullValues) {
-      map.containsValue(null);
+      boolean unused = map.containsValue(null);
     } else {
       try {
-        map.containsKey(null);
+        boolean unused2 = map.containsKey(null);
       } catch (NullPointerException optional) {
       }
     }, @@ -175,11 +175,11 @@ public void testClear() {
   }
 
   public void testContainsKey() {
-    create().containsKey(null);
+    boolean unused = create().containsKey(null);
   }
 
   public void testContainsValue() {
-    create().containsValue(null);
+    boolean unused = create().containsValue(null);
   }
 
   public void testGet() {, @@ -301,10 +301,10 @@ public void testContainsKey() {
     }
     assertTrue(map.containsKey(map.keySet().iterator().next()));
     if (allowsNullKeys) {
-      map.containsKey(null);
+      boolean unused = map.containsKey(null);
     } else {
       try {
-        map.containsKey(null);
+        boolean unused2 = map.containsKey(null);
       } catch (NullPointerException optional) {
       }
     }
@@ -323,10 +323,10 @@ public void testContainsValue() {
     assertFalse(map.containsValue(unmappedValue));
     assertTrue(map.containsValue(map.values().iterator().next()));
     if (allowsNullValues) {
-      map.containsValue(null);
+      boolean unused = map.containsValue(null);
     } else {
       try {
-        map.containsKey(null);
+        boolean unused2 = map.containsKey(null);
       } catch (NullPointerException optional) {
       }
     }, @@ -391,7 +391,13 @@ public FloodingTest() {
       super(
           Arrays.asList(ConstructionPathway.values()),
           n -> n * Math.log(n),
-          ImmutableList.of(QueryOp.create(""contains"", Set::contains, Math::log)));
+          ImmutableList.of(
+              QueryOp.create(
+                  ""contains"",
+                  (s, o) -> {
+                    boolean unused = s.contains(o);
+                  },
+                  Math::log)));
     }
     /** All the ways to construct an ImmutableSet. */
     enum ConstructionPathway implements Construction<Set<Object>> {, @@ -175,11 +175,11 @@ public void testClear() {
   }
 
   public void testContainsKey() {
-    create().containsKey(null);
+    boolean unused = create().containsKey(null);
   }
 
   public void testContainsValue() {
-    create().containsValue(null);
+    boolean unused = create().containsValue(null);
   }
 
   public void testGet() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update to JUnit 4.13

15262018825b31559b39e1ea84cccb29903f44e0

-------

<p> Note another case in which our implementation of TypeVariable throws UnsupportedOperationException.

55fdde6aee4878820e8fc7615c05ec8d0e365b5f

-------

<p> Suppress ignored return values from Collection#contains*.

I think this is all of them!

b574bfaead6951521ba9d174c935b55309fa51b8",MOE Sync 2020-01-06
3764,David P. Baker,"['android/guava/src/com/google/common/cache/LocalCache.java', 'guava/src/com/google/common/cache/LocalCache.java']","@@ -1675,6 +1675,7 @@ static int rehash(int h) {
    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.
    */
   // Guarded By Segment.this
+  @SuppressWarnings(""GuardedBy"")
   @VisibleForTesting
   ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
     int hash = original.getHash();, @@ -1677,6 +1677,7 @@ static int rehash(int h) {
    * This method is a convenience for testing. Code should call {@link Segment#copyEntry} directly.
    */
   // Guarded By Segment.this
+  @SuppressWarnings(""GuardedBy"")
   @VisibleForTesting
   ReferenceEntry<K, V> copyEntry(ReferenceEntry<K, V> original, ReferenceEntry<K, V> newNext) {
     int hash = original.getHash();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Ensure that we generate a non-empty Javadoc jar for guava-gwt.

Without it, we get an error during Sonatype deployment:
  Missing: no javadoc jar found in folder '/com/google/guava/guava-gwt/28.2-jre'

I hacked around this on the GitHub release branch for 28.2 by reenabling Javadoc:
https://github.com/google/guava/commit/a1b3c06876803a0b0e5d2f16708e1328da1bac09

But as you may recall from CL 276327335, we're soon going to have no classes to generate Javadoc for (after we remove GWT-RPC support). So even with Javadoc generation enabled, we'd end up with no jar.

To ensure that we get a jar, I've introduced a package-private dummy class (and then excluded it from the other steps in which source files are used).

80210f266950156ccd1eb56d18af7552f41dd274

-------

<p> ValueGraph: Support incidentEdgeOrder=stable

f05442beb167e9e7953022983f3885cb219d9968

-------

<p> ImmutableValueGraph: Support incidentEdgeOrder=stable

RELNOTES=N/A

12b0521095bde73b06c13ccd9558be10cd648d4f

-------

<p> Graph: Support stable incidentEdgeOrder for undirected graphs

e541ab5ee31f86733a0bfa0caa11f872292f51cd

-------

<p> Add StandardImmutableUndirectedGraphTest

5fddc483ad638b46badddcc44ca0501b9a185c5c

-------

<p> Suppress GuardedBy violation in LocalCache.

This looks like it's just for testing, which I think makes it /probably OK/, but feel free to suggest otherwise.

db04af06932fe7ff009a7903e44471e945ea057d",MOE Sync 2020-01-07
3765,David P. Baker,"['android/guava/src/com/google/common/base/Platform.java', 'android/guava/src/com/google/common/collect/Platform.java', 'android/guava/src/com/google/common/primitives/Platform.java', 'guava/src/com/google/common/base/Platform.java', 'guava/src/com/google/common/collect/Platform.java', 'guava/src/com/google/common/primitives/Platform.java']","@@ -14,9 +14,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
@@ -103,18 +100,5 @@ public boolean isPcreLike() {
     }
   }
 
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
-  static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
-      throw new UnsupportedOperationException(
-          lenientFormat(
-              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
-                  + "" support by setting the system property %s to true. For more about system""
-                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
-              ""https://stackoverflow.com/q/5189914/28465"",
-              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
-    }
-  }
+  static void checkGwtRpcEnabled() {}
 }, @@ -16,9 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -112,20 +109,7 @@ static int reduceExponentIfGwt(int exponent) {
     return exponent;
   }
 
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
-  static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
-      throw new UnsupportedOperationException(
-          lenientFormat(
-              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
-                  + "" support by setting the system property %s to true. For more about system""
-                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
-              ""https://stackoverflow.com/q/5189914/28465"",
-              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
-    }
-  }
+  static void checkGwtRpcEnabled() {}
 
   private Platform() {}
 }, @@ -14,28 +14,12 @@
 
 package com.google.common.primitives;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 
 /** Methods factored out so that they can be emulated differently in GWT. */
 @GwtCompatible(emulated = true)
 final class Platform {
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
-  static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
-      throw new UnsupportedOperationException(
-          lenientFormat(
-              ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
-                  + "" support by setting the system property %s to true. For more about system""
-                  + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
-              ""https://stackoverflow.com/q/5189914/28465"",
-              ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
-    }
-  }
+  static void checkGwtRpcEnabled() {}
 
   private Platform() {}
 }, @@ -14,9 +14,6 @@
 
 package com.google.common.base;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 import java.lang.ref.WeakReference;
 import java.util.Locale;
@@ -98,22 +95,22 @@ public boolean isPcreLike() {
     }
   }
 
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
   static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+    String propertyName = ""guava.gwt.emergency_reenable_rpc"";
+
+    if (!Boolean.parseBoolean(System.getProperty(propertyName, ""false""))) {
       throw new UnsupportedOperationException(
-          lenientFormat(
+          Strings.lenientFormat(
               ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
                   + "" support by setting the system property %s to true. For more about system""
                   + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
+              propertyName,
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
     logger.log(
         java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
+        ""Later in 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
             + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
             + "" can identify which type by looking at the class name in the attached stack trace."",
         new Throwable());, @@ -16,9 +16,6 @@
 
 package com.google.common.collect;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -115,22 +112,22 @@ static int reduceExponentIfGwt(int exponent) {
     return exponent;
   }
 
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
   static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+    String propertyName = ""guava.gwt.emergency_reenable_rpc"";
+
+    if (!Boolean.parseBoolean(System.getProperty(propertyName, ""false""))) {
       throw new UnsupportedOperationException(
-          lenientFormat(
+          com.google.common.base.Strings.lenientFormat(
               ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
                   + "" support by setting the system property %s to true. For more about system""
                   + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
+              propertyName,
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
     logger.log(
         java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
+        ""Later in 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
             + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
             + "" can identify which type by looking at the class name in the attached stack trace."",
         new Throwable());, @@ -14,9 +14,6 @@
 
 package com.google.common.primitives;
 
-import static com.google.common.base.Strings.lenientFormat;
-import static java.lang.Boolean.parseBoolean;
-
 import com.google.common.annotations.GwtCompatible;
 
 /** Methods factored out so that they can be emulated differently in GWT. */
@@ -25,22 +22,22 @@
   private static final java.util.logging.Logger logger =
       java.util.logging.Logger.getLogger(Platform.class.getName());
 
-  private static final String GWT_RPC_PROPERTY_NAME = ""guava.gwt.emergency_reenable_rpc"";
-
   static void checkGwtRpcEnabled() {
-    if (!parseBoolean(System.getProperty(GWT_RPC_PROPERTY_NAME, ""true""))) {
+    String propertyName = ""guava.gwt.emergency_reenable_rpc"";
+
+    if (!Boolean.parseBoolean(System.getProperty(propertyName, ""false""))) {
       throw new UnsupportedOperationException(
-          lenientFormat(
+          com.google.common.base.Strings.lenientFormat(
               ""We are removing GWT-RPC support for Guava types. You can temporarily reenable""
                   + "" support by setting the system property %s to true. For more about system""
                   + "" properties, see %s. For more about Guava's GWT-RPC support, see %s."",
-              GWT_RPC_PROPERTY_NAME,
+              propertyName,
               ""https://stackoverflow.com/q/5189914/28465"",
               ""https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ""));
     }
     logger.log(
         java.util.logging.Level.WARNING,
-        ""In January 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
+        ""Later in 2020, we will remove GWT-RPC support for Guava types. You are seeing this""
             + "" warning because you are sending a Guava type over GWT-RPC, which will break. You""
             + "" can identify which type by looking at the class name in the attached stack trace."",
         new Throwable());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add test case stable incidentEdgeOrder with a self loop to AbstractStandard[Un]directedGraphTest.

aee54682770a3166c231bbfecced91f31c55d32a

-------

<p> Add test for stable incidentEdgeOrder support for mutable undirected valuegraphs in ValueGraphTest

0aba85dd247e254e10fcd84e7b2940fa0383e14e

-------

<p> Fix off-by-one error in AsciiDigits.asciiDigits initialization.

Fixes #3761.

2b27d9f906e18ae1105766d41e0940122ce686a0

-------

<p> Disable GWT-RPC by default in the open-source release.

RELNOTES=[Guava types can no longer be sent over GWT-RPC.](https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ) To _temporarily_ reenable support, set the `guava.gwt.emergency_reenable_rpc` system property to `true`.

ff0cd947f82d24611e39fb3d86e3d19da4af801f",MOE Sync 2020-01-08
3767,David P. Baker,"['android/guava/src/com/google/common/graph/ElementOrder.java', 'android/guava/src/com/google/common/graph/GraphBuilder.java', 'android/guava/src/com/google/common/graph/ValueGraphBuilder.java', 'guava/src/com/google/common/graph/ElementOrder.java', 'guava/src/com/google/common/graph/GraphBuilder.java', 'guava/src/com/google/common/graph/ValueGraphBuilder.java']","@@ -116,8 +116,7 @@ private ElementOrder(Type type, @NullableDecl Comparator<T> comparator) {
    *       </ul>
    * </ul>
    */
-  // TODO(b/142723300): Make this method public
-  static <S> ElementOrder<S> stable() {
+  public static <S> ElementOrder<S> stable() {
     return new ElementOrder<S>(Type.STABLE, null);
   }
 , @@ -155,8 +155,7 @@ private GraphBuilder(boolean directed) {
    * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
    *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
    */
-  // TODO(b/142723300): Make this method public
-  <N1 extends N> GraphBuilder<N1> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
+  public <N1 extends N> GraphBuilder<N1> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
     checkArgument(
         incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED
             || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,, @@ -159,8 +159,8 @@ private ValueGraphBuilder(boolean directed) {
    * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
    *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
    */
-  // TODO(b/142723300): Make this method public
-  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
+  public <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(
+      ElementOrder<N1> incidentEdgeOrder) {
     checkArgument(
         incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED
             || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,, @@ -115,8 +115,7 @@ private ElementOrder(Type type, @Nullable Comparator<T> comparator) {
    *       </ul>
    * </ul>
    */
-  // TODO(b/142723300): Make this method public
-  static <S> ElementOrder<S> stable() {
+  public static <S> ElementOrder<S> stable() {
     return new ElementOrder<S>(Type.STABLE, null);
   }
 , @@ -155,8 +155,7 @@ private GraphBuilder(boolean directed) {
    * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
    *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
    */
-  // TODO(b/142723300): Make this method public
-  <N1 extends N> GraphBuilder<N1> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
+  public <N1 extends N> GraphBuilder<N1> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
     checkArgument(
         incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED
             || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,, @@ -159,8 +159,8 @@ private ValueGraphBuilder(boolean directed) {
    * @throws IllegalArgumentException if {@code incidentEdgeOrder} is not either {@code
    *     ElementOrder.unordered()} or {@code ElementOrder.stable()}.
    */
-  // TODO(b/142723300): Make this method public
-  <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(ElementOrder<N1> incidentEdgeOrder) {
+  public <N1 extends N> ValueGraphBuilder<N1, V> incidentEdgeOrder(
+      ElementOrder<N1> incidentEdgeOrder) {
     checkArgument(
         incidentEdgeOrder.type() == ElementOrder.Type.UNORDERED
             || incidentEdgeOrder.type() == ElementOrder.Type.STABLE,, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add incidentEdgeOrder() to the [Value]Graph interface

RELNOTES=`graph`: Add `incidentEdgeOrder()` to the `[Value]Graph` interfaces

ae2710e8cb1d0ab80e247334273695da0c7b3afb

-------

<p> Make incidentEdgeOrder() public for [Value]Graph

RELNOTES=`graph`: Allow setting a stable incident edge order by calling the newly added method `[Value]Graph.Builder.incidentEdgeOrder(ElementOrder.stable())`.

0ceaed084bb7e52d8fa3b0760cb0ffe486918a00",MOE Sync 2020-01-09
3769,Colin Decker,['pom.xml'],"@@ -247,7 +247,7 @@
       <dependency>
         <groupId>org.checkerframework</groupId>
         <artifactId>checker-qual</artifactId>
-        <version>2.10.0</version>
+        <version>2.11.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Upgrade checker-qual to v2.11.1.

Fixes https://github.com/google/guava/pull/3671

f85d76f668074f9cb396a5f55bf9588d9262a5fa",MOE Sync 2020-01-14
3772,Colin Decker,"['android/guava/src/com/google/common/base/Stopwatch.java', 'guava/src/com/google/common/base/Stopwatch.java']","@@ -29,15 +29,24 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * An object that measures elapsed time in nanoseconds. It is useful to measure elapsed time using
- * this class instead of direct calls to {@link System#nanoTime} for a few reasons:
+ * An object that accurately measures <i>elapsed time</i>: the measured duration between two
+ * successive readings of ""now"" in the same process.
+ *
+ * <p>In contrast, <i>wall time</i> is a reading of ""now"" as given by a method like
+ * {@link System#currentTimeMillis()}, best represented as an {@link Instant}. Such values
+ *
+ * <p><i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}),
+ * but doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time
+ * readings are inherently approximate, routinely affected by periodic clock corrections. Because
+ * this class (by default) uses {@link System#nanoTime}, it is unaffected by these changes.
+ *
+ * <p>Use this class instead of direct calls to {@link System#nanoTime} for two reasons:
  *
  * <ul>
- *   <li>An alternate time source can be substituted, for testing or performance reasons.
- *   <li>As documented by {@code nanoTime}, the value returned has no absolute meaning, and can only
- *       be interpreted as relative to another timestamp returned by {@code nanoTime} at a different
- *       time. {@code Stopwatch} is a more effective abstraction because it exposes only these
- *       relative values, not the absolute ones.
+ *   <li>The raw {@code long} values returned by {@code nanoTime} are meaningless and unsafe to use
+ *       in any other way than how {@code Stopwatch} uses them.
+ *   <li>An alternative source of nanosecond ticks can be substituted, for example for testing or
+ *       performance reasons, without affecting most of your code.
  * </ul>
  *
  * <p>Basic usage:
@@ -52,8 +61,8 @@
  * log.info(""time: "" + stopwatch); // formatted string like ""12.3 ms""
  * }</pre>
  *
- * <p>Stopwatch methods are not idempotent; it is an error to start or stop a stopwatch that is
- * already in the desired state.
+ * <p>The state-changing methods are not idempotent; it is an error to start or stop a stopwatch
+ * that is already in the desired state.
  *
  * <p>When testing code that uses this class, use {@link #createUnstarted(Ticker)} or {@link
  * #createStarted(Ticker)} to supply a fake or mock ticker. This allows you to simulate any valid, @@ -32,15 +32,23 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * An object that measures elapsed time in nanoseconds. It is useful to measure elapsed time using
- * this class instead of direct calls to {@link System#nanoTime} for a few reasons:
+ * An object that accurately measures <i>elapsed time</i>: the measured duration between two
+ * successive readings of ""now"" in the same process.
+ *
+ * <p>In contrast, <i>wall time</i> is a reading of ""now"" as given by a method like
+ * {@link System#currentTimeMillis()}, best represented as an {@link Instant}. Such values
+ * <i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}), but
+ * doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings
+ * are inherently approximate, routinely affected by periodic clock corrections. Because this class
+ * (by default) uses {@link System#nanoTime}, it is unaffected by these changes.
+ *
+ * <p>Use this class instead of direct calls to {@link System#nanoTime} for two reasons:
  *
  * <ul>
- *   <li>An alternate time source can be substituted, for testing or performance reasons.
- *   <li>As documented by {@code nanoTime}, the value returned has no absolute meaning, and can only
- *       be interpreted as relative to another timestamp returned by {@code nanoTime} at a different
- *       time. {@code Stopwatch} is a more effective abstraction because it exposes only these
- *       relative values, not the absolute ones.
+ *   <li>The raw {@code long} values returned by {@code nanoTime} are meaningless and unsafe to use
+ *       in any other way than how {@code Stopwatch} uses them.
+ *   <li>An alternative source of nanosecond ticks can be substituted, for example for testing or
+ *       performance reasons, without affecting most of your code.
  * </ul>
  *
  * <p>Basic usage:
@@ -55,8 +63,8 @@
  * log.info(""time: "" + stopwatch); // formatted string like ""12.3 ms""
  * }</pre>
  *
- * <p>Stopwatch methods are not idempotent; it is an error to start or stop a stopwatch that is
- * already in the desired state.
+ * <p>The state-changing methods are not idempotent; it is an error to start or stop a stopwatch
+ * that is already in the desired state.
  *
  * <p>When testing code that uses this class, use {@link #createUnstarted(Ticker)} or {@link
  * #createStarted(Ticker)} to supply a fake or mock ticker. This allows you to simulate any valid, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Public Suffix data.

fea136b2585cd01765e67de83e54dad6a0aebae5

-------

<p> Rewrite the Stopwatch docs to explain elapsed vs wall time

81b9816a5e8347a05518c7869464e0f357be58b7",MOE Sync 2020-01-16
3773,Colin Decker,"['android/guava/src/com/google/common/io/Resources.java', 'guava/src/com/google/common/io/Resources.java']","@@ -202,6 +202,7 @@ public static URL getResource(String resourceName) {
    *
    * @throws IllegalArgumentException if the resource is not found
    */
+  @CanIgnoreReturnValue // being used to check if a resource exists
   public static URL getResource(Class<?> contextClass, String resourceName) {
     URL url = contextClass.getResource(resourceName);
     checkArgument(, @@ -202,6 +202,7 @@ public static URL getResource(String resourceName) {
    *
    * @throws IllegalArgumentException if the resource is not found
    */
+  @CanIgnoreReturnValue // being used to check if a resource exists
   public static URL getResource(Class<?> contextClass, String resourceName) {
     URL url = contextClass.getResource(resourceName);
     checkArgument(, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Resource.getResource to allow ignoring return value for existence checks.

Specifically this impacts getResource(contextClass, resourceName) as this is already present on getResource(resourceName)

RELNOTES=Update Resource.getResource(*) to allow ignoring return value for existence checks.

383c278b7b8044feac53153c0dd3202d3fa0b3c6",MOE Sync 2020-01-17
3778,Ben McIlwain,['index.md'],"@@ -3,9 +3,11 @@ layout: default
 title: Guava
 ---
 
-Guava is a set of core libraries from Google that includes new collection types
+Guava is a set of core Java libraries from Google that includes new collection types
 (such as multimap and multiset), immutable collections, a graph library, and
-utilities for concurrency, I/O, hashing, primitives, strings, and more!
+utilities for concurrency, I/O, hashing, caching, primitives, strings, and more! It
+is widely used on most Java projects within Google, and widely used by many
+other companies as well.
 
 Guava comes in two flavors.
 
@@ -46,7 +48,7 @@ dependencies {
 }
 ```
 
-## Snapshots
+## Snapshots and Documentation
 
 Snapshots of Guava built from the `master` branch are available through Maven
 using version `HEAD-jre-SNAPSHOT`, or `HEAD-android-SNAPSHOT` for the Android, ","This change makes it clear how widely used Guava actually is; it's not just another throw-away library, it's essential to Java development with Google and many other companies.

<!-- Reviewable:start -->
---
This change is [<img src=""https://reviewable.io/review_button.svg"" height=""34"" align=""absmiddle"" alt=""Reviewable""/>](https://reviewable.io/reviews/google/guava/3778)
<!-- Reviewable:end -->",Add more context to the guava.dev landing page
3780,Chris Povirk,['_config.yml'],"@@ -4,39 +4,19 @@ subtitle: Google core libraries for Java
 description: Google core libraries for Java
 baseurl: /
 url: https://guava.dev
-permalink: /news/:year/:month/:day/:title/
 
 themeColor: red
 
 exclude:
-- ""Gemfile*""
-- ""README.md""
-- ""*.sh""
-
-# Set by default by GitHub pages (can't be changed)
-safe: true
-lsi: false
-markdown: kramdown
-kramdown:
-  input: GFM
-  hard_wrap: false
-highlighter: rouge
-gist:
-  noscript: false
-# source: <top level directory>
-
-# Set by default by GitHub pages (can be changed)
-# github: <repository metadata> (https://help.github.com/articles/repository-metadata-on-github-pages/)
-
-# Collections
-#collections:
-# releases collection disabled until there's non-Javadoc/JDiff content that needs to go there
-# Files under the releases/ directory (where the Javadoc/JDiff is kept) are included directly.
-# When there are .md files that need rendering, they should go under _releases and this collection
-# should be re-enabled.
-# releases:
-#   output: true
-#   permalink: /:collection/:path/
+  - CHANGELOG.md
+  - Gemfile
+  - Gemfile.lock
+  - LICENSE
+  - README.md
+  - _site
+  - node_modules
+  - vendor
+  - ""*.sh""
 
 # Release data
 # Do not change! updaterelease.sh automatically updates these fields, ","The one I really care about removing is `safe: true`.
It seems to have been required at one point but not anymore.
And `safe: true` appears to prevent plugins from working.
This is a problem when I try to use jekyll-redirect-from for b/144155774.

The rest are just to hopefully avoid future problems.
Or maybe cause them :)
But I'm encouraged that they're mostly absent from our other projects, like Truth.

Also, while here, update our exclude section to look more like what we've done for our other projects.
Compare to https://github.com/google/truth/commit/3f22311589f438e51ad2f74d3c67eb234da4ad7e",Remove some settings that we don't appear to need.
3782,Chris Povirk,"['javadocshortcuts/AbstractCache.AbstractCache/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.SimpleStatsCounter/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.incrementBy/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.recordEviction/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.recordHits/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.recordLoadException/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.recordLoadSuccess/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.recordMisses/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter.snapshot/index.md', 'javadocshortcuts/AbstractCache.SimpleStatsCounter/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.recordEviction/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.recordHits/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.recordLoadException/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.recordLoadSuccess/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.recordMisses/index.md', 'javadocshortcuts/AbstractCache.StatsCounter.snapshot/index.md', 'javadocshortcuts/AbstractCache.StatsCounter/index.md', 'javadocshortcuts/AbstractCache.asMap/index.md', 'javadocshortcuts/AbstractCache.cleanUp/index.md', 'javadocshortcuts/AbstractCache.get/index.md', 'javadocshortcuts/AbstractCache.getAllPresent/index.md', 'javadocshortcuts/AbstractCache.invalidate/index.md', 'javadocshortcuts/AbstractCache.invalidateAll/index.md', 'javadocshortcuts/AbstractCache.put/index.md', 'javadocshortcuts/AbstractCache.putAll/index.md', 'javadocshortcuts/AbstractCache.size/index.md', 'javadocshortcuts/AbstractCache.stats/index.md', 'javadocshortcuts/AbstractCache/index.md', 'javadocshortcuts/AbstractExecutionThreadService.AbstractExecutionThreadService/index.md', 'javadocshortcuts/AbstractExecutionThreadService.addListener/index.md', 'javadocshortcuts/AbstractExecutionThreadService.awaitRunning/index.md', 'javadocshortcuts/AbstractExecutionThreadService.awaitTerminated/index.md', 'javadocshortcuts/AbstractExecutionThreadService.executor/index.md', 'javadocshortcuts/AbstractExecutionThreadService.failureCause/index.md', 'javadocshortcuts/AbstractExecutionThreadService.isRunning/index.md', 'javadocshortcuts/AbstractExecutionThreadService.run/index.md', 'javadocshortcuts/AbstractExecutionThreadService.serviceName/index.md', 'javadocshortcuts/AbstractExecutionThreadService.shutDown/index.md', 'javadocshortcuts/AbstractExecutionThreadService.startAsync/index.md', 'javadocshortcuts/AbstractExecutionThreadService.startUp/index.md', 'javadocshortcuts/AbstractExecutionThreadService.state/index.md', 'javadocshortcuts/AbstractExecutionThreadService.stopAsync/index.md', 'javadocshortcuts/AbstractExecutionThreadService.toString/index.md', 'javadocshortcuts/AbstractExecutionThreadService.triggerShutdown/index.md', 'javadocshortcuts/AbstractExecutionThreadService/index.md', 'javadocshortcuts/AbstractFuture.AbstractFuture/index.md', 'javadocshortcuts/AbstractFuture.addListener/index.md', 'javadocshortcuts/AbstractFuture.afterDone/index.md', 'javadocshortcuts/AbstractFuture.cancel/index.md', 'javadocshortcuts/AbstractFuture.get/index.md', 'javadocshortcuts/AbstractFuture.interruptTask/index.md', 'javadocshortcuts/AbstractFuture.isCancelled/index.md', 'javadocshortcuts/AbstractFuture.isDone/index.md', 'javadocshortcuts/AbstractFuture.pendingToString/index.md', 'javadocshortcuts/AbstractFuture.set/index.md', 'javadocshortcuts/AbstractFuture.setException/index.md', 'javadocshortcuts/AbstractFuture.setFuture/index.md', 'javadocshortcuts/AbstractFuture.toString/index.md', 'javadocshortcuts/AbstractFuture.tryInternalFastPathGetFailure/index.md', 'javadocshortcuts/AbstractFuture.wasInterrupted/index.md', 'javadocshortcuts/AbstractFuture/index.md', 'javadocshortcuts/AbstractGraph.AbstractGraph/index.md', 'javadocshortcuts/AbstractGraph.equals/index.md', 'javadocshortcuts/AbstractGraph.hashCode/index.md', 'javadocshortcuts/AbstractGraph.toString/index.md', 'javadocshortcuts/AbstractGraph/index.md', 'javadocshortcuts/AbstractIdleService.AbstractIdleService/index.md', 'javadocshortcuts/AbstractIdleService.addListener/index.md', 'javadocshortcuts/AbstractIdleService.awaitRunning/index.md', 'javadocshortcuts/AbstractIdleService.awaitTerminated/index.md', 'javadocshortcuts/AbstractIdleService.executor/index.md', 'javadocshortcuts/AbstractIdleService.failureCause/index.md', 'javadocshortcuts/AbstractIdleService.isRunning/index.md', 'javadocshortcuts/AbstractIdleService.serviceName/index.md', 'javadocshortcuts/AbstractIdleService.shutDown/index.md', 'javadocshortcuts/AbstractIdleService.startAsync/index.md', 'javadocshortcuts/AbstractIdleService.startUp/index.md', 'javadocshortcuts/AbstractIdleService.state/index.md', 'javadocshortcuts/AbstractIdleService.stopAsync/index.md', 'javadocshortcuts/AbstractIdleService.toString/index.md', 'javadocshortcuts/AbstractIdleService/index.md', 'javadocshortcuts/AbstractInvocationHandler.AbstractInvocationHandler/index.md', 'javadocshortcuts/AbstractInvocationHandler.equals/index.md', 'javadocshortcuts/AbstractInvocationHandler.handleInvocation/index.md', 'javadocshortcuts/AbstractInvocationHandler.hashCode/index.md', 'javadocshortcuts/AbstractInvocationHandler.invoke/index.md', 'javadocshortcuts/AbstractInvocationHandler.toString/index.md', 'javadocshortcuts/AbstractInvocationHandler/index.md', 'javadocshortcuts/AbstractIterator.AbstractIterator/index.md', 'javadocshortcuts/AbstractIterator.computeNext/index.md', 'javadocshortcuts/AbstractIterator.endOfData/index.md', 'javadocshortcuts/AbstractIterator.hasNext/index.md', 'javadocshortcuts/AbstractIterator.next/index.md', 'javadocshortcuts/AbstractIterator.peek/index.md', 'javadocshortcuts/AbstractIterator/index.md', 'javadocshortcuts/AbstractListeningExecutorService.AbstractListeningExecutorService/index.md', 'javadocshortcuts/AbstractListeningExecutorService.newTaskFor/index.md', 'javadocshortcuts/AbstractListeningExecutorService.submit/index.md', 'javadocshortcuts/AbstractListeningExecutorService/index.md', 'javadocshortcuts/AbstractLoadingCache.AbstractLoadingCache/index.md', 'javadocshortcuts/AbstractLoadingCache.apply/index.md', 'javadocshortcuts/AbstractLoadingCache.getAll/index.md', 'javadocshortcuts/AbstractLoadingCache.getUnchecked/index.md', 'javadocshortcuts/AbstractLoadingCache.refresh/index.md', 'javadocshortcuts/AbstractLoadingCache/index.md', 'javadocshortcuts/AbstractNetwork.AbstractNetwork/index.md', 'javadocshortcuts/AbstractNetwork.adjacentEdges/index.md', 'javadocshortcuts/AbstractNetwork.asGraph/index.md', 'javadocshortcuts/AbstractNetwork.degree/index.md', 'javadocshortcuts/AbstractNetwork.edgeConnecting/index.md', 'javadocshortcuts/AbstractNetwork.edgeConnectingOrNull/index.md', 'javadocshortcuts/AbstractNetwork.edgesConnecting/index.md', 'javadocshortcuts/AbstractNetwork.equals/index.md', 'javadocshortcuts/AbstractNetwork.hasEdgeConnecting/index.md', 'javadocshortcuts/AbstractNetwork.hashCode/index.md', 'javadocshortcuts/AbstractNetwork.inDegree/index.md', 'javadocshortcuts/AbstractNetwork.isOrderingCompatible/index.md', 'javadocshortcuts/AbstractNetwork.outDegree/index.md', 'javadocshortcuts/AbstractNetwork.toString/index.md', 'javadocshortcuts/AbstractNetwork.validateEndpoints/index.md', 'javadocshortcuts/AbstractNetwork/index.md', 'javadocshortcuts/AbstractScheduledService.AbstractScheduledService/index.md', 'javadocshortcuts/AbstractScheduledService.CustomScheduler.CustomScheduler/index.md', 'javadocshortcuts/AbstractScheduledService.CustomScheduler.Schedule.Schedule/index.md', 'javadocshortcuts/AbstractScheduledService.CustomScheduler.Schedule/index.md', 'javadocshortcuts/AbstractScheduledService.CustomScheduler.getNextSchedule/index.md', 'javadocshortcuts/AbstractScheduledService.CustomScheduler/index.md', 'javadocshortcuts/AbstractScheduledService.Scheduler.newFixedDelaySchedule/index.md', 'javadocshortcuts/AbstractScheduledService.Scheduler.newFixedRateSchedule/index.md', 'javadocshortcuts/AbstractScheduledService.Scheduler/index.md', 'javadocshortcuts/AbstractScheduledService.addListener/index.md', 'javadocshortcuts/AbstractScheduledService.awaitRunning/index.md', 'javadocshortcuts/AbstractScheduledService.awaitTerminated/index.md', 'javadocshortcuts/AbstractScheduledService.executor/index.md', 'javadocshortcuts/AbstractScheduledService.failureCause/index.md', 'javadocshortcuts/AbstractScheduledService.isRunning/index.md', 'javadocshortcuts/AbstractScheduledService.runOneIteration/index.md', 'javadocshortcuts/AbstractScheduledService.scheduler/index.md', 'javadocshortcuts/AbstractScheduledService.serviceName/index.md', 'javadocshortcuts/AbstractScheduledService.shutDown/index.md', 'javadocshortcuts/AbstractScheduledService.startAsync/index.md', 'javadocshortcuts/AbstractScheduledService.startUp/index.md', 'javadocshortcuts/AbstractScheduledService.state/index.md', 'javadocshortcuts/AbstractScheduledService.stopAsync/index.md', 'javadocshortcuts/AbstractScheduledService.toString/index.md', 'javadocshortcuts/AbstractScheduledService/index.md', 'javadocshortcuts/AbstractSequentialIterator.AbstractSequentialIterator/index.md', 'javadocshortcuts/AbstractSequentialIterator.computeNext/index.md', 'javadocshortcuts/AbstractSequentialIterator.hasNext/index.md', 'javadocshortcuts/AbstractSequentialIterator.next/index.md', 'javadocshortcuts/AbstractSequentialIterator/index.md', 'javadocshortcuts/AbstractService.AbstractService/index.md', 'javadocshortcuts/AbstractService.addListener/index.md', 'javadocshortcuts/AbstractService.awaitRunning/index.md', 'javadocshortcuts/AbstractService.awaitTerminated/index.md', 'javadocshortcuts/AbstractService.doCancelStart/index.md', 'javadocshortcuts/AbstractService.doStart/index.md', 'javadocshortcuts/AbstractService.doStop/index.md', 'javadocshortcuts/AbstractService.failureCause/index.md', 'javadocshortcuts/AbstractService.isRunning/index.md', 'javadocshortcuts/AbstractService.notifyFailed/index.md', 'javadocshortcuts/AbstractService.notifyStarted/index.md', 'javadocshortcuts/AbstractService.notifyStopped/index.md', 'javadocshortcuts/AbstractService.startAsync/index.md', 'javadocshortcuts/AbstractService.state/index.md', 'javadocshortcuts/AbstractService.stopAsync/index.md', 'javadocshortcuts/AbstractService.toString/index.md', 'javadocshortcuts/AbstractService/index.md', 'javadocshortcuts/AbstractValueGraph.AbstractValueGraph/index.md', 'javadocshortcuts/AbstractValueGraph.asGraph/index.md', 'javadocshortcuts/AbstractValueGraph.edgeValue/index.md', 'javadocshortcuts/AbstractValueGraph.equals/index.md', 'javadocshortcuts/AbstractValueGraph.hashCode/index.md', 'javadocshortcuts/AbstractValueGraph.toString/index.md', 'javadocshortcuts/AbstractValueGraph/index.md', 'javadocshortcuts/AllowConcurrentEvents/index.md', 'javadocshortcuts/ArrayBasedCharEscaper.ArrayBasedCharEscaper/index.md', 'javadocshortcuts/ArrayBasedCharEscaper.escape/index.md', 'javadocshortcuts/ArrayBasedCharEscaper.escapeUnsafe/index.md', 'javadocshortcuts/ArrayBasedCharEscaper/index.md', 'javadocshortcuts/ArrayBasedEscaperMap.create/index.md', 'javadocshortcuts/ArrayBasedEscaperMap/index.md', 'javadocshortcuts/ArrayBasedUnicodeEscaper.ArrayBasedUnicodeEscaper/index.md', 'javadocshortcuts/ArrayBasedUnicodeEscaper.escape/index.md', 'javadocshortcuts/ArrayBasedUnicodeEscaper.escapeUnsafe/index.md', 'javadocshortcuts/ArrayBasedUnicodeEscaper.nextEscapeIndex/index.md', 'javadocshortcuts/ArrayBasedUnicodeEscaper/index.md', 'javadocshortcuts/ArrayListMultimap.create/index.md', 'javadocshortcuts/ArrayListMultimap.trimToSize/index.md', 'javadocshortcuts/ArrayListMultimap/index.md', 'javadocshortcuts/ArrayTable.at/index.md', 'javadocshortcuts/ArrayTable.cellSet/index.md', 'javadocshortcuts/ArrayTable.clear/index.md', 'javadocshortcuts/ArrayTable.column/index.md', 'javadocshortcuts/ArrayTable.columnKeyList/index.md', 'javadocshortcuts/ArrayTable.columnKeySet/index.md', 'javadocshortcuts/ArrayTable.columnMap/index.md', 'javadocshortcuts/ArrayTable.contains/index.md', 'javadocshortcuts/ArrayTable.containsColumn/index.md', 'javadocshortcuts/ArrayTable.containsRow/index.md', 'javadocshortcuts/ArrayTable.containsValue/index.md', 'javadocshortcuts/ArrayTable.create/index.md', 'javadocshortcuts/ArrayTable.erase/index.md', 'javadocshortcuts/ArrayTable.eraseAll/index.md', 'javadocshortcuts/ArrayTable.get/index.md', 'javadocshortcuts/ArrayTable.isEmpty/index.md', 'javadocshortcuts/ArrayTable.put/index.md', 'javadocshortcuts/ArrayTable.putAll/index.md', 'javadocshortcuts/ArrayTable.remove/index.md', 'javadocshortcuts/ArrayTable.row/index.md', 'javadocshortcuts/ArrayTable.rowKeyList/index.md', 'javadocshortcuts/ArrayTable.rowKeySet/index.md', 'javadocshortcuts/ArrayTable.rowMap/index.md', 'javadocshortcuts/ArrayTable.set/index.md', 'javadocshortcuts/ArrayTable.size/index.md', 'javadocshortcuts/ArrayTable.toArray/index.md', 'javadocshortcuts/ArrayTable.values/index.md', 'javadocshortcuts/ArrayTable/index.md', 'javadocshortcuts/Ascii.ACK/index.md', 'javadocshortcuts/Ascii.BEL/index.md', 'javadocshortcuts/Ascii.BS/index.md', 'javadocshortcuts/Ascii.CAN/index.md', 'javadocshortcuts/Ascii.CR/index.md', 'javadocshortcuts/Ascii.DC1/index.md', 'javadocshortcuts/Ascii.DC2/index.md', 'javadocshortcuts/Ascii.DC3/index.md', 'javadocshortcuts/Ascii.DC4/index.md', 'javadocshortcuts/Ascii.DEL/index.md', 'javadocshortcuts/Ascii.DLE/index.md', 'javadocshortcuts/Ascii.EM/index.md', 'javadocshortcuts/Ascii.ENQ/index.md', 'javadocshortcuts/Ascii.EOT/index.md', 'javadocshortcuts/Ascii.ESC/index.md', 'javadocshortcuts/Ascii.ETB/index.md', 'javadocshortcuts/Ascii.ETX/index.md', 'javadocshortcuts/Ascii.FF/index.md', 'javadocshortcuts/Ascii.FS/index.md', 'javadocshortcuts/Ascii.GS/index.md', 'javadocshortcuts/Ascii.HT/index.md', 'javadocshortcuts/Ascii.LF/index.md', 'javadocshortcuts/Ascii.MAX/index.md', 'javadocshortcuts/Ascii.MIN/index.md', 'javadocshortcuts/Ascii.NAK/index.md', 'javadocshortcuts/Ascii.NL/index.md', 'javadocshortcuts/Ascii.NUL/index.md', 'javadocshortcuts/Ascii.RS/index.md', 'javadocshortcuts/Ascii.SI/index.md', 'javadocshortcuts/Ascii.SO/index.md', 'javadocshortcuts/Ascii.SOH/index.md', 'javadocshortcuts/Ascii.SP/index.md', 'javadocshortcuts/Ascii.SPACE/index.md', 'javadocshortcuts/Ascii.STX/index.md', 'javadocshortcuts/Ascii.SUB/index.md', 'javadocshortcuts/Ascii.SYN/index.md', 'javadocshortcuts/Ascii.US/index.md', 'javadocshortcuts/Ascii.VT/index.md', 'javadocshortcuts/Ascii.XOFF/index.md', 'javadocshortcuts/Ascii.XON/index.md', 'javadocshortcuts/Ascii.equalsIgnoreCase/index.md', 'javadocshortcuts/Ascii.isLowerCase/index.md', 'javadocshortcuts/Ascii.isUpperCase/index.md', 'javadocshortcuts/Ascii.toLowerCase/index.md', 'javadocshortcuts/Ascii.toUpperCase/index.md', 'javadocshortcuts/Ascii.truncate/index.md', 'javadocshortcuts/Ascii/index.md', 'javadocshortcuts/AsyncCallable.call/index.md', 'javadocshortcuts/AsyncCallable/index.md', 'javadocshortcuts/AsyncEventBus.AsyncEventBus/index.md', 'javadocshortcuts/AsyncEventBus/index.md', 'javadocshortcuts/AsyncFunction.apply/index.md', 'javadocshortcuts/AsyncFunction/index.md', 'javadocshortcuts/AtomicDouble.AtomicDouble/index.md', 'javadocshortcuts/AtomicDouble.addAndGet/index.md', 'javadocshortcuts/AtomicDouble.compareAndSet/index.md', 'javadocshortcuts/AtomicDouble.doubleValue/index.md', 'javadocshortcuts/AtomicDouble.floatValue/index.md', 'javadocshortcuts/AtomicDouble.get/index.md', 'javadocshortcuts/AtomicDouble.getAndAdd/index.md', 'javadocshortcuts/AtomicDouble.getAndSet/index.md', 'javadocshortcuts/AtomicDouble.intValue/index.md', 'javadocshortcuts/AtomicDouble.lazySet/index.md', 'javadocshortcuts/AtomicDouble.longValue/index.md', 'javadocshortcuts/AtomicDouble.set/index.md', 'javadocshortcuts/AtomicDouble.toString/index.md', 'javadocshortcuts/AtomicDouble.weakCompareAndSet/index.md', 'javadocshortcuts/AtomicDouble/index.md', 'javadocshortcuts/AtomicDoubleArray.AtomicDoubleArray/index.md', 'javadocshortcuts/AtomicDoubleArray.addAndGet/index.md', 'javadocshortcuts/AtomicDoubleArray.compareAndSet/index.md', 'javadocshortcuts/AtomicDoubleArray.get/index.md', 'javadocshortcuts/AtomicDoubleArray.getAndAdd/index.md', 'javadocshortcuts/AtomicDoubleArray.getAndSet/index.md', 'javadocshortcuts/AtomicDoubleArray.lazySet/index.md', 'javadocshortcuts/AtomicDoubleArray.length/index.md', 'javadocshortcuts/AtomicDoubleArray.set/index.md', 'javadocshortcuts/AtomicDoubleArray.toString/index.md', 'javadocshortcuts/AtomicDoubleArray.weakCompareAndSet/index.md', 'javadocshortcuts/AtomicDoubleArray/index.md', 'javadocshortcuts/AtomicLongMap.accumulateAndGet/index.md', 'javadocshortcuts/AtomicLongMap.addAndGet/index.md']","@@ -0,0 +1,5 @@
+---
+title: AbstractCache.AbstractCache
+permalink: /AbstractCache.AbstractCache/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#AbstractCache--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.SimpleStatsCounter
+permalink: /AbstractCache.SimpleStatsCounter.SimpleStatsCounter/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#SimpleStatsCounter--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.incrementBy
+permalink: /AbstractCache.SimpleStatsCounter.incrementBy/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#incrementBy-com.google.common.cache.AbstractCache.StatsCounter-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.recordEviction
+permalink: /AbstractCache.SimpleStatsCounter.recordEviction/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#recordEviction--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.recordHits
+permalink: /AbstractCache.SimpleStatsCounter.recordHits/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#recordHits-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.recordLoadException
+permalink: /AbstractCache.SimpleStatsCounter.recordLoadException/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#recordLoadException-long-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.recordLoadSuccess
+permalink: /AbstractCache.SimpleStatsCounter.recordLoadSuccess/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#recordLoadSuccess-long-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.recordMisses
+permalink: /AbstractCache.SimpleStatsCounter.recordMisses/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#recordMisses-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter.snapshot
+permalink: /AbstractCache.SimpleStatsCounter.snapshot/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html#snapshot--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.SimpleStatsCounter
+permalink: /AbstractCache.SimpleStatsCounter/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.SimpleStatsCounter.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.recordEviction
+permalink: /AbstractCache.StatsCounter.recordEviction/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#recordEviction--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.recordHits
+permalink: /AbstractCache.StatsCounter.recordHits/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#recordHits-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.recordLoadException
+permalink: /AbstractCache.StatsCounter.recordLoadException/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#recordLoadException-long-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.recordLoadSuccess
+permalink: /AbstractCache.StatsCounter.recordLoadSuccess/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#recordLoadSuccess-long-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.recordMisses
+permalink: /AbstractCache.StatsCounter.recordMisses/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#recordMisses-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter.snapshot
+permalink: /AbstractCache.StatsCounter.snapshot/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html#snapshot--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.StatsCounter
+permalink: /AbstractCache.StatsCounter/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.StatsCounter.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.asMap
+permalink: /AbstractCache.asMap/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#asMap--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.cleanUp
+permalink: /AbstractCache.cleanUp/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#cleanUp--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.get
+permalink: /AbstractCache.get/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#get-K-java.util.concurrent.Callable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.getAllPresent
+permalink: /AbstractCache.getAllPresent/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#getAllPresent-java.lang.Iterable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.invalidate
+permalink: /AbstractCache.invalidate/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#invalidate-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.invalidateAll
+permalink: /AbstractCache.invalidateAll/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#invalidateAll--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.put
+permalink: /AbstractCache.put/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#put-K-V-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.putAll
+permalink: /AbstractCache.putAll/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#putAll-java.util.Map-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.size
+permalink: /AbstractCache.size/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#size--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache.stats
+permalink: /AbstractCache.stats/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html#stats--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractCache
+permalink: /AbstractCache/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractCache.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.AbstractExecutionThreadService
+permalink: /AbstractExecutionThreadService.AbstractExecutionThreadService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#AbstractExecutionThreadService--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.addListener
+permalink: /AbstractExecutionThreadService.addListener/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#addListener-com.google.common.util.concurrent.Service.Listener-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.awaitRunning
+permalink: /AbstractExecutionThreadService.awaitRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#awaitRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.awaitTerminated
+permalink: /AbstractExecutionThreadService.awaitTerminated/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#awaitTerminated--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.executor
+permalink: /AbstractExecutionThreadService.executor/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#executor--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.failureCause
+permalink: /AbstractExecutionThreadService.failureCause/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#failureCause--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.isRunning
+permalink: /AbstractExecutionThreadService.isRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#isRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.run
+permalink: /AbstractExecutionThreadService.run/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#run--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.serviceName
+permalink: /AbstractExecutionThreadService.serviceName/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#serviceName--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.shutDown
+permalink: /AbstractExecutionThreadService.shutDown/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#shutDown--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.startAsync
+permalink: /AbstractExecutionThreadService.startAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#startAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.startUp
+permalink: /AbstractExecutionThreadService.startUp/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#startUp--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.state
+permalink: /AbstractExecutionThreadService.state/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#state--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.stopAsync
+permalink: /AbstractExecutionThreadService.stopAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#stopAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.toString
+permalink: /AbstractExecutionThreadService.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService.triggerShutdown
+permalink: /AbstractExecutionThreadService.triggerShutdown/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html#triggerShutdown--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractExecutionThreadService
+permalink: /AbstractExecutionThreadService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractExecutionThreadService.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.AbstractFuture
+permalink: /AbstractFuture.AbstractFuture/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#AbstractFuture--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.addListener
+permalink: /AbstractFuture.addListener/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#addListener-java.lang.Runnable-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.afterDone
+permalink: /AbstractFuture.afterDone/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#afterDone--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.cancel
+permalink: /AbstractFuture.cancel/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#cancel-boolean-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.get
+permalink: /AbstractFuture.get/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#get--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.interruptTask
+permalink: /AbstractFuture.interruptTask/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#interruptTask--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.isCancelled
+permalink: /AbstractFuture.isCancelled/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#isCancelled--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.isDone
+permalink: /AbstractFuture.isDone/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#isDone--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.pendingToString
+permalink: /AbstractFuture.pendingToString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#pendingToString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.set
+permalink: /AbstractFuture.set/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#set-V-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.setException
+permalink: /AbstractFuture.setException/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#setException-java.lang.Throwable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.setFuture
+permalink: /AbstractFuture.setFuture/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#setFuture-com.google.common.util.concurrent.ListenableFuture-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.toString
+permalink: /AbstractFuture.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.tryInternalFastPathGetFailure
+permalink: /AbstractFuture.tryInternalFastPathGetFailure/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#tryInternalFastPathGetFailure--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture.wasInterrupted
+permalink: /AbstractFuture.wasInterrupted/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html#wasInterrupted--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractFuture
+permalink: /AbstractFuture/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractFuture.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractGraph.AbstractGraph
+permalink: /AbstractGraph.AbstractGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractGraph.html#AbstractGraph--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractGraph.equals
+permalink: /AbstractGraph.equals/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractGraph.html#equals-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractGraph.hashCode
+permalink: /AbstractGraph.hashCode/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractGraph.html#hashCode--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractGraph.toString
+permalink: /AbstractGraph.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractGraph.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractGraph
+permalink: /AbstractGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractGraph.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.AbstractIdleService
+permalink: /AbstractIdleService.AbstractIdleService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#AbstractIdleService--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.addListener
+permalink: /AbstractIdleService.addListener/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#addListener-com.google.common.util.concurrent.Service.Listener-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.awaitRunning
+permalink: /AbstractIdleService.awaitRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#awaitRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.awaitTerminated
+permalink: /AbstractIdleService.awaitTerminated/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#awaitTerminated--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.executor
+permalink: /AbstractIdleService.executor/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#executor--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.failureCause
+permalink: /AbstractIdleService.failureCause/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#failureCause--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.isRunning
+permalink: /AbstractIdleService.isRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#isRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.serviceName
+permalink: /AbstractIdleService.serviceName/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#serviceName--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.shutDown
+permalink: /AbstractIdleService.shutDown/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#shutDown--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.startAsync
+permalink: /AbstractIdleService.startAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#startAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.startUp
+permalink: /AbstractIdleService.startUp/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#startUp--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.state
+permalink: /AbstractIdleService.state/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#state--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.stopAsync
+permalink: /AbstractIdleService.stopAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#stopAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService.toString
+permalink: /AbstractIdleService.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIdleService
+permalink: /AbstractIdleService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractIdleService.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.AbstractInvocationHandler
+permalink: /AbstractInvocationHandler.AbstractInvocationHandler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#AbstractInvocationHandler--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.equals
+permalink: /AbstractInvocationHandler.equals/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#equals-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.handleInvocation
+permalink: /AbstractInvocationHandler.handleInvocation/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#handleInvocation-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.hashCode
+permalink: /AbstractInvocationHandler.hashCode/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#hashCode--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.invoke
+permalink: /AbstractInvocationHandler.invoke/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler.toString
+permalink: /AbstractInvocationHandler.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractInvocationHandler
+permalink: /AbstractInvocationHandler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/reflect/AbstractInvocationHandler.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.AbstractIterator
+permalink: /AbstractIterator.AbstractIterator/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#AbstractIterator--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.computeNext
+permalink: /AbstractIterator.computeNext/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#computeNext--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.endOfData
+permalink: /AbstractIterator.endOfData/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#endOfData--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.hasNext
+permalink: /AbstractIterator.hasNext/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#hasNext--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.next
+permalink: /AbstractIterator.next/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#next--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator.peek
+permalink: /AbstractIterator.peek/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html#peek--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractIterator
+permalink: /AbstractIterator/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractIterator.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractListeningExecutorService.AbstractListeningExecutorService
+permalink: /AbstractListeningExecutorService.AbstractListeningExecutorService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractListeningExecutorService.html#AbstractListeningExecutorService--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractListeningExecutorService.newTaskFor
+permalink: /AbstractListeningExecutorService.newTaskFor/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractListeningExecutorService.html#newTaskFor-java.lang.Runnable-T-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractListeningExecutorService.submit
+permalink: /AbstractListeningExecutorService.submit/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractListeningExecutorService.html#submit-java.lang.Runnable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractListeningExecutorService
+permalink: /AbstractListeningExecutorService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractListeningExecutorService.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache.AbstractLoadingCache
+permalink: /AbstractLoadingCache.AbstractLoadingCache/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html#AbstractLoadingCache--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache.apply
+permalink: /AbstractLoadingCache.apply/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html#apply-K-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache.getAll
+permalink: /AbstractLoadingCache.getAll/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html#getAll-java.lang.Iterable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache.getUnchecked
+permalink: /AbstractLoadingCache.getUnchecked/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html#getUnchecked-K-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache.refresh
+permalink: /AbstractLoadingCache.refresh/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html#refresh-K-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractLoadingCache
+permalink: /AbstractLoadingCache/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/cache/AbstractLoadingCache.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.AbstractNetwork
+permalink: /AbstractNetwork.AbstractNetwork/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#AbstractNetwork--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.adjacentEdges
+permalink: /AbstractNetwork.adjacentEdges/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#adjacentEdges-E-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.asGraph
+permalink: /AbstractNetwork.asGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#asGraph--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.degree
+permalink: /AbstractNetwork.degree/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#degree-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.edgeConnecting
+permalink: /AbstractNetwork.edgeConnecting/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#edgeConnecting-N-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.edgeConnectingOrNull
+permalink: /AbstractNetwork.edgeConnectingOrNull/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#edgeConnectingOrNull-N-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.edgesConnecting
+permalink: /AbstractNetwork.edgesConnecting/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#edgesConnecting-N-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.equals
+permalink: /AbstractNetwork.equals/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#equals-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.hasEdgeConnecting
+permalink: /AbstractNetwork.hasEdgeConnecting/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#hasEdgeConnecting-N-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.hashCode
+permalink: /AbstractNetwork.hashCode/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#hashCode--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.inDegree
+permalink: /AbstractNetwork.inDegree/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#inDegree-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.isOrderingCompatible
+permalink: /AbstractNetwork.isOrderingCompatible/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#isOrderingCompatible-com.google.common.graph.EndpointPair-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.outDegree
+permalink: /AbstractNetwork.outDegree/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#outDegree-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.toString
+permalink: /AbstractNetwork.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork.validateEndpoints
+permalink: /AbstractNetwork.validateEndpoints/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html#validateEndpoints-com.google.common.graph.EndpointPair-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractNetwork
+permalink: /AbstractNetwork/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractNetwork.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.AbstractScheduledService
+permalink: /AbstractScheduledService.AbstractScheduledService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#AbstractScheduledService--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.CustomScheduler.CustomScheduler
+permalink: /AbstractScheduledService.CustomScheduler.CustomScheduler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.CustomScheduler.html#CustomScheduler--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.CustomScheduler.Schedule.Schedule
+permalink: /AbstractScheduledService.CustomScheduler.Schedule.Schedule/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.CustomScheduler.Schedule.html#Schedule-long-java.util.concurrent.TimeUnit-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.CustomScheduler.Schedule
+permalink: /AbstractScheduledService.CustomScheduler.Schedule/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.CustomScheduler.Schedule.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.CustomScheduler.getNextSchedule
+permalink: /AbstractScheduledService.CustomScheduler.getNextSchedule/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.CustomScheduler.html#getNextSchedule--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.CustomScheduler
+permalink: /AbstractScheduledService.CustomScheduler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.CustomScheduler.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.Scheduler.newFixedDelaySchedule
+permalink: /AbstractScheduledService.Scheduler.newFixedDelaySchedule/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.Scheduler.html#newFixedDelaySchedule-java.time.Duration-java.time.Duration-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.Scheduler.newFixedRateSchedule
+permalink: /AbstractScheduledService.Scheduler.newFixedRateSchedule/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.Scheduler.html#newFixedRateSchedule-java.time.Duration-java.time.Duration-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.Scheduler
+permalink: /AbstractScheduledService.Scheduler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.Scheduler.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.addListener
+permalink: /AbstractScheduledService.addListener/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#addListener-com.google.common.util.concurrent.Service.Listener-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.awaitRunning
+permalink: /AbstractScheduledService.awaitRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#awaitRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.awaitTerminated
+permalink: /AbstractScheduledService.awaitTerminated/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#awaitTerminated--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.executor
+permalink: /AbstractScheduledService.executor/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#executor--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.failureCause
+permalink: /AbstractScheduledService.failureCause/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#failureCause--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.isRunning
+permalink: /AbstractScheduledService.isRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#isRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.runOneIteration
+permalink: /AbstractScheduledService.runOneIteration/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#runOneIteration--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.scheduler
+permalink: /AbstractScheduledService.scheduler/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#scheduler--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.serviceName
+permalink: /AbstractScheduledService.serviceName/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#serviceName--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.shutDown
+permalink: /AbstractScheduledService.shutDown/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#shutDown--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.startAsync
+permalink: /AbstractScheduledService.startAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#startAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.startUp
+permalink: /AbstractScheduledService.startUp/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#startUp--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.state
+permalink: /AbstractScheduledService.state/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#state--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.stopAsync
+permalink: /AbstractScheduledService.stopAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#stopAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService.toString
+permalink: /AbstractScheduledService.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractScheduledService
+permalink: /AbstractScheduledService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractScheduledService.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractSequentialIterator.AbstractSequentialIterator
+permalink: /AbstractSequentialIterator.AbstractSequentialIterator/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractSequentialIterator.html#AbstractSequentialIterator-T-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractSequentialIterator.computeNext
+permalink: /AbstractSequentialIterator.computeNext/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractSequentialIterator.html#computeNext-T-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractSequentialIterator.hasNext
+permalink: /AbstractSequentialIterator.hasNext/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractSequentialIterator.html#hasNext--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractSequentialIterator.next
+permalink: /AbstractSequentialIterator.next/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractSequentialIterator.html#next--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractSequentialIterator
+permalink: /AbstractSequentialIterator/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/AbstractSequentialIterator.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.AbstractService
+permalink: /AbstractService.AbstractService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#AbstractService--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.addListener
+permalink: /AbstractService.addListener/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#addListener-com.google.common.util.concurrent.Service.Listener-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.awaitRunning
+permalink: /AbstractService.awaitRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#awaitRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.awaitTerminated
+permalink: /AbstractService.awaitTerminated/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#awaitTerminated--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.doCancelStart
+permalink: /AbstractService.doCancelStart/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#doCancelStart--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.doStart
+permalink: /AbstractService.doStart/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#doStart--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.doStop
+permalink: /AbstractService.doStop/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#doStop--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.failureCause
+permalink: /AbstractService.failureCause/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#failureCause--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.isRunning
+permalink: /AbstractService.isRunning/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#isRunning--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.notifyFailed
+permalink: /AbstractService.notifyFailed/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#notifyFailed-java.lang.Throwable-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.notifyStarted
+permalink: /AbstractService.notifyStarted/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#notifyStarted--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.notifyStopped
+permalink: /AbstractService.notifyStopped/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#notifyStopped--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.startAsync
+permalink: /AbstractService.startAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#startAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.state
+permalink: /AbstractService.state/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#state--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.stopAsync
+permalink: /AbstractService.stopAsync/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#stopAsync--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService.toString
+permalink: /AbstractService.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractService
+permalink: /AbstractService/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AbstractService.html
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.AbstractValueGraph
+permalink: /AbstractValueGraph.AbstractValueGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#AbstractValueGraph--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.asGraph
+permalink: /AbstractValueGraph.asGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#asGraph--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.edgeValue
+permalink: /AbstractValueGraph.edgeValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#edgeValue-N-N-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.equals
+permalink: /AbstractValueGraph.equals/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#equals-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.hashCode
+permalink: /AbstractValueGraph.hashCode/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#hashCode--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph.toString
+permalink: /AbstractValueGraph.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AbstractValueGraph
+permalink: /AbstractValueGraph/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/graph/AbstractValueGraph.html
+---, @@ -0,0 +1,5 @@
+---
+title: AllowConcurrentEvents
+permalink: /AllowConcurrentEvents/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/eventbus/AllowConcurrentEvents.html
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedCharEscaper.ArrayBasedCharEscaper
+permalink: /ArrayBasedCharEscaper.ArrayBasedCharEscaper/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedCharEscaper.html#ArrayBasedCharEscaper-java.util.Map-char-char-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedCharEscaper.escape
+permalink: /ArrayBasedCharEscaper.escape/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedCharEscaper.html#escape-char-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedCharEscaper.escapeUnsafe
+permalink: /ArrayBasedCharEscaper.escapeUnsafe/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedCharEscaper.html#escapeUnsafe-char-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedCharEscaper
+permalink: /ArrayBasedCharEscaper/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedCharEscaper.html
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedEscaperMap.create
+permalink: /ArrayBasedEscaperMap.create/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedEscaperMap.html#create-java.util.Map-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedEscaperMap
+permalink: /ArrayBasedEscaperMap/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedEscaperMap.html
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedUnicodeEscaper.ArrayBasedUnicodeEscaper
+permalink: /ArrayBasedUnicodeEscaper.ArrayBasedUnicodeEscaper/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedUnicodeEscaper.html#ArrayBasedUnicodeEscaper-java.util.Map-int-int-java.lang.String-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedUnicodeEscaper.escape
+permalink: /ArrayBasedUnicodeEscaper.escape/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedUnicodeEscaper.html#escape-int-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedUnicodeEscaper.escapeUnsafe
+permalink: /ArrayBasedUnicodeEscaper.escapeUnsafe/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedUnicodeEscaper.html#escapeUnsafe-int-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedUnicodeEscaper.nextEscapeIndex
+permalink: /ArrayBasedUnicodeEscaper.nextEscapeIndex/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedUnicodeEscaper.html#nextEscapeIndex-java.lang.CharSequence-int-int-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayBasedUnicodeEscaper
+permalink: /ArrayBasedUnicodeEscaper/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/escape/ArrayBasedUnicodeEscaper.html
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayListMultimap.create
+permalink: /ArrayListMultimap.create/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayListMultimap.html#create--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayListMultimap.trimToSize
+permalink: /ArrayListMultimap.trimToSize/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayListMultimap.html#trimToSize--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayListMultimap
+permalink: /ArrayListMultimap/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayListMultimap.html
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.at
+permalink: /ArrayTable.at/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#at-int-int-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.cellSet
+permalink: /ArrayTable.cellSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#cellSet--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.clear
+permalink: /ArrayTable.clear/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#clear--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.column
+permalink: /ArrayTable.column/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#column-C-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.columnKeyList
+permalink: /ArrayTable.columnKeyList/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#columnKeyList--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.columnKeySet
+permalink: /ArrayTable.columnKeySet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#columnKeySet--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.columnMap
+permalink: /ArrayTable.columnMap/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#columnMap--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.contains
+permalink: /ArrayTable.contains/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#contains-java.lang.Object-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.containsColumn
+permalink: /ArrayTable.containsColumn/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#containsColumn-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.containsRow
+permalink: /ArrayTable.containsRow/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#containsRow-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.containsValue
+permalink: /ArrayTable.containsValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#containsValue-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.create
+permalink: /ArrayTable.create/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#create-com.google.common.collect.Table-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.erase
+permalink: /ArrayTable.erase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#erase-java.lang.Object-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.eraseAll
+permalink: /ArrayTable.eraseAll/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#eraseAll--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.get
+permalink: /ArrayTable.get/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#get-java.lang.Object-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.isEmpty
+permalink: /ArrayTable.isEmpty/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#isEmpty--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.put
+permalink: /ArrayTable.put/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#put-R-C-V-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.putAll
+permalink: /ArrayTable.putAll/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#putAll-com.google.common.collect.Table-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.remove
+permalink: /ArrayTable.remove/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#remove-java.lang.Object-java.lang.Object-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.row
+permalink: /ArrayTable.row/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#row-R-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.rowKeyList
+permalink: /ArrayTable.rowKeyList/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#rowKeyList--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.rowKeySet
+permalink: /ArrayTable.rowKeySet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#rowKeySet--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.rowMap
+permalink: /ArrayTable.rowMap/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#rowMap--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.set
+permalink: /ArrayTable.set/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#set-int-int-V-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.size
+permalink: /ArrayTable.size/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#size--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.toArray
+permalink: /ArrayTable.toArray/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#toArray-java.lang.Class-
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable.values
+permalink: /ArrayTable.values/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html#values--
+---, @@ -0,0 +1,5 @@
+---
+title: ArrayTable
+permalink: /ArrayTable/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/collect/ArrayTable.html
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.ACK
+permalink: /Ascii.ACK/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#ACK
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.BEL
+permalink: /Ascii.BEL/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#BEL
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.BS
+permalink: /Ascii.BS/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#BS
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.CAN
+permalink: /Ascii.CAN/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#CAN
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.CR
+permalink: /Ascii.CR/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#CR
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DC1
+permalink: /Ascii.DC1/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DC1
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DC2
+permalink: /Ascii.DC2/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DC2
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DC3
+permalink: /Ascii.DC3/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DC3
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DC4
+permalink: /Ascii.DC4/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DC4
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DEL
+permalink: /Ascii.DEL/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DEL
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.DLE
+permalink: /Ascii.DLE/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#DLE
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.EM
+permalink: /Ascii.EM/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#EM
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.ENQ
+permalink: /Ascii.ENQ/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#ENQ
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.EOT
+permalink: /Ascii.EOT/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#EOT
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.ESC
+permalink: /Ascii.ESC/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#ESC
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.ETB
+permalink: /Ascii.ETB/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#ETB
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.ETX
+permalink: /Ascii.ETX/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#ETX
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.FF
+permalink: /Ascii.FF/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#FF
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.FS
+permalink: /Ascii.FS/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#FS
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.GS
+permalink: /Ascii.GS/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#GS
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.HT
+permalink: /Ascii.HT/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#HT
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.LF
+permalink: /Ascii.LF/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#LF
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.MAX
+permalink: /Ascii.MAX/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#MAX
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.MIN
+permalink: /Ascii.MIN/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#MIN
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.NAK
+permalink: /Ascii.NAK/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#NAK
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.NL
+permalink: /Ascii.NL/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#NL
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.NUL
+permalink: /Ascii.NUL/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#NUL
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.RS
+permalink: /Ascii.RS/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#RS
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SI
+permalink: /Ascii.SI/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SI
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SO
+permalink: /Ascii.SO/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SO
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SOH
+permalink: /Ascii.SOH/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SOH
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SP
+permalink: /Ascii.SP/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SP
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SPACE
+permalink: /Ascii.SPACE/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SPACE
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.STX
+permalink: /Ascii.STX/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#STX
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SUB
+permalink: /Ascii.SUB/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SUB
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.SYN
+permalink: /Ascii.SYN/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#SYN
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.US
+permalink: /Ascii.US/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#US
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.VT
+permalink: /Ascii.VT/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#VT
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.XOFF
+permalink: /Ascii.XOFF/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#XOFF
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.XON
+permalink: /Ascii.XON/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#XON
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.equalsIgnoreCase
+permalink: /Ascii.equalsIgnoreCase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#equalsIgnoreCase-java.lang.CharSequence-java.lang.CharSequence-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.isLowerCase
+permalink: /Ascii.isLowerCase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#isLowerCase-char-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.isUpperCase
+permalink: /Ascii.isUpperCase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#isUpperCase-char-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.toLowerCase
+permalink: /Ascii.toLowerCase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#toLowerCase-char-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.toUpperCase
+permalink: /Ascii.toUpperCase/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#toUpperCase-char-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii.truncate
+permalink: /Ascii.truncate/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html#truncate-java.lang.CharSequence-int-java.lang.String-
+---, @@ -0,0 +1,5 @@
+---
+title: Ascii
+permalink: /Ascii/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Ascii.html
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncCallable.call
+permalink: /AsyncCallable.call/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AsyncCallable.html#call--
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncCallable
+permalink: /AsyncCallable/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AsyncCallable.html
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncEventBus.AsyncEventBus
+permalink: /AsyncEventBus.AsyncEventBus/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/eventbus/AsyncEventBus.html#AsyncEventBus-java.util.concurrent.Executor-
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncEventBus
+permalink: /AsyncEventBus/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/eventbus/AsyncEventBus.html
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncFunction.apply
+permalink: /AsyncFunction.apply/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AsyncFunction.html#apply-I-
+---, @@ -0,0 +1,5 @@
+---
+title: AsyncFunction
+permalink: /AsyncFunction/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AsyncFunction.html
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.AtomicDouble
+permalink: /AtomicDouble.AtomicDouble/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#AtomicDouble--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.addAndGet
+permalink: /AtomicDouble.addAndGet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#addAndGet-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.compareAndSet
+permalink: /AtomicDouble.compareAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#compareAndSet-double-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.doubleValue
+permalink: /AtomicDouble.doubleValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#doubleValue--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.floatValue
+permalink: /AtomicDouble.floatValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#floatValue--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.get
+permalink: /AtomicDouble.get/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#get--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.getAndAdd
+permalink: /AtomicDouble.getAndAdd/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#getAndAdd-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.getAndSet
+permalink: /AtomicDouble.getAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#getAndSet-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.intValue
+permalink: /AtomicDouble.intValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#intValue--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.lazySet
+permalink: /AtomicDouble.lazySet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#lazySet-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.longValue
+permalink: /AtomicDouble.longValue/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#longValue--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.set
+permalink: /AtomicDouble.set/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#set-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.toString
+permalink: /AtomicDouble.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble.weakCompareAndSet
+permalink: /AtomicDouble.weakCompareAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html#weakCompareAndSet-double-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDouble
+permalink: /AtomicDouble/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDouble.html
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.AtomicDoubleArray
+permalink: /AtomicDoubleArray.AtomicDoubleArray/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#AtomicDoubleArray-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.addAndGet
+permalink: /AtomicDoubleArray.addAndGet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#addAndGet-int-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.compareAndSet
+permalink: /AtomicDoubleArray.compareAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#compareAndSet-int-double-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.get
+permalink: /AtomicDoubleArray.get/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#get-int-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.getAndAdd
+permalink: /AtomicDoubleArray.getAndAdd/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#getAndAdd-int-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.getAndSet
+permalink: /AtomicDoubleArray.getAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#getAndSet-int-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.lazySet
+permalink: /AtomicDoubleArray.lazySet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#lazySet-int-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.length
+permalink: /AtomicDoubleArray.length/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#length--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.set
+permalink: /AtomicDoubleArray.set/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#set-int-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.toString
+permalink: /AtomicDoubleArray.toString/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#toString--
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray.weakCompareAndSet
+permalink: /AtomicDoubleArray.weakCompareAndSet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html#weakCompareAndSet-int-double-double-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicDoubleArray
+permalink: /AtomicDoubleArray/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicDoubleArray.html
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicLongMap.accumulateAndGet
+permalink: /AtomicLongMap.accumulateAndGet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicLongMap.html#accumulateAndGet-K-long-java.util.function.LongBinaryOperator-
+---, @@ -0,0 +1,5 @@
+---
+title: AtomicLongMap.addAndGet
+permalink: /AtomicLongMap.addAndGet/
+redirect_to: https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/AtomicLongMap.html#addAndGet-K-long-
+---, ","e.g.,

https://guava.dev/ImmutableList
https://guava.dev/ImmutableList.copyOf
https://guava.dev/immutablelist",Add shortcuts to Javadoc.
3786,Chris Povirk,['README.md'],"@@ -114,8 +114,8 @@ flavor.
     correctly in other environments. For the Android flavor, our unit tests run
     on API level 15 (Ice Cream Sandwich).
 
-[guava-snapshot-api-docs]: https://google.github.io/guava/releases/snapshot-jre/api/docs/
-[guava-snapshot-api-diffs]: https://google.github.io/guava/releases/snapshot-jre/api/diffs/
+[guava-snapshot-api-docs]: https://guava.dev/releases/snapshot-jre/api/docs/
+[guava-snapshot-api-diffs]: https://guava.dev/releases/snapshot-jre/api/diffs/
 [Guava Explained]: https://github.com/google/guava/wiki/Home
 [Guava Beta Checker]: https://github.com/google/guava-beta-checker
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Link directly to guava.dev for Javadoc.

70f7d83f89d99d24d8a1a041dc8a7329316e03ce",MOE Sync 2020-01-28
3793,Chris Povirk,"['android/guava/src/com/google/common/io/BaseEncoding.java', 'guava/src/com/google/common/io/BaseEncoding.java']","@@ -28,6 +28,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Objects;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -831,8 +832,8 @@ public BaseEncoding withSeparator(String separator, int afterEveryChars) {
       return new SeparatedBaseEncoding(this, separator, afterEveryChars);
     }
 
-    @MonotonicNonNullDecl private transient BaseEncoding upperCase;
-    @MonotonicNonNullDecl private transient BaseEncoding lowerCase;
+    @LazyInit @MonotonicNonNullDecl private transient BaseEncoding upperCase;
+    @LazyInit @MonotonicNonNullDecl private transient BaseEncoding lowerCase;
 
     @Override
     public BaseEncoding upperCase() {, @@ -28,6 +28,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Ascii;
 import com.google.common.base.Objects;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -831,8 +832,8 @@ public BaseEncoding withSeparator(String separator, int afterEveryChars) {
       return new SeparatedBaseEncoding(this, separator, afterEveryChars);
     }
 
-    private transient @MonotonicNonNull BaseEncoding upperCase;
-    private transient @MonotonicNonNull BaseEncoding lowerCase;
+    @LazyInit @MonotonicNonNull private transient BaseEncoding upperCase;
+    @LazyInit @MonotonicNonNull private transient BaseEncoding lowerCase;
 
     @Override
     public BaseEncoding upperCase() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Annotate upperCase and lowerCase with @LazyInit.

This eliminates a TSAN warning.

f325f04c86c8159f5bd9d771e697217a866c46d2",MOE Sync 2020-02-04
3796,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava-tests/test/com/google/common/util/concurrent/AbstractFutureInnocuousThreadTest.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java']","@@ -69,9 +69,20 @@
     implements ListenableFuture<V> {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
-  private static final boolean GENERATE_CANCELLATION_CAUSES =
-      Boolean.parseBoolean(
-          System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
+  private static final boolean GENERATE_CANCELLATION_CAUSES;
+
+  static {
+    // System.getProperty may throw if the security policy does not permit access.
+    boolean generateCancellationCauses;
+    try {
+      generateCancellationCauses =
+          Boolean.parseBoolean(
+              System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
+    } catch (SecurityException e) {
+      generateCancellationCauses = false;
+    }
+    GENERATE_CANCELLATION_CAUSES = generateCancellationCauses;
+  }
 
   /**
    * Tag interface marking trusted subclasses. This enables some optimizations. The implementation, @@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import java.net.URLClassLoader;
+import java.security.Permission;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.PropertyPermission;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.concurrent.GuardedBy;
+import junit.framework.TestCase;
+
+/** Tests for {@link AbstractFuture} using an innocuous thread. */
+
+public class AbstractFutureInnocuousThreadTest extends TestCase {
+  private ClassLoader oldClassLoader;
+  private URLClassLoader classReloader;
+  private Class<?> settableFutureClass;
+  private SecurityManager oldSecurityManager;
+
+  @Override
+  protected void setUp() throws Exception {
+    // Load the ""normal"" copy of SettableFuture and related classes.
+    SettableFuture<?> unused = SettableFuture.create();
+    // Hack to load AbstractFuture et. al. in a new classloader so that it tries to re-read the
+    // cancellation-cause system property. This allows us to test what happens if reading the
+    // property is forbidden and then continue running tests normally in one jvm without resorting
+    // to even crazier hacks to reset static final boolean fields.
+    final String concurrentPackage = SettableFuture.class.getPackage().getName();
+    classReloader =
+        new URLClassLoader(ClassPathUtil.getClassPathUrls()) {
+          @GuardedBy(""loadedClasses"")
+          final Map<String, Class<?>> loadedClasses = new HashMap<>();
+
+          @Override
+          public Class<?> loadClass(String name) throws ClassNotFoundException {
+            if (name.startsWith(concurrentPackage)
+                // Use other classloader for ListenableFuture, so that the objects can interact
+                && !ListenableFuture.class.getName().equals(name)) {
+              synchronized (loadedClasses) {
+                Class<?> toReturn = loadedClasses.get(name);
+                if (toReturn == null) {
+                  toReturn = super.findClass(name);
+                  loadedClasses.put(name, toReturn);
+                }
+                return toReturn;
+              }
+            }
+            return super.loadClass(name);
+          }
+        };
+    oldClassLoader = Thread.currentThread().getContextClassLoader();
+    Thread.currentThread().setContextClassLoader(classReloader);
+
+    oldSecurityManager = System.getSecurityManager();
+    /*
+     * TODO(cpovirk): Why couldn't I get this to work with PermissionCollection and implies(), as
+     * used by ClassPathTest?
+     */
+    final PropertyPermission readSystemProperty =
+        new PropertyPermission(""guava.concurrent.generate_cancellation_cause"", ""read"");
+    SecurityManager disallowPropertySecurityManager =
+        new SecurityManager() {
+          @Override
+          public void checkPermission(Permission p) {
+            if (readSystemProperty.equals(p)) {
+              throw new SecurityException(""Disallowed: "" + p);
+            }
+          }
+        };
+    System.setSecurityManager(disallowPropertySecurityManager);
+
+    settableFutureClass = classReloader.loadClass(SettableFuture.class.getName());
+
+    /*
+     * We must keep the SecurityManager installed during the test body: It affects what kind of
+     * threads ForkJoinPool.commonPool() creates.
+     */
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    System.setSecurityManager(oldSecurityManager);
+    classReloader.close();
+    Thread.currentThread().setContextClassLoader(oldClassLoader);
+  }
+
+  public void testAbstractFutureInitializationWithInnocuousThread_doesNotThrow() throws Exception {
+    CountDownLatch latch = new CountDownLatch(1);
+    // Setting a security manager causes the common ForkJoinPool to use InnocuousThreads with no
+    // permissions.
+    // submit()/join() causes this thread to execute the task instead, so we use a CountDownLatch as
+    // a barrier to synchronize.
+    // TODO(cpovirk): If some other test already initialized commonPool(), this won't work :(
+    // Maybe we should just run this test in its own VM.
+    ForkJoinPool.commonPool()
+        .execute(
+            () -> {
+              try {
+                settableFutureClass.getMethod(""create"").invoke(null);
+                latch.countDown();
+              } catch (Exception e) {
+                throw new RuntimeException(e);
+              }
+            });
+    // In the failure case, await() will timeout.
+    assertTrue(latch.await(2, TimeUnit.SECONDS));
+  }
+
+  // TODO(cpovirk): Write a similar test that doesn't use ForkJoinPool (to run under Android)?
+}, @@ -69,9 +69,20 @@
     implements ListenableFuture<V> {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 
-  private static final boolean GENERATE_CANCELLATION_CAUSES =
-      Boolean.parseBoolean(
-          System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
+  private static final boolean GENERATE_CANCELLATION_CAUSES;
+
+  static {
+    // System.getProperty may throw if the security policy does not permit access.
+    boolean generateCancellationCauses;
+    try {
+      generateCancellationCauses =
+          Boolean.parseBoolean(
+              System.getProperty(""guava.concurrent.generate_cancellation_cause"", ""false""));
+    } catch (SecurityException e) {
+      generateCancellationCauses = false;
+    }
+    GENERATE_CANCELLATION_CAUSES = generateCancellationCauses;
+  }
 
   /**
    * Tag interface marking trusted subclasses. This enables some optimizations. The implementation, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make AbstractFuture compatible with ForkJoinPool by catching exceptions from property retrieval.

Fixes #3788, #3784

RELNOTES=Made it safe to load the `AbstractFuture` class from a `ForkJoinPool` thread under a security manager.

e589b5c884a5996f7040ae38bdf02709f9e300da",MOE Sync 2020-02-06
3797,Chris Povirk,"['android/guava/src/com/google/common/collect/Table.java', 'guava/src/com/google/common/collect/Table.java']","@@ -98,6 +98,7 @@ boolean contains(
    * @param rowKey key of row to search for
    * @param columnKey key of column to search for
    */
+  @NullableDecl
   V get(
       @NullableDecl @CompatibleWith(""R"") Object rowKey,
       @NullableDecl @CompatibleWith(""C"") Object columnKey);, @@ -98,6 +98,7 @@ boolean contains(
    * @param rowKey key of row to search for
    * @param columnKey key of column to search for
    */
+  @Nullable
   V get(
       @Nullable @CompatibleWith(""R"") Object rowKey,
       @Nullable @CompatibleWith(""C"") Object columnKey);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add missing @Nullable.

afa21015d337d38bbaa752aa29b2d50c700f8190",MOE Sync 2020-02-10
3799,,['README.md'],"@@ -3,9 +3,11 @@
 [![Latest release](https://img.shields.io/github/release/google/guava.svg)](https://github.com/google/guava/releases/latest)
 [![Build Status](https://travis-ci.org/google/guava.svg?branch=master)](https://travis-ci.org/google/guava)
 
-Guava is a set of core libraries that includes new collection types (such as
-multimap and multiset), immutable collections, a graph library, and utilities
-for concurrency, I/O, hashing, primitives, strings, and more!
+Guava is a set of core Java libraries from Google that includes new collection types
+(such as multimap and multiset), immutable collections, a graph library, and
+utilities for concurrency, I/O, hashing, caching, primitives, strings, and more! It
+is widely used on most Java projects within Google, and widely used by many
+other companies as well.
 
 Guava comes in two flavors.
 
@@ -60,7 +62,7 @@ For more information on when to use `api` and when to use `implementation`,
 consult the
 [Gradle documentation on API and implementation separation](https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_separation).
 
-## Snapshots
+## Snapshots and Documentation
 
 Snapshots of Guava built from the `master` branch are available through Maven
 using version `HEAD-jre-SNAPSHOT`, or `HEAD-android-SNAPSHOT` for the Android, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Apply changes from https://github.com/google/guava/pull/3778 (which edited guava.dev) to README.md.

528621033995a445a7cf0e69bdbbe4622ceaf6ea",MOE Sync 2020-02-12
3801,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/graph/StandardImmutableDirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardImmutableUndirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardMutableDirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/StandardMutableUndirectedGraphTest.java', 'android/guava-tests/test/com/google/common/graph/ValueGraphTest.java', 'android/guava/src/com/google/common/graph/GraphBuilder.java', 'android/guava/src/com/google/common/graph/ImmutableGraph.java', 'android/guava/src/com/google/common/graph/ImmutableValueGraph.java', 'android/guava/src/com/google/common/graph/StandardMutableGraph.java', 'android/guava/src/com/google/common/graph/StandardMutableValueGraph.java', 'android/guava/src/com/google/common/graph/StandardValueGraph.java', 'android/guava/src/com/google/common/graph/ValueGraphBuilder.java', 'guava-tests/test/com/google/common/graph/StandardImmutableDirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardImmutableUndirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardMutableDirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/StandardMutableUndirectedGraphTest.java', 'guava-tests/test/com/google/common/graph/ValueGraphTest.java', 'guava/src/com/google/common/graph/GraphBuilder.java', 'guava/src/com/google/common/graph/ImmutableGraph.java', 'guava/src/com/google/common/graph/ImmutableValueGraph.java', 'guava/src/com/google/common/graph/StandardMutableGraph.java', 'guava/src/com/google/common/graph/StandardMutableValueGraph.java', 'guava/src/com/google/common/graph/StandardValueGraph.java', 'guava/src/com/google/common/graph/ValueGraphBuilder.java']","@@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for a directed {@link ConfigurableMutableGraph}. */
+/** Tests for a directed {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardImmutableDirectedGraphTest extends AbstractStandardDirectedGraphTest {, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for an undirected {@link ConfigurableMutableGraph}. */
+/** Tests for an undirected {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardImmutableUndirectedGraphTest, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for a directed {@link ConfigurableMutableGraph}. */
+/** Tests for a directed {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardMutableDirectedGraphTest extends AbstractStandardDirectedGraphTest {, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for an undirected {@link ConfigurableMutableGraph}. */
+/** Tests for an undirected {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public class StandardMutableUndirectedGraphTest extends AbstractStandardUndirectedGraphTest {, @@ -33,7 +33,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for {@link ConfigurableMutableValueGraph} and related functionality. */
+/** Tests for {@link StandardMutableValueGraph} and related functionality. */
 // TODO(user): Expand coverage and move to proper test suite.
 @RunWith(JUnit4.class)
 public final class ValueGraphTest {, @@ -169,7 +169,7 @@ private GraphBuilder(boolean directed) {
 
   /** Returns an empty {@link MutableGraph} with the properties of this {@link GraphBuilder}. */
   public <N1 extends N> MutableGraph<N1> build() {
-    return new ConfigurableMutableGraph<N1>(this);
+    return new StandardMutableGraph<N1>(this);
   }
 
   GraphBuilder<N> copy() {, @@ -58,7 +58,7 @@
     return (graph instanceof ImmutableGraph)
         ? (ImmutableGraph<N>) graph
         : new ImmutableGraph<N>(
-            new ConfigurableValueGraph<N, Presence>(
+            new StandardValueGraph<N, Presence>(
                 GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size()));
   }
 , @@ -43,7 +43,7 @@
 @Beta
 @Immutable(containerOf = {""N"", ""V""})
 @SuppressWarnings(""Immutable"") // Extends ConfigurableValueGraph but uses ImmutableMaps.
-public final class ImmutableValueGraph<N, V> extends ConfigurableValueGraph<N, V> {
+public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
 
   private ImmutableValueGraph(ValueGraph<N, V> graph) {
     super(ValueGraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());, @@ -28,12 +28,12 @@
  * @author James Sexton
  * @param <N> Node parameter type
  */
-final class ConfigurableMutableGraph<N> extends ForwardingGraph<N> implements MutableGraph<N> {
+final class StandardMutableGraph<N> extends ForwardingGraph<N> implements MutableGraph<N> {
   private final MutableValueGraph<N, Presence> backingValueGraph;
 
   /** Constructs a {@link MutableGraph} with the properties specified in {@code builder}. */
-  ConfigurableMutableGraph(AbstractGraphBuilder<? super N> builder) {
-    this.backingValueGraph = new ConfigurableMutableValueGraph<>(builder);
+  StandardMutableGraph(AbstractGraphBuilder<? super N> builder) {
+    this.backingValueGraph = new StandardMutableValueGraph<>(builder);
   }
 
   @Override, @@ -38,13 +38,13 @@
  * @param <N> Node parameter type
  * @param <V> Value parameter type
  */
-final class ConfigurableMutableValueGraph<N, V> extends ConfigurableValueGraph<N, V>
+final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     implements MutableValueGraph<N, V> {
 
   private final ElementOrder<N> incidentEdgeOrder;
 
   /** Constructs a mutable graph with the properties specified in {@code builder}. */
-  ConfigurableMutableValueGraph(AbstractGraphBuilder<? super N> builder) {
+  StandardMutableValueGraph(AbstractGraphBuilder<? super N> builder) {
     super(builder);
     incidentEdgeOrder = builder.incidentEdgeOrder.cast();
   }, @@ -43,7 +43,7 @@
  * @param <N> Node parameter type
  * @param <V> Value parameter type
  */
-class ConfigurableValueGraph<N, V> extends AbstractValueGraph<N, V> {
+class StandardValueGraph<N, V> extends AbstractValueGraph<N, V> {
   private final boolean isDirected;
   private final boolean allowsSelfLoops;
   private final ElementOrder<N> nodeOrder;
@@ -53,7 +53,7 @@
   protected long edgeCount; // must be updated when edges are added or removed
 
   /** Constructs a graph with the properties specified in {@code builder}. */
-  ConfigurableValueGraph(AbstractGraphBuilder<? super N> builder) {
+  StandardValueGraph(AbstractGraphBuilder<? super N> builder) {
     this(
         builder,
         builder.nodeOrder.<N, GraphConnections<N, V>>createMap(
@@ -65,7 +65,7 @@
    * Constructs a graph with the properties specified in {@code builder}, initialized with the given
    * node map.
    */
-  ConfigurableValueGraph(
+  StandardValueGraph(
       AbstractGraphBuilder<? super N> builder,
       Map<N, GraphConnections<N, V>> nodeConnections,
       long edgeCount) {, @@ -176,7 +176,7 @@ private ValueGraphBuilder(boolean directed) {
    * ValueGraphBuilder}.
    */
   public <N1 extends N, V1 extends V> MutableValueGraph<N1, V1> build() {
-    return new ConfigurableMutableValueGraph<>(this);
+    return new StandardMutableValueGraph<>(this);
   }
 
   ValueGraphBuilder<N, V> copy() {, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for a directed {@link ConfigurableMutableGraph}. */
+/** Tests for a directed {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardImmutableDirectedGraphTest extends AbstractStandardDirectedGraphTest {, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for an undirected {@link ConfigurableMutableGraph}. */
+/** Tests for an undirected {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardImmutableUndirectedGraphTest, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for a directed {@link ConfigurableMutableGraph}. */
+/** Tests for a directed {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public final class StandardMutableDirectedGraphTest extends AbstractStandardDirectedGraphTest {, @@ -22,7 +22,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-/** Tests for an undirected {@link ConfigurableMutableGraph}. */
+/** Tests for an undirected {@link StandardMutableGraph}. */
 @AndroidIncompatible
 @RunWith(Parameterized.class)
 public class StandardMutableUndirectedGraphTest extends AbstractStandardUndirectedGraphTest {, @@ -35,7 +35,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for {@link ConfigurableMutableValueGraph} and related functionality. */
+/** Tests for {@link StandardMutableValueGraph} and related functionality. */
 // TODO(user): Expand coverage and move to proper test suite.
 @RunWith(JUnit4.class)
 public final class ValueGraphTest {, @@ -169,7 +169,7 @@ private GraphBuilder(boolean directed) {
 
   /** Returns an empty {@link MutableGraph} with the properties of this {@link GraphBuilder}. */
   public <N1 extends N> MutableGraph<N1> build() {
-    return new ConfigurableMutableGraph<N1>(this);
+    return new StandardMutableGraph<N1>(this);
   }
 
   GraphBuilder<N> copy() {, @@ -58,7 +58,7 @@
     return (graph instanceof ImmutableGraph)
         ? (ImmutableGraph<N>) graph
         : new ImmutableGraph<N>(
-            new ConfigurableValueGraph<N, Presence>(
+            new StandardValueGraph<N, Presence>(
                 GraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size()));
   }
 , @@ -43,7 +43,7 @@
 @Beta
 @Immutable(containerOf = {""N"", ""V""})
 @SuppressWarnings(""Immutable"") // Extends ConfigurableValueGraph but uses ImmutableMaps.
-public final class ImmutableValueGraph<N, V> extends ConfigurableValueGraph<N, V> {
+public final class ImmutableValueGraph<N, V> extends StandardValueGraph<N, V> {
 
   private ImmutableValueGraph(ValueGraph<N, V> graph) {
     super(ValueGraphBuilder.from(graph), getNodeConnections(graph), graph.edges().size());, @@ -28,12 +28,12 @@
  * @author James Sexton
  * @param <N> Node parameter type
  */
-final class ConfigurableMutableGraph<N> extends ForwardingGraph<N> implements MutableGraph<N> {
+final class StandardMutableGraph<N> extends ForwardingGraph<N> implements MutableGraph<N> {
   private final MutableValueGraph<N, Presence> backingValueGraph;
 
   /** Constructs a {@link MutableGraph} with the properties specified in {@code builder}. */
-  ConfigurableMutableGraph(AbstractGraphBuilder<? super N> builder) {
-    this.backingValueGraph = new ConfigurableMutableValueGraph<>(builder);
+  StandardMutableGraph(AbstractGraphBuilder<? super N> builder) {
+    this.backingValueGraph = new StandardMutableValueGraph<>(builder);
   }
 
   @Override, @@ -38,13 +38,13 @@
  * @param <N> Node parameter type
  * @param <V> Value parameter type
  */
-final class ConfigurableMutableValueGraph<N, V> extends ConfigurableValueGraph<N, V>
+final class StandardMutableValueGraph<N, V> extends StandardValueGraph<N, V>
     implements MutableValueGraph<N, V> {
 
   private final ElementOrder<N> incidentEdgeOrder;
 
   /** Constructs a mutable graph with the properties specified in {@code builder}. */
-  ConfigurableMutableValueGraph(AbstractGraphBuilder<? super N> builder) {
+  StandardMutableValueGraph(AbstractGraphBuilder<? super N> builder) {
     super(builder);
     incidentEdgeOrder = builder.incidentEdgeOrder.cast();
   }, @@ -43,7 +43,7 @@
  * @param <N> Node parameter type
  * @param <V> Value parameter type
  */
-class ConfigurableValueGraph<N, V> extends AbstractValueGraph<N, V> {
+class StandardValueGraph<N, V> extends AbstractValueGraph<N, V> {
   private final boolean isDirected;
   private final boolean allowsSelfLoops;
   private final ElementOrder<N> nodeOrder;
@@ -53,7 +53,7 @@
   protected long edgeCount; // must be updated when edges are added or removed
 
   /** Constructs a graph with the properties specified in {@code builder}. */
-  ConfigurableValueGraph(AbstractGraphBuilder<? super N> builder) {
+  StandardValueGraph(AbstractGraphBuilder<? super N> builder) {
     this(
         builder,
         builder.nodeOrder.<N, GraphConnections<N, V>>createMap(
@@ -65,7 +65,7 @@
    * Constructs a graph with the properties specified in {@code builder}, initialized with the given
    * node map.
    */
-  ConfigurableValueGraph(
+  StandardValueGraph(
       AbstractGraphBuilder<? super N> builder,
       Map<N, GraphConnections<N, V>> nodeConnections,
       long edgeCount) {, @@ -176,7 +176,7 @@ private ValueGraphBuilder(boolean directed) {
    * ValueGraphBuilder}.
    */
   public <N1 extends N, V1 extends V> MutableValueGraph<N1, V1> build() {
-    return new ConfigurableMutableValueGraph<>(this);
+    return new StandardMutableValueGraph<>(this);
   }
 
   ValueGraphBuilder<N, V> copy() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Rename 'ConfigurableX' to 'StandardX' for [Value]Graph, which better captures what these implementations represent.

Note that this work was already started in the past with the abstract StandardGraph tests.

1be4110bac4c8540053fb4d096fdbb6d28d8a504",MOE Sync 2020-02-17
3802,Kurt Alfred Kluever,"['android/guava/src/com/google/common/collect/SortedMultiset.java', 'android/guava/src/com/google/common/collect/TreeMultimap.java', 'guava/src/com/google/common/collect/SortedMultiset.java', 'guava/src/com/google/common/collect/TreeMultimap.java']","@@ -32,7 +32,7 @@
  *
  * <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the
  * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link
- * Collection} contract, which it is specified in terms of {@link Object#equals}.
+ * Collection} contract, which is specified in terms of {@link Object#equals}.
  *
  * <p>See the Guava User Guide article on <a href=
  * ""https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset""> {@code, @@ -41,7 +41,7 @@
  *
  * <p><b>Warning:</b> The comparators or comparables used must be <i>consistent with equals</i> as
  * explained by the {@link Comparable} class specification. Otherwise, the resulting multiset will
- * violate the general contract of {@link SetMultimap}, which it is specified in terms of {@link
+ * violate the general contract of {@link SetMultimap}, which is specified in terms of {@link
  * Object#equals}.
  *
  * <p>The collections returned by {@code keySet} and {@code asMap} iterate through the keys, @@ -32,7 +32,7 @@
  *
  * <p><b>Warning:</b> The comparison must be <i>consistent with equals</i> as explained by the
  * {@link Comparable} class specification. Otherwise, the resulting multiset will violate the {@link
- * Collection} contract, which it is specified in terms of {@link Object#equals}.
+ * Collection} contract, which is specified in terms of {@link Object#equals}.
  *
  * <p>See the Guava User Guide article on <a href=
  * ""https://github.com/google/guava/wiki/NewCollectionTypesExplained#multiset""> {@code, @@ -41,7 +41,7 @@
  *
  * <p><b>Warning:</b> The comparators or comparables used must be <i>consistent with equals</i> as
  * explained by the {@link Comparable} class specification. Otherwise, the resulting multiset will
- * violate the general contract of {@link SetMultimap}, which it is specified in terms of {@link
+ * violate the general contract of {@link SetMultimap}, which is specified in terms of {@link
  * Object#equals}.
  *
  * <p>The collections returned by {@code keySet} and {@code asMap} iterate through the keys, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make TopKSelector ctor throw IllegalArgumentException when buffer size is too big to be held in memory.

Previously this would lead to java.lang.NegativeArraySizeException.

e0418c067aea976e3e59e23e035d15177112597a

-------

<p> Annotate FluentIterable.from(FluentIterable) with @DoNotCall

RELNOTES=Annotate FluentIterable.from(FluentIterable) with @DoNotCall

e3264687f823752dea2d724d2734b4a18e5c92a3

-------

<p> Fixing a typo in some Guava javadocs.

RELNOTES=Fixing a typo in javadoc.

5efab94ad9b77695012878c6b7c5a8815c7d2d36",MOE Sync 2020-02-19
3804,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/collect/CompactHashMapTest.java', 'android/guava-tests/test/com/google/common/collect/CompactLinkedHashMapTest.java', 'android/guava/src/com/google/common/collect/CompactHashMap.java', 'guava-tests/test/com/google/common/collect/CompactHashMapTest.java', 'guava-tests/test/com/google/common/collect/CompactLinkedHashMapTest.java', 'guava/src/com/google/common/collect/CompactHashMap.java']","@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.google.common.collect;
 
 import static com.google.common.collect.Iterables.getOnlyElement;, @@ -11,6 +11,7 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package com.google.common.collect;
 
 import static com.google.common.truth.Truth.assertThat;, @@ -896,6 +896,7 @@ public void clear() {
     if (delegate != null) {
       metadata =
           Ints.constrainToRange(size(), CompactHashing.DEFAULT_SIZE, CompactHashing.MAX_SIZE);
+      delegate.clear(); // invalidate any iterators left over!
       table = null;
       size = 0;
     } else {, @@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.google.common.collect;
 
 import static com.google.common.collect.Iterables.getOnlyElement;, @@ -11,6 +11,7 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package com.google.common.collect;
 
 import static com.google.common.truth.Truth.assertThat;, @@ -1010,6 +1010,7 @@ public void clear() {
     if (delegate != null) {
       metadata =
           Ints.constrainToRange(size(), CompactHashing.DEFAULT_SIZE, CompactHashing.MAX_SIZE);
+      delegate.clear(); // invalidate any iterators left over!
       table = null;
       size = 0;
     } else {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Invalidate delegate iterators during clear() and make FPP tests more strict

2cb0a5968938965027b9fc046f67db565a8cb68c",MOE Sync 2020-02-21
3805,Kurt Alfred Kluever,"['android/guava-testlib/src/com/google/common/collect/testing/CollectionTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/collect/testing/Helpers.java', 'android/guava-testlib/src/com/google/common/collect/testing/ListTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/collect/testing/SetTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/collect/testing/SortedSetTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java', 'android/guava-testlib/src/com/google/common/testing/ClusterException.java', 'android/guava-tests/test/com/google/common/collect/IteratorsTest.java', 'guava-testlib/src/com/google/common/collect/testing/CollectionTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/collect/testing/Helpers.java', 'guava-testlib/src/com/google/common/collect/testing/ListTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/collect/testing/SetTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/collect/testing/SortedSetTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/collect/testing/google/MultisetTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/collect/testing/google/SortedMultisetTestSuiteBuilder.java', 'guava-testlib/src/com/google/common/testing/ClusterException.java', 'guava-tests/test/com/google/common/collect/IteratorsTest.java']","@@ -91,8 +91,7 @@ private ReserializedCollectionGenerator(OneSizeTestContainerGenerator<Collection
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -169,8 +169,7 @@ public static void assertContains(Iterable<?> actual, Object expected) {
   }
 
   public static void assertContainsAllOf(Iterable<?> actual, Object... expected) {
-    List<Object> expectedList = new ArrayList<>();
-    expectedList.addAll(Arrays.asList(expected));
+    List<Object> expectedList = new ArrayList<>(Arrays.asList(expected));
 
     for (Object o : actual) {
       expectedList.remove(o);, @@ -146,8 +146,7 @@ private ReserializedListGenerator(OneSizeTestContainerGenerator<Collection<E>, E
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -112,8 +112,7 @@ private ReserializedSetGenerator(OneSizeTestContainerGenerator<Collection<E>, E>
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -86,8 +86,7 @@ final TestSuite createSubsetSuite(
     final TestSortedSetGenerator<E> delegate =
         (TestSortedSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();
 
-    List<Feature<?>> features = new ArrayList<>();
-    features.addAll(parentBuilder.getFeatures());
+    List<Feature<?>> features = new ArrayList<>(parentBuilder.getFeatures());
     features.remove(CollectionFeature.ALLOWS_NULL_VALUES);
     features.add(CollectionFeature.SUBSET_VIEW);
 , @@ -88,8 +88,7 @@
   }
 
   private static Set<Feature<?>> computeEntrySetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.GENERAL_PURPOSE);
     derivedFeatures.remove(CollectionFeature.SUPPORTS_ADD);
     derivedFeatures.remove(CollectionFeature.ALLOWS_NULL_VALUES);
@@ -101,8 +100,7 @@
   }
 
   static Set<Feature<?>> computeElementSetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.GENERAL_PURPOSE);
     derivedFeatures.remove(CollectionFeature.SUPPORTS_ADD);
     if (!derivedFeatures.remove(CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)) {
@@ -112,8 +110,7 @@
   }
 
   private static Set<Feature<?>> computeReserializedMultisetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.SERIALIZABLE);
     derivedFeatures.remove(CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -266,8 +266,7 @@ private TestSuite createReserializedSuite(SortedMultisetTestSuiteBuilder<E> pare
     final TestMultisetGenerator<E> delegate =
         (TestMultisetGenerator<E>) parentBuilder.getSubjectGenerator();
 
-    Set<Feature<?>> features = new HashSet<>();
-    features.addAll(parentBuilder.getFeatures());
+    Set<Feature<?>> features = new HashSet<>(parentBuilder.getFeatures());
     features.remove(SERIALIZABLE);
     features.remove(SERIALIZABLE_INCLUDING_VIEWS);
 , @@ -67,8 +67,7 @@ private ClusterException(Collection<? extends Throwable> exceptions) {
     super(
         exceptions.size() + "" exceptions were thrown. The first exception is listed as a cause."",
         exceptions.iterator().next());
-    ArrayList<Throwable> temp = new ArrayList<>();
-    temp.addAll(exceptions);
+    ArrayList<Throwable> temp = new ArrayList<>(exceptions);
     this.exceptions = Collections.unmodifiableCollection(temp);
   }
 , @@ -1279,8 +1279,7 @@ public void testAsEnumerationTypical() {
   }
 
   private static Enumeration<Integer> enumerate(Integer... ints) {
-    Vector<Integer> vector = new Vector<>();
-    vector.addAll(asList(ints));
+    Vector<Integer> vector = new Vector<>(asList(ints));
     return vector.elements();
   }
 , @@ -91,8 +91,7 @@ private ReserializedCollectionGenerator(OneSizeTestContainerGenerator<Collection
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -169,8 +169,7 @@ public static void assertContains(Iterable<?> actual, Object expected) {
   }
 
   public static void assertContainsAllOf(Iterable<?> actual, Object... expected) {
-    List<Object> expectedList = new ArrayList<>();
-    expectedList.addAll(Arrays.asList(expected));
+    List<Object> expectedList = new ArrayList<>(Arrays.asList(expected));
 
     for (Object o : actual) {
       expectedList.remove(o);, @@ -148,8 +148,7 @@ private ReserializedListGenerator(OneSizeTestContainerGenerator<Collection<E>, E
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -112,8 +112,7 @@ private ReserializedSetGenerator(OneSizeTestContainerGenerator<Collection<E>, E>
   }
 
   private static Set<Feature<?>> computeReserializedCollectionFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(SERIALIZABLE);
     derivedFeatures.remove(SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -86,8 +86,7 @@ final TestSuite createSubsetSuite(
     final TestSortedSetGenerator<E> delegate =
         (TestSortedSetGenerator<E>) parentBuilder.getSubjectGenerator().getInnerGenerator();
 
-    List<Feature<?>> features = new ArrayList<>();
-    features.addAll(parentBuilder.getFeatures());
+    List<Feature<?>> features = new ArrayList<>(parentBuilder.getFeatures());
     features.remove(CollectionFeature.ALLOWS_NULL_VALUES);
     features.add(CollectionFeature.SUBSET_VIEW);
 , @@ -89,8 +89,7 @@
   }
 
   private static Set<Feature<?>> computeEntrySetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.GENERAL_PURPOSE);
     derivedFeatures.remove(CollectionFeature.SUPPORTS_ADD);
     derivedFeatures.remove(CollectionFeature.ALLOWS_NULL_VALUES);
@@ -102,8 +101,7 @@
   }
 
   static Set<Feature<?>> computeElementSetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.GENERAL_PURPOSE);
     derivedFeatures.remove(CollectionFeature.SUPPORTS_ADD);
     if (!derivedFeatures.remove(CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS)) {
@@ -113,8 +111,7 @@
   }
 
   private static Set<Feature<?>> computeReserializedMultisetFeatures(Set<Feature<?>> features) {
-    Set<Feature<?>> derivedFeatures = new HashSet<>();
-    derivedFeatures.addAll(features);
+    Set<Feature<?>> derivedFeatures = new HashSet<>(features);
     derivedFeatures.remove(CollectionFeature.SERIALIZABLE);
     derivedFeatures.remove(CollectionFeature.SERIALIZABLE_INCLUDING_VIEWS);
     return derivedFeatures;, @@ -266,8 +266,7 @@ private TestSuite createReserializedSuite(SortedMultisetTestSuiteBuilder<E> pare
     final TestMultisetGenerator<E> delegate =
         (TestMultisetGenerator<E>) parentBuilder.getSubjectGenerator();
 
-    Set<Feature<?>> features = new HashSet<>();
-    features.addAll(parentBuilder.getFeatures());
+    Set<Feature<?>> features = new HashSet<>(parentBuilder.getFeatures());
     features.remove(SERIALIZABLE);
     features.remove(SERIALIZABLE_INCLUDING_VIEWS);
 , @@ -67,8 +67,7 @@ private ClusterException(Collection<? extends Throwable> exceptions) {
     super(
         exceptions.size() + "" exceptions were thrown. The first exception is listed as a cause."",
         exceptions.iterator().next());
-    ArrayList<Throwable> temp = new ArrayList<>();
-    temp.addAll(exceptions);
+    ArrayList<Throwable> temp = new ArrayList<>(exceptions);
     this.exceptions = Collections.unmodifiableCollection(temp);
   }
 , @@ -1279,8 +1279,7 @@ public void testAsEnumerationTypical() {
   }
 
   private static Enumeration<Integer> enumerate(Integer... ints) {
-    Vector<Integer> vector = new Vector<>();
-    vector.addAll(asList(ints));
+    Vector<Integer> vector = new Vector<>(asList(ints));
     return vector.elements();
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Simplify redundant `Collection.addAll()` calls.

Fixes #3800

ae564a1d7c39704e800f04cef427f4c8abd6f010",MOE Sync 2020-02-23
3807,Colin Decker,"['android/guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/AbstractNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableDirectedMultiNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableDirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableUndirectedMultiNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/AbstractDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/AbstractNetworkTest.java', 'guava-tests/test/com/google/common/graph/AbstractUndirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableDirectedMultiNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableSimpleDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableSimpleUndirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableUndirectedMultiNetworkTest.java', 'guava-tests/test/com/google/common/graph/ConfigurableUndirectedNetworkTest.java']","@@ -19,6 +19,7 @@
 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
 import static com.google.common.graph.TestUtil.assertEdgeNotInGraphErrorMessage;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -192,11 +193,13 @@ public void outDegree_oneEdge() {
 
   @Test
   public void addEdge_existingNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     // Adding nodes initially for safety (insulating from possible future
     // modifications to proxy methods)
     addNode(N1);
     addNode(N2);
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     assertThat(network.edges()).contains(E12);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
     // Direction of the added edge is correctly handled
@@ -205,18 +208,22 @@ public void addEdge_existingNodes() {
 
   @Test
   public void addEdge_existingEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N2, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
       // Edge between totally different nodes
-      addEdge(N4, N5, E12);
+      networkAsMutableNetwork.addEdge(N4, N5, E12);
       fail(ERROR_ADDED_EXISTING_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);
@@ -232,9 +239,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes() {
 
   @Test
   public void addEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_PARALLEL_EDGE);
@@ -243,9 +252,11 @@ public void addEdge_parallelEdge() {
 
   @Test
   public void addEdge_orderMismatch() {
+    assume().that(graphIsMutable()).isTrue();
+
     EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);
     try {
-      addEdge(endpoints, E12);
+      networkAsMutableNetwork.addEdge(endpoints, E12);
       fail(""Expected IllegalArgumentException: "" + ENDPOINTS_MISMATCH);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);, @@ -22,6 +22,7 @@
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.graph.TestUtil.sanityCheckSet;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -30,7 +31,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CyclicBarrier;
@@ -57,7 +57,15 @@
  * TODO(user): Differentiate between directed and undirected edge strings.
  */
 public abstract class AbstractNetworkTest {
-  MutableNetwork<Integer, String> network;
+
+  Network<Integer, String> network;
+
+  /**
+   * The same reference as {@link #network}, except as a mutable network. This field is null in case
+   * {@link #createGraph()} didn't return a mutable network.
+   */
+  MutableNetwork<Integer, String> networkAsMutableNetwork;
+
   static final Integer N1 = 1;
   static final Integer N2 = 2;
   static final Integer N3 = 3;
@@ -98,54 +106,36 @@
       ""Reusing an existing edge to connect different nodes succeeded"";
 
   /** Creates and returns an instance of the graph to be tested. */
-  public abstract MutableNetwork<Integer, String> createGraph();
+  public abstract Network<Integer, String> createGraph();
 
   /**
    * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable
-   * graph implementations, this method should add {@code n} to the graph builder and build a new
-   * graph with the current builder state.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
+   * graph implementations, this method should replace {@link #network} with a new graph that
+   * includes this node.
    */
-  @CanIgnoreReturnValue
-  protected boolean addNode(Integer n) {
-    return network.addNode(n);
-  }
+  abstract void addNode(Integer n);
 
   /**
    * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable
-   * graph implementations, this method should add {@code e} to the graph builder and build a new
-   * graph with the current builder state.
-   *
-   * <p>This method should be used in tests of specific implementations if you want to ensure
-   * uniform behavior (including side effects) with how edges are added elsewhere in the tests. For
-   * example, the existing implementations of this method explicitly add the supplied nodes to the
-   * graph, and then call {@code graph.addEdge()} to connect the edge to the nodes; this is not part
-   * of the contract of {@code graph.addEdge()} and is done for convenience. In cases where you want
-   * to avoid such side effects (e.g., if you're testing what happens in your implementation if you
-   * add an edge whose end-points don't already exist in the graph), you should <b>not</b> use this
-   * method.
-   *
-   * <p>TODO(user): remove the addNode() calls, that's now contractually guaranteed
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
+   * graph implementations, this method should replace {@link #network} with a new graph that
+   * includes this edge.
    */
-  @CanIgnoreReturnValue
-  protected boolean addEdge(Integer n1, Integer n2, String e) {
-    network.addNode(n1);
-    network.addNode(n2);
-    return network.addEdge(n1, n2, e);
+  abstract void addEdge(Integer n1, Integer n2, String e);
+
+  final void addEdge(EndpointPair<Integer> endpoints, String e) {
+    addEdge(endpoints.nodeU(), endpoints.nodeV(), e);
   }
 
-  protected boolean addEdge(EndpointPair<Integer> endpoints, String e) {
-    network.addNode(endpoints.nodeU());
-    network.addNode(endpoints.nodeV());
-    return network.addEdge(endpoints, e);
+  final boolean graphIsMutable() {
+    return networkAsMutableNetwork != null;
   }
 
   @Before
   public void init() {
     network = createGraph();
+    if (network instanceof MutableNetwork) {
+      networkAsMutableNetwork = (MutableNetwork<Integer, String>) network;
+    }
   }
 
   @After
@@ -615,45 +605,56 @@ public void successors_nodeNotInGraph() {
 
   @Test
   public void addNode_newNode() {
-    assertTrue(addNode(N1));
-    assertThat(network.nodes()).contains(N1);
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).contains(N1);
   }
 
   @Test
   public void addNode_existingNode() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
-    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());
-    assertFalse(addNode(N1));
-    assertThat(network.nodes()).containsExactlyElementsIn(nodes);
+    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(networkAsMutableNetwork.nodes());
+    assertFalse(networkAsMutableNetwork.addNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactlyElementsIn(nodes);
   }
 
   @Test
   public void removeNode_existingNode() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N4, N1, E41);
-    assertTrue(network.removeNode(N1));
-    assertFalse(network.removeNode(N1));
-    assertThat(network.nodes()).containsExactly(N2, N4);
-    assertThat(network.edges()).doesNotContain(E12);
-    assertThat(network.edges()).doesNotContain(E41);
+    assertTrue(networkAsMutableNetwork.removeNode(N1));
+    assertFalse(networkAsMutableNetwork.removeNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactly(N2, N4);
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12);
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E41);
   }
 
   @Test
   public void removeNode_nodeNotPresent() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
-    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());
-    assertFalse(network.removeNode(NODE_NOT_IN_GRAPH));
-    assertThat(network.nodes()).containsExactlyElementsIn(nodes);
+    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(networkAsMutableNetwork.nodes());
+    assertFalse(networkAsMutableNetwork.removeNode(NODE_NOT_IN_GRAPH));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactlyElementsIn(nodes);
   }
 
   @Test
   public void removeNode_queryAfterRemoval() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     @SuppressWarnings(""unused"")
-    Set<Integer> unused = network.adjacentNodes(N1); // ensure cache (if any) is populated
-    assertTrue(network.removeNode(N1));
+    Set<Integer> unused =
+        networkAsMutableNetwork.adjacentNodes(N1); // ensure cache (if any) is populated
+    assertTrue(networkAsMutableNetwork.removeNode(N1));
     try {
-      network.adjacentNodes(N1);
+      networkAsMutableNetwork.adjacentNodes(N1);
       fail(ERROR_NODE_NOT_IN_GRAPH);
     } catch (IllegalArgumentException e) {
       assertNodeNotInGraphErrorMessage(e);
@@ -662,39 +663,48 @@ public void removeNode_queryAfterRemoval() {
 
   @Test
   public void removeEdge_existingEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E12));
-    assertFalse(network.removeEdge(E12));
-    assertThat(network.edges()).doesNotContain(E12);
-    assertThat(network.edgesConnecting(N1, N2)).isEmpty();
+    assertTrue(networkAsMutableNetwork.removeEdge(E12));
+    assertFalse(networkAsMutableNetwork.removeEdge(E12));
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12);
+    assertThat(networkAsMutableNetwork.edgesConnecting(N1, N2)).isEmpty();
   }
 
   @Test
   public void removeEdge_oneOfMany() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N3, E13);
     addEdge(N1, N4, E14);
-    assertThat(network.edges()).containsExactly(E12, E13, E14);
-    assertTrue(network.removeEdge(E13));
-    assertThat(network.edges()).containsExactly(E12, E14);
+    assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E13, E14);
+    assertTrue(networkAsMutableNetwork.removeEdge(E13));
+    assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E14);
   }
 
   @Test
   public void removeEdge_edgeNotPresent() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
-    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertFalse(network.removeEdge(EDGE_NOT_IN_GRAPH));
-    assertThat(network.edges()).containsExactlyElementsIn(edges);
+    ImmutableSet<String> edges = ImmutableSet.copyOf(networkAsMutableNetwork.edges());
+    assertFalse(networkAsMutableNetwork.removeEdge(EDGE_NOT_IN_GRAPH));
+    assertThat(networkAsMutableNetwork.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void removeEdge_queryAfterRemoval() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     @SuppressWarnings(""unused"")
-    EndpointPair<Integer> unused = network.incidentNodes(E12); // ensure cache (if any) is populated
-    assertTrue(network.removeEdge(E12));
+    EndpointPair<Integer> unused =
+        networkAsMutableNetwork.incidentNodes(E12); // ensure cache (if any) is populated
+    assertTrue(networkAsMutableNetwork.removeEdge(E12));
     try {
-      network.incidentNodes(E12);
+      networkAsMutableNetwork.incidentNodes(E12);
       fail(ERROR_EDGE_NOT_IN_GRAPH);
     } catch (IllegalArgumentException e) {
       assertEdgeNotInGraphErrorMessage(e);, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -128,32 +129,38 @@ public void outDegree_oneEdge() {
 
   @Test
   public void addEdge_existingNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     // Adding nodes initially for safety (insulating from possible future
     // modifications to proxy methods)
     addNode(N1);
     addNode(N2);
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     assertThat(network.edges()).contains(E12);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
     assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenSameNodes() {
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N2, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
-    assertThat(addEdge(N2, N1, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N2, N1, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
       // Edge between totally different nodes
-      addEdge(N4, N5, E12);
+      networkAsMutableNetwork.addEdge(N4, N5, E12);
       fail(ERROR_ADDED_EXISTING_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -162,15 +169,17 @@ public void addEdge_existingEdgeBetweenDifferentNodes() {
 
   @Test
   public void addEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
     }
     try {
-      addEdge(N2, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N2, N1, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -179,7 +188,9 @@ public void addEdge_parallelEdge() {
 
   @Test
   public void addEdge_orderMismatch() {
+    assume().that(graphIsMutable()).isTrue();
+
     EndpointPair<Integer> endpoints = EndpointPair.ordered(N1, N2);
-    assertThat(addEdge(endpoints, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(endpoints, E12)).isTrue();
   }
 }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
@@ -33,6 +34,16 @@
     return NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void adjacentEdges_parallelEdges() {
     addEdge(N1, N2, E12);
@@ -44,8 +55,9 @@ public void adjacentEdges_parallelEdges() {
 
   @Test
   public void edgesConnecting_parallelEdges() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
+    addEdge(N1, N2, E12);
+    addEdge(N1, N2, E12_A);
+
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);
     // Passed nodes should be in the correct edge direction, first is the
     // source node and the second is the target node
@@ -54,44 +66,53 @@ public void edgesConnecting_parallelEdges() {
 
   @Test
   public void edgesConnecting_parallelSelfLoopEdges() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    addEdge(N1, N1, E11);
+    addEdge(N1, N1, E11_A);
+
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelEdge() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelSelfLoopEdge() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Test
   public void removeEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
-    assertTrue(network.removeEdge(E12_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }
 
   @Test
   public void removeEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     addEdge(N1, N1, E11_A);
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E11_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
-    assertTrue(network.removeEdge(E11));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11));
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -33,6 +34,16 @@
     return NetworkBuilder.directed().allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void edges_selfLoop() {
     addEdge(N1, N1, E11);
@@ -146,37 +157,43 @@ public void outDegree_selfLoop() {
   @Override
   @Test
   public void addEdge_selfLoop() {
-    assertThat(addEdge(N1, N1, E11)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isTrue();
     assertThat(network.edges()).contains(E11);
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
   }
 
   @Test
   public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N1, E11)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N2, E11);
+      networkAsMutableNetwork.addEdge(N1, N2, E11);
       fail(""Reusing an existing self-loop edge to connect different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     try {
-      addEdge(N2, N2, E11);
+      networkAsMutableNetwork.addEdge(N2, N2, E11);
       fail(""Reusing an existing self-loop edge to make a different self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N1, E12);
+      networkAsMutableNetwork.addEdge(N1, N1, E12);
       fail(""Reusing an existing edge to add a self-loop edge between different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -185,9 +202,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
 
   @Test
   public void addEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
       fail(""Adding a parallel self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -196,17 +215,21 @@ public void addEdge_parallelSelfLoopEdge() {
 
   @Test
   public void removeNode_existingNodeWithSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     addEdge(N1, N1, E11);
-    assertThat(network.removeNode(N1)).isTrue();
+    assertThat(networkAsMutableNetwork.removeNode(N1)).isTrue();
     assertThat(network.nodes()).isEmpty();
     assertThat(network.edges()).doesNotContain(E11);
   }
 
   @Test
   public void removeEdge_existingSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
-    assertThat(network.removeEdge(E11)).isTrue();
+    assertThat(networkAsMutableNetwork.removeEdge(E11)).isTrue();
     assertThat(network.edges()).doesNotContain(E11);
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -37,6 +38,16 @@
     return NetworkBuilder.directed().allowsParallelEdges(false).allowsSelfLoops(false).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Override
   @Test
   public void nodes_checkReturnedSetMutability() {
@@ -179,8 +190,10 @@ public void successors_checkReturnedSetMutability() {
 
   @Test
   public void addEdge_selfLoop() {
+    assume().that(graphIsMutable()).isTrue();
+
     try {
-      addEdge(N1, N1, E11);
+      networkAsMutableNetwork.addEdge(N1, N1, E11);
       fail(ERROR_ADDED_SELF_LOOP);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP);
@@ -195,10 +208,12 @@ public void addEdge_selfLoop() {
    */
   @Test
   public void addEdge_nodesNotInGraph() {
-    network.addNode(N1);
-    assertTrue(network.addEdge(N1, N5, E15));
-    assertTrue(network.addEdge(N4, N1, E41));
-    assertTrue(network.addEdge(N2, N3, E23));
+    assume().that(graphIsMutable()).isTrue();
+
+    networkAsMutableNetwork.addNode(N1);
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));
+    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));
     assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();
     assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();
     assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -37,6 +38,16 @@
     return NetworkBuilder.undirected().allowsParallelEdges(false).allowsSelfLoops(false).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Override
   @Test
   public void nodes_checkReturnedSetMutability() {
@@ -179,8 +190,10 @@ public void successors_checkReturnedSetMutability() {
 
   @Test
   public void addEdge_selfLoop() {
+    assume().that(graphIsMutable()).isTrue();
+
     try {
-      addEdge(N1, N1, E11);
+      networkAsMutableNetwork.addEdge(N1, N1, E11);
       fail(ERROR_ADDED_SELF_LOOP);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP);
@@ -195,10 +208,12 @@ public void addEdge_selfLoop() {
    */
   @Test
   public void addEdge_nodesNotInGraph() {
-    network.addNode(N1);
-    assertTrue(network.addEdge(N1, N5, E15));
-    assertTrue(network.addEdge(N4, N1, E41));
-    assertTrue(network.addEdge(N2, N3, E23));
+    assume().that(graphIsMutable()).isTrue();
+
+    networkAsMutableNetwork.addNode(N1);
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));
+    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));
     assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();
     assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();
     assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
@@ -34,66 +35,87 @@
     return NetworkBuilder.undirected().allowsParallelEdges(true).allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void adjacentEdges_parallelEdges() {
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
     addEdge(N1, N2, E12_B);
     addEdge(N3, N4, E34);
+
     assertThat(network.adjacentEdges(E12)).containsExactly(E12_A, E12_B);
   }
 
   @Test
   public void edgesConnecting_parallelEdges() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
-    assertTrue(addEdge(N2, N1, E21));
+    addEdge(N1, N2, E12);
+    addEdge(N1, N2, E12_A);
+    addEdge(N2, N1, E21);
+
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);
     assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);
   }
 
   @Test
   public void edgesConnecting_parallelSelfLoopEdges() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    addEdge(N1, N1, E11);
+    addEdge(N1, N1, E11_A);
+
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelEdge() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
-    assertTrue(addEdge(N2, N1, E21));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N1, E21));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);
   }
 
   @Override
   @Test
   public void addEdge_parallelSelfLoopEdge() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Test
   public void removeEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
     addEdge(N2, N1, E21);
-    assertTrue(network.removeEdge(E12_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E21);
   }
 
   @Test
   public void removeEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     addEdge(N1, N1, E11_A);
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E11_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
-    assertTrue(network.removeEdge(E11));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11));
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -33,6 +34,16 @@
     return NetworkBuilder.undirected().allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void edges_selfLoop() {
     addEdge(N1, N1, E11);
@@ -135,37 +146,43 @@ public void outDegree_selfLoop() {
   @Override
   @Test
   public void addEdge_selfLoop() {
-    assertThat(addEdge(N1, N1, E11)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isTrue();
     assertThat(network.edges()).contains(E11);
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
   }
 
   @Test
   public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N1, E11)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N2, E11);
+      networkAsMutableNetwork.addEdge(N1, N2, E11);
       fail(""Reusing an existing self-loop edge to connect different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     try {
-      addEdge(N2, N2, E11);
+      networkAsMutableNetwork.addEdge(N2, N2, E11);
       fail(""Reusing an existing self-loop edge to make a different self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N1, E12);
+      networkAsMutableNetwork.addEdge(N1, N1, E12);
       fail(""Reusing an existing edge to add a self-loop edge between different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -174,9 +191,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
 
   @Test
   public void addEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
       fail(""Adding a parallel self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -185,17 +204,21 @@ public void addEdge_parallelSelfLoopEdge() {
 
   @Test
   public void removeNode_existingNodeWithSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     addEdge(N1, N1, E11);
-    assertThat(network.removeNode(N1)).isTrue();
+    assertThat(networkAsMutableNetwork.removeNode(N1)).isTrue();
     assertThat(network.nodes()).isEmpty();
     assertThat(network.edges()).doesNotContain(E11);
   }
 
   @Test
   public void removeEdge_existingSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
-    assertThat(network.removeEdge(E11)).isTrue();
+    assertThat(networkAsMutableNetwork.removeEdge(E11)).isTrue();
     assertThat(network.edges()).doesNotContain(E11);
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
   }, @@ -19,6 +19,7 @@
 import static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;
 import static com.google.common.graph.TestUtil.assertEdgeNotInGraphErrorMessage;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -204,11 +205,13 @@ public void outDegree_oneEdge() {
 
   @Test
   public void addEdge_existingNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     // Adding nodes initially for safety (insulating from possible future
     // modifications to proxy methods)
     addNode(N1);
     addNode(N2);
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     assertThat(network.edges()).contains(E12);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
     // Direction of the added edge is correctly handled
@@ -217,18 +220,22 @@ public void addEdge_existingNodes() {
 
   @Test
   public void addEdge_existingEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N2, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
       // Edge between totally different nodes
-      addEdge(N4, N5, E12);
+      networkAsMutableNetwork.addEdge(N4, N5, E12);
       fail(ERROR_ADDED_EXISTING_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_REUSE_EDGE);
@@ -244,9 +251,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes() {
 
   @Test
   public void addEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_PARALLEL_EDGE);
@@ -255,9 +264,11 @@ public void addEdge_parallelEdge() {
 
   @Test
   public void addEdge_orderMismatch() {
+    assume().that(graphIsMutable()).isTrue();
+
     EndpointPair<Integer> endpoints = EndpointPair.unordered(N1, N2);
     try {
-      addEdge(endpoints, E12);
+      networkAsMutableNetwork.addEdge(endpoints, E12);
       fail(""Expected IllegalArgumentException: "" + ENDPOINTS_MISMATCH);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ENDPOINTS_MISMATCH);, @@ -22,6 +22,7 @@
 import static com.google.common.graph.TestUtil.assertStronglyEquivalent;
 import static com.google.common.graph.TestUtil.sanityCheckSet;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -30,7 +31,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CyclicBarrier;
@@ -57,7 +57,15 @@
  * TODO(user): Differentiate between directed and undirected edge strings.
  */
 public abstract class AbstractNetworkTest {
-  MutableNetwork<Integer, String> network;
+
+  Network<Integer, String> network;
+
+  /**
+   * The same reference as {@link #network}, except as a mutable network. This field is null in case
+   * {@link #createGraph()} didn't return a mutable network.
+   */
+  MutableNetwork<Integer, String> networkAsMutableNetwork;
+
   static final Integer N1 = 1;
   static final Integer N2 = 2;
   static final Integer N3 = 3;
@@ -98,54 +106,36 @@
       ""Reusing an existing edge to connect different nodes succeeded"";
 
   /** Creates and returns an instance of the graph to be tested. */
-  public abstract MutableNetwork<Integer, String> createGraph();
+  public abstract Network<Integer, String> createGraph();
 
   /**
    * A proxy method that adds the node {@code n} to the graph being tested. In case of Immutable
-   * graph implementations, this method should add {@code n} to the graph builder and build a new
-   * graph with the current builder state.
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
+   * graph implementations, this method should replace {@link #network} with a new graph that
+   * includes this node.
    */
-  @CanIgnoreReturnValue
-  protected boolean addNode(Integer n) {
-    return network.addNode(n);
-  }
+  abstract void addNode(Integer n);
 
   /**
    * A proxy method that adds the edge {@code e} to the graph being tested. In case of Immutable
-   * graph implementations, this method should add {@code e} to the graph builder and build a new
-   * graph with the current builder state.
-   *
-   * <p>This method should be used in tests of specific implementations if you want to ensure
-   * uniform behavior (including side effects) with how edges are added elsewhere in the tests. For
-   * example, the existing implementations of this method explicitly add the supplied nodes to the
-   * graph, and then call {@code graph.addEdge()} to connect the edge to the nodes; this is not part
-   * of the contract of {@code graph.addEdge()} and is done for convenience. In cases where you want
-   * to avoid such side effects (e.g., if you're testing what happens in your implementation if you
-   * add an edge whose end-points don't already exist in the graph), you should <b>not</b> use this
-   * method.
-   *
-   * <p>TODO(user): remove the addNode() calls, that's now contractually guaranteed
-   *
-   * @return {@code true} iff the graph was modified as a result of this call
+   * graph implementations, this method should replace {@link #network} with a new graph that
+   * includes this edge.
    */
-  @CanIgnoreReturnValue
-  protected boolean addEdge(Integer n1, Integer n2, String e) {
-    network.addNode(n1);
-    network.addNode(n2);
-    return network.addEdge(n1, n2, e);
+  abstract void addEdge(Integer n1, Integer n2, String e);
+
+  final void addEdge(EndpointPair<Integer> endpoints, String e) {
+    addEdge(endpoints.nodeU(), endpoints.nodeV(), e);
   }
 
-  protected boolean addEdge(EndpointPair<Integer> endpoints, String e) {
-    network.addNode(endpoints.nodeU());
-    network.addNode(endpoints.nodeV());
-    return network.addEdge(endpoints, e);
+  final boolean graphIsMutable() {
+    return networkAsMutableNetwork != null;
   }
 
   @Before
   public void init() {
     network = createGraph();
+    if (network instanceof MutableNetwork) {
+      networkAsMutableNetwork = (MutableNetwork<Integer, String>) network;
+    }
   }
 
   @After
@@ -622,45 +612,56 @@ public void successors_nodeNotInGraph() {
 
   @Test
   public void addNode_newNode() {
-    assertTrue(addNode(N1));
-    assertThat(network.nodes()).contains(N1);
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).contains(N1);
   }
 
   @Test
   public void addNode_existingNode() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
-    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());
-    assertFalse(addNode(N1));
-    assertThat(network.nodes()).containsExactlyElementsIn(nodes);
+    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(networkAsMutableNetwork.nodes());
+    assertFalse(networkAsMutableNetwork.addNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactlyElementsIn(nodes);
   }
 
   @Test
   public void removeNode_existingNode() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N4, N1, E41);
-    assertTrue(network.removeNode(N1));
-    assertFalse(network.removeNode(N1));
-    assertThat(network.nodes()).containsExactly(N2, N4);
-    assertThat(network.edges()).doesNotContain(E12);
-    assertThat(network.edges()).doesNotContain(E41);
+    assertTrue(networkAsMutableNetwork.removeNode(N1));
+    assertFalse(networkAsMutableNetwork.removeNode(N1));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactly(N2, N4);
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12);
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E41);
   }
 
   @Test
   public void removeNode_nodeNotPresent() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
-    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(network.nodes());
-    assertFalse(network.removeNode(NODE_NOT_IN_GRAPH));
-    assertThat(network.nodes()).containsExactlyElementsIn(nodes);
+    ImmutableSet<Integer> nodes = ImmutableSet.copyOf(networkAsMutableNetwork.nodes());
+    assertFalse(networkAsMutableNetwork.removeNode(NODE_NOT_IN_GRAPH));
+    assertThat(networkAsMutableNetwork.nodes()).containsExactlyElementsIn(nodes);
   }
 
   @Test
   public void removeNode_queryAfterRemoval() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     @SuppressWarnings(""unused"")
-    Set<Integer> unused = network.adjacentNodes(N1); // ensure cache (if any) is populated
-    assertTrue(network.removeNode(N1));
+    Set<Integer> unused =
+        networkAsMutableNetwork.adjacentNodes(N1); // ensure cache (if any) is populated
+    assertTrue(networkAsMutableNetwork.removeNode(N1));
     try {
-      network.adjacentNodes(N1);
+      networkAsMutableNetwork.adjacentNodes(N1);
       fail(ERROR_NODE_NOT_IN_GRAPH);
     } catch (IllegalArgumentException e) {
       assertNodeNotInGraphErrorMessage(e);
@@ -669,39 +670,48 @@ public void removeNode_queryAfterRemoval() {
 
   @Test
   public void removeEdge_existingEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E12));
-    assertFalse(network.removeEdge(E12));
-    assertThat(network.edges()).doesNotContain(E12);
-    assertThat(network.edgesConnecting(N1, N2)).isEmpty();
+    assertTrue(networkAsMutableNetwork.removeEdge(E12));
+    assertFalse(networkAsMutableNetwork.removeEdge(E12));
+    assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12);
+    assertThat(networkAsMutableNetwork.edgesConnecting(N1, N2)).isEmpty();
   }
 
   @Test
   public void removeEdge_oneOfMany() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N3, E13);
     addEdge(N1, N4, E14);
-    assertThat(network.edges()).containsExactly(E12, E13, E14);
-    assertTrue(network.removeEdge(E13));
-    assertThat(network.edges()).containsExactly(E12, E14);
+    assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E13, E14);
+    assertTrue(networkAsMutableNetwork.removeEdge(E13));
+    assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E14);
   }
 
   @Test
   public void removeEdge_edgeNotPresent() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
-    ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertFalse(network.removeEdge(EDGE_NOT_IN_GRAPH));
-    assertThat(network.edges()).containsExactlyElementsIn(edges);
+    ImmutableSet<String> edges = ImmutableSet.copyOf(networkAsMutableNetwork.edges());
+    assertFalse(networkAsMutableNetwork.removeEdge(EDGE_NOT_IN_GRAPH));
+    assertThat(networkAsMutableNetwork.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void removeEdge_queryAfterRemoval() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     @SuppressWarnings(""unused"")
-    EndpointPair<Integer> unused = network.incidentNodes(E12); // ensure cache (if any) is populated
-    assertTrue(network.removeEdge(E12));
+    EndpointPair<Integer> unused =
+        networkAsMutableNetwork.incidentNodes(E12); // ensure cache (if any) is populated
+    assertTrue(networkAsMutableNetwork.removeEdge(E12));
     try {
-      network.incidentNodes(E12);
+      networkAsMutableNetwork.incidentNodes(E12);
       fail(ERROR_EDGE_NOT_IN_GRAPH);
     } catch (IllegalArgumentException e) {
       assertEdgeNotInGraphErrorMessage(e);, @@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth8.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -136,32 +137,38 @@ public void outDegree_oneEdge() {
 
   @Test
   public void addEdge_existingNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     // Adding nodes initially for safety (insulating from possible future
     // modifications to proxy methods)
     addNode(N1);
     addNode(N2);
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     assertThat(network.edges()).contains(E12);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
     assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenSameNodes() {
-    assertThat(addEdge(N1, N2, E12)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isTrue();
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N2, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N2, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
-    assertThat(addEdge(N2, N1, E12)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N2, N1, E12)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
       // Edge between totally different nodes
-      addEdge(N4, N5, E12);
+      networkAsMutableNetwork.addEdge(N4, N5, E12);
       fail(ERROR_ADDED_EXISTING_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -170,15 +177,17 @@ public void addEdge_existingEdgeBetweenDifferentNodes() {
 
   @Test
   public void addEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N2, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
     }
     try {
-      addEdge(N2, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N2, N1, EDGE_NOT_IN_GRAPH);
       fail(ERROR_ADDED_PARALLEL_EDGE);
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -187,7 +196,9 @@ public void addEdge_parallelEdge() {
 
   @Test
   public void addEdge_orderMismatch() {
+    assume().that(graphIsMutable()).isTrue();
+
     EndpointPair<Integer> endpoints = EndpointPair.ordered(N1, N2);
-    assertThat(addEdge(endpoints, E12)).isTrue();
+    assertThat(networkAsMutableNetwork.addEdge(endpoints, E12)).isTrue();
   }
 }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
@@ -33,6 +34,16 @@
     return NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void adjacentEdges_parallelEdges() {
     addEdge(N1, N2, E12);
@@ -44,8 +55,9 @@ public void adjacentEdges_parallelEdges() {
 
   @Test
   public void edgesConnecting_parallelEdges() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
+    addEdge(N1, N2, E12);
+    addEdge(N1, N2, E12_A);
+
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);
     // Passed nodes should be in the correct edge direction, first is the
     // source node and the second is the target node
@@ -54,44 +66,53 @@ public void edgesConnecting_parallelEdges() {
 
   @Test
   public void edgesConnecting_parallelSelfLoopEdges() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    addEdge(N1, N1, E11);
+    addEdge(N1, N1, E11_A);
+
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelEdge() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelSelfLoopEdge() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Test
   public void removeEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
-    assertTrue(network.removeEdge(E12_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }
 
   @Test
   public void removeEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     addEdge(N1, N1, E11_A);
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E11_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
-    assertTrue(network.removeEdge(E11));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11));
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -33,6 +34,16 @@
     return NetworkBuilder.directed().allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void edges_selfLoop() {
     addEdge(N1, N1, E11);
@@ -146,37 +157,43 @@ public void outDegree_selfLoop() {
   @Override
   @Test
   public void addEdge_selfLoop() {
-    assertThat(addEdge(N1, N1, E11)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isTrue();
     assertThat(network.edges()).contains(E11);
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
   }
 
   @Test
   public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N1, E11)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N2, E11);
+      networkAsMutableNetwork.addEdge(N1, N2, E11);
       fail(""Reusing an existing self-loop edge to connect different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     try {
-      addEdge(N2, N2, E11);
+      networkAsMutableNetwork.addEdge(N2, N2, E11);
       fail(""Reusing an existing self-loop edge to make a different self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N1, E12);
+      networkAsMutableNetwork.addEdge(N1, N1, E12);
       fail(""Reusing an existing edge to add a self-loop edge between different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -185,9 +202,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
 
   @Test
   public void addEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
       fail(""Adding a parallel self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -196,17 +215,21 @@ public void addEdge_parallelSelfLoopEdge() {
 
   @Test
   public void removeNode_existingNodeWithSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     addEdge(N1, N1, E11);
-    assertThat(network.removeNode(N1)).isTrue();
+    assertThat(networkAsMutableNetwork.removeNode(N1)).isTrue();
     assertThat(network.nodes()).isEmpty();
     assertThat(network.edges()).doesNotContain(E11);
   }
 
   @Test
   public void removeEdge_existingSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
-    assertThat(network.removeEdge(E11)).isTrue();
+    assertThat(networkAsMutableNetwork.removeEdge(E11)).isTrue();
     assertThat(network.edges()).doesNotContain(E11);
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -37,6 +38,16 @@
     return NetworkBuilder.directed().allowsParallelEdges(false).allowsSelfLoops(false).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Override
   @Test
   public void nodes_checkReturnedSetMutability() {
@@ -179,8 +190,10 @@ public void successors_checkReturnedSetMutability() {
 
   @Test
   public void addEdge_selfLoop() {
+    assume().that(graphIsMutable()).isTrue();
+
     try {
-      addEdge(N1, N1, E11);
+      networkAsMutableNetwork.addEdge(N1, N1, E11);
       fail(ERROR_ADDED_SELF_LOOP);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP);
@@ -195,10 +208,12 @@ public void addEdge_selfLoop() {
    */
   @Test
   public void addEdge_nodesNotInGraph() {
-    network.addNode(N1);
-    assertTrue(network.addEdge(N1, N5, E15));
-    assertTrue(network.addEdge(N4, N1, E41));
-    assertTrue(network.addEdge(N2, N3, E23));
+    assume().that(graphIsMutable()).isTrue();
+
+    networkAsMutableNetwork.addNode(N1);
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));
+    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));
     assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();
     assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();
     assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -37,6 +38,16 @@
     return NetworkBuilder.undirected().allowsParallelEdges(false).allowsSelfLoops(false).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Override
   @Test
   public void nodes_checkReturnedSetMutability() {
@@ -179,8 +190,10 @@ public void successors_checkReturnedSetMutability() {
 
   @Test
   public void addEdge_selfLoop() {
+    assume().that(graphIsMutable()).isTrue();
+
     try {
-      addEdge(N1, N1, E11);
+      networkAsMutableNetwork.addEdge(N1, N1, E11);
       fail(ERROR_ADDED_SELF_LOOP);
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP);
@@ -195,10 +208,12 @@ public void addEdge_selfLoop() {
    */
   @Test
   public void addEdge_nodesNotInGraph() {
-    network.addNode(N1);
-    assertTrue(network.addEdge(N1, N5, E15));
-    assertTrue(network.addEdge(N4, N1, E41));
-    assertTrue(network.addEdge(N2, N3, E23));
+    assume().that(graphIsMutable()).isTrue();
+
+    networkAsMutableNetwork.addNode(N1);
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15));
+    assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23));
     assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder();
     assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();
     assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
@@ -34,66 +35,87 @@
     return NetworkBuilder.undirected().allowsParallelEdges(true).allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void adjacentEdges_parallelEdges() {
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
     addEdge(N1, N2, E12_B);
     addEdge(N3, N4, E34);
+
     assertThat(network.adjacentEdges(E12)).containsExactly(E12_A, E12_B);
   }
 
   @Test
   public void edgesConnecting_parallelEdges() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
-    assertTrue(addEdge(N2, N1, E21));
+    addEdge(N1, N2, E12);
+    addEdge(N1, N2, E12_A);
+    addEdge(N2, N1, E21);
+
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);
     assertThat(network.edgesConnecting(N2, N1)).containsExactly(E12, E12_A, E21);
   }
 
   @Test
   public void edgesConnecting_parallelSelfLoopEdges() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    addEdge(N1, N1, E11);
+    addEdge(N1, N1, E11_A);
+
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Override
   @Test
   public void addEdge_parallelEdge() {
-    assertTrue(addEdge(N1, N2, E12));
-    assertTrue(addEdge(N1, N2, E12_A));
-    assertTrue(addEdge(N2, N1, E21));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12));
+    assertTrue(networkAsMutableNetwork.addEdge(N2, N1, E21));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N2, E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E12_A, E21);
   }
 
   @Override
   @Test
   public void addEdge_parallelSelfLoopEdge() {
-    assertTrue(addEdge(N1, N1, E11));
-    assertTrue(addEdge(N1, N1, E11_A));
+    assume().that(graphIsMutable()).isTrue();
+
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11));
+    assertTrue(networkAsMutableNetwork.addEdge(N1, N1, E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11, E11_A);
   }
 
   @Test
   public void removeEdge_parallelEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N2, E12);
     addEdge(N1, N2, E12_A);
     addEdge(N2, N1, E21);
-    assertTrue(network.removeEdge(E12_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E12_A));
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12, E21);
   }
 
   @Test
   public void removeEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     addEdge(N1, N1, E11_A);
     addEdge(N1, N2, E12);
-    assertTrue(network.removeEdge(E11_A));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11_A));
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
-    assertTrue(network.removeEdge(E11));
+    assertTrue(networkAsMutableNetwork.removeEdge(E11));
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
     assertThat(network.edgesConnecting(N1, N2)).containsExactly(E12);
   }, @@ -17,6 +17,7 @@
 package com.google.common.graph;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.TruthJUnit.assume;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.ImmutableSet;
@@ -33,6 +34,16 @@
     return NetworkBuilder.undirected().allowsSelfLoops(true).build();
   }
 
+  @Override
+  void addNode(Integer n) {
+    networkAsMutableNetwork.addNode(n);
+  }
+
+  @Override
+  void addEdge(Integer n1, Integer n2, String e) {
+    networkAsMutableNetwork.addEdge(n1, n2, e);
+  }
+
   @Test
   public void edges_selfLoop() {
     addEdge(N1, N1, E11);
@@ -135,37 +146,43 @@ public void outDegree_selfLoop() {
   @Override
   @Test
   public void addEdge_selfLoop() {
-    assertThat(addEdge(N1, N1, E11)).isTrue();
+    assume().that(graphIsMutable()).isTrue();
+
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isTrue();
     assertThat(network.edges()).contains(E11);
     assertThat(network.edgesConnecting(N1, N1)).containsExactly(E11);
   }
 
   @Test
   public void addEdge_existingSelfLoopEdgeBetweenSameNodes() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     ImmutableSet<String> edges = ImmutableSet.copyOf(network.edges());
-    assertThat(addEdge(N1, N1, E11)).isFalse();
+    assertThat(networkAsMutableNetwork.addEdge(N1, N1, E11)).isFalse();
     assertThat(network.edges()).containsExactlyElementsIn(edges);
   }
 
   @Test
   public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N2, E11);
+      networkAsMutableNetwork.addEdge(N1, N2, E11);
       fail(""Reusing an existing self-loop edge to connect different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     try {
-      addEdge(N2, N2, E11);
+      networkAsMutableNetwork.addEdge(N2, N2, E11);
       fail(""Reusing an existing self-loop edge to make a different self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
     }
     addEdge(N1, N2, E12);
     try {
-      addEdge(N1, N1, E12);
+      networkAsMutableNetwork.addEdge(N1, N1, E12);
       fail(""Reusing an existing edge to add a self-loop edge between different nodes succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_REUSE_EDGE);
@@ -174,9 +191,11 @@ public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops() {
 
   @Test
   public void addEdge_parallelSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
     try {
-      addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
+      networkAsMutableNetwork.addEdge(N1, N1, EDGE_NOT_IN_GRAPH);
       fail(""Adding a parallel self-loop edge succeeded"");
     } catch (IllegalArgumentException e) {
       assertThat(e.getMessage()).contains(ERROR_PARALLEL_EDGE);
@@ -185,17 +204,21 @@ public void addEdge_parallelSelfLoopEdge() {
 
   @Test
   public void removeNode_existingNodeWithSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addNode(N1);
     addEdge(N1, N1, E11);
-    assertThat(network.removeNode(N1)).isTrue();
+    assertThat(networkAsMutableNetwork.removeNode(N1)).isTrue();
     assertThat(network.nodes()).isEmpty();
     assertThat(network.edges()).doesNotContain(E11);
   }
 
   @Test
   public void removeEdge_existingSelfLoopEdge() {
+    assume().that(graphIsMutable()).isTrue();
+
     addEdge(N1, N1, E11);
-    assertThat(network.removeEdge(E11)).isTrue();
+    assertThat(networkAsMutableNetwork.removeEdge(E11)).isTrue();
     assertThat(network.edges()).doesNotContain(E11);
     assertThat(network.edgesConnecting(N1, N1)).isEmpty();
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Refactor AbstractNetworkTest in the same way as AbstractGraphTest was refactored earlier: Allow the graph under test to be immutable.

Note: This is a pure refactor, no coverage is changing.

1ae455b65162b8a1adf369e24f1d593b5f2886a3",MOE Sync 2020-02-25
3810,Chris Povirk,"['android/guava-tests/test/com/google/common/graph/StandardDirectedMultiNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardDirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardSimpleDirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardSimpleDirectedSortedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardSimpleUndirectedNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardUndirectedMultiNetworkTest.java', 'android/guava-tests/test/com/google/common/graph/StandardUndirectedNetworkTest.java', 'android/guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java', 'android/guava/src/com/google/common/graph/DirectedGraphConnections.java', 'android/guava/src/com/google/common/graph/ElementOrder.java', 'android/guava/src/com/google/common/graph/ImmutableNetwork.java', 'android/guava/src/com/google/common/graph/NetworkBuilder.java', 'android/guava/src/com/google/common/graph/StandardMutableNetwork.java', 'android/guava/src/com/google/common/graph/StandardNetwork.java', 'guava-tests/test/com/google/common/graph/StandardDirectedMultiNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardSimpleDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardSimpleDirectedSortedNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardSimpleUndirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardUndirectedMultiNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardUndirectedNetworkTest.java', 'guava/src/com/google/common/graph/AbstractDirectedNetworkConnections.java', 'guava/src/com/google/common/graph/DirectedGraphConnections.java', 'guava/src/com/google/common/graph/ElementOrder.java', 'guava/src/com/google/common/graph/ImmutableNetwork.java', 'guava/src/com/google/common/graph/NetworkBuilder.java', 'guava/src/com/google/common/graph/StandardMutableNetwork.java', 'guava/src/com/google/common/graph/StandardNetwork.java']","@@ -24,11 +24,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for a directed {@link ConfigurableMutableNetwork} allowing parallel edges and self-loops.
- */
+/** Tests for a directed {@link StandardMutableNetwork} allowing parallel edges and self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableDirectedMultiNetworkTest extends ConfigurableDirectedNetworkTest {
+public class StandardDirectedMultiNetworkTest extends StandardDirectedNetworkTest {
   @Override
   public MutableNetwork<Integer, String> createGraph() {
     return NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();, @@ -25,9 +25,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for a directed {@link ConfigurableMutableNetwork} allowing self-loops. */
+/** Tests for a directed {@link StandardMutableNetwork} allowing self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableDirectedNetworkTest extends ConfigurableSimpleDirectedNetworkTest {
+public class StandardDirectedNetworkTest extends StandardSimpleDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -27,11 +27,11 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed graph
- * (parallel and self-loop edges are not allowed).
+ * Tests for a directed {@link StandardMutableNetwork}, creating a simple directed graph (parallel
+ * and self-loop edges are not allowed).
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleDirectedNetworkTest extends AbstractDirectedNetworkTest {
+public class StandardSimpleDirectedNetworkTest extends AbstractDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -23,15 +23,14 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed sorted graph
+ * Tests for a directed {@link StandardMutableNetwork}, creating a simple directed sorted graph
  * (parallel and self-loop edges are not allowed).
  *
  * <p>The main purpose of this class is to run the inherited {@link #concurrentIteration} test
  * against a sorted graph so as to cover {@link MapRetrievalCache}.
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleDirectedSortedNetworkTest
-    extends ConfigurableSimpleDirectedNetworkTest {
+public class StandardSimpleDirectedSortedNetworkTest extends StandardSimpleDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -27,11 +27,11 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for an undirected {@link ConfigurableMutableNetwork}, creating a simple undirected graph
+ * Tests for an undirected {@link StandardMutableNetwork}, creating a simple undirected graph
  * (parallel and self-loop edges are not allowed).
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleUndirectedNetworkTest extends AbstractUndirectedNetworkTest {
+public class StandardSimpleUndirectedNetworkTest extends AbstractUndirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -25,11 +25,10 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for an undirected {@link ConfigurableMutableNetwork} allowing parallel edges and
- * self-loops.
+ * Tests for an undirected {@link StandardMutableNetwork} allowing parallel edges and self-loops.
  */
 @RunWith(JUnit4.class)
-public class ConfigurableUndirectedMultiNetworkTest extends ConfigurableUndirectedNetworkTest {
+public class StandardUndirectedMultiNetworkTest extends StandardUndirectedNetworkTest {
   @Override
   public MutableNetwork<Integer, String> createGraph() {
     return NetworkBuilder.undirected().allowsParallelEdges(true).allowsSelfLoops(true).build();, @@ -25,9 +25,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for an undirected {@link ConfigurableMutableNetwork} allowing self-loops. */
+/** Tests for an undirected {@link StandardMutableNetwork} allowing self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableUndirectedNetworkTest extends ConfigurableSimpleUndirectedNetworkTest {
+public class StandardUndirectedNetworkTest extends StandardSimpleUndirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -119,6 +119,9 @@ public N removeOutEdge(E edge) {
 
   @Override
   public void addInEdge(E edge, N node, boolean isSelfLoop) {
+    checkNotNull(edge);
+    checkNotNull(node);
+
     if (isSelfLoop) {
       checkPositive(++selfLoopCount);
     }
@@ -128,6 +131,9 @@ public void addInEdge(E edge, N node, boolean isSelfLoop) {
 
   @Override
   public void addOutEdge(E edge, N node) {
+    checkNotNull(edge);
+    checkNotNull(node);
+
     N previousNode = outEdgeMap.put(edge, node);
     checkState(previousNode == null);
   }, @@ -177,6 +177,9 @@ private DirectedGraphConnections(
 
   static <N, V> DirectedGraphConnections<N, V> ofImmutable(
       N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
+    checkNotNull(thisNode);
+    checkNotNull(successorNodeToValueFn);
+
     Map<N, Object> adjacentNodeValues = new HashMap<>();
     ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder =
         ImmutableList.builder();
@@ -363,6 +366,8 @@ public boolean contains(@NullableDecl Object obj) {
 
   @Override
   public Iterator<EndpointPair<N>> incidentEdgeIterator(final N thisNode) {
+    checkNotNull(thisNode);
+
     final Iterator<EndpointPair<N>> resultWithDoubleSelfLoop;
     if (orderedNodeConnections == null) {
       resultWithDoubleSelfLoop =
@@ -421,6 +426,7 @@ public boolean contains(@NullableDecl Object obj) {
   @SuppressWarnings(""unchecked"")
   @Override
   public V value(N node) {
+    checkNotNull(node);
     Object value = adjacentNodeValues.get(node);
     if (value == PRED) {
       return null;
@@ -434,6 +440,8 @@ public V value(N node) {
   @SuppressWarnings(""unchecked"")
   @Override
   public void removePredecessor(N node) {
+    checkNotNull(node);
+
     Object previousValue = adjacentNodeValues.get(node);
     boolean removedPredecessor;
 
@@ -459,6 +467,7 @@ public void removePredecessor(N node) {
   @SuppressWarnings(""unchecked"")
   @Override
   public V removeSuccessor(Object node) {
+    checkNotNull(node);
     Object previousValue = adjacentNodeValues.get(node);
     Object removedValue;
 , @@ -137,7 +137,7 @@ private ElementOrder(Type type, @NullableDecl Comparator<T> comparator) {
    * determined by {@code comparator}.
    */
   public static <S> ElementOrder<S> sorted(Comparator<S> comparator) {
-    return new ElementOrder<S>(Type.SORTED, comparator);
+    return new ElementOrder<S>(Type.SORTED, checkNotNull(comparator));
   }
 
   /** Returns the type of ordering used. */, @@ -45,8 +45,8 @@
  */
 @Beta
 @Immutable(containerOf = {""N"", ""E""})
-@SuppressWarnings(""Immutable"") // Extends ConfigurableNetwork but uses ImmutableMaps.
-public final class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {
+@SuppressWarnings(""Immutable"") // Extends StandardNetwork but uses ImmutableMaps.
+public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
 
   private ImmutableNetwork(Network<N, E> network) {
     super(, @@ -182,7 +182,7 @@ private NetworkBuilder(boolean directed) {
 
   /** Returns an empty {@link MutableNetwork} with the properties of this {@link NetworkBuilder}. */
   public <N1 extends N, E1 extends E> MutableNetwork<N1, E1> build() {
-    return new ConfigurableMutableNetwork<>(this);
+    return new StandardMutableNetwork<>(this);
   }
 
   @SuppressWarnings(""unchecked""), @@ -39,11 +39,11 @@
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  */
-final class ConfigurableMutableNetwork<N, E> extends ConfigurableNetwork<N, E>
+final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     implements MutableNetwork<N, E> {
 
   /** Constructs a mutable graph with the properties specified in {@code builder}. */
-  ConfigurableMutableNetwork(NetworkBuilder<? super N, ? super E> builder) {
+  StandardMutableNetwork(NetworkBuilder<? super N, ? super E> builder) {
     super(builder);
   }
 , @@ -48,7 +48,7 @@
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  */
-class ConfigurableNetwork<N, E> extends AbstractNetwork<N, E> {
+class StandardNetwork<N, E> extends AbstractNetwork<N, E> {
   private final boolean isDirected;
   private final boolean allowsParallelEdges;
   private final boolean allowsSelfLoops;
@@ -62,7 +62,7 @@
   protected final MapIteratorCache<E, N> edgeToReferenceNode; // referenceNode == source if directed
 
   /** Constructs a graph with the properties specified in {@code builder}. */
-  ConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder) {
+  StandardNetwork(NetworkBuilder<? super N, ? super E> builder) {
     this(
         builder,
         builder.nodeOrder.<N, NetworkConnections<N, E>>createMap(
@@ -74,7 +74,7 @@
    * Constructs a graph with the properties specified in {@code builder}, initialized with the given
    * node and edge maps.
    */
-  ConfigurableNetwork(
+  StandardNetwork(
       NetworkBuilder<? super N, ? super E> builder,
       Map<N, NetworkConnections<N, E>> nodeConnections,
       Map<E, N> edgeToReferenceNode) {, @@ -24,11 +24,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Tests for a directed {@link ConfigurableMutableNetwork} allowing parallel edges and self-loops.
- */
+/** Tests for a directed {@link StandardMutableNetwork} allowing parallel edges and self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableDirectedMultiNetworkTest extends ConfigurableDirectedNetworkTest {
+public class StandardDirectedMultiNetworkTest extends StandardDirectedNetworkTest {
   @Override
   public MutableNetwork<Integer, String> createGraph() {
     return NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();, @@ -25,9 +25,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for a directed {@link ConfigurableMutableNetwork} allowing self-loops. */
+/** Tests for a directed {@link StandardMutableNetwork} allowing self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableDirectedNetworkTest extends ConfigurableSimpleDirectedNetworkTest {
+public class StandardDirectedNetworkTest extends StandardSimpleDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -27,11 +27,11 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed graph
- * (parallel and self-loop edges are not allowed).
+ * Tests for a directed {@link StandardMutableNetwork}, creating a simple directed graph (parallel
+ * and self-loop edges are not allowed).
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleDirectedNetworkTest extends AbstractDirectedNetworkTest {
+public class StandardSimpleDirectedNetworkTest extends AbstractDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -23,15 +23,14 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for a directed {@link ConfigurableMutableNetwork}, creating a simple directed sorted graph
+ * Tests for a directed {@link StandardMutableNetwork}, creating a simple directed sorted graph
  * (parallel and self-loop edges are not allowed).
  *
  * <p>The main purpose of this class is to run the inherited {@link #concurrentIteration} test
  * against a sorted graph so as to cover {@link MapRetrievalCache}.
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleDirectedSortedNetworkTest
-    extends ConfigurableSimpleDirectedNetworkTest {
+public class StandardSimpleDirectedSortedNetworkTest extends StandardSimpleDirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -27,11 +27,11 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for an undirected {@link ConfigurableMutableNetwork}, creating a simple undirected graph
+ * Tests for an undirected {@link StandardMutableNetwork}, creating a simple undirected graph
  * (parallel and self-loop edges are not allowed).
  */
 @RunWith(JUnit4.class)
-public class ConfigurableSimpleUndirectedNetworkTest extends AbstractUndirectedNetworkTest {
+public class StandardSimpleUndirectedNetworkTest extends AbstractUndirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -25,11 +25,10 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Tests for an undirected {@link ConfigurableMutableNetwork} allowing parallel edges and
- * self-loops.
+ * Tests for an undirected {@link StandardMutableNetwork} allowing parallel edges and self-loops.
  */
 @RunWith(JUnit4.class)
-public class ConfigurableUndirectedMultiNetworkTest extends ConfigurableUndirectedNetworkTest {
+public class StandardUndirectedMultiNetworkTest extends StandardUndirectedNetworkTest {
   @Override
   public MutableNetwork<Integer, String> createGraph() {
     return NetworkBuilder.undirected().allowsParallelEdges(true).allowsSelfLoops(true).build();, @@ -25,9 +25,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for an undirected {@link ConfigurableMutableNetwork} allowing self-loops. */
+/** Tests for an undirected {@link StandardMutableNetwork} allowing self-loops. */
 @RunWith(JUnit4.class)
-public class ConfigurableUndirectedNetworkTest extends ConfigurableSimpleUndirectedNetworkTest {
+public class StandardUndirectedNetworkTest extends StandardSimpleUndirectedNetworkTest {
 
   @Override
   public MutableNetwork<Integer, String> createGraph() {, @@ -119,6 +119,9 @@ public N removeOutEdge(E edge) {
 
   @Override
   public void addInEdge(E edge, N node, boolean isSelfLoop) {
+    checkNotNull(edge);
+    checkNotNull(node);
+
     if (isSelfLoop) {
       checkPositive(++selfLoopCount);
     }
@@ -128,6 +131,9 @@ public void addInEdge(E edge, N node, boolean isSelfLoop) {
 
   @Override
   public void addOutEdge(E edge, N node) {
+    checkNotNull(edge);
+    checkNotNull(node);
+
     N previousNode = outEdgeMap.put(edge, node);
     checkState(previousNode == null);
   }, @@ -177,6 +177,9 @@ private DirectedGraphConnections(
 
   static <N, V> DirectedGraphConnections<N, V> ofImmutable(
       N thisNode, Iterable<EndpointPair<N>> incidentEdges, Function<N, V> successorNodeToValueFn) {
+    checkNotNull(thisNode);
+    checkNotNull(successorNodeToValueFn);
+
     Map<N, Object> adjacentNodeValues = new HashMap<>();
     ImmutableList.Builder<NodeConnection<N>> orderedNodeConnectionsBuilder =
         ImmutableList.builder();
@@ -363,6 +366,8 @@ public boolean contains(@Nullable Object obj) {
 
   @Override
   public Iterator<EndpointPair<N>> incidentEdgeIterator(final N thisNode) {
+    checkNotNull(thisNode);
+
     final Iterator<EndpointPair<N>> resultWithDoubleSelfLoop;
     if (orderedNodeConnections == null) {
       resultWithDoubleSelfLoop =
@@ -421,6 +426,7 @@ public boolean contains(@Nullable Object obj) {
   @SuppressWarnings(""unchecked"")
   @Override
   public V value(N node) {
+    checkNotNull(node);
     Object value = adjacentNodeValues.get(node);
     if (value == PRED) {
       return null;
@@ -434,6 +440,8 @@ public V value(N node) {
   @SuppressWarnings(""unchecked"")
   @Override
   public void removePredecessor(N node) {
+    checkNotNull(node);
+
     Object previousValue = adjacentNodeValues.get(node);
     boolean removedPredecessor;
 
@@ -459,6 +467,7 @@ public void removePredecessor(N node) {
   @SuppressWarnings(""unchecked"")
   @Override
   public V removeSuccessor(Object node) {
+    checkNotNull(node);
     Object previousValue = adjacentNodeValues.get(node);
     Object removedValue;
 , @@ -136,7 +136,7 @@ private ElementOrder(Type type, @Nullable Comparator<T> comparator) {
    * determined by {@code comparator}.
    */
   public static <S> ElementOrder<S> sorted(Comparator<S> comparator) {
-    return new ElementOrder<S>(Type.SORTED, comparator);
+    return new ElementOrder<S>(Type.SORTED, checkNotNull(comparator));
   }
 
   /** Returns the type of ordering used. */, @@ -45,8 +45,8 @@
  */
 @Beta
 @Immutable(containerOf = {""N"", ""E""})
-@SuppressWarnings(""Immutable"") // Extends ConfigurableNetwork but uses ImmutableMaps.
-public final class ImmutableNetwork<N, E> extends ConfigurableNetwork<N, E> {
+@SuppressWarnings(""Immutable"") // Extends StandardNetwork but uses ImmutableMaps.
+public final class ImmutableNetwork<N, E> extends StandardNetwork<N, E> {
 
   private ImmutableNetwork(Network<N, E> network) {
     super(, @@ -182,7 +182,7 @@ private NetworkBuilder(boolean directed) {
 
   /** Returns an empty {@link MutableNetwork} with the properties of this {@link NetworkBuilder}. */
   public <N1 extends N, E1 extends E> MutableNetwork<N1, E1> build() {
-    return new ConfigurableMutableNetwork<>(this);
+    return new StandardMutableNetwork<>(this);
   }
 
   @SuppressWarnings(""unchecked""), @@ -39,11 +39,11 @@
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  */
-final class ConfigurableMutableNetwork<N, E> extends ConfigurableNetwork<N, E>
+final class StandardMutableNetwork<N, E> extends StandardNetwork<N, E>
     implements MutableNetwork<N, E> {
 
   /** Constructs a mutable graph with the properties specified in {@code builder}. */
-  ConfigurableMutableNetwork(NetworkBuilder<? super N, ? super E> builder) {
+  StandardMutableNetwork(NetworkBuilder<? super N, ? super E> builder) {
     super(builder);
   }
 , @@ -48,7 +48,7 @@
  * @param <N> Node parameter type
  * @param <E> Edge parameter type
  */
-class ConfigurableNetwork<N, E> extends AbstractNetwork<N, E> {
+class StandardNetwork<N, E> extends AbstractNetwork<N, E> {
   private final boolean isDirected;
   private final boolean allowsParallelEdges;
   private final boolean allowsSelfLoops;
@@ -62,7 +62,7 @@
   protected final MapIteratorCache<E, N> edgeToReferenceNode; // referenceNode == source if directed
 
   /** Constructs a graph with the properties specified in {@code builder}. */
-  ConfigurableNetwork(NetworkBuilder<? super N, ? super E> builder) {
+  StandardNetwork(NetworkBuilder<? super N, ? super E> builder) {
     this(
         builder,
         builder.nodeOrder.<N, NetworkConnections<N, E>>createMap(
@@ -74,7 +74,7 @@
    * Constructs a graph with the properties specified in {@code builder}, initialized with the given
    * node and edge maps.
    */
-  ConfigurableNetwork(
+  StandardNetwork(
       NetworkBuilder<? super N, ? super E> builder,
       Map<N, NetworkConnections<N, E>> nodeConnections,
       Map<E, N> edgeToReferenceNode) {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make Compact(Linked)HashSet fall back to a java.util.LinkedHashSet if hash flooding is detected, just as the immutable collections do.

a97eccf35da1290e69a2b95375b10cbced95c7b6

-------

<p> Make lenientToString easier for nullness-analysis tools to understand.

And I think prevent it from turning a StackOverflowError into a NullPointerException in unlikely cases?

As far as tools know, String.valueOf is capable of throwing an Error or RuntimeException, even when it's called with a parameter whose values is null. Thus, tools conclude that the flow of the program might reach `o.getClass().getName()` when `o` is null. That would in turn produce NullPointerException.

Tools might not even be wrong, since String.valueOf could produce a StackOverflowError if we were *just* about to run out of space. Of course, in that case we're going to have problems in the catch() block no matter what... :)

To avoid this, we check for null in lenientToString itself.

e9d2fcc35213b848d2904e82768dc5d42d33039a

-------

<p> Make GWT compilation of tests no longer flaky.

bb6e55fe20861fe0160d9e95fc5507ef4c6a0ee2

-------

<p> Update Public Suffix data.

1323cda77015764438d4febdd83240c006b9da48

-------

<p> Rename 'ConfigurableX' to 'StandardX' for Network, which better captures what these implementations represent.

Note that this work was already done for [Value]Graph.

ef37cf45afbcd44a75de665b03966a075af7727a",MOE Sync 2020-02-27
3811,Chris Povirk,"['android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java', 'guava-tests/test/com/google/common/graph/AbstractGraphTest.java']","@@ -94,10 +94,6 @@
    */
   abstract void putEdge(Integer n1, Integer n2);
 
-  final void putEdge(EndpointPair<Integer> endpoints) {
-    putEdge(endpoints.nodeU(), endpoints.nodeV());
-  }
-
   final boolean graphIsMutable() {
     return graphAsMutableGraph != null;
   }, @@ -94,10 +94,6 @@
    */
   abstract void putEdge(Integer n1, Integer n2);
 
-  final void putEdge(EndpointPair<Integer> endpoints) {
-    putEdge(endpoints.nodeU(), endpoints.nodeV());
-  }
-
   final boolean graphIsMutable() {
     return graphAsMutableGraph != null;
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove remaining documentation references to configurable implementations

9c3f315f62358c54a0e03fda782eba0e8d39419f

-------

<p> Delete unused method

71f625f15620bf4893322011536977459321c1a5",MOE Sync 2020-02-27
3814,Colin Decker,"['android/guava-tests/test/com/google/common/io/CharStreamsTest.java', 'android/guava/src/com/google/common/io/CharStreams.java', 'guava-tests/test/com/google/common/io/CharStreamsTest.java', 'guava/src/com/google/common/io/CharStreams.java']","@@ -267,6 +267,21 @@ public void testNullWriter() throws Exception {
     String test = ""Test string for NullWriter"";
     nullWriter.write(test);
     nullWriter.write(test, 2, 10);
+    nullWriter.append(null);
+    nullWriter.append(null, 0, 4);
+
+    try {
+      nullWriter.append(null, -1, 4);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
+    try {
+      nullWriter.append(null, 0, 5);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
     // nothing really to assert?
     assertSame(CharStreams.nullWriter(), CharStreams.nullWriter());
   }, @@ -28,6 +28,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Provides utility methods for working with character streams.
@@ -306,14 +307,13 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(CharSequence csq) {
-      checkNotNull(csq);
+    public Writer append(@NullableDecl CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(CharSequence csq, int start, int end) {
-      checkPositionIndexes(start, end, csq.length());
+    public Writer append(@NullableDecl CharSequence csq, int start, int end) {
+      checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }
 , @@ -267,6 +267,21 @@ public void testNullWriter() throws Exception {
     String test = ""Test string for NullWriter"";
     nullWriter.write(test);
     nullWriter.write(test, 2, 10);
+    nullWriter.append(null);
+    nullWriter.append(null, 0, 4);
+
+    try {
+      nullWriter.append(null, -1, 4);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
+    try {
+      nullWriter.append(null, 0, 5);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
     // nothing really to assert?
     assertSame(CharStreams.nullWriter(), CharStreams.nullWriter());
   }, @@ -28,6 +28,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with character streams.
@@ -306,14 +307,13 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(CharSequence csq) {
-      checkNotNull(csq);
+    public Writer append(@Nullable CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(CharSequence csq, int start, int end) {
-      checkPositionIndexes(start, end, csq.length());
+    public Writer append(@Nullable CharSequence csq, int start, int end) {
+      checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make nullWriter().append(...) (both overloads) accept a null CharSequence.

The docs of Writer are misleading:

""""""
An invocation of this method of the form out.append(csq) behaves in exactly the same way as the invocation
     out.write(csq.toString())
""""""
https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html#append%28java.lang.CharSequence%29

But that's not true, as the docs go on to say:

""""""
csq - The character sequence to append. If csq is null, then the four characters ""null"" are appended to this writer.
""""""

Accepting null in the 2-arg method is arguably even weirder, but at least the docs call it out more prominently:
https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html#append%28java.lang.CharSequence,%20int,%20int%29

Credit to the Checker Framework for identifying this bug.

a27746a876d9426a7252460ef288f4abf9c0d785",MOE Sync 2020-03-02
3815,Nick,"['android/guava-tests/test/com/google/common/io/CharStreamsTest.java', 'android/guava/src/com/google/common/io/CharStreams.java', 'guava-tests/test/com/google/common/io/CharStreamsTest.java', 'guava/src/com/google/common/io/CharStreams.java']","@@ -267,6 +267,21 @@ public void testNullWriter() throws Exception {
     String test = ""Test string for NullWriter"";
     nullWriter.write(test);
     nullWriter.write(test, 2, 10);
+    nullWriter.append(null);
+    nullWriter.append(null, 0, 4);
+
+    try {
+      nullWriter.append(null, -1, 4);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
+    try {
+      nullWriter.append(null, 0, 5);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
     // nothing really to assert?
     assertSame(CharStreams.nullWriter(), CharStreams.nullWriter());
   }, @@ -28,6 +28,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
+import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * Provides utility methods for working with character streams.
@@ -306,14 +307,13 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(CharSequence csq) {
-      checkNotNull(csq);
+    public Writer append(@NullableDecl CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(CharSequence csq, int start, int end) {
-      checkPositionIndexes(start, end, csq.length());
+    public Writer append(@NullableDecl CharSequence csq, int start, int end) {
+      checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }
 , @@ -267,6 +267,21 @@ public void testNullWriter() throws Exception {
     String test = ""Test string for NullWriter"";
     nullWriter.write(test);
     nullWriter.write(test, 2, 10);
+    nullWriter.append(null);
+    nullWriter.append(null, 0, 4);
+
+    try {
+      nullWriter.append(null, -1, 4);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
+    try {
+      nullWriter.append(null, 0, 5);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+
     // nothing really to assert?
     assertSame(CharStreams.nullWriter(), CharStreams.nullWriter());
   }, @@ -28,6 +28,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with character streams.
@@ -306,14 +307,13 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(CharSequence csq) {
-      checkNotNull(csq);
+    public Writer append(@Nullable CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(CharSequence csq, int start, int end) {
-      checkPositionIndexes(start, end, csq.length());
+    public Writer append(@Nullable CharSequence csq, int start, int end) {
+      checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Store each result in a ""Present<V>"" instance instead of an Optional<V>.

We can't store a plain V because we need to distinguish between Optional.absent() and null (at least in the Google-internal successfulAsMap -- and eventually in whenAllComplete(...).collectToList() (#1519), which is likely to omit failures instead of mapping them to null as successfulAsList does).

We may have problems using Optional when we adopt new nullability annotations, since Optional<V> might not be a valid instantiation when V is instantiated with a nullable type.

e371bf1af65c4c6727d1194fd59ffcc99a8ea084

-------

<p> Migrate from @MonotonicNonNull to @Nullable.

The features of @MonotonicNonNull don't buy us anything in our use case, since we check the fields for null on every access, anyway.

And @MonotonicNonNull is likely not to be available in the set of nullness annotations we adopt.

https://checkerframework.org/api/org/checkerframework/checker/nullness/qual/MonotonicNonNull.html

d4d5d6293d45c41110cb35c3e6e3a27996fe91bc

-------

<p> Rollback a8107fae90ddec3a1c6d4dbba80ccf9c8a90c54d pending internal break

8a32d0b35e3c8342ef1cb503de9ef2881958ad68

-------

<p> Roll-forward of a8107fae90ddec3a1c6d4dbba80ccf9c8a90c54d

Make nullWriter().append(...) (both overloads) accept a null CharSequence.

The docs of Writer are misleading:

""""""
An invocation of this method of the form out.append(csq) behaves in exactly the same way as the invocation
     out.write(csq.toString())
""""""
https://docs.oracle.com/javase/7/docs/api/java/io/Writer.html#app...

29992f2f557770a4c52c78f47750ae12b26d72fd",MOE Sync 2020-03-04
3818,David P. Baker,"['android/guava/src/com/google/common/util/concurrent/CollectionFuture.java', 'guava/src/com/google/common/util/concurrent/CollectionFuture.java']","@@ -28,6 +28,12 @@
 /** Aggregate future that collects (stores) results of each future. */
 @GwtCompatible(emulated = true)
 abstract class CollectionFuture<V, C> extends AggregateFuture<V, C> {
+  /*
+   * We access this field racily but safely. For discussion of a similar situation, see the comments
+   * on the fields of TimeoutFuture. This field is slightly different than the fields discussed
+   * there: cancel() never reads this field, only writes to it. That makes the race here completely
+   * harmless, rather than just 99.99% harmless.
+   */
   private List<Present<V>> values;
 
   CollectionFuture(, @@ -28,6 +28,12 @@
 /** Aggregate future that collects (stores) results of each future. */
 @GwtCompatible(emulated = true)
 abstract class CollectionFuture<V, C> extends AggregateFuture<V, C> {
+  /*
+   * We access this field racily but safely. For discussion of a similar situation, see the comments
+   * on the fields of TimeoutFuture. This field is slightly different than the fields discussed
+   * there: cancel() never reads this field, only writes to it. That makes the race here completely
+   * harmless, rather than just 99.99% harmless.
+   */
   private List<Present<V>> values;
 
   CollectionFuture(, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Document that our racy access is safe.

2c9301827eab9df3769c09ca1ae74c7c8673ea76",MOE Sync 2020-03-09
3819,David P. Baker,"['android/guava-tests/test/com/google/common/graph/StandardMutableDirectedNetworkTest.java', 'guava-tests/test/com/google/common/graph/StandardMutableDirectedNetworkTest.java']","@@ -16,16 +16,34 @@
 
 package com.google.common.graph;
 
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /** Tests for a directed {@link StandardMutableNetwork} allowing self-loops. */
-@RunWith(JUnit4.class)
+@AndroidIncompatible
+@RunWith(Parameterized.class)
 public class StandardMutableDirectedNetworkTest extends AbstractStandardDirectedNetworkTest {
 
+  @Parameters(name = ""allowsSelfLoops={0}"")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[][] {
+          {false}, {true},
+        });
+  }
+
+  private final boolean allowsSelfLoops;
+
+  public StandardMutableDirectedNetworkTest(boolean allowsSelfLoops) {
+    this.allowsSelfLoops = allowsSelfLoops;
+  }
+
   @Override
   MutableNetwork<Integer, String> createGraph() {
-    return NetworkBuilder.directed().allowsSelfLoops(true).build();
+    return NetworkBuilder.directed().allowsSelfLoops(allowsSelfLoops).build();
   }
 
   @Override, @@ -16,16 +16,34 @@
 
 package com.google.common.graph;
 
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /** Tests for a directed {@link StandardMutableNetwork} allowing self-loops. */
-@RunWith(JUnit4.class)
+@AndroidIncompatible
+@RunWith(Parameterized.class)
 public class StandardMutableDirectedNetworkTest extends AbstractStandardDirectedNetworkTest {
 
+  @Parameters(name = ""allowsSelfLoops={0}"")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[][] {
+          {false}, {true},
+        });
+  }
+
+  private final boolean allowsSelfLoops;
+
+  public StandardMutableDirectedNetworkTest(boolean allowsSelfLoops) {
+    this.allowsSelfLoops = allowsSelfLoops;
+  }
+
   @Override
   MutableNetwork<Integer, String> createGraph() {
-    return NetworkBuilder.directed().allowsSelfLoops(true).build();
+    return NetworkBuilder.directed().allowsSelfLoops(allowsSelfLoops).build();
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Simplify AbstractGraphTest by replacing allowsSelfLoops() and incidentEdgeOrder() by graph accessors.

a8d9fcb85edea8f185af28da6b4e12f2636e59a6

-------

<p> Simplify the AbstractNetworkTest tree (undirected branch): Delete StandardSimpleUndirectedNetworkTest

This is similar to an earlier refector of the AbstractGraphTest tree.

Note: This is a pure refactor: No tests were added or removed.

34ed9b2c6d258e867b043401ebd9614a175476b8

-------

<p> Move all tests from StandardMutableUndirectedNetworkTest to AbstractStandardUndirectedNetworkTest

This is similar to an earlier refector of the AbstractGraphTest tree.

Note: This is a pure refactor: No tests were added or removed.

6dfb447e78c21e1e206cb91453f4e4e03e6b261b

-------

<p> Make StandardMutableUndirectedNetworkTest parameterized so that it tests both with and without self loops.

This is similar to an earlier refector of the AbstractGraphTest tree.

ee6595018132ed9e859152f0d11450598c168774

-------

<p> Simplify the AbstractNetworkTest tree (directed branch): Delete StandardSimpleDirectedNetworkTest

This is similar to an earlier refector of the AbstractGraphTest tree.

45bb762daf790b278f7ceaaab8c94575b70df32d

-------

<p> Move all tests from StandardMutableDirectedNetworkTest to AbstractStandardDirectedNetworkTest

This is similar to an earlier refector of the AbstractGraphTest tree.

Note: This is a pure refactor: No tests were added or removed.

bd328cd0dfeb89d27225cf9b4caecc5756ed42b3

-------

<p> Make StandardMutableDirectedNetworkTest parameterized so that it tests both with and without self loops.

This is similar to an earlier refector of the AbstractGraphTest tree.

c5d8c5b19184f54be74b27d56e7d4f29824fdeac",MOE Sync 2020-03-10
3823,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java', 'guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java']","@@ -188,7 +188,7 @@ public void run() {
     // Check that this thread has been marked as interrupted again now that the thread has been
     // returned by SequentialExecutor. Clear the bit while checking so that the test doesn't hose
     // JUnit or some other test case.
-    assertThat(Thread.currentThread().interrupted()).isTrue();
+    assertThat(Thread.interrupted()).isTrue();
   }
 
   public void testInterrupt_doesNotInterruptSubsequentTask() throws Exception {
@@ -215,7 +215,7 @@ public void run() {
     // Check that the interruption of a SequentialExecutor's task is restored to the thread once
     // it is yielded. Clear the bit while checking so that the test doesn't hose JUnit or some other
     // test case.
-    assertThat(Thread.currentThread().interrupted()).isTrue();
+    assertThat(Thread.interrupted()).isTrue();
   }
 
   public void testInterrupt_doesNotStopExecution() {, @@ -188,7 +188,7 @@ public void run() {
     // Check that this thread has been marked as interrupted again now that the thread has been
     // returned by SequentialExecutor. Clear the bit while checking so that the test doesn't hose
     // JUnit or some other test case.
-    assertThat(Thread.currentThread().interrupted()).isTrue();
+    assertThat(Thread.interrupted()).isTrue();
   }
 
   public void testInterrupt_doesNotInterruptSubsequentTask() throws Exception {
@@ -215,7 +215,7 @@ public void run() {
     // Check that the interruption of a SequentialExecutor's task is restored to the thread once
     // it is yielded. Clear the bit while checking so that the test doesn't hose JUnit or some other
     // test case.
-    assertThat(Thread.currentThread().interrupted()).isTrue();
+    assertThat(Thread.interrupted()).isTrue();
   }
 
   public void testInterrupt_doesNotStopExecution() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Replace Thread.currentThread().interrupted() with Thread.interrupted() or Thread.currentThread().interrupt(), whichever seems appropriate.

Thread.interrupted: static method on Thread which returns whether the thread has been interrupted (and resets the interrupt bit)

Thread.currentThread().interrupt(): interrupts the current thread

744b356fa6769d4ae6924d649ac20da6c7e748ac",MOE Sync 2020-03-16
3824,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java', 'android/guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java', 'guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java', 'guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'guava/src/com/google/common/util/concurrent/SequentialExecutor.java']","@@ -17,6 +17,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.MoreExecutors.newSequentialExecutor;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 
 import com.google.common.collect.ImmutableList;
@@ -348,4 +349,21 @@ public void run() {
       assertThat(expected).hasCauseThat().isInstanceOf(RejectedExecutionException.class);
     }
   }
+
+  public void testToString() {
+    Executor delegate =
+        new Executor() {
+          @Override
+          public void execute(Runnable task) {}
+
+          @Override
+          public String toString() {
+            return ""theDelegate"";
+          }
+        };
+    Executor sequential1 = newSequentialExecutor(delegate);
+    Executor sequential2 = newSequentialExecutor(delegate);
+    assertThat(sequential1.toString()).contains(""theDelegate"");
+    assertThat(sequential1.toString()).isNotEqualTo(sequential2.toString());
+  }
 }, @@ -985,6 +985,11 @@ public void run() {
                   thrownFromDelegate = false;
                   command.run();
                 }
+
+                @Override
+                public String toString() {
+                  return command.toString();
+                }
               });
         } catch (RejectedExecutionException e) {
           if (thrownFromDelegate) {, @@ -19,6 +19,7 @@
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUED;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUING;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.RUNNING;
+import static java.lang.System.identityHashCode;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
@@ -239,4 +240,9 @@ private void workOnQueue() {
       }
     }
   }
+
+  @Override
+  public String toString() {
+    return ""SequentialExecutor@"" + identityHashCode(this) + ""{"" + executor + ""}"";
+  }
 }, @@ -17,6 +17,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.MoreExecutors.newSequentialExecutor;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 
 import com.google.common.collect.ImmutableList;
@@ -348,4 +349,21 @@ public void run() {
       assertThat(expected).hasCauseThat().isInstanceOf(RejectedExecutionException.class);
     }
   }
+
+  public void testToString() {
+    Executor delegate =
+        new Executor() {
+          @Override
+          public void execute(Runnable task) {}
+
+          @Override
+          public String toString() {
+            return ""theDelegate"";
+          }
+        };
+    Executor sequential1 = newSequentialExecutor(delegate);
+    Executor sequential2 = newSequentialExecutor(delegate);
+    assertThat(sequential1.toString()).contains(""theDelegate"");
+    assertThat(sequential1.toString()).isNotEqualTo(sequential2.toString());
+  }
 }, @@ -1090,6 +1090,11 @@ public void run() {
                   thrownFromDelegate = false;
                   command.run();
                 }
+
+                @Override
+                public String toString() {
+                  return command.toString();
+                }
               });
         } catch (RejectedExecutionException e) {
           if (thrownFromDelegate) {, @@ -19,6 +19,7 @@
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUED;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.QUEUING;
 import static com.google.common.util.concurrent.SequentialExecutor.WorkerRunningState.RUNNING;
+import static java.lang.System.identityHashCode;
 
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
@@ -239,4 +240,9 @@ private void workOnQueue() {
       }
     }
   }
+
+  @Override
+  public String toString() {
+    return ""SequentialExecutor@"" + identityHashCode(this) + ""{"" + executor + ""}"";
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Implement some more toString() methods for debugging.

I added these locally while debugging, but they seem potentially generally useful.

d52651a64c4965bb06be812b90aee6191e7a80f8",MOE Sync 2020-03-16
3825,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/CollectionFuture.java', 'guava/src/com/google/common/util/concurrent/CollectionFuture.java']","@@ -41,7 +41,7 @@
       boolean allMustSucceed) {
     super(futures, allMustSucceed, true);
 
-    this.values =
+    List<Present<V>> values =
         futures.isEmpty()
             ? ImmutableList.<Present<V>>of()
             : Lists.<Present<V>>newArrayListWithCapacity(futures.size());
@@ -50,6 +50,8 @@
     for (int i = 0; i < futures.size(); ++i) {
       values.add(null);
     }
+
+    this.values = values;
   }
 
   @Override, @@ -41,7 +41,7 @@
       boolean allMustSucceed) {
     super(futures, allMustSucceed, true);
 
-    this.values =
+    List<Present<V>> values =
         futures.isEmpty()
             ? ImmutableList.<Present<V>>of()
             : Lists.<Present<V>>newArrayListWithCapacity(futures.size());
@@ -50,6 +50,8 @@
     for (int i = 0; i < futures.size(); ++i) {
       values.add(null);
     }
+
+    this.values = values;
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Store `values` in a local first instead of repeatedly reading it from a field.

At worst, this is a no-op. At best, it may perform better.

b6d4f65f1065dcf3fe75bbeb1b2df226280116c5",MOE Sync 2020-03-16
3827,Chris Povirk,"['guava-tests/test/com/google/common/util/concurrent/ListeningScheduledExecutorServiceTest.java', 'guava/src/com/google/common/util/concurrent/ListeningScheduledExecutorService.java']","@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ForwardingListenableFuture.SimpleForwardingListenableFuture;
+import java.time.Duration;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Delayed;
+import java.util.concurrent.TimeUnit;
+import junit.framework.TestCase;
+
+/** Tests for default methods of the interface. */
+public class ListeningScheduledExecutorServiceTest extends TestCase {
+
+  private Runnable recordedCommand;
+  private long recordedDelay;
+  private long recordedInterval;
+  private TimeUnit recordedTimeUnit;
+
+  private final ListeningScheduledExecutorService executorService = new FakeExecutorService();
+
+  public void testScheduleRunnable() throws Exception {
+    Runnable command = () -> {};
+
+    ListenableScheduledFuture<?> future = executorService.schedule(command, Duration.ofSeconds(12));
+
+    assertThat(future.get()).isEqualTo(""schedule"");
+    assertThat(recordedCommand).isSameInstanceAs(command);
+    assertThat(recordedTimeUnit).isEqualTo(TimeUnit.NANOSECONDS);
+    assertThat(Duration.ofNanos(recordedDelay)).isEqualTo(Duration.ofSeconds(12));
+  }
+
+  public void testScheduleCallable() throws Exception {
+    Callable<String> callable = () -> ""hello"";
+
+    ListenableScheduledFuture<String> future =
+        executorService.schedule(callable, Duration.ofMinutes(12));
+
+    assertThat(future.get()).isEqualTo(""hello"");
+    assertThat(recordedTimeUnit).isEqualTo(TimeUnit.NANOSECONDS);
+    assertThat(Duration.ofNanos(recordedDelay)).isEqualTo(Duration.ofMinutes(12));
+  }
+
+  public void testScheduleAtFixedRate() throws Exception {
+    Runnable command = () -> {};
+
+    ListenableScheduledFuture<?> future =
+        executorService.scheduleAtFixedRate(command, Duration.ofDays(2), Duration.ofHours(4));
+
+    assertThat(future.get()).isEqualTo(""scheduleAtFixedRate"");
+    assertThat(recordedCommand).isSameInstanceAs(command);
+    assertThat(recordedTimeUnit).isEqualTo(TimeUnit.NANOSECONDS);
+    assertThat(Duration.ofNanos(recordedDelay)).isEqualTo(Duration.ofDays(2));
+    assertThat(Duration.ofNanos(recordedInterval)).isEqualTo(Duration.ofHours(4));
+  }
+
+  public void testScheduleWithFixedDelay() throws Exception {
+    Runnable command = () -> {};
+
+    ListenableScheduledFuture<?> future =
+        executorService.scheduleWithFixedDelay(command, Duration.ofDays(8), Duration.ofHours(16));
+
+    assertThat(future.get()).isEqualTo(""scheduleWithFixedDelay"");
+    assertThat(recordedCommand).isSameInstanceAs(command);
+    assertThat(recordedTimeUnit).isEqualTo(TimeUnit.NANOSECONDS);
+    assertThat(Duration.ofNanos(recordedDelay)).isEqualTo(Duration.ofDays(8));
+    assertThat(Duration.ofNanos(recordedInterval)).isEqualTo(Duration.ofHours(16));
+  }
+
+  private class FakeExecutorService extends AbstractListeningExecutorService
+      implements ListeningScheduledExecutorService {
+    @Override
+    public ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+      recordedCommand = command;
+      recordedDelay = delay;
+      recordedTimeUnit = unit;
+      return ImmediateScheduledFuture.of(""schedule"");
+    }
+
+    @Override
+    public <V> ListenableScheduledFuture<V> schedule(
+        Callable<V> callable, long delay, TimeUnit unit) {
+      recordedDelay = delay;
+      recordedTimeUnit = unit;
+      try {
+        return ImmediateScheduledFuture.of(callable.call());
+      } catch (Exception e) {
+        return ImmediateScheduledFuture.failed(e);
+      }
+    }
+
+    @Override
+    public ListenableScheduledFuture<?> scheduleAtFixedRate(
+        Runnable command, long initialDelay, long period, TimeUnit unit) {
+      recordedCommand = command;
+      recordedDelay = initialDelay;
+      recordedInterval = period;
+      recordedTimeUnit = unit;
+      return ImmediateScheduledFuture.of(""scheduleAtFixedRate"");
+    }
+
+    @Override
+    public ListenableScheduledFuture<?> scheduleWithFixedDelay(
+        Runnable command, long initialDelay, long delay, TimeUnit unit) {
+      recordedCommand = command;
+      recordedDelay = initialDelay;
+      recordedInterval = delay;
+      recordedTimeUnit = unit;
+      return ImmediateScheduledFuture.of(""scheduleWithFixedDelay"");
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void shutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isShutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isTerminated() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private static class ImmediateScheduledFuture<V> extends SimpleForwardingListenableFuture<V>
+      implements ListenableScheduledFuture<V> {
+    static <V> ListenableScheduledFuture<V> of(V value) {
+      return new ImmediateScheduledFuture<>(Futures.immediateFuture(value));
+    }
+
+    static <V> ListenableScheduledFuture<V> failed(Throwable t) {
+      return new ImmediateScheduledFuture<>(Futures.immediateFailedFuture(t));
+    }
+
+    ImmediateScheduledFuture(ListenableFuture<V> delegate) {
+      super(delegate);
+    }
+
+    @Override
+    public long getDelay(TimeUnit unit) {
+      return 0;
+    }
+
+    @Override
+    public int compareTo(Delayed other) {
+      return 0;
+    }
+  }
+}, @@ -14,7 +14,10 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.util.concurrent.Internal.toNanosSaturated;
+
 import com.google.common.annotations.GwtIncompatible;
+import java.time.Duration;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -36,17 +39,57 @@
   @Override
   ListenableScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
 
+  /**
+   * Duration-based overload of {@link #schedule(Runnable, long, TimeUnit)}.
+   *
+   * @since NEXT
+   */
+  default ListenableScheduledFuture<?> schedule(Runnable command, Duration delay) {
+    return schedule(command, toNanosSaturated(delay), TimeUnit.NANOSECONDS);
+  }
+
   /** @since 15.0 (previously returned ScheduledFuture) */
   @Override
   <V> ListenableScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
 
+  /**
+   * Duration-based overload of {@link #schedule(Callable, long, TimeUnit)}.
+   *
+   * @since NEXT
+   */
+  default <V> ListenableScheduledFuture<V> schedule(Callable<V> callable, Duration delay) {
+    return schedule(callable, toNanosSaturated(delay), TimeUnit.NANOSECONDS);
+  }
+
   /** @since 15.0 (previously returned ScheduledFuture) */
   @Override
   ListenableScheduledFuture<?> scheduleAtFixedRate(
       Runnable command, long initialDelay, long period, TimeUnit unit);
 
+  /**
+   * Duration-based overload of {@link #scheduleAtFixedRate(Runnable, long, long, TimeUnit)}.
+   *
+   * @since NEXT
+   */
+  default ListenableScheduledFuture<?> scheduleAtFixedRate(
+      Runnable command, Duration initialDelay, Duration period) {
+    return scheduleAtFixedRate(
+        command, toNanosSaturated(initialDelay), toNanosSaturated(period), TimeUnit.NANOSECONDS);
+  }
+
   /** @since 15.0 (previously returned ScheduledFuture) */
   @Override
   ListenableScheduledFuture<?> scheduleWithFixedDelay(
       Runnable command, long initialDelay, long delay, TimeUnit unit);
+
+  /**
+   * Duration-based overload of {@link #scheduleWithFixedDelay(Runnable, long, long, TimeUnit)}.
+   *
+   * @since NEXT
+   */
+  default ListenableScheduledFuture<?> scheduleWithFixedDelay(
+      Runnable command, Duration initialDelay, Duration delay) {
+    return scheduleWithFixedDelay(
+        command, toNanosSaturated(initialDelay), toNanosSaturated(delay), TimeUnit.NANOSECONDS);
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add `Duration`-based default methods to `ListeningScheduledExecutorService`

They just delegate to the existing methods from the interface, using the existing saturated conversion to nanoseconds. This matches existing `Duration`-based overloads of `(long, TimeUnit)` methods in the same package.

RELNOTES=Added `Duration`-based `default` methods to `ListeningScheduledExecutorService`.

c7984e7e5c40868ca47faede472ad77c10965114",MOE Sync 2020-03-17
3830,Chris Povirk,"['android/guava-tests/test/com/google/common/io/ByteSourceTest.java', 'android/guava/src/com/google/common/io/ByteSource.java', 'guava-tests/test/com/google/common/io/ByteSourceTest.java', 'guava/src/com/google/common/io/ByteSource.java']","@@ -454,6 +454,10 @@ public void testCopyExceptions() {
     }
   }
 
+  public void testSlice_returnEmptySource() {
+    assertEquals(ByteSource.empty(), source.slice(0, 3).slice(4, 3));
+  }
+
   private static int getAndResetRecords(TestLogHandler logHandler) {
     int records = logHandler.getStoredLogRecords().size();
     logHandler.clear();, @@ -530,7 +530,9 @@ public ByteSource slice(long offset, long length) {
       checkArgument(offset >= 0, ""offset (%s) may not be negative"", offset);
       checkArgument(length >= 0, ""length (%s) may not be negative"", length);
       long maxLength = this.length - offset;
-      return ByteSource.this.slice(this.offset + offset, Math.min(length, maxLength));
+      return maxLength <= 0
+          ? ByteSource.empty()
+          : ByteSource.this.slice(this.offset + offset, Math.min(length, maxLength));
     }
 
     @Override, @@ -454,6 +454,10 @@ public void testCopyExceptions() {
     }
   }
 
+  public void testSlice_returnEmptySource() {
+    assertEquals(ByteSource.empty(), source.slice(0, 3).slice(4, 3));
+  }
+
   private static int getAndResetRecords(TestLogHandler logHandler) {
     int records = logHandler.getStoredLogRecords().size();
     logHandler.clear();, @@ -530,7 +530,9 @@ public ByteSource slice(long offset, long length) {
       checkArgument(offset >= 0, ""offset (%s) may not be negative"", offset);
       checkArgument(length >= 0, ""length (%s) may not be negative"", length);
       long maxLength = this.length - offset;
-      return ByteSource.this.slice(this.offset + offset, Math.min(length, maxLength));
+      return maxLength <= 0
+          ? ByteSource.empty()
+          : ByteSource.this.slice(this.offset + offset, Math.min(length, maxLength));
     }
 
     @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fixed double slicing ByteSource (#3501).

Fixes #3829

6fb7746b8bc39d4d547a1b2bb47549c6b8314af4",MOE Sync 2020-03-19
3831,Chris Povirk,"['android/guava-tests/test/com/google/common/io/BaseEncodingTest.java', 'guava-gwt/test/com/google/common/io/BaseEncodingTest_gwt.java', 'guava-tests/test/com/google/common/io/BaseEncodingTest.java']","@@ -19,6 +19,7 @@
 import static com.google.common.io.BaseEncoding.base32;
 import static com.google.common.io.BaseEncoding.base32Hex;
 import static com.google.common.io.BaseEncoding.base64;
+import static com.google.common.io.BaseEncoding.base64Url;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -191,6 +192,16 @@ public void testBase64Offset() {
     testEncodesWithOffset(base64(), ""foobar"", 4, 0, """");
   }
 
+  public void testBase64Url() {
+    testDecodesByBytes(base64Url(), ""_zzz"", new byte[] {-1, 60, -13});
+    testDecodesByBytes(base64Url(), ""-zzz"", new byte[] {-5, 60, -13});
+  }
+
+  public void testBase64UrlInvalidDecodings() {
+    assertFailsToDecode(base64Url(), ""+zzz"", ""Unrecognized character: +"");
+    assertFailsToDecode(base64Url(), ""/zzz"", ""Unrecognized character: /"");
+  }
+
   public void testBase32() {
     // The following test vectors are specified in RFC 4648 itself
     testEncodingWithCasing(base32(), """", """");
@@ -384,6 +395,11 @@ private static void testDecodes(BaseEncoding encoding, String encoded, String de
     assertThat(encoding.decode(encoded)).isEqualTo(decoded.getBytes(UTF_8));
   }
 
+  private static void testDecodesByBytes(BaseEncoding encoding, String encoded, byte[] decoded) {
+    assertTrue(encoding.canDecode(encoded));
+    assertThat(encoding.decode(encoded)).isEqualTo(decoded);
+  }
+
   private static void assertFailsToDecode(BaseEncoding encoding, String cannotDecode) {
     assertFailsToDecode(encoding, cannotDecode, null);
   }, @@ -133,6 +133,16 @@ public void testBase64OmitPadding() throws Exception {
   testCase.testBase64OmitPadding();
 }
 
+public void testBase64Url() throws Exception {
+  com.google.common.io.BaseEncodingTest testCase = new com.google.common.io.BaseEncodingTest();
+  testCase.testBase64Url();
+}
+
+public void testBase64UrlInvalidDecodings() throws Exception {
+  com.google.common.io.BaseEncodingTest testCase = new com.google.common.io.BaseEncodingTest();
+  testCase.testBase64UrlInvalidDecodings();
+}
+
 public void testSeparatorSameAsPadChar() throws Exception {
   com.google.common.io.BaseEncodingTest testCase = new com.google.common.io.BaseEncodingTest();
   testCase.testSeparatorSameAsPadChar();, @@ -19,6 +19,7 @@
 import static com.google.common.io.BaseEncoding.base32;
 import static com.google.common.io.BaseEncoding.base32Hex;
 import static com.google.common.io.BaseEncoding.base64;
+import static com.google.common.io.BaseEncoding.base64Url;
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
@@ -191,6 +192,16 @@ public void testBase64Offset() {
     testEncodesWithOffset(base64(), ""foobar"", 4, 0, """");
   }
 
+  public void testBase64Url() {
+    testDecodesByBytes(base64Url(), ""_zzz"", new byte[] {-1, 60, -13});
+    testDecodesByBytes(base64Url(), ""-zzz"", new byte[] {-5, 60, -13});
+  }
+
+  public void testBase64UrlInvalidDecodings() {
+    assertFailsToDecode(base64Url(), ""+zzz"", ""Unrecognized character: +"");
+    assertFailsToDecode(base64Url(), ""/zzz"", ""Unrecognized character: /"");
+  }
+
   public void testBase32() {
     // The following test vectors are specified in RFC 4648 itself
     testEncodingWithCasing(base32(), """", """");
@@ -384,6 +395,11 @@ private static void testDecodes(BaseEncoding encoding, String encoded, String de
     assertThat(encoding.decode(encoded)).isEqualTo(decoded.getBytes(UTF_8));
   }
 
+  private static void testDecodesByBytes(BaseEncoding encoding, String encoded, byte[] decoded) {
+    assertTrue(encoding.canDecode(encoded));
+    assertThat(encoding.decode(encoded)).isEqualTo(decoded);
+  }
+
   private static void assertFailsToDecode(BaseEncoding encoding, String cannotDecode) {
     assertFailsToDecode(encoding, cannotDecode, null);
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add some unit tests for base64Url() in BaseEncoding

Fixes #3816

e1c08a80e340efb4477dd601d6073936cc67617f",MOE Sync 2020-03-20
3833,Nick,"['android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java']","@@ -268,6 +268,7 @@ public void addListener(Listener listener, Executor executor) {
    * <p>RuntimeExceptions thrown by a listener will be caught and logged.
    *
    * @param listener the listener to run when the manager changes state
+   * @since 15.0
    */
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());, @@ -270,6 +270,7 @@ public void addListener(Listener listener, Executor executor) {
    * <p>RuntimeExceptions thrown by a listener will be caught and logged.
    *
    * @param listener the listener to run when the manager changes state
+   * @since 15.0
    */
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make sure native.js files are included in the Guava GWT release.

This is needed for J2CL compatibility.

b1511bdf9bd51b666d07550ba258f556a6bef2fa

-------

<p> Add missing `@since` for 1-arg `ServiceManager.addListener`.

https://guava.dev/releases/15.0/api/diffs/changes/com.google.common.util.concurrent.ServiceManager.html#com.google.common.util.concurrent.ServiceManager.addListener_added%28com.google.common.util.concurrent.ServiceManager.Listener%29

29d356e629ed4798ba2fe9a71600e708e132b529",MOE Sync 2020-03-25
3836,Nick,"['android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java']","@@ -243,8 +243,9 @@ public ServiceManager(Iterable<? extends Service> services) {
    * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and
    * logged.
    *
-   * <p>For fast, lightweight listeners that would be safe to execute in any thread, consider
-   * calling {@link #addListener(Listener)}.
+   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
+   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
+   * documentation.
    *
    * @param listener the listener to run when the manager changes state
    * @param executor the executor in which the listeners callback methods will be run.
@@ -269,7 +270,14 @@ public void addListener(Listener listener, Executor executor) {
    *
    * @param listener the listener to run when the manager changes state
    * @since 15.0
+   * @deprecated Use {@linkplain #addListener(Listener, Executor) the overload that accepts an
+   *     executor}. For equivalent behavior, pass {@link MoreExecutors#directExecutor}. However,
+   *     consider whether another executor would be more appropriate, as discussed in the docs for
+   *     {@link ListenableFuture#addListener ListenableFuture.addListener}. This method is scheduled
+   *     for deletion in October 2020.
    */
+  @Beta // currently redundant, but ensures we keep this @Beta when we gradate the class!
+  @Deprecated
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());
   }, @@ -245,8 +245,9 @@ public ServiceManager(Iterable<? extends Service> services) {
    * during {@code Executor.execute} (e.g., a {@code RejectedExecutionException}) will be caught and
    * logged.
    *
-   * <p>For fast, lightweight listeners that would be safe to execute in any thread, consider
-   * calling {@link #addListener(Listener)}.
+   * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
+   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
+   * documentation.
    *
    * @param listener the listener to run when the manager changes state
    * @param executor the executor in which the listeners callback methods will be run.
@@ -271,7 +272,14 @@ public void addListener(Listener listener, Executor executor) {
    *
    * @param listener the listener to run when the manager changes state
    * @since 15.0
+   * @deprecated Use {@linkplain #addListener(Listener, Executor) the overload that accepts an
+   *     executor}. For equivalent behavior, pass {@link MoreExecutors#directExecutor}. However,
+   *     consider whether another executor would be more appropriate, as discussed in the docs for
+   *     {@link ListenableFuture#addListener ListenableFuture.addListener}. This method is scheduled
+   *     for deletion in October 2020.
    */
+  @Beta // currently redundant, but ensures we keep this @Beta when we gradate the class!
+  @Deprecated
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Deprecate 1-arg overload of ServiceManager.addListener.

It default to directExecutor(). directExecutor() is often useful, but it should be an explicit choice, as some usages are dangerous:
https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/util/concurrent/ListenableFuture.html#addListener-java.lang.Runnable-java.util.concurrent.Executor-

https://github.com/google/guava/issues/3418

RELNOTES=`util.concurrent`: Deprecated the 1-arg overload of `ServiceManager.addListener`.

200056a4525bf28f1d252505f1564fdf26322ccb",MOE Sync 2020-03-30
3837,Nick,"['android/guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'guava-gwt/test/com/google/common/util/concurrent/FuturesTest_gwt.java', 'guava-tests/test/com/google/common/util/concurrent/FuturesTest.java', 'guava/src/com/google/common/util/concurrent/Futures.java']","@@ -31,6 +31,7 @@
 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
+import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
 import static com.google.common.util.concurrent.Futures.inCompletionOrder;
 import static com.google.common.util.concurrent.Futures.lazyTransform;
 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
@@ -138,6 +139,14 @@ public void testImmediateFuture() throws Exception {
     assertThat(future.toString()).contains(""[status=SUCCESS, result=["" + DATA1 + ""]]"");
   }
 
+  public void testImmediateVoidFuture() throws Exception {
+    ListenableFuture<Void> voidFuture = immediateVoidFuture();
+
+    assertThat(getDone(voidFuture)).isNull();
+    assertThat(getDoneFromTimeoutOverload(voidFuture)).isNull();
+    assertThat(voidFuture.toString()).contains(""[status=SUCCESS, result=[null]]"");
+  }
+
   public void testImmediateFailedFuture() throws Exception {
     Exception exception = new Exception();
     ListenableFuture<String> future = immediateFailedFuture(exception);, @@ -135,6 +135,17 @@ private Futures() {}
     return new ImmediateFuture<>(value);
   }
 
+  /**
+   * Returns a successful {@code ListenableFuture<Void>}. This method is equivalent to {@code
+   * immediateFuture(null)} except that it is restricted to produce futures of type {@code Void}.
+   *
+   * @since NEXT
+   */
+  @SuppressWarnings(""unchecked"")
+  public static ListenableFuture<Void> immediateVoidFuture() {
+    return (ListenableFuture<Void>) ImmediateFuture.NULL;
+  }
+
   /**
    * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.
    *, @@ -1746,6 +1746,33 @@ public void testImmediateFuture() throws Exception {
   }
 }
 
+public void testImmediateVoidFuture() throws Exception {
+  com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
+  testCase.setUp();
+  Throwable failure = null;
+  try {
+    testCase.testImmediateVoidFuture();
+  } catch (Throwable t) {
+    failure = t;
+  }
+  try {
+    testCase.tearDown();
+  } catch (Throwable t) {
+    if (failure == null) {
+      failure = t;
+    }
+  }
+  if (failure instanceof Exception) {
+    throw (Exception) failure;
+  }
+  if (failure instanceof Error) {
+    throw (Error) failure;
+  }
+  if (failure != null) {
+    throw new RuntimeException(failure);
+  }
+}
+
 public void testNonCancellationPropagating_delegateCancelled() throws Exception {
   com.google.common.util.concurrent.FuturesTest testCase = new com.google.common.util.concurrent.FuturesTest();
   testCase.setUp();, @@ -31,6 +31,7 @@
 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
+import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
 import static com.google.common.util.concurrent.Futures.inCompletionOrder;
 import static com.google.common.util.concurrent.Futures.lazyTransform;
 import static com.google.common.util.concurrent.Futures.nonCancellationPropagating;
@@ -138,6 +139,14 @@ public void testImmediateFuture() throws Exception {
     assertThat(future.toString()).contains(""[status=SUCCESS, result=["" + DATA1 + ""]]"");
   }
 
+  public void testImmediateVoidFuture() throws Exception {
+    ListenableFuture<Void> voidFuture = immediateVoidFuture();
+
+    assertThat(getDone(voidFuture)).isNull();
+    assertThat(getDoneFromTimeoutOverload(voidFuture)).isNull();
+    assertThat(voidFuture.toString()).contains(""[status=SUCCESS, result=[null]]"");
+  }
+
   public void testImmediateFailedFuture() throws Exception {
     Exception exception = new Exception();
     ListenableFuture<String> future = immediateFailedFuture(exception);, @@ -137,6 +137,17 @@ private Futures() {}
     return new ImmediateFuture<>(value);
   }
 
+  /**
+   * Returns a successful {@code ListenableFuture<Void>}. This method is equivalent to {@code
+   * immediateFuture(null)} except that it is restricted to produce futures of type {@code Void}.
+   *
+   * @since NEXT
+   */
+  @SuppressWarnings(""unchecked"")
+  public static ListenableFuture<Void> immediateVoidFuture() {
+    return (ListenableFuture<Void>) ImmediateFuture.NULL;
+  }
+
   /**
    * Returns a {@code ListenableFuture} which has an exception set immediately upon construction.
    *, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add immediateVoidFuture() to Futures.java to create an immediately succeeding ListenableFuture<Void>.

RELNOTES=`util.concurrent`: Added `immediateVoidFuture`.

e90c8bbe566429fc46a33f88930c6379e57a8094",MOE Sync 2020-03-30
3839,Nick,"['android/guava-tests/test/com/google/common/collect/ImmutableSortedSetTest.java', 'android/guava/src/com/google/common/collect/ImmutableSortedSet.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java', 'guava-gwt/test/com/google/common/collect/ImmutableSortedSetTest_gwt.java', 'guava-tests/test/com/google/common/collect/ImmutableSortedSetTest.java', 'guava/src/com/google/common/collect/ImmutableSortedSet.java']","@@ -1005,6 +1005,44 @@ public void testTailSetExclusive() {
     }
   }
 
+  public void testFloor_emptySet() {
+    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(new String[] {});
+    assertThat(set.floor(""f"")).isNull();
+  }
+
+  public void testFloor_elementPresent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""a"", ""e"", ""f"", ""b"", ""i"", ""d"", ""a"", ""c"", ""k""});
+    assertThat(set.floor(""f"")).isEqualTo(""f"");
+    assertThat(set.floor(""j"")).isEqualTo(""i"");
+    assertThat(set.floor(""q"")).isEqualTo(""k"");
+  }
+
+  public void testFloor_elementAbsent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""e"", ""f"", ""b"", ""i"", ""d"", ""c"", ""k""});
+    assertThat(set.floor(""a"")).isNull();
+  }
+
+  public void testCeiling_emptySet() {
+    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(new String[] {});
+    assertThat(set.ceiling(""f"")).isNull();
+  }
+
+  public void testCeiling_elementPresent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""e"", ""f"", ""f"", ""i"", ""d"", ""c"", ""k"", ""p"", ""c""});
+    assertThat(set.ceiling(""f"")).isEqualTo(""f"");
+    assertThat(set.ceiling(""h"")).isEqualTo(""i"");
+    assertThat(set.ceiling(""a"")).isEqualTo(""c"");
+  }
+
+  public void testCeiling_elementAbsent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""a"", ""e"", ""f"", ""b"", ""i"", ""d"", ""a"", ""c"", ""k""});
+    assertThat(set.ceiling(""l"")).isNull();
+  }
+
   public void testSubSetExclusiveExclusive() {
     String[] strings = NUMBER_NAMES.toArray(new String[0]);
     ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);, @@ -618,14 +618,12 @@ public E lower(E e) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public E floor(E e) {
     return Iterators.getNext(headSet(e, true).descendingIterator(), null);
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public E ceiling(E e) {
     return Iterables.getFirst(tailSet(e, true), null);, @@ -321,6 +321,16 @@ E higher(E e) {
     return null;
   }
 
+  public E ceiling(E e) {
+    ImmutableSortedSet<E> set = tailSet(e, true);
+    return !set.isEmpty() ? set.first() : null;
+  }
+
+  public E floor(E e) {
+    ImmutableSortedSet<E> set = headSet(e, true);
+    return !set.isEmpty() ? set.last() : null;
+  }
+
   ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
     checkNotNull(toElement);
     if (inclusive) {, @@ -68,6 +68,21 @@ public void testBuilderWithNonDuplicateElements() throws Exception {
   testCase.testBuilderWithNonDuplicateElements();
 }
 
+public void testCeiling_elementAbsent() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testCeiling_elementAbsent();
+}
+
+public void testCeiling_elementPresent() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testCeiling_elementPresent();
+}
+
+public void testCeiling_emptySet() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testCeiling_emptySet();
+}
+
 public void testComplexBuilder() throws Exception {
   com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
   testCase.testComplexBuilder();
@@ -453,6 +468,21 @@ public void testExplicit_tailSet() throws Exception {
   testCase.testExplicit_tailSet();
 }
 
+public void testFloor_elementAbsent() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testFloor_elementAbsent();
+}
+
+public void testFloor_elementPresent() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testFloor_elementPresent();
+}
+
+public void testFloor_emptySet() throws Exception {
+  com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
+  testCase.testFloor_emptySet();
+}
+
 public void testHeadSetExclusive() throws Exception {
   com.google.common.collect.ImmutableSortedSetTest testCase = new com.google.common.collect.ImmutableSortedSetTest();
   testCase.testHeadSetExclusive();, @@ -1081,6 +1081,44 @@ public void testTailSetExclusive() {
     }
   }
 
+  public void testFloor_emptySet() {
+    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(new String[] {});
+    assertThat(set.floor(""f"")).isNull();
+  }
+
+  public void testFloor_elementPresent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""a"", ""e"", ""f"", ""b"", ""i"", ""d"", ""a"", ""c"", ""k""});
+    assertThat(set.floor(""f"")).isEqualTo(""f"");
+    assertThat(set.floor(""j"")).isEqualTo(""i"");
+    assertThat(set.floor(""q"")).isEqualTo(""k"");
+  }
+
+  public void testFloor_elementAbsent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""e"", ""f"", ""b"", ""i"", ""d"", ""c"", ""k""});
+    assertThat(set.floor(""a"")).isNull();
+  }
+
+  public void testCeiling_emptySet() {
+    ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(new String[] {});
+    assertThat(set.ceiling(""f"")).isNull();
+  }
+
+  public void testCeiling_elementPresent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""e"", ""f"", ""f"", ""i"", ""d"", ""c"", ""k"", ""p"", ""c""});
+    assertThat(set.ceiling(""f"")).isEqualTo(""f"");
+    assertThat(set.ceiling(""h"")).isEqualTo(""i"");
+    assertThat(set.ceiling(""a"")).isEqualTo(""c"");
+  }
+
+  public void testCeiling_elementAbsent() {
+    ImmutableSortedSet<String> set =
+        ImmutableSortedSet.copyOf(new String[] {""e"", ""a"", ""e"", ""f"", ""b"", ""i"", ""d"", ""a"", ""c"", ""k""});
+    assertThat(set.ceiling(""l"")).isNull();
+  }
+
   public void testSubSetExclusiveExclusive() {
     String[] strings = NUMBER_NAMES.toArray(new String[0]);
     ImmutableSortedSet<String> set = ImmutableSortedSet.copyOf(strings);, @@ -693,14 +693,12 @@ public E lower(E e) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public E floor(E e) {
     return Iterators.getNext(headSet(e, true).descendingIterator(), null);
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public E ceiling(E e) {
     return Iterables.getFirst(tailSet(e, true), null);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Introducing floor(E) and ceiling(E) method in GWT emulated ImmutableSortedSet package.

RELNOTES=`com.google.common.collect.ImmutableSortedSet`: Added `ceiling` and `floor` methods for GWT emulated ImmutableSortedSet

706830ee1c7903af3d1d04478a601c2bd0a763bc",MOE Sync 2020-03-31
3840,Nick,"['android/guava/src/com/google/common/collect/ImmutableSortedSet.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java', 'guava/src/com/google/common/collect/ImmutableSortedSet.java']","@@ -543,7 +543,6 @@ static int unsafeCompare(Comparator<?> comparator, Object a, Object b) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
     return headSetImpl(checkNotNull(toElement), inclusive);
@@ -593,7 +592,6 @@ static int unsafeCompare(Comparator<?> comparator, Object a, Object b) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public ImmutableSortedSet<E> tailSet(E fromElement, boolean inclusive) {
     return tailSetImpl(checkNotNull(fromElement), inclusive);, @@ -331,7 +331,7 @@ public E floor(E e) {
     return !set.isEmpty() ? set.last() : null;
   }
 
-  ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
+  public ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
     checkNotNull(toElement);
     if (inclusive) {
       E tmp = higher(toElement);
@@ -372,7 +372,7 @@ public E last() {
     }
   }
 
-  ImmutableSortedSet<E> tailSet(E fromElement, boolean inclusive) {
+  public ImmutableSortedSet<E> tailSet(E fromElement, boolean inclusive) {
     checkNotNull(fromElement);
     if (!inclusive) {
       E tmp = higher(fromElement);, @@ -618,7 +618,6 @@ static int unsafeCompare(Comparator<?> comparator, Object a, Object b) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public ImmutableSortedSet<E> headSet(E toElement, boolean inclusive) {
     return headSetImpl(checkNotNull(toElement), inclusive);
@@ -668,7 +667,6 @@ static int unsafeCompare(Comparator<?> comparator, Object a, Object b) {
   }
 
   /** @since 12.0 */
-  @GwtIncompatible // NavigableSet
   @Override
   public ImmutableSortedSet<E> tailSet(E fromElement, boolean inclusive) {
     return tailSetImpl(checkNotNull(fromElement), inclusive);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Making headSet(E, boolean), tailSet(E, boolean) public in GWT emulated ImmutableSortedSet.

RELNOTES=`com.google.common.collect.ImmutableSortedSet`: Making `headSet(E, boolean)` and `tailSet(E, boolean)` methods public for GWT emulated ImmutableSortedSet.

e6779e404f0cd44fdc4b955acc03ad39250ffbe3",MOE Sync 2020-03-31
3841,Nick,"['android/guava-tests/test/com/google/common/collect/QueuesTest.java', 'guava-tests/test/com/google/common/collect/QueuesTest.java']","@@ -77,7 +77,7 @@ public void setUp() {
   @Override
   public void tearDown() throws InterruptedException {
     threadPool.shutdown();
-    assertTrue(""Some worker didn't finish in time"", threadPool.awaitTermination(1, SECONDS));
+    assertTrue(""Some worker didn't finish in time"", threadPool.awaitTermination(10, SECONDS));
   }
 
   private static <T> int drain(, @@ -77,7 +77,7 @@ public void setUp() {
   @Override
   public void tearDown() throws InterruptedException {
     threadPool.shutdown();
-    assertTrue(""Some worker didn't finish in time"", threadPool.awaitTermination(1, SECONDS));
+    assertTrue(""Some worker didn't finish in time"", threadPool.awaitTermination(10, SECONDS));
   }
 
   private static <T> int drain(, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make `Duration` overloads of `awaitRunning` and `awaitTerminated` `final` in all `Abstract*Service` classes.

The other overloads already are already `final`. These ones aren't only because we didn't think to do this when adding the new `default` methods.

929867a724fc2a9b4f881534dca8d1458c9ece9c

-------

<p> Extend deadline to fix flakiness.

It's possible that we don't really need to assert that the pool finishes shutting down at all. Maybe the other existing assertions are enough? But I haven't bothered to look into it.

1611de32e6a029ef713499b6e878c1af11f613ca",MOE Sync 2020-04-02
3842,Nick,"['android/guava-tests/test/com/google/common/primitives/DoublesTest.java', 'android/guava-tests/test/com/google/common/primitives/FloatsTest.java', 'android/guava-tests/test/com/google/common/primitives/IntsTest.java', 'android/guava-tests/test/com/google/common/primitives/ShortsTest.java', 'android/guava/src/com/google/common/primitives/Doubles.java', 'android/guava/src/com/google/common/primitives/DoublesMethodsForWeb.java', 'android/guava/src/com/google/common/primitives/Floats.java', 'android/guava/src/com/google/common/primitives/FloatsMethodsForWeb.java', 'android/guava/src/com/google/common/primitives/Ints.java', 'android/guava/src/com/google/common/primitives/IntsMethodsForWeb.java', 'android/guava/src/com/google/common/primitives/Shorts.java', 'android/guava/src/com/google/common/primitives/ShortsMethodsForWeb.java', 'guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/DoublesMethodsForWeb.java', 'guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/FloatsMethodsForWeb.java', 'guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/IntsMethodsForWeb.java', 'guava-gwt/src-super/com/google/common/primitives/super/com/google/common/primitives/ShortsMethodsForWeb.java', 'guava-gwt/test/com/google/common/primitives/DoublesTest_gwt.java', 'guava-gwt/test/com/google/common/primitives/FloatsTest_gwt.java', 'guava-gwt/test/com/google/common/primitives/IntsTest_gwt.java', 'guava-gwt/test/com/google/common/primitives/ShortsTest_gwt.java', 'guava-tests/test/com/google/common/primitives/DoublesTest.java', 'guava-tests/test/com/google/common/primitives/FloatsTest.java', 'guava-tests/test/com/google/common/primitives/IntsTest.java', 'guava-tests/test/com/google/common/primitives/ShortsTest.java', 'guava/src/com/google/common/primitives/Doubles.java', 'guava/src/com/google/common/primitives/DoublesMethodsForWeb.java', 'guava/src/com/google/common/primitives/Floats.java', 'guava/src/com/google/common/primitives/FloatsMethodsForWeb.java', 'guava/src/com/google/common/primitives/Ints.java', 'guava/src/com/google/common/primitives/IntsMethodsForWeb.java', 'guava/src/com/google/common/primitives/Shorts.java', 'guava/src/com/google/common/primitives/ShortsMethodsForWeb.java']","@@ -194,6 +194,7 @@ public void testLastIndexOf() {
     assertEquals(-1, Doubles.lastIndexOf(new double[] {NaN, 5.0}, NaN));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Doubles.max();
@@ -216,6 +217,7 @@ public void testMax() {
     assertTrue(Double.isNaN(Doubles.max(VALUES)));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Doubles.min();, @@ -186,6 +186,7 @@ public void testLastIndexOf() {
     assertEquals(-1, Floats.lastIndexOf(new float[] {NaN, 5f}, NaN));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Floats.max();
@@ -207,6 +208,7 @@ public void testMax() {
     assertTrue(Float.isNaN(Floats.max(VALUES)));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Floats.min();, @@ -155,6 +155,7 @@ public void testLastIndexOf() {
     assertEquals(3, Ints.lastIndexOf(new int[] {(int) 2, (int) 3, (int) 2, (int) 3}, (int) 3));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Ints.max();
@@ -169,6 +170,7 @@ public void testMax() {
     assertEquals((int) 9, Ints.max((int) 8, (int) 6, (int) 7, (int) 5, (int) 3, (int) 0, (int) 9));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Ints.min();, @@ -175,6 +175,7 @@ public void testLastIndexOf() {
         3, Shorts.lastIndexOf(new short[] {(short) 2, (short) 3, (short) 2, (short) 3}, (short) 3));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Shorts.max();
@@ -191,6 +192,7 @@ public void testMax() {
         Shorts.max((short) 8, (short) 6, (short) 7, (short) 5, (short) 3, (short) 0, (short) 9));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Shorts.min();, @@ -46,7 +46,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Doubles {
+public final class Doubles extends DoublesMethodsForWeb {
   private Doubles() {}
 
   /**
@@ -207,6 +207,8 @@ private static int lastIndexOf(double[] array, double target, int start, int end
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static double min(double... array) {
     checkArgument(array.length > 0);
     double min = array[0];
@@ -225,6 +227,8 @@ public static double min(double... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static double max(double... array) {
     checkArgument(array.length > 0);
     double max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Doubles}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class DoublesMethodsForWeb {}, @@ -46,7 +46,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Floats {
+public final class Floats extends FloatsMethodsForWeb {
   private Floats() {}
 
   /**
@@ -204,6 +204,8 @@ private static int lastIndexOf(float[] array, float target, int start, int end)
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static float min(float... array) {
     checkArgument(array.length > 0);
     float min = array[0];
@@ -222,6 +224,8 @@ public static float min(float... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static float max(float... array) {
     checkArgument(array.length > 0);
     float max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Floats}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class FloatsMethodsForWeb {}, @@ -21,6 +21,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -42,8 +43,8 @@
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible
-public final class Ints {
+@GwtCompatible(emulated = true)
+public final class Ints extends IntsMethodsForWeb {
   private Ints() {}
 
   /**
@@ -218,6 +219,8 @@ private static int lastIndexOf(int[] array, int target, int start, int end) {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static int min(int... array) {
     checkArgument(array.length > 0);
     int min = array[0];
@@ -237,6 +240,8 @@ public static int min(int... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static int max(int... array) {
     checkArgument(array.length > 0);
     int max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Ints}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class IntsMethodsForWeb {}, @@ -44,7 +44,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Shorts {
+public final class Shorts extends ShortsMethodsForWeb {
   private Shorts() {}
 
   /**
@@ -218,6 +218,8 @@ private static int lastIndexOf(short[] array, short target, int start, int end)
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static short min(short... array) {
     checkArgument(array.length > 0);
     short min = array[0];
@@ -237,6 +239,8 @@ public static short min(short... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static short max(short... array) {
     checkArgument(array.length > 0);
     short max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Shorts}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class ShortsMethodsForWeb {}, @@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import jsinterop.annotations.JsMethod;
+import jsinterop.annotations.JsPackage;
+
+/** Web specializations for {@link Doubles} methods. */
+abstract class DoublesMethodsForWeb {
+
+  @JsMethod(name = ""Math.min"", namespace = JsPackage.GLOBAL)
+  public static native double min(double... array);
+
+  @JsMethod(name = ""Math.max"", namespace = JsPackage.GLOBAL)
+  public static native double max(double... array);
+}, @@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import jsinterop.annotations.JsMethod;
+import jsinterop.annotations.JsPackage;
+
+/** Web specializations for {@link Floats} methods. */
+abstract class FloatsMethodsForWeb {
+
+  @JsMethod(name = ""Math.min"", namespace = JsPackage.GLOBAL)
+  public static native float min(float... array);
+
+  @JsMethod(name = ""Math.max"", namespace = JsPackage.GLOBAL)
+  public static native float max(float... array);
+}, @@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import jsinterop.annotations.JsMethod;
+import jsinterop.annotations.JsPackage;
+
+/** Web specializations for {@link Ints} methods. */
+abstract class IntsMethodsForWeb {
+
+  @JsMethod(name = ""Math.min"", namespace = JsPackage.GLOBAL)
+  public static native int min(int... array);
+
+  @JsMethod(name = ""Math.max"", namespace = JsPackage.GLOBAL)
+  public static native int max(int... array);
+}, @@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import jsinterop.annotations.JsMethod;
+import jsinterop.annotations.JsPackage;
+
+/** Web specializations for {@link Shorts} methods. */
+abstract class ShortsMethodsForWeb {
+
+  @JsMethod(name = ""Math.min"", namespace = JsPackage.GLOBAL)
+  public static native short min(short... array);
+
+  @JsMethod(name = ""Math.max"", namespace = JsPackage.GLOBAL)
+  public static native short max(short... array);
+}, @@ -108,21 +108,11 @@ public void testMax() throws Exception {
   testCase.testMax();
 }
 
-public void testMax_noArgs() throws Exception {
-  com.google.common.primitives.DoublesTest testCase = new com.google.common.primitives.DoublesTest();
-  testCase.testMax_noArgs();
-}
-
 public void testMin() throws Exception {
   com.google.common.primitives.DoublesTest testCase = new com.google.common.primitives.DoublesTest();
   testCase.testMin();
 }
 
-public void testMin_noArgs() throws Exception {
-  com.google.common.primitives.DoublesTest testCase = new com.google.common.primitives.DoublesTest();
-  testCase.testMin_noArgs();
-}
-
 public void testReverse() throws Exception {
   com.google.common.primitives.DoublesTest testCase = new com.google.common.primitives.DoublesTest();
   testCase.testReverse();, @@ -103,21 +103,11 @@ public void testMax() throws Exception {
   testCase.testMax();
 }
 
-public void testMax_noArgs() throws Exception {
-  com.google.common.primitives.FloatsTest testCase = new com.google.common.primitives.FloatsTest();
-  testCase.testMax_noArgs();
-}
-
 public void testMin() throws Exception {
   com.google.common.primitives.FloatsTest testCase = new com.google.common.primitives.FloatsTest();
   testCase.testMin();
 }
 
-public void testMin_noArgs() throws Exception {
-  com.google.common.primitives.FloatsTest testCase = new com.google.common.primitives.FloatsTest();
-  testCase.testMin_noArgs();
-}
-
 public void testReverse() throws Exception {
   com.google.common.primitives.FloatsTest testCase = new com.google.common.primitives.FloatsTest();
   testCase.testReverse();, @@ -128,21 +128,11 @@ public void testMax() throws Exception {
   testCase.testMax();
 }
 
-public void testMax_noArgs() throws Exception {
-  com.google.common.primitives.IntsTest testCase = new com.google.common.primitives.IntsTest();
-  testCase.testMax_noArgs();
-}
-
 public void testMin() throws Exception {
   com.google.common.primitives.IntsTest testCase = new com.google.common.primitives.IntsTest();
   testCase.testMin();
 }
 
-public void testMin_noArgs() throws Exception {
-  com.google.common.primitives.IntsTest testCase = new com.google.common.primitives.IntsTest();
-  testCase.testMin_noArgs();
-}
-
 public void testReverse() throws Exception {
   com.google.common.primitives.IntsTest testCase = new com.google.common.primitives.IntsTest();
   testCase.testReverse();, @@ -108,21 +108,11 @@ public void testMax() throws Exception {
   testCase.testMax();
 }
 
-public void testMax_noArgs() throws Exception {
-  com.google.common.primitives.ShortsTest testCase = new com.google.common.primitives.ShortsTest();
-  testCase.testMax_noArgs();
-}
-
 public void testMin() throws Exception {
   com.google.common.primitives.ShortsTest testCase = new com.google.common.primitives.ShortsTest();
   testCase.testMin();
 }
 
-public void testMin_noArgs() throws Exception {
-  com.google.common.primitives.ShortsTest testCase = new com.google.common.primitives.ShortsTest();
-  testCase.testMin_noArgs();
-}
-
 public void testReverse() throws Exception {
   com.google.common.primitives.ShortsTest testCase = new com.google.common.primitives.ShortsTest();
   testCase.testReverse();, @@ -194,6 +194,7 @@ public void testLastIndexOf() {
     assertEquals(-1, Doubles.lastIndexOf(new double[] {NaN, 5.0}, NaN));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Doubles.max();
@@ -216,6 +217,7 @@ public void testMax() {
     assertTrue(Double.isNaN(Doubles.max(VALUES)));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Doubles.min();, @@ -186,6 +186,7 @@ public void testLastIndexOf() {
     assertEquals(-1, Floats.lastIndexOf(new float[] {NaN, 5f}, NaN));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Floats.max();
@@ -207,6 +208,7 @@ public void testMax() {
     assertTrue(Float.isNaN(Floats.max(VALUES)));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Floats.min();, @@ -155,6 +155,7 @@ public void testLastIndexOf() {
     assertEquals(3, Ints.lastIndexOf(new int[] {(int) 2, (int) 3, (int) 2, (int) 3}, (int) 3));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Ints.max();
@@ -169,6 +170,7 @@ public void testMax() {
     assertEquals((int) 9, Ints.max((int) 8, (int) 6, (int) 7, (int) 5, (int) 3, (int) 0, (int) 9));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Ints.min();, @@ -175,6 +175,7 @@ public void testLastIndexOf() {
         3, Shorts.lastIndexOf(new short[] {(short) 2, (short) 3, (short) 2, (short) 3}, (short) 3));
   }
 
+  @GwtIncompatible
   public void testMax_noArgs() {
     try {
       Shorts.max();
@@ -191,6 +192,7 @@ public void testMax() {
         Shorts.max((short) 8, (short) 6, (short) 7, (short) 5, (short) 3, (short) 0, (short) 9));
   }
 
+  @GwtIncompatible
   public void testMin_noArgs() {
     try {
       Shorts.min();, @@ -48,7 +48,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Doubles {
+public final class Doubles extends DoublesMethodsForWeb {
   private Doubles() {}
 
   /**
@@ -209,6 +209,8 @@ private static int lastIndexOf(double[] array, double target, int start, int end
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static double min(double... array) {
     checkArgument(array.length > 0);
     double min = array[0];
@@ -227,6 +229,8 @@ public static double min(double... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static double max(double... array) {
     checkArgument(array.length > 0);
     double max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Doubles}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class DoublesMethodsForWeb {}, @@ -46,7 +46,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Floats {
+public final class Floats extends FloatsMethodsForWeb {
   private Floats() {}
 
   /**
@@ -204,6 +204,8 @@ private static int lastIndexOf(float[] array, float target, int start, int end)
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static float min(float... array) {
     checkArgument(array.length > 0);
     float min = array[0];
@@ -222,6 +224,8 @@ public static float min(float... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static float max(float... array) {
     checkArgument(array.length > 0);
     float max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Floats}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class FloatsMethodsForWeb {}, @@ -21,6 +21,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Converter;
 import java.io.Serializable;
 import java.util.AbstractList;
@@ -44,8 +45,8 @@
  * @author Kevin Bourrillion
  * @since 1.0
  */
-@GwtCompatible
-public final class Ints {
+@GwtCompatible(emulated = true)
+public final class Ints extends IntsMethodsForWeb {
   private Ints() {}
 
   /**
@@ -220,6 +221,8 @@ private static int lastIndexOf(int[] array, int target, int start, int end) {
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static int min(int... array) {
     checkArgument(array.length > 0);
     int min = array[0];
@@ -239,6 +242,8 @@ public static int min(int... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static int max(int... array) {
     checkArgument(array.length > 0);
     int max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Ints}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class IntsMethodsForWeb {}, @@ -44,7 +44,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-public final class Shorts {
+public final class Shorts extends ShortsMethodsForWeb {
   private Shorts() {}
 
   /**
@@ -218,6 +218,8 @@ private static int lastIndexOf(short[] array, short target, int start, int end)
    *     the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static short min(short... array) {
     checkArgument(array.length > 0);
     short min = array[0];
@@ -237,6 +239,8 @@ public static short min(short... array) {
    *     in the array
    * @throws IllegalArgumentException if {@code array} is empty
    */
+  @GwtIncompatible(
+      ""Available in GWT! Annotation is to avoid conflict with GWT specialization of base class."")
   public static short max(short... array) {
     checkArgument(array.length > 0);
     short max = array[0];, @@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.primitives;
+
+import com.google.common.annotations.GwtCompatible;
+
+/**
+ * Holder for web specializations of methods of {@code Shorts}. Intended to be empty for regular
+ * version.
+ */
+@GwtCompatible(emulated = true)
+abstract class ShortsMethodsForWeb {}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add j2cl specializers for Doubles.min/max, Floats.min/max, Ints.min/max, and Shorts.min/max.

79c378445bb29e204853b80645e6fb0f949c289c",MOE Sync 2020-04-02
3846,Nick,"['android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'android/guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/ServiceManagerBridge.java']","@@ -39,7 +39,6 @@
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
@@ -121,7 +120,7 @@
  */
 @Beta
 @GwtIncompatible
-public final class ServiceManager {
+public final class ServiceManager implements ServiceManagerBridge {
   private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());
   private static final ListenerCallQueue.Event<Listener> HEALTHY_EVENT =
       new ListenerCallQueue.Event<Listener>() {
@@ -396,8 +395,11 @@ public boolean isHealthy() {
    *
    * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will
    * correspond to a point in time view of the services.
+   *
+   * @since NEXT (present with return type {@code ImmutableMultimap} since 14.0)
    */
-  public ImmutableMultimap<State, Service> servicesByState() {
+  @Override
+  public ImmutableSetMultimap<State, Service> servicesByState() {
     return state.servicesByState();
   }
 
@@ -601,7 +603,7 @@ void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {
       }
     }
 
-    ImmutableMultimap<State, Service> servicesByState() {
+    ImmutableSetMultimap<State, Service> servicesByState() {
       ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();
       monitor.enter();
       try {, @@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.util.concurrent.Service.State;
+
+/**
+ * Superinterface of {@link ServiceManager} to introduce a bridge method for {@code
+ * servicesByState()}, to ensure binary compatibility with older Guava versions that specified
+ * {@code servicesByState()} to return {@code ImmutableMultimap}.
+ */
+@GwtIncompatible
+interface ServiceManagerBridge {
+  ImmutableMultimap<State, Service> servicesByState();
+}, @@ -40,7 +40,6 @@
 import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
@@ -123,7 +122,7 @@
  */
 @Beta
 @GwtIncompatible
-public final class ServiceManager {
+public final class ServiceManager implements ServiceManagerBridge {
   private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());
   private static final ListenerCallQueue.Event<Listener> HEALTHY_EVENT =
       new ListenerCallQueue.Event<Listener>() {
@@ -426,8 +425,11 @@ public boolean isHealthy() {
    *
    * <p>N.B. This snapshot is guaranteed to be consistent, i.e. the set of states returned will
    * correspond to a point in time view of the services.
+   *
+   * @since NEXT (present with return type {@code ImmutableMultimap} since 14.0)
    */
-  public ImmutableMultimap<State, Service> servicesByState() {
+  @Override
+  public ImmutableSetMultimap<State, Service> servicesByState() {
     return state.servicesByState();
   }
 
@@ -631,7 +633,7 @@ void awaitStopped(long timeout, TimeUnit unit) throws TimeoutException {
       }
     }
 
-    ImmutableMultimap<State, Service> servicesByState() {
+    ImmutableSetMultimap<State, Service> servicesByState() {
       ImmutableSetMultimap.Builder<State, Service> builder = ImmutableSetMultimap.builder();
       monitor.enter();
       try {, @@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.collect.ImmutableMultimap;
+import com.google.common.util.concurrent.Service.State;
+
+/**
+ * Superinterface of {@link ServiceManager} to introduce a bridge method for {@code
+ * servicesByState()}, to ensure binary compatibility with older Guava versions that specified
+ * {@code servicesByState()} to return {@code ImmutableMultimap}.
+ */
+@GwtIncompatible
+interface ServiceManagerBridge {
+  ImmutableMultimap<State, Service> servicesByState();
+}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Change return type of ServiceManager.servicesByState() to ImmutableSetMultimap.

But also generate a bridge method with the old signature for binary compatibility.

https://github.com/google/guava/issues/3418 (which I keep forgetting to mention from commits...)

[]

RELNOTES=`util.concurrent`: Changed the return type of `ServiceManager.servicesByState()` to `ImmutableSetMultimap` (but also retained a method with the old signature for binary compatibility).

c467744698d85d56349fbc773cb75fae747a9a4c",MOE Sync 2020-04-03
3852,Nick,"['android/guava/src/com/google/common/hash/Murmur3_128HashFunction.java', 'android/guava/src/com/google/common/hash/SipHashFunction.java', 'guava/src/com/google/common/hash/Murmur3_128HashFunction.java', 'guava/src/com/google/common/hash/SipHashFunction.java']","@@ -166,7 +166,7 @@ protected void processRemaining(ByteBuffer bb) {
     }
 
     @Override
-    public HashCode makeHash() {
+    protected HashCode makeHash() {
       h1 ^= length;
       h2 ^= length;
 , @@ -143,7 +143,7 @@ protected void processRemaining(ByteBuffer buffer) {
     }
 
     @Override
-    public HashCode makeHash() {
+    protected HashCode makeHash() {
       // End with a byte encoding the positive integer b mod 256.
       finalM ^= b << 56;
       processM(finalM);, @@ -166,7 +166,7 @@ protected void processRemaining(ByteBuffer bb) {
     }
 
     @Override
-    public HashCode makeHash() {
+    protected HashCode makeHash() {
       h1 ^= length;
       h2 ^= length;
 , @@ -143,7 +143,7 @@ protected void processRemaining(ByteBuffer buffer) {
     }
 
     @Override
-    public HashCode makeHash() {
+    protected HashCode makeHash() {
       // End with a byte encoding the positive integer b mod 256.
       finalM ^= b << 56;
       processM(finalM);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Merge StandardSimpleDirectedSortedNetworkTest into StandardMutableDirectedNetworkTest.

1f1a0a2fd37345ee966049e54091cb2f66f4c1c3

-------

<p> Move tests from Multinetwork-test classes to base classes in preparation for merging the Multinetwork-classes with the mutable classes.

8563c8706b499acd7f1e16c6cf42904f032aa5d1

-------

<p> Merge StandardDirectedMultiNetworkTest into StandardMutableDirectedNetworkTest.

d50fcf89b5148f12e4d0713e3deab0a75ac47c1a

-------

<p> Merge StandardUndirectedMultiNetworkTest into StandardMutableUndirectedNetworkTest

bbce918101323bbaf2e8f063a1ceca4769d74996

-------

<p> Add StandardImmutableDirectedNetworkTest.

879cec90e07092bf63d748dbac028f2d2b28a9bc

-------

<p> Fix unnecessary method access level escalation.

Fixes https://github.com/google/guava/pull/3843

8ae733081feff0801bb1fb71e5bd39f713e19595",MOE Sync 2020-04-09
3854,Chris Povirk,['.travis.yml'],"@@ -10,7 +10,6 @@ addons:
   apt:
     packages:
       - openjdk-8-source
-      - openjdk-11-source
 
 install: mvn -B -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn install -U -DskipTests=true -f $ROOT_POM
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Try yet again to inherit docs from the JDK when building Javadoc for snapshots.

I am optimistic: See https://github.com/google/guava/issues/3669#issuecomment-611658339

c76c0af95f7c115ec9d87c7961d0292d2ff9d736

-------

<p> Use @code instead of @link to allow imports to be stripped

fd4ed9d63a985f16ee5eae9e3e64dae000f4d793

-------

<p> Don't request openjdk-11-source.

We don't need it yet, since we build Javadoc snapshots with OpenJDK 8.
Maybe we'll need it someday, but currently it doesn't exist :)

https://travis-ci.org/github/google/guava/jobs/673105448
E: Unable to locate package openjdk-11-source

Followup to CL 305716744.

6e89adb89e313f5dba7b2c2c88056fdaf0e5c434",MOE Sync 2020-04-09
3856,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java', 'android/guava/src/com/google/common/util/concurrent/AbstractIdleService.java', 'android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'android/guava/src/com/google/common/util/concurrent/AbstractService.java', 'android/guava/src/com/google/common/util/concurrent/Service.java', 'android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/AbstractExecutionThreadService.java', 'guava/src/com/google/common/util/concurrent/AbstractIdleService.java', 'guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'guava/src/com/google/common/util/concurrent/AbstractService.java', 'guava/src/com/google/common/util/concurrent/Service.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java']","@@ -32,7 +32,6 @@
  * @author Jesse Wilson
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractExecutionThreadService implements Service {
   private static final Logger logger =
@@ -140,7 +139,14 @@ protected void shutDown() throws Exception {}
    * Invoked to request the service to stop.
    *
    * <p>By default this method does nothing.
+   *
+   * <p>Currently, this method is invoked while holding a lock. If an implementation of this method
+   * blocks, it can prevent this service from changing state. If you need to performing a blocking
+   * operation in order to trigger shutdown, consider instead registering a listener and
+   * implementing {@code stopping}. Note, however, that {@code stopping} does not run at exactly the
+   * same times as {@code triggerShutdown}.
    */
+  @Beta
   protected void triggerShutdown() {}
 
   /**, @@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -31,7 +30,6 @@
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractIdleService implements Service {
 , @@ -18,7 +18,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
-import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -94,7 +93,6 @@
  * @author Luke Sandberg
  * @since 11.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractScheduledService implements Service {
   private static final Logger logger = Logger.getLogger(AbstractScheduledService.class.getName());
@@ -440,7 +438,6 @@ public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutExc
    * @author Luke Sandberg
    * @since 11.0
    */
-  @Beta
   public abstract static class CustomScheduler extends Scheduler {
 
     /** A callable class that can reschedule itself using a {@link CustomScheduler}. */
@@ -567,7 +564,6 @@ public boolean isCancelled() {
      * @author Luke Sandberg
      * @since 11.0
      */
-    @Beta
     protected static final class Schedule {
 
       private final long delay;, @@ -47,7 +47,6 @@
  * @author Luke Sandberg
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractService implements Service {
   private static final ListenerCallQueue.Event<Listener> STARTING_EVENT =
@@ -235,6 +234,7 @@ protected AbstractService() {}
    *
    * @since 27.0
    */
+  @Beta
   @ForOverride
   protected void doCancelStart() {}
 , @@ -14,10 +14,9 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.DoNotMock;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -52,7 +51,6 @@
  * @author Luke Sandberg
  * @since 9.0 (in 1.0 as {@code com.google.common.base.Service})
  */
-@Beta
 @DoNotMock(""Create an AbstractIdleService"")
 @GwtIncompatible
 public interface Service {
@@ -175,7 +173,6 @@
    *
    * @since 9.0 (in 1.0 as {@code com.google.common.base.Service.State})
    */
-  @Beta // should come out of Beta when Service does
   enum State {
     /** A service in this state is inactive. It does minimal work and consumes minimal resources. */
     NEW {
@@ -243,7 +240,6 @@ boolean isTerminal() {
    * @author Luke Sandberg
    * @since 15.0 (present as an interface in 13.0)
    */
-  @Beta // should come out of Beta when Service does
   abstract class Listener {
     /**
      * Called when the service transitions from {@linkplain State#NEW NEW} to {@linkplain, @@ -118,7 +118,6 @@
  * @author Luke Sandberg
  * @since 14.0
  */
-@Beta
 @GwtIncompatible
 public final class ServiceManager implements ServiceManagerBridge {
   private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());
@@ -156,7 +155,6 @@ public String toString() {
    * @author Luke Sandberg
    * @since 15.0 (present as an interface in 14.0)
    */
-  @Beta // Should come out of Beta when ServiceManager does
   public abstract static class Listener {
     /**
      * Called when the service initially becomes healthy.
@@ -275,7 +273,7 @@ public void addListener(Listener listener, Executor executor) {
    *     {@link ListenableFuture#addListener ListenableFuture.addListener}. This method is scheduled
    *     for deletion in October 2020.
    */
-  @Beta // currently redundant, but ensures we keep this @Beta when we gradate the class!
+  @Beta
   @Deprecated
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());, @@ -33,7 +33,6 @@
  * @author Jesse Wilson
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractExecutionThreadService implements Service {
   private static final Logger logger =
@@ -141,7 +140,14 @@ protected void shutDown() throws Exception {}
    * Invoked to request the service to stop.
    *
    * <p>By default this method does nothing.
+   *
+   * <p>Currently, this method is invoked while holding a lock. If an implementation of this method
+   * blocks, it can prevent this service from changing state. If you need to performing a blocking
+   * operation in order to trigger shutdown, consider instead registering a listener and
+   * implementing {@code stopping}. Note, however, that {@code stopping} does not run at exactly the
+   * same times as {@code triggerShutdown}.
    */
+  @Beta
   protected void triggerShutdown() {}
 
   /**, @@ -14,7 +14,6 @@
 
 package com.google.common.util.concurrent;
 
-import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -32,7 +31,6 @@
  * @author Chris Nokleberg
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractIdleService implements Service {
 , @@ -19,7 +19,6 @@
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
-import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Supplier;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -96,7 +95,6 @@
  * @author Luke Sandberg
  * @since 11.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractScheduledService implements Service {
   private static final Logger logger = Logger.getLogger(AbstractScheduledService.class.getName());
@@ -481,7 +479,6 @@ public final void awaitTerminated(long timeout, TimeUnit unit) throws TimeoutExc
    * @author Luke Sandberg
    * @since 11.0
    */
-  @Beta
   public abstract static class CustomScheduler extends Scheduler {
 
     /** A callable class that can reschedule itself using a {@link CustomScheduler}. */
@@ -607,7 +604,6 @@ public boolean isCancelled() {
      * @author Luke Sandberg
      * @since 11.0
      */
-    @Beta
     protected static final class Schedule {
 
       private final long delay;, @@ -48,7 +48,6 @@
  * @author Luke Sandberg
  * @since 1.0
  */
-@Beta
 @GwtIncompatible
 public abstract class AbstractService implements Service {
   private static final ListenerCallQueue.Event<Listener> STARTING_EVENT =
@@ -236,6 +235,7 @@ protected AbstractService() {}
    *
    * @since 27.0
    */
+  @Beta
   @ForOverride
   protected void doCancelStart() {}
 , @@ -16,10 +16,9 @@
 
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 
-import com.google.common.annotations.Beta;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.DoNotMock;
 import java.time.Duration;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -55,7 +54,6 @@
  * @author Luke Sandberg
  * @since 9.0 (in 1.0 as {@code com.google.common.base.Service})
  */
-@Beta
 @DoNotMock(""Create an AbstractIdleService"")
 @GwtIncompatible
 public interface Service {
@@ -206,7 +204,6 @@ default void awaitTerminated(Duration timeout) throws TimeoutException {
    *
    * @since 9.0 (in 1.0 as {@code com.google.common.base.Service.State})
    */
-  @Beta // should come out of Beta when Service does
   enum State {
     /** A service in this state is inactive. It does minimal work and consumes minimal resources. */
     NEW {
@@ -274,7 +271,6 @@ boolean isTerminal() {
    * @author Luke Sandberg
    * @since 15.0 (present as an interface in 13.0)
    */
-  @Beta // should come out of Beta when Service does
   abstract class Listener {
     /**
      * Called when the service transitions from {@linkplain State#NEW NEW} to {@linkplain, @@ -120,7 +120,6 @@
  * @author Luke Sandberg
  * @since 14.0
  */
-@Beta
 @GwtIncompatible
 public final class ServiceManager implements ServiceManagerBridge {
   private static final Logger logger = Logger.getLogger(ServiceManager.class.getName());
@@ -158,7 +157,6 @@ public String toString() {
    * @author Luke Sandberg
    * @since 15.0 (present as an interface in 14.0)
    */
-  @Beta // Should come out of Beta when ServiceManager does
   public abstract static class Listener {
     /**
      * Called when the service initially becomes healthy.
@@ -277,7 +275,7 @@ public void addListener(Listener listener, Executor executor) {
    *     {@link ListenableFuture#addListener ListenableFuture.addListener}. This method is scheduled
    *     for deletion in October 2020.
    */
-  @Beta // currently redundant, but ensures we keep this @Beta when we gradate the class!
+  @Beta
   @Deprecated
   public void addListener(Listener listener) {
     state.addListener(listener, directExecutor());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove `@Beta` from `Service` and `ServiceManager`.

This leaves `AbstractListeningExecutorService` as `@Beta`.

Fixes #3806, #3418
Relevant to #2966

(I have tweaked Jesse's initial PR to leave `AbstractExecutionThreadService.triggerShutdown` and `AbstractService.doCancelStart` as `@Beta`, since we aren't sure we like the locking behavior of the former, and we've realized that `Listener.stopping` _might_ be a reasonable substitute for both.)

RELNOTES=`util.concurrent`: Removed `@Beta` from `Service` and related classes.

33574d771b099991822ed78a726df0eea4646eea",MOE Sync 2020-04-10
3863,,"['android/pom.xml', 'pom.xml']","@@ -70,6 +70,7 @@
         <directory>src</directory>
         <excludes>
           <exclude>**/*.java</exclude>
+          <exclude>**/*.sw*</exclude>
         </excludes>
       </resource>
     </resources>, @@ -71,6 +71,7 @@
         <directory>src</directory>
         <excludes>
           <exclude>**/*.java</exclude>
+          <exclude>**/*.sw*</exclude>
         </excludes>
       </resource>
     </resources>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix typo.

edec878cd22137472cef45c4bef51bc85c47fe5f

-------

<p> Remove duplicate assumption.

37b04ee8f96d1eb55bbd261d525a1ee5bd48b90e

-------

<p> Exclude Vim swap files from the jar we build.

Fixes https://github.com/google/guava/issues/3861

9bcde055e730a60b5bb94594e3ee953f176b8bd4",MOE Sync 2020-04-15
3869,David P. Baker,['refactorings/TraverserRewrite.java'],"@@ -24,6 +24,7 @@
  * Refaster rules to rewrite usages of {@code com.google.common.collect.TreeTraverser} in terms of
  * {@code com.google.common.graph.Traverser}.
  */
+@SuppressWarnings(""DefaultPackage"")
 public class TraverserRewrite {
   abstract class TreeTraverserPreOrder<N> {
     @Placeholder, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> This change suppresses DefaultPackage check for any java class which uses the default java package, in preparation for enabling a compiler error that will prevent new instances of the bug.

The Google Java Style Guide §8.2.1 requires Java files to have a (non-default) package declaration.  Missing package declarations can cause odd problems that are difficult to debug, such as a class not being included in a test suite or confusion around package-private visibility.

RELNOTES=suppresses warning for using default package

6eec9ca96b8880cf17b9190b1148e28b3e2ca2e4",MOE Sync 2020-04-20
3872,David P. Baker,['README.md'],"@@ -19,7 +19,7 @@ Guava comes in two flavors.
 
 ## Adding Guava to your build
 
-Guava's Maven group ID is `com.google.guava` and its artifact ID is `guava`.
+Guava's Maven group ID is `com.google.guava`, and its artifact ID is `guava`.
 Guava provides two different ""flavors"": one for use on a (Java 8+) JRE and one
 for use on Android or Java 7 or by any library that wants to be compatible with
 either of those. These flavors are specified in the Maven version field as
@@ -89,8 +89,8 @@ flavor.
 
 1.  APIs marked with the `@Beta` annotation at the class or method level are
     subject to change. They can be modified in any way, or even removed, at any
-    time. If your code is a library itself (i.e. it is used on the CLASSPATH of
-    users outside your own control), you should not use beta APIs, unless you
+    time. If your code is a library itself (i.e., it is used on the CLASSPATH of
+    users outside your own control), you should not use beta APIs unless you
     [repackage] them. **If your code is a library, we strongly recommend using
     the [Guava Beta Checker] to ensure that you do not use any `@Beta` APIs!**
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update readme with some grammar corrections.

Closes #3857

c6707a7f1bbffad71b4a5f8ff7266cb41b0f9f66",MOE Sync 2020-04-22
3875,David P. Baker,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Hide InternetDomainName.region() from GWT/j2cl.

The method is not used from GWT/j2cl.

c5ee3ef6930aacb7f517f403ff4f69c16c6ae1c3

-------

<p> Update Public Suffix data.

The Guava copy is typically updated whenever Chrome's copy is updated, which
is roughly every 6 weeks. Subscribe to the Chrome Milestone Calendar to see the
dates.

2cd759cecd0b76ab124d1a32522fb43880b5358b",MOE Sync 2020-04-23
3876,David P. Baker,"['android/guava/src/com/google/common/collect/CartesianList.java', 'android/guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/CartesianList.java', 'guava/src/com/google/common/collect/Sets.java']","@@ -118,7 +118,21 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@NullableDecl Object o) {
-    return indexOf(o) != -1;
+  public boolean contains(@NullableDecl Object object) {
+    if (!(object instanceof List)) {
+      return false;
+    }
+    List<?> list = (List<?>) object;
+    if (list.size() != axes.size()) {
+      return false;
+    }
+    int i = 0;
+    for (Object o : list) {
+      if (!axes.get(i).contains(o)) {
+        return false;
+      }
+      i++;
+    }
+    return true;
   }
 }, @@ -1337,6 +1337,25 @@ private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> deleg
       return delegate;
     }
 
+    @Override
+    public boolean contains(@NullableDecl Object object) {
+      if (!(object instanceof List)) {
+        return false;
+      }
+      List<?> list = (List<?>) object;
+      if (list.size() != axes.size()) {
+        return false;
+      }
+      int i = 0;
+      for (Object o : list) {
+        if (!axes.get(i).contains(o)) {
+          return false;
+        }
+        i++;
+      }
+      return true;
+    }
+
     @Override
     public boolean equals(@NullableDecl Object object) {
       // Warning: this is broken if size() == 0, so it is critical that we, @@ -118,7 +118,21 @@ public int size() {
   }
 
   @Override
-  public boolean contains(@Nullable Object o) {
-    return indexOf(o) != -1;
+  public boolean contains(@Nullable Object object) {
+    if (!(object instanceof List)) {
+      return false;
+    }
+    List<?> list = (List<?>) object;
+    if (list.size() != axes.size()) {
+      return false;
+    }
+    int i = 0;
+    for (Object o : list) {
+      if (!axes.get(i).contains(o)) {
+        return false;
+      }
+      i++;
+    }
+    return true;
   }
 }, @@ -1428,6 +1428,25 @@ private CartesianSet(ImmutableList<ImmutableSet<E>> axes, CartesianList<E> deleg
       return delegate;
     }
 
+    @Override
+    public boolean contains(@Nullable Object object) {
+      if (!(object instanceof List)) {
+        return false;
+      }
+      List<?> list = (List<?>) object;
+      if (list.size() != axes.size()) {
+        return false;
+      }
+      int i = 0;
+      for (Object o : list) {
+        if (!axes.get(i).contains(o)) {
+          return false;
+        }
+        i++;
+      }
+      return true;
+    }
+
     @Override
     public boolean equals(@Nullable Object object) {
       // Warning: this is broken if size() == 0, so it is critical that we, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix GitHub #3873 by reimplementing Cartesian{Set,List}.contains.

RELNOTES=Fixed #3873.

27506700d2ce3a3a24840aa0ba932dba4a275663",MOE Sync 2020-04-24
3885,Chris Povirk,"['android/guava/src/com/google/common/collect/TreeRangeMap.java', 'guava/src/com/google/common/collect/TreeRangeMap.java']","@@ -120,7 +120,6 @@ public V get(K key) {
 
   @Override
   public void put(Range<K> range, V value) {
-    // don't short-circuit if the range is empty - it may be between two ranges we can coalesce.
     if (!range.isEmpty()) {
       checkNotNull(value);
       remove(range);
@@ -130,6 +129,7 @@ public void put(Range<K> range, V value) {
 
   @Override
   public void putCoalescing(Range<K> range, V value) {
+    // don't short-circuit if the range is empty - it may be between two ranges we can coalesce.
     if (entriesByLowerBound.isEmpty()) {
       put(range, value);
       return;, @@ -119,7 +119,6 @@ public boolean contains(K value) {
 
   @Override
   public void put(Range<K> range, V value) {
-    // don't short-circuit if the range is empty - it may be between two ranges we can coalesce.
     if (!range.isEmpty()) {
       checkNotNull(value);
       remove(range);
@@ -129,6 +128,7 @@ public void put(Range<K> range, V value) {
 
   @Override
   public void putCoalescing(Range<K> range, V value) {
+    // don't short-circuit if the range is empty - it may be between two ranges we can coalesce.
     if (entriesByLowerBound.isEmpty()) {
       put(range, value);
       return;, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Move comment to a more appropriate location

The comment was added along with putCoalescing in CL 143507326.

Fixes #3883

8a704a86f565065a7573a13bb95d919a6c5bcbeb",MOE Sync 2020-04-28
3887,Chris Povirk,"['android/guava-tests/test/com/google/common/collect/TreeRangeMapTest.java', 'android/guava/src/com/google/common/collect/TreeRangeMap.java', 'guava-tests/test/com/google/common/collect/TreeRangeMapTest.java', 'guava/src/com/google/common/collect/TreeRangeMap.java']","@@ -489,6 +489,20 @@ public void testPutCoalescingEmpty() {
     assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), rangeMap.asMapOfRanges());
   }
 
+  public void testPutCoalescingSubmapEmpty() {
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 1), 1);
+    rangeMap.put(Range.closedOpen(1, 2), 1);
+    assertEquals(
+        ImmutableMap.of(Range.closedOpen(0, 1), 1, Range.closedOpen(1, 2), 1),
+        rangeMap.asMapOfRanges());
+
+    RangeMap<Integer, Integer> subRangeMap = rangeMap.subRangeMap(Range.closedOpen(0, 2));
+    subRangeMap.putCoalescing(Range.closedOpen(1, 1), 1); // empty range coalesces connected ranges
+    assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), subRangeMap.asMapOfRanges());
+    assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), rangeMap.asMapOfRanges());
+  }
+
   public void testPutCoalescingComplex() {
     // {[0..1): 1, [1..3): 1, [3..5): 1, [7..10): 2, [12..15): 2, [18..19): 3}
     RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();, @@ -431,7 +431,7 @@ public void put(Range<K> range, V value) {
 
     @Override
     public void putCoalescing(Range<K> range, V value) {
-      if (entriesByLowerBound.isEmpty() || range.isEmpty() || !subRange.encloses(range)) {
+      if (entriesByLowerBound.isEmpty() || !subRange.encloses(range)) {
         put(range, value);
         return;
       }, @@ -490,6 +490,20 @@ public void testPutCoalescingEmpty() {
     assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), rangeMap.asMapOfRanges());
   }
 
+  public void testPutCoalescingSubmapEmpty() {
+    RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();
+    rangeMap.put(Range.closedOpen(0, 1), 1);
+    rangeMap.put(Range.closedOpen(1, 2), 1);
+    assertEquals(
+        ImmutableMap.of(Range.closedOpen(0, 1), 1, Range.closedOpen(1, 2), 1),
+        rangeMap.asMapOfRanges());
+
+    RangeMap<Integer, Integer> subRangeMap = rangeMap.subRangeMap(Range.closedOpen(0, 2));
+    subRangeMap.putCoalescing(Range.closedOpen(1, 1), 1); // empty range coalesces connected ranges
+    assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), subRangeMap.asMapOfRanges());
+    assertEquals(ImmutableMap.of(Range.closedOpen(0, 2), 1), rangeMap.asMapOfRanges());
+  }
+
   public void testPutCoalescingComplex() {
     // {[0..1): 1, [1..3): 1, [3..5): 1, [7..10): 2, [12..15): 2, [18..19): 3}
     RangeMap<Integer, Integer> rangeMap = TreeRangeMap.create();, @@ -508,7 +508,7 @@ public void put(Range<K> range, V value) {
 
     @Override
     public void putCoalescing(Range<K> range, V value) {
-      if (entriesByLowerBound.isEmpty() || range.isEmpty() || !subRange.encloses(range)) {
+      if (entriesByLowerBound.isEmpty() || !subRange.encloses(range)) {
         put(range, value);
         return;
       }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fixed TreeRangeMap.SubRangeMap.putCoalescing

The short circuiting on an attempt to put an empty range caused the contract of putCoalescing to be violated.

Fixes #3886

6e0e978abc6d3de458ed7e2b9cb0533c735d36a2",MOE Sync 2020-04-28
3892,Nick,"['android/guava-tests/test/com/google/common/collect/SetsTest.java', 'android/guava/src/com/google/common/collect/Sets.java', 'guava-gwt/test/com/google/common/collect/SetsTest_gwt.java', 'guava-tests/test/com/google/common/collect/SetsTest.java', 'guava/src/com/google/common/collect/Sets.java']","@@ -949,6 +949,13 @@ public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet() {
     }
   }
 
+  public void testPowerSetEquals_independentOfOrder() {
+    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3, 4);
+    Set<Set<Integer>> forward = powerSet(elements);
+    Set<Set<Integer>> reverse = powerSet(ImmutableSet.copyOf(elements.asList().reverse()));
+    new EqualsTester().addEqualityGroup(forward, reverse).testEquals();
+  }
+
   /**
    * Test that a hash code miscomputed by ""input.hashCode() * tooFarValue / 2"" is correct under our
    * {@code hashCode} implementation., @@ -1505,7 +1505,7 @@ public boolean contains(@NullableDecl Object obj) {
     public boolean equals(@NullableDecl Object obj) {
       if (obj instanceof PowerSet) {
         PowerSet<?> that = (PowerSet<?>) obj;
-        return inputSet.equals(that.inputSet);
+        return inputSet.keySet().equals(that.inputSet.keySet());
       }
       return super.equals(obj);
     }, @@ -303,6 +303,11 @@ public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet() throws Exceptio
   testCase.testPowerSetEqualsAndHashCode_verifyAgainstHashSet();
 }
 
+public void testPowerSetEquals_independentOfOrder() throws Exception {
+  com.google.common.collect.SetsTest testCase = new com.google.common.collect.SetsTest();
+  testCase.testPowerSetEquals_independentOfOrder();
+}
+
 public void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero() throws Exception {
   com.google.common.collect.SetsTest testCase = new com.google.common.collect.SetsTest();
   testCase.testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero();, @@ -961,6 +961,13 @@ public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet() {
     }
   }
 
+  public void testPowerSetEquals_independentOfOrder() {
+    ImmutableSet<Integer> elements = ImmutableSet.of(1, 2, 3, 4);
+    Set<Set<Integer>> forward = powerSet(elements);
+    Set<Set<Integer>> reverse = powerSet(ImmutableSet.copyOf(elements.asList().reverse()));
+    new EqualsTester().addEqualityGroup(forward, reverse).testEquals();
+  }
+
   /**
    * Test that a hash code miscomputed by ""input.hashCode() * tooFarValue / 2"" is correct under our
    * {@code hashCode} implementation., @@ -1596,7 +1596,7 @@ public boolean contains(@Nullable Object obj) {
     public boolean equals(@Nullable Object obj) {
       if (obj instanceof PowerSet) {
         PowerSet<?> that = (PowerSet<?>) obj;
-        return inputSet.equals(that.inputSet);
+        return inputSet.keySet().equals(that.inputSet.keySet());
       }
       return super.equals(obj);
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix PowerSet.equals() when comparing to another PowerSet whose items are the same, but in a different iteration order.

RELNOTES:
  Fix issue where PowerSet.equals(PowerSet) would erroneously return
  false if the PowerSet's underlying Sets were equal, but in a different
  iteration order.

Fixes #3891, #3890

befd5ced9edc93a65c75201eb0698a571398005f",MOE Sync 2020-05-04
3893,Nick,"['android/guava-tests/test/com/google/common/util/concurrent/UninterruptiblesTest.java', 'android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java', 'guava-tests/test/com/google/common/util/concurrent/UninterruptiblesTest.java', 'guava/src/com/google/common/util/concurrent/Uninterruptibles.java']","@@ -22,13 +22,16 @@
 import static com.google.common.util.concurrent.Uninterruptibles.putUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.takeUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryAcquireUninterruptibly;
+import static com.google.common.util.concurrent.Uninterruptibles.tryLockUninterruptibly;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Stopwatch;
 import com.google.common.testing.NullPointerTester;
 import com.google.common.testing.TearDown;
 import com.google.common.testing.TearDownStack;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Date;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
@@ -141,6 +144,63 @@ public void testConditionAwaitInterruptedTimeoutNotExceeded() {
     assertInterrupted();
   }
 
+  // Lock.tryLock() tests
+  public void testTryLockTimeoutExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    Thread lockThread = acquireFor(lock, 5, SECONDS);
+
+    boolean lockAcquired = tryLockUninterruptibly(lock, 500, MILLISECONDS);
+
+    assertFalse(lockAcquired);
+    assertAtLeastTimePassed(stopwatch, 500);
+    assertNotInterrupted();
+
+    // finish locking thread
+    lockThread.interrupt();
+  }
+
+  public void testTryLockTimeoutNotExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    acquireFor(lock, 500, MILLISECONDS);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1500, MILLISECONDS);
+
+    assertTrue(signaledBeforeTimeout);
+    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
+    assertNotInterrupted();
+  }
+
+  public void testTryLockInterruptedTimeoutExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    Thread lockThread = acquireFor(lock, 5, SECONDS);
+    requestInterruptIn(500);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1000, MILLISECONDS);
+
+    assertFalse(signaledBeforeTimeout);
+    assertAtLeastTimePassed(stopwatch, 1000);
+    assertInterrupted();
+
+    // finish locking thread
+    lockThread.interrupt();
+  }
+
+  public void testTryLockInterruptedTimeoutNotExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    acquireFor(lock, 1000, MILLISECONDS);
+    requestInterruptIn(500);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1500, MILLISECONDS);
+
+    assertTrue(signaledBeforeTimeout);
+    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
+    assertInterrupted();
+  }
+
   // BlockingQueue.put() tests
   public void testPutWithNoWait() {
     Stopwatch stopwatch = Stopwatch.createStarted();
@@ -729,6 +789,30 @@ private static void requestInterruptIn(long millis) {
     InterruptionUtil.requestInterruptIn(millis, MILLISECONDS);
   }
 
+  @CanIgnoreReturnValue
+  private static Thread acquireFor(final Lock lock, final long duration, final TimeUnit unit) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    Thread thread =
+        new Thread() {
+          @Override
+          public void run() {
+            lock.lock();
+            latch.countDown();
+            try {
+              Thread.sleep(unit.toMillis(duration));
+            } catch (InterruptedException e) {
+              // simply finish execution
+            } finally {
+              lock.unlock();
+            }
+          }
+        };
+    thread.setDaemon(true);
+    thread.start();
+    awaitUninterruptibly(latch);
+    return thread;
+  }
+
   private static class TestCondition implements Condition {
     private final Lock lock;
     private final Condition condition;, @@ -29,6 +29,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
 
 /**
  * Utilities for treating interruptible operations as uninterruptible. In all cases, if a thread is
@@ -366,6 +367,35 @@ public static boolean tryAcquireUninterruptibly(
     }
   }
 
+  /**
+   * Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}
+   * uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
+  public static boolean tryLockUninterruptibly(Lock lock, long timeout, TimeUnit unit) {
+    boolean interrupted = false;
+    try {
+      long remainingNanos = unit.toNanos(timeout);
+      long end = System.nanoTime() + remainingNanos;
+
+      while (true) {
+        try {
+          return lock.tryLock(remainingNanos, NANOSECONDS);
+        } catch (InterruptedException e) {
+          interrupted = true;
+          remainingNanos = end - System.nanoTime();
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   // TODO(user): Add support for waitUninterruptibly.
 
   private Uninterruptibles() {}, @@ -22,13 +22,16 @@
 import static com.google.common.util.concurrent.Uninterruptibles.putUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.takeUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryAcquireUninterruptibly;
+import static com.google.common.util.concurrent.Uninterruptibles.tryLockUninterruptibly;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.base.Preconditions;
 import com.google.common.base.Stopwatch;
 import com.google.common.testing.NullPointerTester;
 import com.google.common.testing.TearDown;
 import com.google.common.testing.TearDownStack;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Date;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
@@ -141,6 +144,63 @@ public void testConditionAwaitInterruptedTimeoutNotExceeded() {
     assertInterrupted();
   }
 
+  // Lock.tryLock() tests
+  public void testTryLockTimeoutExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    Thread lockThread = acquireFor(lock, 5, SECONDS);
+
+    boolean lockAcquired = tryLockUninterruptibly(lock, 500, MILLISECONDS);
+
+    assertFalse(lockAcquired);
+    assertAtLeastTimePassed(stopwatch, 500);
+    assertNotInterrupted();
+
+    // finish locking thread
+    lockThread.interrupt();
+  }
+
+  public void testTryLockTimeoutNotExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    acquireFor(lock, 500, MILLISECONDS);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1500, MILLISECONDS);
+
+    assertTrue(signaledBeforeTimeout);
+    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
+    assertNotInterrupted();
+  }
+
+  public void testTryLockInterruptedTimeoutExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    Thread lockThread = acquireFor(lock, 5, SECONDS);
+    requestInterruptIn(500);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1000, MILLISECONDS);
+
+    assertFalse(signaledBeforeTimeout);
+    assertAtLeastTimePassed(stopwatch, 1000);
+    assertInterrupted();
+
+    // finish locking thread
+    lockThread.interrupt();
+  }
+
+  public void testTryLockInterruptedTimeoutNotExceeded() {
+    Stopwatch stopwatch = Stopwatch.createStarted();
+    Lock lock = new ReentrantLock();
+    acquireFor(lock, 1000, MILLISECONDS);
+    requestInterruptIn(500);
+
+    boolean signaledBeforeTimeout = tryLockUninterruptibly(lock, 1500, MILLISECONDS);
+
+    assertTrue(signaledBeforeTimeout);
+    assertTimeNotPassed(stopwatch, LONG_DELAY_MS);
+    assertInterrupted();
+  }
+
   // BlockingQueue.put() tests
   public void testPutWithNoWait() {
     Stopwatch stopwatch = Stopwatch.createStarted();
@@ -729,6 +789,30 @@ private static void requestInterruptIn(long millis) {
     InterruptionUtil.requestInterruptIn(millis, MILLISECONDS);
   }
 
+  @CanIgnoreReturnValue
+  private static Thread acquireFor(final Lock lock, final long duration, final TimeUnit unit) {
+    final CountDownLatch latch = new CountDownLatch(1);
+    Thread thread =
+        new Thread() {
+          @Override
+          public void run() {
+            lock.lock();
+            latch.countDown();
+            try {
+              Thread.sleep(unit.toMillis(duration));
+            } catch (InterruptedException e) {
+              // simply finish execution
+            } finally {
+              lock.unlock();
+            }
+          }
+        };
+    thread.setDaemon(true);
+    thread.start();
+    awaitUninterruptibly(latch);
+    return thread;
+  }
+
   private static class TestCondition implements Condition {
     private final Lock lock;
     private final Condition condition;, @@ -32,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
 
 /**
  * Utilities for treating interruptible operations as uninterruptible. In all cases, if a thread is
@@ -471,6 +472,47 @@ public static boolean tryAcquireUninterruptibly(
     }
   }
 
+  /**
+   * Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}
+   * uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @GwtIncompatible // concurrency
+  @Beta
+  public static boolean tryLockUninterruptibly(Lock lock, Duration timeout) {
+    return tryLockUninterruptibly(lock, toNanosSaturated(timeout), TimeUnit.NANOSECONDS);
+  }
+
+  /**
+   * Invokes {@code lock.}{@link Lock#tryLock(long, TimeUnit) tryLock(timeout, unit)}
+   * uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"") // should accept a java.time.Duration
+  public static boolean tryLockUninterruptibly(Lock lock, long timeout, TimeUnit unit) {
+    boolean interrupted = false;
+    try {
+      long remainingNanos = unit.toNanos(timeout);
+      long end = System.nanoTime() + remainingNanos;
+
+      while (true) {
+        try {
+          return lock.tryLock(remainingNanos, NANOSECONDS);
+        } catch (InterruptedException e) {
+          interrupted = true;
+          remainingNanos = end - System.nanoTime();
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   // TODO(user): Add support for waitUninterruptibly.
 
   private Uninterruptibles() {}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adds constants for `Cross-Origin-Embedder-Policy(-Report-Only)?` headers ([W3](https://wicg.github.io/cross-origin-embedder-policy/#COEP)).

RELNOTES=Adds constants for `Cross-Origin-Embedder-Policy(-Report-Only)?` headers.

a061f7e066ad470b47b749c0514ac581cf2397e2

-------

<p> Implement tryLockUninterruptibly

Fixes #3880

c9278360493d074ecc88c9d42adbcde2ad90f035",MOE Sync 2020-05-06
3898,Kurt Alfred Kluever,"['android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java', 'guava/src/com/google/common/util/concurrent/SequentialExecutor.java']","@@ -24,7 +24,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.WeakOuter;
+import com.google.j2objc.annotations.RetainedWith;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.Executor;
@@ -80,7 +80,7 @@
   @GuardedBy(""queue"")
   private long workerRunCount = 0;
 
-  private final QueueWorker worker = new QueueWorker();
+  @RetainedWith private final QueueWorker worker = new QueueWorker();
 
   /** Use {@link MoreExecutors#newSequentialExecutor} */
   SequentialExecutor(Executor executor) {
@@ -164,7 +164,6 @@ public void run() {
   }
 
   /** Worker that runs tasks from {@link #queue} until it is empty. */
-  @WeakOuter
   private final class QueueWorker implements Runnable {
     @Override
     public void run() {, @@ -24,7 +24,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
-import com.google.j2objc.annotations.WeakOuter;
+import com.google.j2objc.annotations.RetainedWith;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.concurrent.Executor;
@@ -80,7 +80,7 @@
   @GuardedBy(""queue"")
   private long workerRunCount = 0;
 
-  private final QueueWorker worker = new QueueWorker();
+  @RetainedWith private final QueueWorker worker = new QueueWorker();
 
   /** Use {@link MoreExecutors#newSequentialExecutor} */
   SequentialExecutor(Executor executor) {
@@ -164,7 +164,6 @@ public void run() {
   }
 
   /** Worker that runs tasks from {@link #queue} until it is empty. */
-  @WeakOuter
   private final class QueueWorker implements Runnable {
     @Override
     public void run() {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Ensure QueueWorker does not outlive SequentialExecutor on iOS.

When `SequentialExecutor` is used on iOS as J2ObjC-transpiled code, we need to
make sure that `SequentialExecutor.QueueWorker` does not outlive its outer
class. Previously, because the inner class was annotated with `@WeakOuter`, it
could happen, and, when this happened, the inner class would then invoke
methods on a dangling pointer and crash the process in turn. The issue is now
fixed by annotating the worker field in the outer class with `@RetainedWith`.

Although `@RetainedWith` was initially designed for bimaps, the annotation
addresses exactly the lifecycle problem here.

180157a2ab9d4574d69eeed3d654ceaff7f5b59d",MOE Sync 2020-05-12
3899,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/collect/ListsTest.java', 'android/guava/src/com/google/common/collect/CartesianList.java', 'guava-gwt/test/com/google/common/collect/ListsTest_gwt.java', 'guava-tests/test/com/google/common/collect/ListsTest.java', 'guava/src/com/google/common/collect/CartesianList.java']","@@ -629,6 +629,16 @@ public void testCartesianProduct_indexOf() {
     assertEquals(actual.indexOf(list(1, 1, 1)), -1);
   }
 
+  public void testCartesianProduct_lastIndexOf() {
+    List<List<Integer>> actual = Lists.cartesianProduct(list(1, 1), list(2, 3));
+    assertThat(actual.lastIndexOf(list(1, 2))).isEqualTo(2);
+    assertThat(actual.lastIndexOf(list(1, 3))).isEqualTo(3);
+    assertThat(actual.lastIndexOf(list(1, 1))).isEqualTo(-1);
+
+    assertThat(actual.lastIndexOf(list(1))).isEqualTo(-1);
+    assertThat(actual.lastIndexOf(list(1, 1, 1))).isEqualTo(-1);
+  }
+
   @SuppressWarnings(""unchecked"") // varargs!
   public void testCartesianProduct_unrelatedTypes() {
     List<Integer> x = list(1, 2);, @@ -88,6 +88,28 @@ public int indexOf(Object o) {
     return computedIndex;
   }
 
+  @Override
+  public int lastIndexOf(Object o) {
+    if (!(o instanceof List)) {
+      return -1;
+    }
+    List<?> list = (List<?>) o;
+    if (list.size() != axes.size()) {
+      return -1;
+    }
+    ListIterator<?> itr = list.listIterator();
+    int computedIndex = 0;
+    while (itr.hasNext()) {
+      int axisIndex = itr.nextIndex();
+      int elemIndex = axes.get(axisIndex).lastIndexOf(itr.next());
+      if (elemIndex == -1) {
+        return -1;
+      }
+      computedIndex += elemIndex * axesSizeProduct[axisIndex + 1];
+    }
+    return computedIndex;
+  }
+
   @Override
   public ImmutableList<E> get(final int index) {
     checkElementIndex(index, size());, @@ -68,6 +68,11 @@ public void testCartesianProduct_indexOf() throws Exception {
   testCase.testCartesianProduct_indexOf();
 }
 
+public void testCartesianProduct_lastIndexOf() throws Exception {
+  com.google.common.collect.ListsTest testCase = new com.google.common.collect.ListsTest();
+  testCase.testCartesianProduct_lastIndexOf();
+}
+
 public void testCartesianProduct_unrelatedTypes() throws Exception {
   com.google.common.collect.ListsTest testCase = new com.google.common.collect.ListsTest();
   testCase.testCartesianProduct_unrelatedTypes();, @@ -629,6 +629,16 @@ public void testCartesianProduct_indexOf() {
     assertEquals(actual.indexOf(list(1, 1, 1)), -1);
   }
 
+  public void testCartesianProduct_lastIndexOf() {
+    List<List<Integer>> actual = Lists.cartesianProduct(list(1, 1), list(2, 3));
+    assertThat(actual.lastIndexOf(list(1, 2))).isEqualTo(2);
+    assertThat(actual.lastIndexOf(list(1, 3))).isEqualTo(3);
+    assertThat(actual.lastIndexOf(list(1, 1))).isEqualTo(-1);
+
+    assertThat(actual.lastIndexOf(list(1))).isEqualTo(-1);
+    assertThat(actual.lastIndexOf(list(1, 1, 1))).isEqualTo(-1);
+  }
+
   @SuppressWarnings(""unchecked"") // varargs!
   public void testCartesianProduct_unrelatedTypes() {
     List<Integer> x = list(1, 2);, @@ -88,6 +88,28 @@ public int indexOf(Object o) {
     return computedIndex;
   }
 
+  @Override
+  public int lastIndexOf(Object o) {
+    if (!(o instanceof List)) {
+      return -1;
+    }
+    List<?> list = (List<?>) o;
+    if (list.size() != axes.size()) {
+      return -1;
+    }
+    ListIterator<?> itr = list.listIterator();
+    int computedIndex = 0;
+    while (itr.hasNext()) {
+      int axisIndex = itr.nextIndex();
+      int elemIndex = axes.get(axisIndex).lastIndexOf(itr.next());
+      if (elemIndex == -1) {
+        return -1;
+      }
+      computedIndex += elemIndex * axesSizeProduct[axisIndex + 1];
+    }
+    return computedIndex;
+  }
+
   @Override
   public ImmutableList<E> get(final int index) {
     checkElementIndex(index, size());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> In ImmutableIntArray, use Arrays.copyOf when expanding the internal array.

909bdb290675c41238a194ad32e6686cda58f6dc

-------

<p> Implemented lastIndexOf in CartesianList

Fixes #3878

13da6dd1e8446bc2e5e6a5ac6e87e82ce0b7743f",MOE Sync 2020-05-13
3904,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/net/HttpHeadersTest.java', 'android/guava/src/com/google/common/net/HttpHeaders.java', 'guava-tests/test/com/google/common/net/HttpHeadersTest.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -50,7 +50,8 @@ public void testConstantNameMatchesString() throws Exception {
             .build();
     ImmutableSet<String> uppercaseAcronyms =
         ImmutableSet.of(
-            ""ID"", ""DNT"", ""DNS"", ""HTTP2"", ""IP"", ""MD5"", ""P3P"", ""TE"", ""UID"", ""URL"", ""WWW"", ""XSS"");
+            ""CH"", ""ID"", ""DNT"", ""DNS"", ""HTTP2"", ""IP"", ""MD5"", ""P3P"", ""TE"", ""UA"", ""UID"", ""URL"", ""WWW"",
+            ""XSS"");
     assertConstantNameMatchesString(HttpHeaders.class, specialCases, uppercaseAcronyms);
   }
 , @@ -474,6 +474,14 @@ private ReferrerPolicyValues() {}
    */
   public static final String X_MOZ = ""X-Moz"";
 
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-ua"">{@code Sec-CH-UA}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA = ""Sec-CH-UA"";
+
   /**
    * The HTTP <a href=""https://w3c.github.io/webappsec-fetch-metadata/"">{@code Sec-Fetch-Dest}</a>
    * header field name., @@ -50,7 +50,8 @@ public void testConstantNameMatchesString() throws Exception {
             .build();
     ImmutableSet<String> uppercaseAcronyms =
         ImmutableSet.of(
-            ""ID"", ""DNT"", ""DNS"", ""HTTP2"", ""IP"", ""MD5"", ""P3P"", ""TE"", ""UID"", ""URL"", ""WWW"", ""XSS"");
+            ""CH"", ""ID"", ""DNT"", ""DNS"", ""HTTP2"", ""IP"", ""MD5"", ""P3P"", ""TE"", ""UA"", ""UID"", ""URL"", ""WWW"",
+            ""XSS"");
     assertConstantNameMatchesString(HttpHeaders.class, specialCases, uppercaseAcronyms);
   }
 , @@ -474,6 +474,14 @@ private ReferrerPolicyValues() {}
    */
   public static final String X_MOZ = ""X-Moz"";
 
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-ua"">{@code Sec-CH-UA}</a>
+   * header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA = ""Sec-CH-UA"";
+
   /**
    * The HTTP <a href=""https://w3c.github.io/webappsec-fetch-metadata/"">{@code Sec-Fetch-Dest}</a>
    * header field name., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Suppress IdentityHashMapBoxing check

This would soon become an ERROR in blaze.

0b46c0b65b9f98f3cc36aaf185a888d3e8e76f60

-------

<p> Adding the Sec-CH-UA header. Ignore ClangTidy. It has to do with the constant naming scheme for httputils.h.

Spec for header: https://wicg.github.io/ua-client-hints/

bd128b4f293ea94eaad3aa0ba29d71ee8ea25b3c",MOE Sync 2020-05-14
3905,Kurt Alfred Kluever,"['android/guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/net/HttpHeaders.java']","@@ -481,6 +481,41 @@ private ReferrerPolicyValues() {}
    * @since NEXT
    */
   public static final String SEC_CH_UA = ""Sec-CH-UA"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-model"">{@code
+   * Sec-CH-UA-Model}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_MODEL = ""Sec-CH-UA-Model"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-platform"">{@code
+   * Sec-CH-UA-Platform}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_PLATFORM = ""Sec-CH-UA-Platform"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-platform-version"">{@code
+   * Sec-CH-UA-Platform-Version}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_PLATFORM_VERSION = ""Sec-CH-UA-Platform-Version"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-full-version"">{@code
+   * Sec-CH-UA-Full-Version}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_FULL_VERSION = ""Sec-CH-UA-Full-Version"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-mobile"">{@code
+   * Sec-CH-UA-Mobile}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_MOBILE = ""Sec-CH-UA-Mobile"";
 
   /**
    * The HTTP <a href=""https://w3c.github.io/webappsec-fetch-metadata/"">{@code Sec-Fetch-Dest}</a>, @@ -481,6 +481,41 @@ private ReferrerPolicyValues() {}
    * @since NEXT
    */
   public static final String SEC_CH_UA = ""Sec-CH-UA"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-model"">{@code
+   * Sec-CH-UA-Model}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_MODEL = ""Sec-CH-UA-Model"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-platform"">{@code
+   * Sec-CH-UA-Platform}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_PLATFORM = ""Sec-CH-UA-Platform"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-platform-version"">{@code
+   * Sec-CH-UA-Platform-Version}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_PLATFORM_VERSION = ""Sec-CH-UA-Platform-Version"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-full-version"">{@code
+   * Sec-CH-UA-Full-Version}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_FULL_VERSION = ""Sec-CH-UA-Full-Version"";
+  /**
+   * The HTTP <a href=""https://wicg.github.io/ua-client-hints/#sec-ch-mobile"">{@code
+   * Sec-CH-UA-Mobile}</a> header field name.
+   *
+   * @since NEXT
+   */
+  public static final String SEC_CH_UA_MOBILE = ""Sec-CH-UA-Mobile"";
 
   /**
    * The HTTP <a href=""https://w3c.github.io/webappsec-fetch-metadata/"">{@code Sec-Fetch-Dest}</a>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adding the rest of the client-hints headers (besides Arch which I don't think we need).

Header Spec Here: https://wicg.github.io/ua-client-hints/#http-ua-hints

RELNOTES=N/A

fab81c3b8e934e47c7cb846b1428865781ac2200",MOE Sync 2020-05-17
3915,David P. Baker,"['android/guava/src/com/google/common/collect/Range.java', 'guava/src/com/google/common/collect/Range.java']","@@ -91,6 +91,7 @@
  * <h3>Other notes</h3>
  *
  * <ul>
+ *   <li>All ranges are shallow-immutable.
  *   <li>Instances of this type are obtained using the static factory methods in this class.
  *   <li>Ranges are <i>convex</i>: whenever two values are contained, all values in between them
  *       must also be contained. More formally, for any {@code c1 <= c2 <= c3} of type {@code C},, @@ -91,6 +91,7 @@
  * <h3>Other notes</h3>
  *
  * <ul>
+ *   <li>All ranges are shallow-immutable.
  *   <li>Instances of this type are obtained using the static factory methods in this class.
  *   <li>Ranges are <i>convex</i>: whenever two values are contained, all values in between them
  *       must also be contained. More formally, for any {@code c1 <= c2 <= c3} of type {@code C},, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Document that Ranges are immutable.

Fixes https://github.com/google/guava/issues/1813

9485ee0fb525dfa69d91561aba0035b371d9c327",MOE Sync 2020-06-01
3917,David P. Baker,"['android/guava/src/com/google/common/annotations/VisibleForTesting.java', 'guava/src/com/google/common/annotations/VisibleForTesting.java']","@@ -18,6 +18,13 @@
  * Annotates a program element that exists, or is more widely visible than otherwise necessary, only
  * for use in test code.
  *
+ * <p><b>Do not use this interface</b> for public or protected declarations: it is a fig leaf for
+ * bad design, and it does not prevent anyone from using the declaration---and experience has shown
+ * that they will. If the method breaks the encapsulation of its class, then its internal
+ * representation will be hard to change. Instead, use <a
+ * href=""http://errorprone.info/bugpattern/RestrictedApiChecker"">RestrictedApiChecker</a>, which
+ * enforces fine-grained visibility policies.
+ *
  * @author Johannes Henkel
  */
 @GwtCompatible, @@ -18,6 +18,13 @@
  * Annotates a program element that exists, or is more widely visible than otherwise necessary, only
  * for use in test code.
  *
+ * <p><b>Do not use this interface</b> for public or protected declarations: it is a fig leaf for
+ * bad design, and it does not prevent anyone from using the declaration---and experience has shown
+ * that they will. If the method breaks the encapsulation of its class, then its internal
+ * representation will be hard to change. Instead, use <a
+ * href=""http://errorprone.info/bugpattern/RestrictedApiChecker"">RestrictedApiChecker</a>, which
+ * enforces fine-grained visibility policies.
+ *
  * @author Johannes Henkel
  */
 @GwtCompatible, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Added support for the ""font"" Top-Level Media Type (https://tools.ietf.org/html/rfc8081)

RELNOTES=`net`: Added support for ""font"" Top-Level Media Type

45003f5fe824838cdce85fea05de84dcb6b54993

-------

<p> guava: disavow VisibleForTesting

Johannes and I invented this class in the early days of Blaze,
and in hindsight it was clearly a mistake; it encourages self-deception.
This change adds a comment discouraging its further use.

8bb1bf1b54f6152c14b69c3699c7fe7f07332a9a",MOE Sync 2020-06-02
3919,David P. Baker,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove @DoNotCall from FluentIterable.from(FluentIterable).

4ec122fa84a4d3384324250a74120d32e0ccfa1c

-------

<p> Update Public Suffix data.

This copy is typically updated whenever Chrome's copy is updated, which
is roughly every 6 weeks. Subscribe to the Chrome Milestone Calendar to see the
dates.

0d5c668d46ecba2a1ec5656b603bbdb30786e9e1",MOE Sync 2020-06-04
3921,David P. Baker,"['android/guava-tests/test/com/google/common/math/BigIntegerMathTest.java', 'android/guava/src/com/google/common/math/BigIntegerMath.java', 'android/guava/src/com/google/common/math/ToDoubleRounder.java', 'guava-tests/test/com/google/common/math/BigIntegerMathTest.java', 'guava/src/com/google/common/math/BigIntegerMath.java', 'guava/src/com/google/common/math/ToDoubleRounder.java']","@@ -22,6 +22,8 @@
 import static com.google.common.math.MathTesting.NEGATIVE_BIGINTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.NONZERO_BIGINTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_BIGINTEGER_CANDIDATES;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.math.BigInteger.ONE;
 import static java.math.BigInteger.TEN;
 import static java.math.BigInteger.ZERO;
@@ -33,6 +35,7 @@
 import static java.math.RoundingMode.HALF_UP;
 import static java.math.RoundingMode.UNNECESSARY;
 import static java.math.RoundingMode.UP;
+import static java.math.RoundingMode.values;
 import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
@@ -41,6 +44,9 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
 import junit.framework.TestCase;
 
 /**
@@ -542,6 +548,219 @@ public void testBinomialOutside() {
     }
   }
 
+  @GwtIncompatible
+  private static final class RoundToDoubleTester {
+    private final BigInteger input;
+    private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
+    private boolean unnecessaryShouldThrow = false;
+
+    RoundToDoubleTester(BigInteger input) {
+      this.input = input;
+    }
+
+    RoundToDoubleTester setExpectation(double expectedValue, RoundingMode... modes) {
+      for (RoundingMode mode : modes) {
+        Double previous = expectedValues.put(mode, expectedValue);
+        if (previous != null) {
+          throw new AssertionError();
+        }
+      }
+      return this;
+    }
+
+    public RoundToDoubleTester roundUnnecessaryShouldThrow() {
+      unnecessaryShouldThrow = true;
+      return this;
+    }
+
+    public void test() {
+      assertThat(expectedValues.keySet())
+          .containsAtLeastElementsIn(EnumSet.complementOf(EnumSet.of(UNNECESSARY)));
+      for (Map.Entry<RoundingMode, Double> entry : expectedValues.entrySet()) {
+        RoundingMode mode = entry.getKey();
+        Double expectation = entry.getValue();
+        assertWithMessage(""roundToDouble("" + input + "", "" + mode + "")"")
+            .that(BigIntegerMath.roundToDouble(input, mode))
+            .isEqualTo(expectation);
+      }
+
+      if (!expectedValues.containsKey(UNNECESSARY)) {
+        assertWithMessage(""Expected roundUnnecessaryShouldThrow call"")
+            .that(unnecessaryShouldThrow)
+            .isTrue();
+        try {
+          BigIntegerMath.roundToDouble(input, UNNECESSARY);
+          fail(""Expected ArithmeticException for roundToDouble("" + input + "", UNNECESSARY)"");
+        } catch (ArithmeticException expected) {
+          // expected
+        }
+      }
+    }
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_Zero() {
+    new RoundToDoubleTester(BigInteger.ZERO).setExpectation(0.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallPositive() {
+    new RoundToDoubleTester(BigInteger.valueOf(16)).setExpectation(16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentable() {
+    new RoundToDoubleTester(BigInteger.valueOf(1L << 53))
+        .setExpectation(Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
+    double twoToThe53 = Math.pow(2, 53);
+    // the representable doubles are 2^53 and 2^53 + 2.
+    // 2^53+1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 53) + 1))
+        .setExpectation(twoToThe53, DOWN, FLOOR, HALF_DOWN, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe53), CEILING, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOne() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 1))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusThree() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+3 is more than halfway between, so HALF_DOWN and HALF_UP will both go up.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 3))
+        .setExpectation(twoToThe54, DOWN, FLOOR)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusFour() {
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 4))
+        .setExpectation(Math.pow(2, 54) + 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDouble() {
+    BigInteger maxDoubleAsBI = DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY);
+    new RoundToDoubleTester(maxDoubleAsBI).setExpectation(Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDoublePlusOne() {
+    BigInteger maxDoubleAsBI =
+        DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY).add(BigInteger.ONE);
+    new RoundToDoubleTester(maxDoubleAsBI)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_wayTooBig() {
+    BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT);
+    new RoundToDoubleTester(bi)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallNegative() {
+    new RoundToDoubleTester(BigInteger.valueOf(-16)).setExpectation(-16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentable() {
+    new RoundToDoubleTester(BigInteger.valueOf(-1L << 53))
+        .setExpectation(-Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
+    // the representable doubles are -2^53 and -2^53 - 2.
+    // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 53) - 1))
+        .setExpectation(-Math.pow(2, 53), DOWN, CEILING, HALF_DOWN, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 53)), FLOOR, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusOne() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 1))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusThree() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 3))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
+        .setExpectation(
+            DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusFour() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 4))
+        .setExpectation(-Math.pow(2, 54) - 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDouble() {
+    BigInteger minDoubleAsBI = DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY);
+    new RoundToDoubleTester(minDoubleAsBI).setExpectation(-Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDoubleMinusOne() {
+    BigInteger minDoubleAsBI =
+        DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY).subtract(BigInteger.ONE);
+    new RoundToDoubleTester(minDoubleAsBI)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeWayTooBig() {
+    BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT).negate();
+    new RoundToDoubleTester(bi)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
   @GwtIncompatible // NullPointerTester
   public void testNullPointers() {
     NullPointerTester tester = new NullPointerTester();, @@ -21,7 +21,9 @@
 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
 import static java.math.RoundingMode.CEILING;
 import static java.math.RoundingMode.FLOOR;
+import static java.math.RoundingMode.HALF_DOWN;
 import static java.math.RoundingMode.HALF_EVEN;
+import static java.math.RoundingMode.UNNECESSARY;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -56,7 +58,7 @@
    */
   @Beta
   public static BigInteger ceilingPowerOfTwo(BigInteger x) {
-    return BigInteger.ZERO.setBit(log2(x, RoundingMode.CEILING));
+    return BigInteger.ZERO.setBit(log2(x, CEILING));
   }
 
   /**
@@ -68,7 +70,7 @@ public static BigInteger ceilingPowerOfTwo(BigInteger x) {
    */
   @Beta
   public static BigInteger floorPowerOfTwo(BigInteger x) {
-    return BigInteger.ZERO.setBit(log2(x, RoundingMode.FLOOR));
+    return BigInteger.ZERO.setBit(log2(x, FLOOR));
   }
 
   /** Returns {@code true} if {@code x} represents a power of two. */
@@ -306,6 +308,57 @@ private static BigInteger sqrtApproxWithDoubles(BigInteger x) {
     return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)), HALF_EVEN);
   }
 
+  /**
+   * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
+   * is precisely representable as a {@code double}, its {@code double} value will be returned;
+   * otherwise, the rounding will choose between the two nearest representable values with {@code
+   * mode}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
+   * infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
+   * representable as a double, but {@code roundToDouble(BigInteger.valueOf(2).pow(2000), HALF_UP)}
+   * will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
+   * default rounding mode: if the two nearest representable values are equally near, the one with
+   * the least significant bit zero is chosen. (In such cases, both of the nearest representable
+   * values are even integers; this method returns the one that is a multiple of a greater power of
+   * two.)
+   *
+   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
+   *     is not precisely representable as a {@code double}
+   * @since NEXT
+   */
+  @GwtIncompatible
+  public static double roundToDouble(BigInteger x, RoundingMode mode) {
+    return BigIntegerToDoubleRounder.INSTANCE.roundToDouble(x, mode);
+  }
+
+  @GwtIncompatible
+  private static class BigIntegerToDoubleRounder extends ToDoubleRounder<BigInteger> {
+    private static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+
+    @Override
+    double roundToDoubleArbitrarily(BigInteger bigInteger) {
+      return DoubleUtils.bigToDouble(bigInteger);
+    }
+
+    @Override
+    int sign(BigInteger bigInteger) {
+      return bigInteger.signum();
+    }
+
+    @Override
+    BigInteger toX(double d, RoundingMode mode) {
+      return DoubleMath.roundToBigInteger(d, mode);
+    }
+
+    @Override
+    BigInteger minus(BigInteger a, BigInteger b) {
+      return a.subtract(b);
+    }
+  }
+
   /**
    * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
    * RoundingMode}.
@@ -432,7 +485,7 @@ public static BigInteger binomial(int n, int k) {
     long numeratorAccum = n;
     long denominatorAccum = 1;
 
-    int bits = LongMath.log2(n, RoundingMode.CEILING);
+    int bits = LongMath.log2(n, CEILING);
 
     int numeratorBits = bits;
 , @@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.math.RoundingMode;
+
+/**
+ * Helper type to implement rounding {@code X} to a representable {@code double} value according to
+ * a {@link RoundingMode}.
+ */
+@GwtIncompatible
+abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
+  /**
+   * Returns x rounded to either the greatest double less than or equal to the precise value of x,
+   * or the least double greater than or equal to the precise value of x.
+   */
+  abstract double roundToDoubleArbitrarily(X x);
+
+  /** Returns the sign of x: either -1, 0, or 1. */
+  abstract int sign(X x);
+
+  /** Returns d's value as an X, rounded with the specified mode. */
+  abstract X toX(double d, RoundingMode mode);
+
+  /** Returns a - b, guaranteed that both arguments are nonnegative. */
+  abstract X minus(X a, X b);
+
+  /** Rounds {@code x} to a {@code double}. */
+  final double roundToDouble(X x, RoundingMode mode) {
+    checkNotNull(x, ""x"");
+    checkNotNull(mode, ""mode"");
+    double roundArbitrarily = roundToDoubleArbitrarily(x);
+    if (Double.isInfinite(roundArbitrarily)) {
+      switch (mode) {
+        case DOWN:
+        case HALF_EVEN:
+        case HALF_DOWN:
+        case HALF_UP:
+          return Double.MAX_VALUE * sign(x);
+        case FLOOR:
+          return (roundArbitrarily == Double.POSITIVE_INFINITY)
+              ? Double.MAX_VALUE
+              : Double.NEGATIVE_INFINITY;
+        case CEILING:
+          return (roundArbitrarily == Double.POSITIVE_INFINITY)
+              ? Double.POSITIVE_INFINITY
+              : -Double.MAX_VALUE;
+        case UP:
+          return roundArbitrarily;
+        case UNNECESSARY:
+          throw new ArithmeticException(x + "" cannot be represented precisely as a double"");
+      }
+    }
+    X roundArbitrarilyAsX = toX(roundArbitrarily, RoundingMode.UNNECESSARY);
+    int cmpXToRoundArbitrarily = x.compareTo(roundArbitrarilyAsX);
+    switch (mode) {
+      case UNNECESSARY:
+        checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);
+        return roundArbitrarily;
+      case FLOOR:
+        return (cmpXToRoundArbitrarily >= 0)
+            ? roundArbitrarily
+            : DoubleUtils.nextDown(roundArbitrarily);
+      case CEILING:
+        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+      case DOWN:
+        if (sign(x) >= 0) {
+          return (cmpXToRoundArbitrarily >= 0)
+              ? roundArbitrarily
+              : DoubleUtils.nextDown(roundArbitrarily);
+        } else {
+          return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+        }
+      case UP:
+        if (sign(x) >= 0) {
+          return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+        } else {
+          return (cmpXToRoundArbitrarily >= 0)
+              ? roundArbitrarily
+              : DoubleUtils.nextDown(roundArbitrarily);
+        }
+      case HALF_DOWN:
+      case HALF_UP:
+      case HALF_EVEN:
+        {
+          X roundFloor;
+          double roundFloorAsDouble;
+          X roundCeiling;
+          double roundCeilingAsDouble;
+
+          if (cmpXToRoundArbitrarily >= 0) {
+            roundFloorAsDouble = roundArbitrarily;
+            roundFloor = roundArbitrarilyAsX;
+            roundCeilingAsDouble = Math.nextUp(roundArbitrarily);
+            if (roundCeilingAsDouble == Double.POSITIVE_INFINITY) {
+              return roundFloorAsDouble;
+            }
+            roundCeiling = toX(roundCeilingAsDouble, RoundingMode.CEILING);
+          } else {
+            roundCeilingAsDouble = roundArbitrarily;
+            roundCeiling = roundArbitrarilyAsX;
+            roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);
+            if (roundFloorAsDouble == Double.NEGATIVE_INFINITY) {
+              return roundCeilingAsDouble;
+            }
+            roundFloor = toX(roundFloorAsDouble, RoundingMode.FLOOR);
+          }
+
+          X deltaToFloor = minus(x, roundFloor);
+          X deltaToCeiling = minus(roundCeiling, x);
+          int diff = deltaToFloor.compareTo(deltaToCeiling);
+          if (diff < 0) { // closer to floor
+            return roundFloorAsDouble;
+          } else if (diff > 0) { // closer to ceiling
+            return roundCeilingAsDouble;
+          }
+          // halfway between the representable values; do the half-whatever logic
+          switch (mode) {
+            case HALF_EVEN:
+              return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0)
+                  ? roundFloorAsDouble
+                  : roundCeilingAsDouble;
+            case HALF_DOWN:
+              return (sign(x) >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;
+            case HALF_UP:
+              return (sign(x) >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;
+            default:
+              throw new AssertionError(""impossible"");
+          }
+        }
+    }
+    throw new AssertionError(""impossible"");
+  }
+}, @@ -22,6 +22,8 @@
 import static com.google.common.math.MathTesting.NEGATIVE_BIGINTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.NONZERO_BIGINTEGER_CANDIDATES;
 import static com.google.common.math.MathTesting.POSITIVE_BIGINTEGER_CANDIDATES;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.math.BigInteger.ONE;
 import static java.math.BigInteger.TEN;
 import static java.math.BigInteger.ZERO;
@@ -33,6 +35,7 @@
 import static java.math.RoundingMode.HALF_UP;
 import static java.math.RoundingMode.UNNECESSARY;
 import static java.math.RoundingMode.UP;
+import static java.math.RoundingMode.values;
 import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
@@ -41,6 +44,9 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.RoundingMode;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
 import junit.framework.TestCase;
 
 /**
@@ -542,6 +548,219 @@ public void testBinomialOutside() {
     }
   }
 
+  @GwtIncompatible
+  private static final class RoundToDoubleTester {
+    private final BigInteger input;
+    private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
+    private boolean unnecessaryShouldThrow = false;
+
+    RoundToDoubleTester(BigInteger input) {
+      this.input = input;
+    }
+
+    RoundToDoubleTester setExpectation(double expectedValue, RoundingMode... modes) {
+      for (RoundingMode mode : modes) {
+        Double previous = expectedValues.put(mode, expectedValue);
+        if (previous != null) {
+          throw new AssertionError();
+        }
+      }
+      return this;
+    }
+
+    public RoundToDoubleTester roundUnnecessaryShouldThrow() {
+      unnecessaryShouldThrow = true;
+      return this;
+    }
+
+    public void test() {
+      assertThat(expectedValues.keySet())
+          .containsAtLeastElementsIn(EnumSet.complementOf(EnumSet.of(UNNECESSARY)));
+      for (Map.Entry<RoundingMode, Double> entry : expectedValues.entrySet()) {
+        RoundingMode mode = entry.getKey();
+        Double expectation = entry.getValue();
+        assertWithMessage(""roundToDouble("" + input + "", "" + mode + "")"")
+            .that(BigIntegerMath.roundToDouble(input, mode))
+            .isEqualTo(expectation);
+      }
+
+      if (!expectedValues.containsKey(UNNECESSARY)) {
+        assertWithMessage(""Expected roundUnnecessaryShouldThrow call"")
+            .that(unnecessaryShouldThrow)
+            .isTrue();
+        try {
+          BigIntegerMath.roundToDouble(input, UNNECESSARY);
+          fail(""Expected ArithmeticException for roundToDouble("" + input + "", UNNECESSARY)"");
+        } catch (ArithmeticException expected) {
+          // expected
+        }
+      }
+    }
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_Zero() {
+    new RoundToDoubleTester(BigInteger.ZERO).setExpectation(0.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallPositive() {
+    new RoundToDoubleTester(BigInteger.valueOf(16)).setExpectation(16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentable() {
+    new RoundToDoubleTester(BigInteger.valueOf(1L << 53))
+        .setExpectation(Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
+    double twoToThe53 = Math.pow(2, 53);
+    // the representable doubles are 2^53 and 2^53 + 2.
+    // 2^53+1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 53) + 1))
+        .setExpectation(twoToThe53, DOWN, FLOOR, HALF_DOWN, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe53), CEILING, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOne() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 1))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusThree() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+3 is more than halfway between, so HALF_DOWN and HALF_UP will both go up.
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 3))
+        .setExpectation(twoToThe54, DOWN, FLOOR)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusFour() {
+    new RoundToDoubleTester(BigInteger.valueOf((1L << 54) + 4))
+        .setExpectation(Math.pow(2, 54) + 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDouble() {
+    BigInteger maxDoubleAsBI = DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY);
+    new RoundToDoubleTester(maxDoubleAsBI).setExpectation(Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDoublePlusOne() {
+    BigInteger maxDoubleAsBI =
+        DoubleMath.roundToBigInteger(Double.MAX_VALUE, UNNECESSARY).add(BigInteger.ONE);
+    new RoundToDoubleTester(maxDoubleAsBI)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_wayTooBig() {
+    BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT);
+    new RoundToDoubleTester(bi)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallNegative() {
+    new RoundToDoubleTester(BigInteger.valueOf(-16)).setExpectation(-16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentable() {
+    new RoundToDoubleTester(BigInteger.valueOf(-1L << 53))
+        .setExpectation(-Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
+    // the representable doubles are -2^53 and -2^53 - 2.
+    // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 53) - 1))
+        .setExpectation(-Math.pow(2, 53), DOWN, CEILING, HALF_DOWN, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 53)), FLOOR, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusOne() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 1))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusThree() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 3))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
+        .setExpectation(
+            DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusFour() {
+    new RoundToDoubleTester(BigInteger.valueOf((-1L << 54) - 4))
+        .setExpectation(-Math.pow(2, 54) - 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDouble() {
+    BigInteger minDoubleAsBI = DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY);
+    new RoundToDoubleTester(minDoubleAsBI).setExpectation(-Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDoubleMinusOne() {
+    BigInteger minDoubleAsBI =
+        DoubleMath.roundToBigInteger(-Double.MAX_VALUE, UNNECESSARY).subtract(BigInteger.ONE);
+    new RoundToDoubleTester(minDoubleAsBI)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeWayTooBig() {
+    BigInteger bi = BigInteger.ONE.shiftLeft(2 * Double.MAX_EXPONENT).negate();
+    new RoundToDoubleTester(bi)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
   @GwtIncompatible // NullPointerTester
   public void testNullPointers() {
     NullPointerTester tester = new NullPointerTester();, @@ -21,7 +21,9 @@
 import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
 import static java.math.RoundingMode.CEILING;
 import static java.math.RoundingMode.FLOOR;
+import static java.math.RoundingMode.HALF_DOWN;
 import static java.math.RoundingMode.HALF_EVEN;
+import static java.math.RoundingMode.UNNECESSARY;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
@@ -56,7 +58,7 @@
    */
   @Beta
   public static BigInteger ceilingPowerOfTwo(BigInteger x) {
-    return BigInteger.ZERO.setBit(log2(x, RoundingMode.CEILING));
+    return BigInteger.ZERO.setBit(log2(x, CEILING));
   }
 
   /**
@@ -68,7 +70,7 @@ public static BigInteger ceilingPowerOfTwo(BigInteger x) {
    */
   @Beta
   public static BigInteger floorPowerOfTwo(BigInteger x) {
-    return BigInteger.ZERO.setBit(log2(x, RoundingMode.FLOOR));
+    return BigInteger.ZERO.setBit(log2(x, FLOOR));
   }
 
   /** Returns {@code true} if {@code x} represents a power of two. */
@@ -306,6 +308,57 @@ private static BigInteger sqrtApproxWithDoubles(BigInteger x) {
     return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)), HALF_EVEN);
   }
 
+  /**
+   * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
+   * is precisely representable as a {@code double}, its {@code double} value will be returned;
+   * otherwise, the rounding will choose between the two nearest representable values with {@code
+   * mode}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
+   * infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
+   * representable as a double, but {@code roundToDouble(BigInteger.valueOf(2).pow(2000), HALF_UP)}
+   * will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
+   * default rounding mode: if the two nearest representable values are equally near, the one with
+   * the least significant bit zero is chosen. (In such cases, both of the nearest representable
+   * values are even integers; this method returns the one that is a multiple of a greater power of
+   * two.)
+   *
+   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
+   *     is not precisely representable as a {@code double}
+   * @since NEXT
+   */
+  @GwtIncompatible
+  public static double roundToDouble(BigInteger x, RoundingMode mode) {
+    return BigIntegerToDoubleRounder.INSTANCE.roundToDouble(x, mode);
+  }
+
+  @GwtIncompatible
+  private static class BigIntegerToDoubleRounder extends ToDoubleRounder<BigInteger> {
+    private static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+
+    @Override
+    double roundToDoubleArbitrarily(BigInteger bigInteger) {
+      return DoubleUtils.bigToDouble(bigInteger);
+    }
+
+    @Override
+    int sign(BigInteger bigInteger) {
+      return bigInteger.signum();
+    }
+
+    @Override
+    BigInteger toX(double d, RoundingMode mode) {
+      return DoubleMath.roundToBigInteger(d, mode);
+    }
+
+    @Override
+    BigInteger minus(BigInteger a, BigInteger b) {
+      return a.subtract(b);
+    }
+  }
+
   /**
    * Returns the result of dividing {@code p} by {@code q}, rounding using the specified {@code
    * RoundingMode}.
@@ -432,7 +485,7 @@ public static BigInteger binomial(int n, int k) {
     long numeratorAccum = n;
     long denominatorAccum = 1;
 
-    int bits = LongMath.log2(n, RoundingMode.CEILING);
+    int bits = LongMath.log2(n, CEILING);
 
     int numeratorBits = bits;
 , @@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.math.RoundingMode;
+
+/**
+ * Helper type to implement rounding {@code X} to a representable {@code double} value according to
+ * a {@link RoundingMode}.
+ */
+@GwtIncompatible
+abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
+  /**
+   * Returns x rounded to either the greatest double less than or equal to the precise value of x,
+   * or the least double greater than or equal to the precise value of x.
+   */
+  abstract double roundToDoubleArbitrarily(X x);
+
+  /** Returns the sign of x: either -1, 0, or 1. */
+  abstract int sign(X x);
+
+  /** Returns d's value as an X, rounded with the specified mode. */
+  abstract X toX(double d, RoundingMode mode);
+
+  /** Returns a - b, guaranteed that both arguments are nonnegative. */
+  abstract X minus(X a, X b);
+
+  /** Rounds {@code x} to a {@code double}. */
+  final double roundToDouble(X x, RoundingMode mode) {
+    checkNotNull(x, ""x"");
+    checkNotNull(mode, ""mode"");
+    double roundArbitrarily = roundToDoubleArbitrarily(x);
+    if (Double.isInfinite(roundArbitrarily)) {
+      switch (mode) {
+        case DOWN:
+        case HALF_EVEN:
+        case HALF_DOWN:
+        case HALF_UP:
+          return Double.MAX_VALUE * sign(x);
+        case FLOOR:
+          return (roundArbitrarily == Double.POSITIVE_INFINITY)
+              ? Double.MAX_VALUE
+              : Double.NEGATIVE_INFINITY;
+        case CEILING:
+          return (roundArbitrarily == Double.POSITIVE_INFINITY)
+              ? Double.POSITIVE_INFINITY
+              : -Double.MAX_VALUE;
+        case UP:
+          return roundArbitrarily;
+        case UNNECESSARY:
+          throw new ArithmeticException(x + "" cannot be represented precisely as a double"");
+      }
+    }
+    X roundArbitrarilyAsX = toX(roundArbitrarily, RoundingMode.UNNECESSARY);
+    int cmpXToRoundArbitrarily = x.compareTo(roundArbitrarilyAsX);
+    switch (mode) {
+      case UNNECESSARY:
+        checkRoundingUnnecessary(cmpXToRoundArbitrarily == 0);
+        return roundArbitrarily;
+      case FLOOR:
+        return (cmpXToRoundArbitrarily >= 0)
+            ? roundArbitrarily
+            : DoubleUtils.nextDown(roundArbitrarily);
+      case CEILING:
+        return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+      case DOWN:
+        if (sign(x) >= 0) {
+          return (cmpXToRoundArbitrarily >= 0)
+              ? roundArbitrarily
+              : DoubleUtils.nextDown(roundArbitrarily);
+        } else {
+          return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+        }
+      case UP:
+        if (sign(x) >= 0) {
+          return (cmpXToRoundArbitrarily <= 0) ? roundArbitrarily : Math.nextUp(roundArbitrarily);
+        } else {
+          return (cmpXToRoundArbitrarily >= 0)
+              ? roundArbitrarily
+              : DoubleUtils.nextDown(roundArbitrarily);
+        }
+      case HALF_DOWN:
+      case HALF_UP:
+      case HALF_EVEN:
+        {
+          X roundFloor;
+          double roundFloorAsDouble;
+          X roundCeiling;
+          double roundCeilingAsDouble;
+
+          if (cmpXToRoundArbitrarily >= 0) {
+            roundFloorAsDouble = roundArbitrarily;
+            roundFloor = roundArbitrarilyAsX;
+            roundCeilingAsDouble = Math.nextUp(roundArbitrarily);
+            if (roundCeilingAsDouble == Double.POSITIVE_INFINITY) {
+              return roundFloorAsDouble;
+            }
+            roundCeiling = toX(roundCeilingAsDouble, RoundingMode.CEILING);
+          } else {
+            roundCeilingAsDouble = roundArbitrarily;
+            roundCeiling = roundArbitrarilyAsX;
+            roundFloorAsDouble = DoubleUtils.nextDown(roundArbitrarily);
+            if (roundFloorAsDouble == Double.NEGATIVE_INFINITY) {
+              return roundCeilingAsDouble;
+            }
+            roundFloor = toX(roundFloorAsDouble, RoundingMode.FLOOR);
+          }
+
+          X deltaToFloor = minus(x, roundFloor);
+          X deltaToCeiling = minus(roundCeiling, x);
+          int diff = deltaToFloor.compareTo(deltaToCeiling);
+          if (diff < 0) { // closer to floor
+            return roundFloorAsDouble;
+          } else if (diff > 0) { // closer to ceiling
+            return roundCeilingAsDouble;
+          }
+          // halfway between the representable values; do the half-whatever logic
+          switch (mode) {
+            case HALF_EVEN:
+              return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0)
+                  ? roundFloorAsDouble
+                  : roundCeilingAsDouble;
+            case HALF_DOWN:
+              return (sign(x) >= 0) ? roundFloorAsDouble : roundCeilingAsDouble;
+            case HALF_UP:
+              return (sign(x) >= 0) ? roundCeilingAsDouble : roundFloorAsDouble;
+            default:
+              throw new AssertionError(""impossible"");
+          }
+        }
+    }
+    throw new AssertionError(""impossible"");
+  }
+}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Implement BigIntegerMath.roundToDouble, which rounds to the nearest representable double value.

Partially implements https://github.com/google/guava/issues/3895

RELNOTES=`math`: Added `BigIntegerMath.roundToDouble`.

d01a196043e7d1620f2880da5d35a31da9acd898",MOE Sync 2020-06-05
3922,Kurt Alfred Kluever,"['android/guava/src/com/google/common/collect/Ordering.java', 'guava/src/com/google/common/collect/Ordering.java']","@@ -582,8 +582,8 @@ protected Ordering() {}
    * <p><b>Implementation note:</b> this method is invoked by the default implementations of the
    * other {@code min} overloads, so overriding it will affect their behavior.
    *
-   * <p><b>Java 8 users:</b> Use {@code Collections.min(Arrays.asList(a, b), thisComparator)}
-   * instead (but note that it does not guarantee which tied minimum element is returned).
+   * <p><b>Note:</b> Consider using {@code Comparators.min(a, b, thisComparator)} instead. If {@code
+   * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.min(a, b)}.
    *
    * @param a value to compare, returned if less than or equal to b.
    * @param b value to compare.
@@ -668,8 +668,8 @@ protected Ordering() {}
    * <p><b>Implementation note:</b> this method is invoked by the default implementations of the
    * other {@code max} overloads, so overriding it will affect their behavior.
    *
-   * <p><b>Java 8 users:</b> Use {@code Collections.max(Arrays.asList(a, b), thisComparator)}
-   * instead (but note that it does not guarantee which tied maximum element is returned).
+   * <p><b>Note:</b> Consider using {@code Comparators.max(a, b, thisComparator)} instead. If {@code
+   * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.max(a, b)}.
    *
    * @param a value to compare, returned if greater than or equal to b.
    * @param b value to compare., @@ -582,8 +582,8 @@ protected Ordering() {}
    * <p><b>Implementation note:</b> this method is invoked by the default implementations of the
    * other {@code min} overloads, so overriding it will affect their behavior.
    *
-   * <p><b>Java 8 users:</b> Use {@code Collections.min(Arrays.asList(a, b), thisComparator)}
-   * instead (but note that it does not guarantee which tied minimum element is returned).
+   * <p><b>Note:</b> Consider using {@code Comparators.min(a, b, thisComparator)} instead. If {@code
+   * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.min(a, b)}.
    *
    * @param a value to compare, returned if less than or equal to b.
    * @param b value to compare.
@@ -668,8 +668,8 @@ protected Ordering() {}
    * <p><b>Implementation note:</b> this method is invoked by the default implementations of the
    * other {@code max} overloads, so overriding it will affect their behavior.
    *
-   * <p><b>Java 8 users:</b> Use {@code Collections.max(Arrays.asList(a, b), thisComparator)}
-   * instead (but note that it does not guarantee which tied maximum element is returned).
+   * <p><b>Note:</b> Consider using {@code Comparators.max(a, b, thisComparator)} instead. If {@code
+   * thisComparator} is {@link Ordering#natural}, then use {@code Comparators.max(a, b)}.
    *
    * @param a value to compare, returned if greater than or equal to b.
    * @param b value to compare., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Efficient UnmodifiableMultimap forEach

forEach can pass calls directly to the delegate protected
collection because it is a read-only operation.

Fixes #3911
Fixes #3912

98a616453df021b0792beb71c81b94d73e0cb69b

-------

<p> Add Comparators.min/max

RELNOTES=`collect`: Added two-element min and max methods to Comparators.

fc7433e647e82057ccc040885bf38dc503465d54

-------

<p> Discourage Ordering.min(E, E) and max(E, E) in favor of Comparators.min(E, E, Comparator) and max(E, E, Comparator).

RELNOTES=Discourage the use of Ordering.min(E, E) and max(E, E).

8bf31e175d0f103ade07a351ed6135496f635991",MOE Sync 2020-06-08
3924,Chris Povirk,"['android/guava-tests/test/com/google/common/collect/MapsTest.java', 'guava-tests/test/com/google/common/collect/MapsTest.java']","@@ -245,6 +245,8 @@ public void testLinkedHashMapGeneralizesTypes() {
     assertEquals(original, map);
   }
 
+  // Intentionally using IdentityHashMap to test creation.
+  @SuppressWarnings(""IdentityHashMapBoxing"")
   public void testIdentityHashMap() {
     IdentityHashMap<Integer, Integer> map = Maps.newIdentityHashMap();
     assertEquals(Collections.emptyMap(), map);, @@ -245,6 +245,8 @@ public void testLinkedHashMapGeneralizesTypes() {
     assertEquals(original, map);
   }
 
+  // Intentionally using IdentityHashMap to test creation.
+  @SuppressWarnings(""IdentityHashMapBoxing"")
   public void testIdentityHashMap() {
     IdentityHashMap<Integer, Integer> map = Maps.newIdentityHashMap();
     assertEquals(Collections.emptyMap(), map);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Suppress IdentityHashMapBoxing check

6d6dcf2a14a3cf58feed2f5eb4bbe5c69eaabd83",MOE Sync 2020-06-09
3925,Chris Povirk,"['android/guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/Converter.java']","@@ -20,6 +20,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.ForOverride;
 import com.google.errorprone.annotations.concurrent.LazyInit;
+import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.Iterator;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
@@ -241,7 +242,7 @@ public void remove() {
 
   private static final class ReverseConverter<A, B> extends Converter<B, A>
       implements Serializable {
-    final Converter<A, B> original;
+    @RetainedWith final Converter<A, B> original;
 
     ReverseConverter(Converter<A, B> original) {
       this.original = original;, @@ -20,6 +20,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.ForOverride;
 import com.google.errorprone.annotations.concurrent.LazyInit;
+import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.Iterator;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -240,7 +241,7 @@ public void remove() {
 
   private static final class ReverseConverter<A, B> extends Converter<B, A>
       implements Serializable {
-    final Converter<A, B> original;
+    @RetainedWith final Converter<A, B> original;
 
     ReverseConverter(Converter<A, B> original) {
       this.original = original;, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Break retain-cycle in Converter.java, when used in J2ObjC target.

4e820ef25352203e042bc4fc45547fae3da7c55d",MOE Sync 2020-06-10
3930,Chris Povirk,"['android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java']","@@ -48,7 +48,7 @@ public void testCopyChannel() throws IOException {
 
     ReadableByteChannel inChannel = Channels.newChannel(new ByteArrayInputStream(expected));
     ByteStreams.copy(inChannel, outChannel);
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testCopyFileChannel() throws IOException {
@@ -68,7 +68,7 @@ public void testCopyFileChannel() throws IOException {
     }
     byte[] actual = out.toByteArray();
     for (int i = 0; i < 500 * chunkSize; i += chunkSize) {
-      assertEquals(dummyData, Arrays.copyOfRange(actual, i, i + chunkSize));
+      assertThat(Arrays.copyOfRange(actual, i, i + chunkSize)).isEqualTo(dummyData);
     }
   }
 
@@ -119,15 +119,15 @@ public void testReadFully() throws IOException {
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 0);
-    assertEquals(new byte[10], b);
+    assertThat(b).isEqualTo(new byte[10]);
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 10);
-    assertEquals(newPreFilledByteArray(10), b);
+    assertThat(b).isEqualTo(newPreFilledByteArray(10));
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 5);
-    assertEquals(new byte[] {0, 1, 2, 3, 4, 0, 0, 0, 0, 0}, b);
+    assertThat(b).isEqualTo(new byte[] {0, 1, 2, 3, 4, 0, 0, 0, 0, 0});
   }
 
   public void testSkipFully() throws IOException {
@@ -177,7 +177,7 @@ public void testNewDataInput_readFully() {
     ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
     byte[] actual = new byte[bytes.length];
     in.readFully(actual);
-    assertEquals(bytes, actual);
+    assertThat(actual).isEqualTo(bytes);
   }
 
   public void testNewDataInput_readFullyAndThenSome() {
@@ -317,54 +317,54 @@ public void testNewDataOutput_writeInt() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeInt(0x12345678);
     out.writeInt(0x76543210);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_sized() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput(4);
     out.writeInt(0x12345678);
     out.writeInt(0x76543210);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeLong() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeLong(0x1234567876543210L);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeByteArray() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(bytes);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeByte() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(0x12);
     out.writeByte(0x34);
-    assertEquals(new byte[] {0x12, 0x34}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0x12, 0x34});
   }
 
   public void testNewDataOutput_writeByteOffset() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(bytes, 4, 2);
     byte[] expected = {bytes[4], bytes[5]};
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeBoolean() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeBoolean(true);
     out.writeBoolean(false);
     byte[] expected = {(byte) 1, (byte) 0};
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeChar() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeChar('a');
-    assertEquals(new byte[] {0, 97}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0, 97});
   }
 
   // Hardcoded because of Android problems. See testUtf16Expected.
@@ -376,14 +376,14 @@ public void testNewDataOutput_writeChars() {
     out.writeChars(""r\u00C9sum\u00C9"");
     // need to remove byte order mark before comparing
     byte[] expected = Arrays.copyOfRange(utf16ExpectedWithBom, 2, 14);
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   @AndroidIncompatible // https://code.google.com/p/android/issues/detail?id=196848
   public void testUtf16Expected() {
     byte[] hardcodedExpected = utf16ExpectedWithBom;
     byte[] computedExpected = ""r\u00C9sum\u00C9"".getBytes(Charsets.UTF_16);
-    assertEquals(hardcodedExpected, computedExpected);
+    assertThat(computedExpected).isEqualTo(hardcodedExpected);
   }
 
   public void testNewDataOutput_writeUTF() {
@@ -394,93 +394,93 @@ public void testNewDataOutput_writeUTF() {
     // writeUTF writes the length of the string in 2 bytes
     assertEquals(0, actual[0]);
     assertEquals(expected.length, actual[1]);
-    assertEquals(expected, Arrays.copyOfRange(actual, 2, actual.length));
+    assertThat(Arrays.copyOfRange(actual, 2, actual.length)).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeShort() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeShort(0x1234);
-    assertEquals(new byte[] {0x12, 0x34}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0x12, 0x34});
   }
 
   public void testNewDataOutput_writeDouble() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeDouble(Double.longBitsToDouble(0x1234567876543210L));
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeFloat() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeFloat(Float.intBitsToFloat(0x12345678));
     out.writeFloat(Float.intBitsToFloat(0x76543210));
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_BAOS() {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     ByteArrayDataOutput out = ByteStreams.newDataOutput(baos);
     out.writeInt(0x12345678);
     assertEquals(4, baos.size());
-    assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
+    assertThat(baos.toByteArray()).isEqualTo(new byte[] {0x12, 0x34, 0x56, 0x78});
   }
 
   private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
 
   public void testToByteArray() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_emptyStream() throws IOException {
     InputStream in = newTestStream(0);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(new byte[0], b);
+    assertThat(b).isEqualTo(new byte[0]);
   }
 
   public void testToByteArray_largeStream() throws IOException {
     // well, large enough to require multiple buffers
     byte[] expected = newPreFilledByteArray(10000000);
     InputStream in = new ByteArrayInputStream(expected);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(expected, b);
+    assertThat(b).isEqualTo(expected);
   }
 
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     // this results in toByteArrayInternal being called when the stream is actually exhausted
     byte[] b = ByteStreams.toByteArray(in, 99);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 98);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testExhaust() throws IOException {
@@ -515,8 +515,8 @@ public long skip(long n) throws IOException {
 
   public void testReadBytes() throws IOException {
     final byte[] array = newPreFilledByteArray(1000);
-    assertEquals(
-        array, ByteStreams.readBytes(new ByteArrayInputStream(array), new TestByteProcessor()));
+    assertThat(ByteStreams.readBytes(new ByteArrayInputStream(array), new TestByteProcessor()))
+        .isEqualTo(array);
   }
 
   private static class TestByteProcessor implements ByteProcessor<byte[]> {
@@ -543,7 +543,8 @@ public void testByteProcessorStopEarly() throws IOException {
             new ByteProcessor<Integer>() {
               @Override
               public boolean processBytes(byte[] buf, int off, int len) {
-                assertEquals(Arrays.copyOfRange(buf, off, off + len), newPreFilledByteArray(8192));
+                assertThat(newPreFilledByteArray(8192))
+                    .isEqualTo(Arrays.copyOfRange(buf, off, off + len));
                 return false;
               }
 
@@ -670,9 +671,4 @@ public boolean markSupported() {
       return false;
     }
   }
-
-  // TODO(cpovirk): Inline this.
-  private static void assertEquals(byte[] expected, byte[] actual) {
-    assertThat(actual).isEqualTo(expected);
-  }
 }, @@ -48,7 +48,7 @@ public void testCopyChannel() throws IOException {
 
     ReadableByteChannel inChannel = Channels.newChannel(new ByteArrayInputStream(expected));
     ByteStreams.copy(inChannel, outChannel);
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testCopyFileChannel() throws IOException {
@@ -68,7 +68,7 @@ public void testCopyFileChannel() throws IOException {
     }
     byte[] actual = out.toByteArray();
     for (int i = 0; i < 500 * chunkSize; i += chunkSize) {
-      assertEquals(dummyData, Arrays.copyOfRange(actual, i, i + chunkSize));
+      assertThat(Arrays.copyOfRange(actual, i, i + chunkSize)).isEqualTo(dummyData);
     }
   }
 
@@ -119,15 +119,15 @@ public void testReadFully() throws IOException {
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 0);
-    assertEquals(new byte[10], b);
+    assertThat(b).isEqualTo(new byte[10]);
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 10);
-    assertEquals(newPreFilledByteArray(10), b);
+    assertThat(b).isEqualTo(newPreFilledByteArray(10));
 
     Arrays.fill(b, (byte) 0);
     ByteStreams.readFully(newTestStream(10), b, 0, 5);
-    assertEquals(new byte[] {0, 1, 2, 3, 4, 0, 0, 0, 0, 0}, b);
+    assertThat(b).isEqualTo(new byte[] {0, 1, 2, 3, 4, 0, 0, 0, 0, 0});
   }
 
   public void testSkipFully() throws IOException {
@@ -177,7 +177,7 @@ public void testNewDataInput_readFully() {
     ByteArrayDataInput in = ByteStreams.newDataInput(bytes);
     byte[] actual = new byte[bytes.length];
     in.readFully(actual);
-    assertEquals(bytes, actual);
+    assertThat(actual).isEqualTo(bytes);
   }
 
   public void testNewDataInput_readFullyAndThenSome() {
@@ -317,54 +317,54 @@ public void testNewDataOutput_writeInt() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeInt(0x12345678);
     out.writeInt(0x76543210);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_sized() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput(4);
     out.writeInt(0x12345678);
     out.writeInt(0x76543210);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeLong() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeLong(0x1234567876543210L);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeByteArray() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(bytes);
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeByte() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(0x12);
     out.writeByte(0x34);
-    assertEquals(new byte[] {0x12, 0x34}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0x12, 0x34});
   }
 
   public void testNewDataOutput_writeByteOffset() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.write(bytes, 4, 2);
     byte[] expected = {bytes[4], bytes[5]};
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeBoolean() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeBoolean(true);
     out.writeBoolean(false);
     byte[] expected = {(byte) 1, (byte) 0};
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeChar() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeChar('a');
-    assertEquals(new byte[] {0, 97}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0, 97});
   }
 
   // Hardcoded because of Android problems. See testUtf16Expected.
@@ -376,14 +376,14 @@ public void testNewDataOutput_writeChars() {
     out.writeChars(""r\u00C9sum\u00C9"");
     // need to remove byte order mark before comparing
     byte[] expected = Arrays.copyOfRange(utf16ExpectedWithBom, 2, 14);
-    assertEquals(expected, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
   @AndroidIncompatible // https://code.google.com/p/android/issues/detail?id=196848
   public void testUtf16Expected() {
     byte[] hardcodedExpected = utf16ExpectedWithBom;
     byte[] computedExpected = ""r\u00C9sum\u00C9"".getBytes(Charsets.UTF_16);
-    assertEquals(hardcodedExpected, computedExpected);
+    assertThat(computedExpected).isEqualTo(hardcodedExpected);
   }
 
   public void testNewDataOutput_writeUTF() {
@@ -394,93 +394,93 @@ public void testNewDataOutput_writeUTF() {
     // writeUTF writes the length of the string in 2 bytes
     assertEquals(0, actual[0]);
     assertEquals(expected.length, actual[1]);
-    assertEquals(expected, Arrays.copyOfRange(actual, 2, actual.length));
+    assertThat(Arrays.copyOfRange(actual, 2, actual.length)).isEqualTo(expected);
   }
 
   public void testNewDataOutput_writeShort() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeShort(0x1234);
-    assertEquals(new byte[] {0x12, 0x34}, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(new byte[] {0x12, 0x34});
   }
 
   public void testNewDataOutput_writeDouble() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeDouble(Double.longBitsToDouble(0x1234567876543210L));
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_writeFloat() {
     ByteArrayDataOutput out = ByteStreams.newDataOutput();
     out.writeFloat(Float.intBitsToFloat(0x12345678));
     out.writeFloat(Float.intBitsToFloat(0x76543210));
-    assertEquals(bytes, out.toByteArray());
+    assertThat(out.toByteArray()).isEqualTo(bytes);
   }
 
   public void testNewDataOutput_BAOS() {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     ByteArrayDataOutput out = ByteStreams.newDataOutput(baos);
     out.writeInt(0x12345678);
     assertEquals(4, baos.size());
-    assertEquals(new byte[] {0x12, 0x34, 0x56, 0x78}, baos.toByteArray());
+    assertThat(baos.toByteArray()).isEqualTo(new byte[] {0x12, 0x34, 0x56, 0x78});
   }
 
   private static final byte[] PRE_FILLED_100 = newPreFilledByteArray(100);
 
   public void testToByteArray() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_emptyStream() throws IOException {
     InputStream in = newTestStream(0);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(new byte[0], b);
+    assertThat(b).isEqualTo(new byte[0]);
   }
 
   public void testToByteArray_largeStream() throws IOException {
     // well, large enough to require multiple buffers
     byte[] expected = newPreFilledByteArray(10000000);
     InputStream in = new ByteArrayInputStream(expected);
     byte[] b = ByteStreams.toByteArray(in);
-    assertEquals(expected, b);
+    assertThat(b).isEqualTo(expected);
   }
 
   public void testToByteArray_withSize_givenCorrectSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 100);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSmallerSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 80);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenLargerSize() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 120);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeZero() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 0);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeOneSmallerThanActual() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     // this results in toByteArrayInternal being called when the stream is actually exhausted
     byte[] b = ByteStreams.toByteArray(in, 99);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testToByteArray_withSize_givenSizeTwoSmallerThanActual() throws IOException {
     InputStream in = new ByteArrayInputStream(PRE_FILLED_100);
     byte[] b = ByteStreams.toByteArray(in, 98);
-    assertEquals(PRE_FILLED_100, b);
+    assertThat(b).isEqualTo(PRE_FILLED_100);
   }
 
   public void testExhaust() throws IOException {
@@ -515,8 +515,8 @@ public long skip(long n) throws IOException {
 
   public void testReadBytes() throws IOException {
     final byte[] array = newPreFilledByteArray(1000);
-    assertEquals(
-        array, ByteStreams.readBytes(new ByteArrayInputStream(array), new TestByteProcessor()));
+    assertThat(ByteStreams.readBytes(new ByteArrayInputStream(array), new TestByteProcessor()))
+        .isEqualTo(array);
   }
 
   private static class TestByteProcessor implements ByteProcessor<byte[]> {
@@ -543,7 +543,8 @@ public void testByteProcessorStopEarly() throws IOException {
             new ByteProcessor<Integer>() {
               @Override
               public boolean processBytes(byte[] buf, int off, int len) {
-                assertEquals(Arrays.copyOfRange(buf, off, off + len), newPreFilledByteArray(8192));
+                assertThat(newPreFilledByteArray(8192))
+                    .isEqualTo(Arrays.copyOfRange(buf, off, off + len));
                 return false;
               }
 
@@ -670,9 +671,4 @@ public boolean markSupported() {
       return false;
     }
   }
-
-  // TODO(cpovirk): Inline this.
-  private static void assertEquals(byte[] expected, byte[] actual) {
-    assertThat(actual).isEqualTo(expected);
-  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Cleanup ByteStreamsTest.java to fix a couple of IntelliJ warnings/suggestions.

#codehealh

acc2296fdea9cb498431a92eb5b363262b74b313

-------

<p> Inline `ByteStreamsTest#assertEquals(byte[], byte[])`

#codehealth

62ee8a07ad4d3c66e255da66a3382ac790656e2d",MOE Sync 2020-06-12
3931,Chris Povirk,"['android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'android/guava-tests/test/com/google/common/io/IoTestCase.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava-tests/test/com/google/common/io/IoTestCase.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -23,6 +23,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -41,7 +42,7 @@
  */
 public class ByteStreamsTest extends IoTestCase {
 
-  public void testCopyChannel() throws IOException {
+  public void testCopy_channel() throws IOException {
     byte[] expected = newPreFilledByteArray(100);
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -51,7 +52,7 @@ public void testCopyChannel() throws IOException {
     assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
-  public void testCopyFileChannel() throws IOException {
+  public void testCopy_channel_fromFile() throws IOException {
     final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -72,6 +73,68 @@ public void testCopyFileChannel() throws IOException {
     }
   }
 
+  public void testCopy_stream() throws IOException {
+    byte[] expected = newPreFilledByteArray(100);
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    ByteStreams.copy(new ByteArrayInputStream(expected), out);
+
+    assertThat(out.toByteArray()).isEqualTo(expected);
+  }
+
+  public void testCopy_stream_files_emptyDestination() throws IOException {
+    byte[] expected = new byte[] {0, 1, 2};
+    File inputFile = createTempFile(expected);
+    File outputFile = createTempFile();
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
+      ByteStreams.copy(inputStream, outputStream);
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(expected);
+  }
+
+  public void testCopy_stream_files_appendDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {3, 4, 5});
+    File outputFile = createTempFile(new byte[] {0, 1, 2});
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
+      ByteStreams.copy(inputStream, outputStream);
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 1, 2, 3, 4, 5});
+  }
+
+  public void testCopy_stream_files_additionalWrites_emptyDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {0, 1, 2});
+    File outputFile = createTempFile();
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
+      outputStream.write(new byte[] {0, 0});
+      ByteStreams.copy(inputStream, outputStream);
+      outputStream.write(new byte[] {2, 2});
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
+  }
+
+  public void testCopy_stream_files_additionalWrites_appendDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {0, 1, 2});
+    File outputFile = createTempFile(new byte[] {0});
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
+      outputStream.write(new byte[] {0});
+      ByteStreams.copy(inputStream, outputStream);
+      outputStream.write(new byte[] {2, 2});
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
+  }
+
   public void testReadFully() throws IOException {
     byte[] b = new byte[10];
 , @@ -139,6 +139,18 @@ protected final File createTempFile() throws IOException {
     return File.createTempFile(""test"", null, getTempDir());
   }
 
+  /**
+   * Creates a new temp file in the temp directory returned by {@link #getTempDir()}. The file will
+   * be deleted in the tear-down for this test.
+   *
+   * @param content which should be written to the file
+   */
+  protected final File createTempFile(byte[] content) throws IOException {
+    File file = File.createTempFile(""test"", null, getTempDir());
+    Files.write(content, file);
+    return file;
+  }
+
   /** Returns a byte array of length size that has values 0 .. size - 1. */
   static byte[] newPreFilledByteArray(int size) {
     return newPreFilledByteArray(0, size);, @@ -30,6 +30,8 @@
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -103,6 +105,15 @@ private ByteStreams() {}
   public static long copy(InputStream from, OutputStream to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
+
+    // Use java.nio.channels in case we're copying from file to file.
+    // Copying through channels happens ideally in the kernel space and therefore faster.
+    if (from instanceof FileInputStream && to instanceof FileOutputStream) {
+      FileChannel fromChannel = ((FileInputStream) from).getChannel();
+      FileChannel toChannel = ((FileOutputStream) to).getChannel();
+      return copyFileChannel(fromChannel, toChannel);
+    }
+
     byte[] buf = createBuffer();
     long total = 0;
     while (true) {
@@ -130,16 +141,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     checkNotNull(from);
     checkNotNull(to);
     if (from instanceof FileChannel) {
-      FileChannel sourceChannel = (FileChannel) from;
-      long oldPosition = sourceChannel.position();
-      long position = oldPosition;
-      long copied;
-      do {
-        copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
-        position += copied;
-        sourceChannel.position(position);
-      } while (copied > 0 || position < sourceChannel.size());
-      return position - oldPosition;
+      return copyFileChannel((FileChannel) from, to);
     }
 
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
@@ -154,6 +156,18 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
+  private static long copyFileChannel(FileChannel from, WritableByteChannel to) throws IOException {
+    long oldPosition = from.position();
+    long position = oldPosition;
+    long copied;
+    do {
+      copied = from.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
+      position += copied;
+      from.position(position);
+    } while (copied > 0 || position < from.size());
+    return position - oldPosition;
+  }
+
   /** Max array length on JVM. */
   private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
 , @@ -23,6 +23,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -41,7 +42,7 @@
  */
 public class ByteStreamsTest extends IoTestCase {
 
-  public void testCopyChannel() throws IOException {
+  public void testCopy_channel() throws IOException {
     byte[] expected = newPreFilledByteArray(100);
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -51,7 +52,7 @@ public void testCopyChannel() throws IOException {
     assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
-  public void testCopyFileChannel() throws IOException {
+  public void testCopy_channel_fromFile() throws IOException {
     final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -72,6 +73,68 @@ public void testCopyFileChannel() throws IOException {
     }
   }
 
+  public void testCopy_stream() throws IOException {
+    byte[] expected = newPreFilledByteArray(100);
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    ByteStreams.copy(new ByteArrayInputStream(expected), out);
+
+    assertThat(out.toByteArray()).isEqualTo(expected);
+  }
+
+  public void testCopy_stream_files_emptyDestination() throws IOException {
+    byte[] expected = new byte[] {0, 1, 2};
+    File inputFile = createTempFile(expected);
+    File outputFile = createTempFile();
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
+      ByteStreams.copy(inputStream, outputStream);
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(expected);
+  }
+
+  public void testCopy_stream_files_appendDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {3, 4, 5});
+    File outputFile = createTempFile(new byte[] {0, 1, 2});
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
+      ByteStreams.copy(inputStream, outputStream);
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 1, 2, 3, 4, 5});
+  }
+
+  public void testCopy_stream_files_additionalWrites_emptyDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {0, 1, 2});
+    File outputFile = createTempFile();
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
+      outputStream.write(new byte[] {0, 0});
+      ByteStreams.copy(inputStream, outputStream);
+      outputStream.write(new byte[] {2, 2});
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
+  }
+
+  public void testCopy_stream_files_additionalWrites_appendDestination() throws IOException {
+    File inputFile = createTempFile(new byte[] {0, 1, 2});
+    File outputFile = createTempFile(new byte[] {0});
+
+    try (FileInputStream inputStream = new FileInputStream(inputFile);
+        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
+      outputStream.write(new byte[] {0});
+      ByteStreams.copy(inputStream, outputStream);
+      outputStream.write(new byte[] {2, 2});
+    }
+
+    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
+  }
+
   public void testReadFully() throws IOException {
     byte[] b = new byte[10];
 , @@ -139,6 +139,18 @@ protected final File createTempFile() throws IOException {
     return File.createTempFile(""test"", null, getTempDir());
   }
 
+  /**
+   * Creates a new temp file in the temp directory returned by {@link #getTempDir()}. The file will
+   * be deleted in the tear-down for this test.
+   *
+   * @param content which should be written to the file
+   */
+  protected final File createTempFile(byte[] content) throws IOException {
+    File file = File.createTempFile(""test"", null, getTempDir());
+    Files.write(content, file);
+    return file;
+  }
+
   /** Returns a byte array of length size that has values 0 .. size - 1. */
   static byte[] newPreFilledByteArray(int size) {
     return newPreFilledByteArray(0, size);, @@ -30,6 +30,8 @@
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -103,6 +105,15 @@ private ByteStreams() {}
   public static long copy(InputStream from, OutputStream to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
+
+    // Use java.nio.channels in case we're copying from file to file.
+    // Copying through channels happens ideally in the kernel space and therefore faster.
+    if (from instanceof FileInputStream && to instanceof FileOutputStream) {
+      FileChannel fromChannel = ((FileInputStream) from).getChannel();
+      FileChannel toChannel = ((FileOutputStream) to).getChannel();
+      return copyFileChannel(fromChannel, toChannel);
+    }
+
     byte[] buf = createBuffer();
     long total = 0;
     while (true) {
@@ -130,16 +141,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     checkNotNull(from);
     checkNotNull(to);
     if (from instanceof FileChannel) {
-      FileChannel sourceChannel = (FileChannel) from;
-      long oldPosition = sourceChannel.position();
-      long position = oldPosition;
-      long copied;
-      do {
-        copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
-        position += copied;
-        sourceChannel.position(position);
-      } while (copied > 0 || position < sourceChannel.size());
-      return position - oldPosition;
+      return copyFileChannel((FileChannel) from, to);
     }
 
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
@@ -154,6 +156,18 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
+  private static long copyFileChannel(FileChannel from, WritableByteChannel to) throws IOException {
+    long oldPosition = from.position();
+    long position = oldPosition;
+    long copied;
+    do {
+      copied = from.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
+      position += copied;
+      from.position(position);
+    } while (copied > 0 || position < from.size());
+    return position - oldPosition;
+  }
+
   /** Max array length on JVM. */
   private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Upgraded ByteStreams#copy(InputStream, OutputStream) to use the faster FileChannel if possible.
See also https://medium.com/@xunnan.xu/its-all-about-buffers-zero-copy-mmap-and-java-nio-50f2a1bfc05c for some background.

RELNOTES=`io`: Upgraded `ByteStreams#copy(InputStream, OutputStream)` to use the faster `FileChannel` if possible.

27bc3deb733b2f38bd853953fa21e2e116fc6c34",MOE Sync 2020-06-12
3936,Nick,"['android/guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'android/guava-tests/test/com/google/common/io/IoTestCase.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'guava-tests/test/com/google/common/io/ByteStreamsTest.java', 'guava-tests/test/com/google/common/io/IoTestCase.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -23,7 +23,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -42,7 +41,7 @@
  */
 public class ByteStreamsTest extends IoTestCase {
 
-  public void testCopy_channel() throws IOException {
+  public void testCopyChannel() throws IOException {
     byte[] expected = newPreFilledByteArray(100);
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -52,7 +51,7 @@ public void testCopy_channel() throws IOException {
     assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
-  public void testCopy_channel_fromFile() throws IOException {
+  public void testCopyFileChannel() throws IOException {
     final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -73,68 +72,6 @@ public void testCopy_channel_fromFile() throws IOException {
     }
   }
 
-  public void testCopy_stream() throws IOException {
-    byte[] expected = newPreFilledByteArray(100);
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    ByteStreams.copy(new ByteArrayInputStream(expected), out);
-
-    assertThat(out.toByteArray()).isEqualTo(expected);
-  }
-
-  public void testCopy_stream_files_emptyDestination() throws IOException {
-    byte[] expected = new byte[] {0, 1, 2};
-    File inputFile = createTempFile(expected);
-    File outputFile = createTempFile();
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
-      ByteStreams.copy(inputStream, outputStream);
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(expected);
-  }
-
-  public void testCopy_stream_files_appendDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {3, 4, 5});
-    File outputFile = createTempFile(new byte[] {0, 1, 2});
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
-      ByteStreams.copy(inputStream, outputStream);
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 1, 2, 3, 4, 5});
-  }
-
-  public void testCopy_stream_files_additionalWrites_emptyDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {0, 1, 2});
-    File outputFile = createTempFile();
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
-      outputStream.write(new byte[] {0, 0});
-      ByteStreams.copy(inputStream, outputStream);
-      outputStream.write(new byte[] {2, 2});
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
-  }
-
-  public void testCopy_stream_files_additionalWrites_appendDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {0, 1, 2});
-    File outputFile = createTempFile(new byte[] {0});
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
-      outputStream.write(new byte[] {0});
-      ByteStreams.copy(inputStream, outputStream);
-      outputStream.write(new byte[] {2, 2});
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
-  }
-
   public void testReadFully() throws IOException {
     byte[] b = new byte[10];
 , @@ -139,18 +139,6 @@ protected final File createTempFile() throws IOException {
     return File.createTempFile(""test"", null, getTempDir());
   }
 
-  /**
-   * Creates a new temp file in the temp directory returned by {@link #getTempDir()}. The file will
-   * be deleted in the tear-down for this test.
-   *
-   * @param content which should be written to the file
-   */
-  protected final File createTempFile(byte[] content) throws IOException {
-    File file = File.createTempFile(""test"", null, getTempDir());
-    Files.write(content, file);
-    return file;
-  }
-
   /** Returns a byte array of length size that has values 0 .. size - 1. */
   static byte[] newPreFilledByteArray(int size) {
     return newPreFilledByteArray(0, size);, @@ -30,8 +30,6 @@
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -105,15 +103,6 @@ private ByteStreams() {}
   public static long copy(InputStream from, OutputStream to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
-
-    // Use java.nio.channels in case we're copying from file to file.
-    // Copying through channels happens ideally in the kernel space and therefore faster.
-    if (from instanceof FileInputStream && to instanceof FileOutputStream) {
-      FileChannel fromChannel = ((FileInputStream) from).getChannel();
-      FileChannel toChannel = ((FileOutputStream) to).getChannel();
-      return copyFileChannel(fromChannel, toChannel);
-    }
-
     byte[] buf = createBuffer();
     long total = 0;
     while (true) {
@@ -141,7 +130,16 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     checkNotNull(from);
     checkNotNull(to);
     if (from instanceof FileChannel) {
-      return copyFileChannel((FileChannel) from, to);
+      FileChannel sourceChannel = (FileChannel) from;
+      long oldPosition = sourceChannel.position();
+      long position = oldPosition;
+      long copied;
+      do {
+        copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
+        position += copied;
+        sourceChannel.position(position);
+      } while (copied > 0 || position < sourceChannel.size());
+      return position - oldPosition;
     }
 
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
@@ -156,18 +154,6 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
-  private static long copyFileChannel(FileChannel from, WritableByteChannel to) throws IOException {
-    long oldPosition = from.position();
-    long position = oldPosition;
-    long copied;
-    do {
-      copied = from.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
-      position += copied;
-      from.position(position);
-    } while (copied > 0 || position < from.size());
-    return position - oldPosition;
-  }
-
   /** Max array length on JVM. */
   private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
 , @@ -23,7 +23,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
@@ -42,7 +41,7 @@
  */
 public class ByteStreamsTest extends IoTestCase {
 
-  public void testCopy_channel() throws IOException {
+  public void testCopyChannel() throws IOException {
     byte[] expected = newPreFilledByteArray(100);
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -52,7 +51,7 @@ public void testCopy_channel() throws IOException {
     assertThat(out.toByteArray()).isEqualTo(expected);
   }
 
-  public void testCopy_channel_fromFile() throws IOException {
+  public void testCopyFileChannel() throws IOException {
     final int chunkSize = 14407; // Random prime, unlikely to match any internal chunk size
     ByteArrayOutputStream out = new ByteArrayOutputStream();
     WritableByteChannel outChannel = Channels.newChannel(out);
@@ -73,68 +72,6 @@ public void testCopy_channel_fromFile() throws IOException {
     }
   }
 
-  public void testCopy_stream() throws IOException {
-    byte[] expected = newPreFilledByteArray(100);
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    ByteStreams.copy(new ByteArrayInputStream(expected), out);
-
-    assertThat(out.toByteArray()).isEqualTo(expected);
-  }
-
-  public void testCopy_stream_files_emptyDestination() throws IOException {
-    byte[] expected = new byte[] {0, 1, 2};
-    File inputFile = createTempFile(expected);
-    File outputFile = createTempFile();
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
-      ByteStreams.copy(inputStream, outputStream);
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(expected);
-  }
-
-  public void testCopy_stream_files_appendDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {3, 4, 5});
-    File outputFile = createTempFile(new byte[] {0, 1, 2});
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
-      ByteStreams.copy(inputStream, outputStream);
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 1, 2, 3, 4, 5});
-  }
-
-  public void testCopy_stream_files_additionalWrites_emptyDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {0, 1, 2});
-    File outputFile = createTempFile();
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile)) {
-      outputStream.write(new byte[] {0, 0});
-      ByteStreams.copy(inputStream, outputStream);
-      outputStream.write(new byte[] {2, 2});
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
-  }
-
-  public void testCopy_stream_files_additionalWrites_appendDestination() throws IOException {
-    File inputFile = createTempFile(new byte[] {0, 1, 2});
-    File outputFile = createTempFile(new byte[] {0});
-
-    try (FileInputStream inputStream = new FileInputStream(inputFile);
-        FileOutputStream outputStream = new FileOutputStream(outputFile, /* append= */ true)) {
-      outputStream.write(new byte[] {0});
-      ByteStreams.copy(inputStream, outputStream);
-      outputStream.write(new byte[] {2, 2});
-    }
-
-    assertThat(Files.asByteSource(outputFile).read()).isEqualTo(new byte[] {0, 0, 0, 1, 2, 2, 2});
-  }
-
   public void testReadFully() throws IOException {
     byte[] b = new byte[10];
 , @@ -139,18 +139,6 @@ protected final File createTempFile() throws IOException {
     return File.createTempFile(""test"", null, getTempDir());
   }
 
-  /**
-   * Creates a new temp file in the temp directory returned by {@link #getTempDir()}. The file will
-   * be deleted in the tear-down for this test.
-   *
-   * @param content which should be written to the file
-   */
-  protected final File createTempFile(byte[] content) throws IOException {
-    File file = File.createTempFile(""test"", null, getTempDir());
-    Files.write(content, file);
-    return file;
-  }
-
   /** Returns a byte array of length size that has values 0 .. size - 1. */
   static byte[] newPreFilledByteArray(int size) {
     return newPreFilledByteArray(0, size);, @@ -30,8 +30,6 @@
 import java.io.DataOutput;
 import java.io.DataOutputStream;
 import java.io.EOFException;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.FilterInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -105,15 +103,6 @@ private ByteStreams() {}
   public static long copy(InputStream from, OutputStream to) throws IOException {
     checkNotNull(from);
     checkNotNull(to);
-
-    // Use java.nio.channels in case we're copying from file to file.
-    // Copying through channels happens ideally in the kernel space and therefore faster.
-    if (from instanceof FileInputStream && to instanceof FileOutputStream) {
-      FileChannel fromChannel = ((FileInputStream) from).getChannel();
-      FileChannel toChannel = ((FileOutputStream) to).getChannel();
-      return copyFileChannel(fromChannel, toChannel);
-    }
-
     byte[] buf = createBuffer();
     long total = 0;
     while (true) {
@@ -141,7 +130,16 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     checkNotNull(from);
     checkNotNull(to);
     if (from instanceof FileChannel) {
-      return copyFileChannel((FileChannel) from, to);
+      FileChannel sourceChannel = (FileChannel) from;
+      long oldPosition = sourceChannel.position();
+      long position = oldPosition;
+      long copied;
+      do {
+        copied = sourceChannel.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
+        position += copied;
+        sourceChannel.position(position);
+      } while (copied > 0 || position < sourceChannel.size());
+      return position - oldPosition;
     }
 
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
@@ -156,18 +154,6 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     return total;
   }
 
-  private static long copyFileChannel(FileChannel from, WritableByteChannel to) throws IOException {
-    long oldPosition = from.position();
-    long position = oldPosition;
-    long copied;
-    do {
-      copied = from.transferTo(position, ZERO_COPY_CHUNK_SIZE, to);
-      position += copied;
-      from.position(position);
-    } while (copied > 0 || position < from.size());
-    return position - oldPosition;
-  }
-
   /** Max array length on JVM. */
   private static final int MAX_ARRAY_LEN = Integer.MAX_VALUE - 8;
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Revert a1e9a0bd1260a657f7502e5b81d38dfb818cd1d4

Causing some internal failures

457767d10299005df3f7a3e7aba3eef8ee528b9a",MOE Sync 2020-06-16
3937,Nick,"['android/guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'android/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java', 'cycle_whitelist.txt', 'guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'guava/src/com/google/common/util/concurrent/ExecutionSequencer.java']","@@ -15,13 +15,9 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.util.concurrent.Futures.allAsList;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
-import com.google.common.annotations.GwtIncompatible;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -144,114 +140,6 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
-  public void testAvoidsStackOverflow_manyQueued() throws Exception {
-    final SettableFuture<Void> settableFuture = SettableFuture.create();
-    ArrayList<ListenableFuture<Void>> results = new ArrayList<>(50_001);
-    results.add(
-        serializer.submitAsync(
-            new AsyncCallable<Void>() {
-              @Override
-              public ListenableFuture<Void> call() {
-                return settableFuture;
-              }
-            },
-            directExecutor()));
-    for (int i = 0; i < 50_000; i++) {
-      results.add(serializer.submit(Callables.<Void>returning(null), directExecutor()));
-    }
-    settableFuture.set(null);
-    getDone(allAsList(results));
-  }
-
-  private static final class LongHolder {
-    long count;
-  }
-
-  private static final int ITERATION_COUNT = 50_000;
-  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
-
-  @GwtIncompatible // threads
-
-  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
-    final LongHolder holder = new LongHolder();
-    final ArrayList<ListenableFuture<Integer>> lengthChecks = new ArrayList<>();
-    final List<Integer> completeLengthChecks;
-    final int baseStackDepth;
-    ExecutorService service = Executors.newFixedThreadPool(5);
-    try {
-      // Avoid counting frames from the executor itself, or the ExecutionSequencer
-      baseStackDepth =
-          serializer
-              .submit(
-                  new Callable<Integer>() {
-                    @Override
-                    public Integer call() {
-                      return Thread.currentThread().getStackTrace().length;
-                    }
-                  },
-                  service)
-              .get();
-      final SettableFuture<Void> settableFuture = SettableFuture.create();
-      ListenableFuture<?> unused =
-          serializer.submitAsync(
-              new AsyncCallable<Void>() {
-                @Override
-                public ListenableFuture<Void> call() {
-                  return settableFuture;
-                }
-              },
-              directExecutor());
-      for (int i = 0; i < 50_000; i++) {
-        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
-          // after some number of iterations, switch threads
-          unused =
-              serializer.submit(
-                  new Callable<Void>() {
-                    @Override
-                    public Void call() {
-                      holder.count++;
-                      return null;
-                    }
-                  },
-                  service);
-        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
-          // When at max depth, record stack trace depth
-          lengthChecks.add(
-              serializer.submit(
-                  new Callable<Integer>() {
-                    @Override
-                    public Integer call() {
-                      holder.count++;
-                      return Thread.currentThread().getStackTrace().length;
-                    }
-                  },
-                  directExecutor()));
-        } else {
-          // Otherwise, schedule a task on directExecutor
-          unused =
-              serializer.submit(
-                  new Callable<Void>() {
-                    @Override
-                    public Void call() {
-                      holder.count++;
-                      return null;
-                    }
-                  },
-                  directExecutor());
-        }
-      }
-      settableFuture.set(null);
-      completeLengthChecks = allAsList(lengthChecks).get();
-    } finally {
-      service.shutdown();
-    }
-    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
-    for (int length : completeLengthChecks) {
-      // Verify that at max depth, less than one stack frame per submitted task was consumed
-      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
-    }
-  }
-
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, @@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
@@ -59,8 +58,6 @@ public static ExecutionSequencer create() {
   private final AtomicReference<ListenableFuture<Object>> ref =
       new AtomicReference<>(immediateFuture(null));
 
-  private ThreadAndTask threadAndTask = new ThreadAndTask();
-
   /**
    * Enqueues a task to run when the previous task (if any) completes.
    *
@@ -70,7 +67,6 @@ public static ExecutionSequencer create() {
    */
   public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
     checkNotNull(callable);
-    checkNotNull(executor);
     return submitAsync(
         new AsyncCallable<T>() {
           @Override
@@ -96,7 +92,6 @@ public String toString() {
   public <T> ListenableFuture<T> submitAsync(
       final AsyncCallable<T> callable, final Executor executor) {
     checkNotNull(callable);
-    checkNotNull(executor);
     final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
     final AsyncCallable<T> task =
         new AsyncCallable<T>() {
@@ -135,7 +130,7 @@ public String toString() {
             new Executor() {
               @Override
               public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, new NonReentrantExecutor(executor));
+                oldFuture.addListener(runnable, executor);
               }
             });
 
@@ -169,124 +164,4 @@ public void run() {
 
     return outputFuture;
   }
-
-  /**
-   * This object is unsafely published, but avoids problematic races by relying exclusively on the
-   * identity equality of its Thread field so that the task field is only accessed by a single
-   * thread.
-   */
-  private static final class ThreadAndTask {
-    /**
-     * This field is only used for identity comparisons with the current thread. Field assignments
-     * are atomic, but do not provide happens-before ordering; however:
-     *
-     * <ul>
-     *   <li>If this field's value == currentThread, we know that it's up to date, because write
-     *       operations in a thread always happen-before subsequent read operations in the same
-     *       thread
-     *   <li>If this field's value == null because of unsafe publication, we know that it isn't the
-     *       object associated with our thread, because if it was the publication wouldn't have been
-     *       unsafe and we'd have seen our thread as the value. This state is also why a new
-     *       ThreadAndTask object must be created for each inline execution, because observing a
-     *       null thread does not mean the object is safe to reuse.
-     *   <li>If this field's value is some other thread object, we know that it's not our thread.
-     *   <li>If this field's value == null because it originally belonged to another thread and that
-     *       thread cleared it, we still know that it's not associated with our thread
-     *   <li>If this field's value == null because it was associated with our thread and was
-     *       cleared, we know that we're not executing inline any more
-     * </ul>
-     *
-     * All the states where thread != currentThread are identical for our purposes, and so even
-     * though it's racy, we don't care which of those values we get, so no need to synchronize.
-     */
-    Thread thread;
-    /** Only used by the thread associated with this object */
-    Runnable task;
-  }
-
-  /**
-   * This class helps avoid a StackOverflowError when large numbers of tasks are submitted with
-   * {@link MoreExecutors#directExecutor}. Normally, when the first future completes, all the other
-   * tasks would be called recursively. Here, we detect that the delegate executor is executing
-   * inline, and maintain a queue to dispatch tasks iteratively.
-   *
-   * <p>This class would certainly be simpler and easier to reason about if it were built with
-   * ThreadLocal; however, ThreadLocal is not well optimized for the case where the ThreadLocal is
-   * non-static, and is initialized/removed frequently - this causes churn in the Thread specific
-   * hashmaps. Using a static ThreadLocal to avoid that overhead would mean that different
-   * ExecutionSequencer objects interfere with each other, which would be undesirable, in addition
-   * to increasing the memory footprint of every thread that interacted with it. In order to release
-   * entries in thread-specific maps when the ThreadLocal object itself is no longer referenced,
-   * ThreadLocal is usually implemented with a WeakReference, which can have negative performance
-   * properties; for example, calling WeakReference.get() on Android will block during an
-   * otherwise-concurrent GC cycle.
-   */
-  private final class NonReentrantExecutor implements Executor {
-    final Executor delegate;
-
-    private NonReentrantExecutor(Executor delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override
-    public void execute(final Runnable task) {
-      final Thread submitting = Thread.currentThread();
-      final ThreadAndTask submittingThreadAndTask = threadAndTask;
-      if (submittingThreadAndTask.thread == submitting) {
-        // Submit from inside a reentrant submit. We don't know if this one will be reentrant (and
-        // can't know without submitting something to the executor) so queue to run iteratively.
-        // Task must be null, since each execution on this executor can only produce one more
-        // execution.
-        checkState(submittingThreadAndTask.task == null);
-        submittingThreadAndTask.task =
-            new Runnable() {
-              @Override
-              public void run() {
-                delegate.execute(task);
-              }
-            };
-      } else {
-        delegate.execute(
-            new Runnable() {
-              @Override
-              public void run() {
-                Thread executingThread = Thread.currentThread();
-                if (executingThread != submitting) {
-                  task.run();
-                  return;
-                }
-                // Executor called reentrantly! Make sure that further calls don't overflow stack.
-                // Further reentrant calls will see that their current thread is the same as the
-                // one set in threadAndTask, and queue rather than calling execute() directly.
-                ThreadAndTask executingThreadAndTask = new ThreadAndTask();
-                executingThreadAndTask.thread = executingThread;
-                // Unconditionally set; there is no risk of throwing away a queued task from
-                // another thread, because in order for the current task to run on this executor
-                // the previous task must have already started execution. Because each task on a
-                // NonReentrantExecutor can only produce one execute() call to another instance
-                // from the same ExecutionSequencer, we know by induction that the task that
-                // launched this one must not have added any other runnables to that thread's
-                // queue, and thus we cannot be replacing a TaskAndThread object that would
-                // otherwise have another task queued on to it.
-                threadAndTask = executingThreadAndTask;
-                try {
-                  task.run();
-                  // Now check if our task attempted to reentrantly execute the next task.
-                  Runnable queuedTask;
-                  while ((queuedTask = executingThreadAndTask.task) != null) {
-                    executingThreadAndTask.task = null;
-                    queuedTask.run();
-                  }
-                } finally {
-                  // Null out the thread field, so that we don't leak a reference to Thread, and
-                  // so that future `thread == currentThread()` calls from this thread don't
-                  // incorrectly queue instead of executing. Don't null out the threadAndTask
-                  // field, because it might not be ours any more.
-                  executingThreadAndTask.thread = null;
-                }
-              }
-            });
-      }
-    }
-  }
 }, @@ -15,9 +15,6 @@ NAMESPACE org.junit
 # ***** REAL CYCLES *****
 # Inverses (currently not solvable by weakening a reference)
 FIELD com.google.common.base.Converter.reverse
-# Cycle exists until future completes
-TYPE com.google.common.util.concurrent.ExecutionSequencer.NonReentrantExecutor
-FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.ExecutionSequencer.submitAsync.$
 
 # ***** FALSE POSITIVES *****
 , @@ -15,13 +15,9 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.util.concurrent.Futures.allAsList;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
-import com.google.common.annotations.GwtIncompatible;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -144,114 +140,6 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
-  public void testAvoidsStackOverflow_manyQueued() throws Exception {
-    final SettableFuture<Void> settableFuture = SettableFuture.create();
-    ArrayList<ListenableFuture<Void>> results = new ArrayList<>(50_001);
-    results.add(
-        serializer.submitAsync(
-            new AsyncCallable<Void>() {
-              @Override
-              public ListenableFuture<Void> call() {
-                return settableFuture;
-              }
-            },
-            directExecutor()));
-    for (int i = 0; i < 50_000; i++) {
-      results.add(serializer.submit(Callables.<Void>returning(null), directExecutor()));
-    }
-    settableFuture.set(null);
-    getDone(allAsList(results));
-  }
-
-  private static final class LongHolder {
-    long count;
-  }
-
-  private static final int ITERATION_COUNT = 50_000;
-  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
-
-  @GwtIncompatible // threads
-
-  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
-    final LongHolder holder = new LongHolder();
-    final ArrayList<ListenableFuture<Integer>> lengthChecks = new ArrayList<>();
-    final List<Integer> completeLengthChecks;
-    final int baseStackDepth;
-    ExecutorService service = Executors.newFixedThreadPool(5);
-    try {
-      // Avoid counting frames from the executor itself, or the ExecutionSequencer
-      baseStackDepth =
-          serializer
-              .submit(
-                  new Callable<Integer>() {
-                    @Override
-                    public Integer call() {
-                      return Thread.currentThread().getStackTrace().length;
-                    }
-                  },
-                  service)
-              .get();
-      final SettableFuture<Void> settableFuture = SettableFuture.create();
-      ListenableFuture<?> unused =
-          serializer.submitAsync(
-              new AsyncCallable<Void>() {
-                @Override
-                public ListenableFuture<Void> call() {
-                  return settableFuture;
-                }
-              },
-              directExecutor());
-      for (int i = 0; i < 50_000; i++) {
-        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
-          // after some number of iterations, switch threads
-          unused =
-              serializer.submit(
-                  new Callable<Void>() {
-                    @Override
-                    public Void call() {
-                      holder.count++;
-                      return null;
-                    }
-                  },
-                  service);
-        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
-          // When at max depth, record stack trace depth
-          lengthChecks.add(
-              serializer.submit(
-                  new Callable<Integer>() {
-                    @Override
-                    public Integer call() {
-                      holder.count++;
-                      return Thread.currentThread().getStackTrace().length;
-                    }
-                  },
-                  directExecutor()));
-        } else {
-          // Otherwise, schedule a task on directExecutor
-          unused =
-              serializer.submit(
-                  new Callable<Void>() {
-                    @Override
-                    public Void call() {
-                      holder.count++;
-                      return null;
-                    }
-                  },
-                  directExecutor());
-        }
-      }
-      settableFuture.set(null);
-      completeLengthChecks = allAsList(lengthChecks).get();
-    } finally {
-      service.shutdown();
-    }
-    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
-    for (int length : completeLengthChecks) {
-      // Verify that at max depth, less than one stack frame per submitted task was consumed
-      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
-    }
-  }
-
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, @@ -15,7 +15,6 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
@@ -59,8 +58,6 @@ public static ExecutionSequencer create() {
   private final AtomicReference<ListenableFuture<Object>> ref =
       new AtomicReference<>(immediateFuture(null));
 
-  private ThreadAndTask threadAndTask = new ThreadAndTask();
-
   /**
    * Enqueues a task to run when the previous task (if any) completes.
    *
@@ -70,7 +67,6 @@ public static ExecutionSequencer create() {
    */
   public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
     checkNotNull(callable);
-    checkNotNull(executor);
     return submitAsync(
         new AsyncCallable<T>() {
           @Override
@@ -96,7 +92,6 @@ public String toString() {
   public <T> ListenableFuture<T> submitAsync(
       final AsyncCallable<T> callable, final Executor executor) {
     checkNotNull(callable);
-    checkNotNull(executor);
     final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
     final AsyncCallable<T> task =
         new AsyncCallable<T>() {
@@ -135,7 +130,7 @@ public String toString() {
             new Executor() {
               @Override
               public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, new NonReentrantExecutor(executor));
+                oldFuture.addListener(runnable, executor);
               }
             });
 
@@ -169,124 +164,4 @@ public void run() {
 
     return outputFuture;
   }
-
-  /**
-   * This object is unsafely published, but avoids problematic races by relying exclusively on the
-   * identity equality of its Thread field so that the task field is only accessed by a single
-   * thread.
-   */
-  private static final class ThreadAndTask {
-    /**
-     * This field is only used for identity comparisons with the current thread. Field assignments
-     * are atomic, but do not provide happens-before ordering; however:
-     *
-     * <ul>
-     *   <li>If this field's value == currentThread, we know that it's up to date, because write
-     *       operations in a thread always happen-before subsequent read operations in the same
-     *       thread
-     *   <li>If this field's value == null because of unsafe publication, we know that it isn't the
-     *       object associated with our thread, because if it was the publication wouldn't have been
-     *       unsafe and we'd have seen our thread as the value. This state is also why a new
-     *       ThreadAndTask object must be created for each inline execution, because observing a
-     *       null thread does not mean the object is safe to reuse.
-     *   <li>If this field's value is some other thread object, we know that it's not our thread.
-     *   <li>If this field's value == null because it originally belonged to another thread and that
-     *       thread cleared it, we still know that it's not associated with our thread
-     *   <li>If this field's value == null because it was associated with our thread and was
-     *       cleared, we know that we're not executing inline any more
-     * </ul>
-     *
-     * All the states where thread != currentThread are identical for our purposes, and so even
-     * though it's racy, we don't care which of those values we get, so no need to synchronize.
-     */
-    Thread thread;
-    /** Only used by the thread associated with this object */
-    Runnable task;
-  }
-
-  /**
-   * This class helps avoid a StackOverflowError when large numbers of tasks are submitted with
-   * {@link MoreExecutors#directExecutor}. Normally, when the first future completes, all the other
-   * tasks would be called recursively. Here, we detect that the delegate executor is executing
-   * inline, and maintain a queue to dispatch tasks iteratively.
-   *
-   * <p>This class would certainly be simpler and easier to reason about if it were built with
-   * ThreadLocal; however, ThreadLocal is not well optimized for the case where the ThreadLocal is
-   * non-static, and is initialized/removed frequently - this causes churn in the Thread specific
-   * hashmaps. Using a static ThreadLocal to avoid that overhead would mean that different
-   * ExecutionSequencer objects interfere with each other, which would be undesirable, in addition
-   * to increasing the memory footprint of every thread that interacted with it. In order to release
-   * entries in thread-specific maps when the ThreadLocal object itself is no longer referenced,
-   * ThreadLocal is usually implemented with a WeakReference, which can have negative performance
-   * properties; for example, calling WeakReference.get() on Android will block during an
-   * otherwise-concurrent GC cycle.
-   */
-  private final class NonReentrantExecutor implements Executor {
-    final Executor delegate;
-
-    private NonReentrantExecutor(Executor delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override
-    public void execute(final Runnable task) {
-      final Thread submitting = Thread.currentThread();
-      final ThreadAndTask submittingThreadAndTask = threadAndTask;
-      if (submittingThreadAndTask.thread == submitting) {
-        // Submit from inside a reentrant submit. We don't know if this one will be reentrant (and
-        // can't know without submitting something to the executor) so queue to run iteratively.
-        // Task must be null, since each execution on this executor can only produce one more
-        // execution.
-        checkState(submittingThreadAndTask.task == null);
-        submittingThreadAndTask.task =
-            new Runnable() {
-              @Override
-              public void run() {
-                delegate.execute(task);
-              }
-            };
-      } else {
-        delegate.execute(
-            new Runnable() {
-              @Override
-              public void run() {
-                Thread executingThread = Thread.currentThread();
-                if (executingThread != submitting) {
-                  task.run();
-                  return;
-                }
-                // Executor called reentrantly! Make sure that further calls don't overflow stack.
-                // Further reentrant calls will see that their current thread is the same as the
-                // one set in threadAndTask, and queue rather than calling execute() directly.
-                ThreadAndTask executingThreadAndTask = new ThreadAndTask();
-                executingThreadAndTask.thread = executingThread;
-                // Unconditionally set; there is no risk of throwing away a queued task from
-                // another thread, because in order for the current task to run on this executor
-                // the previous task must have already started execution. Because each task on a
-                // NonReentrantExecutor can only produce one execute() call to another instance
-                // from the same ExecutionSequencer, we know by induction that the task that
-                // launched this one must not have added any other runnables to that thread's
-                // queue, and thus we cannot be replacing a TaskAndThread object that would
-                // otherwise have another task queued on to it.
-                threadAndTask = executingThreadAndTask;
-                try {
-                  task.run();
-                  // Now check if our task attempted to reentrantly execute the next task.
-                  Runnable queuedTask;
-                  while ((queuedTask = executingThreadAndTask.task) != null) {
-                    executingThreadAndTask.task = null;
-                    queuedTask.run();
-                  }
-                } finally {
-                  // Null out the thread field, so that we don't leak a reference to Thread, and
-                  // so that future `thread == currentThread()` calls from this thread don't
-                  // incorrectly queue instead of executing. Don't null out the threadAndTask
-                  // field, because it might not be ours any more.
-                  executingThreadAndTask.thread = null;
-                }
-              }
-            });
-      }
-    }
-  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add a Guava wiki entry about finding the min/max for various circumstances.

3bb0d85dd8f0e404684bede39c06bc0602b3f0c5

-------

<p> Avoid reentrancy in ExecutionSequencer.

db53357fea477695deeaa32746660bf86d6d51c1

-------

<p> Revert db53357fea477695deeaa32746660bf86d6d51c1

Broke a test

2ef8463838b23ae8c40c022fd96e7b143e0de018",MOE Sync 2020-06-17
3939,Nick,"['android/guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java']","@@ -17,13 +17,19 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
+import com.google.common.testing.TestLogHandler;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.logging.Logger;
 import junit.framework.TestCase;
 
 /** Tests for {@link ExecutionSequencer} */
@@ -140,6 +146,51 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
+  public void testCancellationDuringReentrancy() throws Exception {
+    TestLogHandler logHandler = new TestLogHandler();
+    Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
+
+    List<Future<?>> results = new ArrayList<>();
+    final Runnable[] manualExecutorTask = new Runnable[1];
+    Executor manualExecutor =
+        new Executor() {
+          @Override
+          public void execute(Runnable task) {
+            manualExecutorTask[0] = task;
+          }
+        };
+
+    results.add(serializer.submit(Callables.returning(null), manualExecutor));
+    final Future<?>[] thingToCancel = new Future<?>[1];
+    results.add(
+        serializer.submit(
+            new Callable<Void>() {
+              @Override
+              public Void call() {
+                thingToCancel[0].cancel(false);
+                return null;
+              }
+            },
+            directExecutor()));
+    thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
+    results.add(thingToCancel[0]);
+    // Enqueue more than enough tasks to force reentrancy.
+    for (int i = 0; i < 5; i++) {
+      results.add(serializer.submit(Callables.returning(null), directExecutor()));
+    }
+
+    manualExecutorTask[0].run();
+
+    for (Future<?> result : results) {
+      if (!result.isCancelled()) {
+        result.get(10, SECONDS);
+      }
+      // TODO(cpovirk): Verify that the cancelled futures are exactly ones that we expect.
+    }
+
+    assertThat(logHandler.getStoredLogRecords()).isEmpty();
+  }
+
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, @@ -17,13 +17,19 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
+import com.google.common.testing.TestLogHandler;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.logging.Logger;
 import junit.framework.TestCase;
 
 /** Tests for {@link ExecutionSequencer} */
@@ -140,6 +146,51 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
+  public void testCancellationDuringReentrancy() throws Exception {
+    TestLogHandler logHandler = new TestLogHandler();
+    Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
+
+    List<Future<?>> results = new ArrayList<>();
+    final Runnable[] manualExecutorTask = new Runnable[1];
+    Executor manualExecutor =
+        new Executor() {
+          @Override
+          public void execute(Runnable task) {
+            manualExecutorTask[0] = task;
+          }
+        };
+
+    results.add(serializer.submit(Callables.returning(null), manualExecutor));
+    final Future<?>[] thingToCancel = new Future<?>[1];
+    results.add(
+        serializer.submit(
+            new Callable<Void>() {
+              @Override
+              public Void call() {
+                thingToCancel[0].cancel(false);
+                return null;
+              }
+            },
+            directExecutor()));
+    thingToCancel[0] = serializer.submit(Callables.returning(null), directExecutor());
+    results.add(thingToCancel[0]);
+    // Enqueue more than enough tasks to force reentrancy.
+    for (int i = 0; i < 5; i++) {
+      results.add(serializer.submit(Callables.returning(null), directExecutor()));
+    }
+
+    manualExecutorTask[0].run();
+
+    for (Future<?> result : results) {
+      if (!result.isCancelled()) {
+        result.get(10, SECONDS);
+      }
+      // TODO(cpovirk): Verify that the cancelled futures are exactly ones that we expect.
+    }
+
+    assertThat(logHandler.getStoredLogRecords()).isEmpty();
+  }
+
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add LongMath.roundToDouble.

RELNOTES=Add LongMath.roundToDouble (#3895)

6f176593caf7fe7549c115ada136287ea31e2875

-------

<p> Add a test for the bug introduced by CL 316779471.

68962e5893c9812d79508d82c8b70e9bb7350146",MOE Sync 2020-06-18
3941,Nick,"['android/guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'android/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java', 'cycle_whitelist.txt', 'guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'guava/src/com/google/common/util/concurrent/ExecutionSequencer.java']","@@ -15,11 +15,16 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.Futures.allAsList;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.testing.GcFinalization;
 import com.google.common.testing.TestLogHandler;
+import com.google.j2objc.annotations.J2ObjCIncompatible;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -146,6 +151,36 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
+  @GwtIncompatible
+  @J2ObjCIncompatible // gc
+  @AndroidIncompatible
+  public void testCancellationWithReferencedObject() throws Exception {
+    Object toBeGCed = new Object();
+    WeakReference<Object> ref = new WeakReference<>(toBeGCed);
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<?> ignored =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
+    toBeGCed = null;
+    GcFinalization.awaitClear(ref);
+  }
+
+  private static Callable<String> toStringCallable(final Object object) {
+    return new Callable<String>() {
+      @Override
+      public String call() {
+        return object.toString();
+      }
+    };
+  }
+
   public void testCancellationDuringReentrancy() throws Exception {
     TestLogHandler logHandler = new TestLogHandler();
     Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
@@ -191,6 +226,171 @@ public Void call() {
     assertThat(logHandler.getStoredLogRecords()).isEmpty();
   }
 
+  public void testAvoidsStackOverflow_manySubmitted() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ArrayList<ListenableFuture<Void>> results = new ArrayList<>(50_001);
+    results.add(
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor()));
+    for (int i = 0; i < 50_000; i++) {
+      results.add(serializer.submit(Callables.<Void>returning(null), directExecutor()));
+    }
+    settableFuture.set(null);
+    getDone(allAsList(results));
+  }
+
+  public void testAvoidsStackOverflow_manyCancelled() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<Void> unused =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    for (int i = 0; i < 50_000; i++) {
+      serializer.submit(Callables.<Void>returning(null), directExecutor()).cancel(true);
+    }
+    ListenableFuture<Integer> stackDepthCheck =
+        serializer.submit(
+            new Callable<Integer>() {
+              @Override
+              public Integer call() {
+                return Thread.currentThread().getStackTrace().length;
+              }
+            },
+            directExecutor());
+    settableFuture.set(null);
+    assertThat(getDone(stackDepthCheck))
+        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
+  }
+
+  public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<Void> unused =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    for (int i = 0; i < 25_000; i++) {
+      serializer.submit(Callables.<Void>returning(null), directExecutor()).cancel(true);
+      unused = serializer.submit(Callables.<Void>returning(null), directExecutor());
+    }
+    ListenableFuture<Integer> stackDepthCheck =
+        serializer.submit(
+            new Callable<Integer>() {
+              @Override
+              public Integer call() {
+                return Thread.currentThread().getStackTrace().length;
+              }
+            },
+            directExecutor());
+    settableFuture.set(null);
+    assertThat(getDone(stackDepthCheck))
+        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
+  }
+
+  private static final class LongHolder {
+    long count;
+  }
+
+  private static final int ITERATION_COUNT = 50_000;
+  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
+
+  @GwtIncompatible // threads
+
+  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
+    final LongHolder holder = new LongHolder();
+    final ArrayList<ListenableFuture<Integer>> lengthChecks = new ArrayList<>();
+    final List<Integer> completeLengthChecks;
+    final int baseStackDepth;
+    ExecutorService service = Executors.newFixedThreadPool(5);
+    try {
+      // Avoid counting frames from the executor itself, or the ExecutionSequencer
+      baseStackDepth =
+          serializer
+              .submit(
+                  new Callable<Integer>() {
+                    @Override
+                    public Integer call() {
+                      return Thread.currentThread().getStackTrace().length;
+                    }
+                  },
+                  service)
+              .get();
+      final SettableFuture<Void> settableFuture = SettableFuture.create();
+      ListenableFuture<?> unused =
+          serializer.submitAsync(
+              new AsyncCallable<Void>() {
+                @Override
+                public ListenableFuture<Void> call() {
+                  return settableFuture;
+                }
+              },
+              directExecutor());
+      for (int i = 0; i < 50_000; i++) {
+        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
+          // after some number of iterations, switch threads
+          unused =
+              serializer.submit(
+                  new Callable<Void>() {
+                    @Override
+                    public Void call() {
+                      holder.count++;
+                      return null;
+                    }
+                  },
+                  service);
+        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
+          // When at max depth, record stack trace depth
+          lengthChecks.add(
+              serializer.submit(
+                  new Callable<Integer>() {
+                    @Override
+                    public Integer call() {
+                      holder.count++;
+                      return Thread.currentThread().getStackTrace().length;
+                    }
+                  },
+                  directExecutor()));
+        } else {
+          // Otherwise, schedule a task on directExecutor
+          unused =
+              serializer.submit(
+                  new Callable<Void>() {
+                    @Override
+                    public Void call() {
+                      holder.count++;
+                      return null;
+                    }
+                  },
+                  directExecutor());
+        }
+      }
+      settableFuture.set(null);
+      completeLengthChecks = allAsList(lengthChecks).get();
+    } finally {
+      service.shutdown();
+    }
+    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
+    for (int length : completeLengthChecks) {
+      // Verify that at max depth, less than one stack frame per submitted task was consumed
+      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
+    }
+  }
+
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, @@ -15,6 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
@@ -48,16 +49,48 @@ public static ExecutionSequencer create() {
     return new ExecutionSequencer();
   }
 
-  enum RunningState {
-    NOT_RUN,
-    CANCELLED,
-    STARTED,
-  }
-
   /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
   private final AtomicReference<ListenableFuture<Object>> ref =
       new AtomicReference<>(immediateFuture(null));
 
+  private ThreadConfinedTaskQueue latestTaskQueue = new ThreadConfinedTaskQueue();
+
+  /**
+   * This object is unsafely published, but avoids problematic races by relying exclusively on the
+   * identity equality of its Thread field so that the task field is only accessed by a single
+   * thread.
+   */
+  private static final class ThreadConfinedTaskQueue {
+    /**
+     * This field is only used for identity comparisons with the current thread. Field assignments
+     * are atomic, but do not provide happens-before ordering; however:
+     *
+     * <ul>
+     *   <li>If this field's value == currentThread, we know that it's up to date, because write
+     *       operations in a thread always happen-before subsequent read operations in the same
+     *       thread
+     *   <li>If this field's value == null because of unsafe publication, we know that it isn't the
+     *       object associated with our thread, because if it was the publication wouldn't have been
+     *       unsafe and we'd have seen our thread as the value. This state is also why a new
+     *       ThreadConfinedTaskQueue object must be created for each inline execution, because
+     *       observing a null thread does not mean the object is safe to reuse.
+     *   <li>If this field's value is some other thread object, we know that it's not our thread.
+     *   <li>If this field's value == null because it originally belonged to another thread and that
+     *       thread cleared it, we still know that it's not associated with our thread
+     *   <li>If this field's value == null because it was associated with our thread and was
+     *       cleared, we know that we're not executing inline any more
+     * </ul>
+     *
+     * All the states where thread != currentThread are identical for our purposes, and so even
+     * though it's racy, we don't care which of those values we get, so no need to synchronize.
+     */
+    Thread thread;
+    /** Only used by the thread associated with this object */
+    Runnable nextTask;
+    /** Only used by the thread associated with this object */
+    Executor nextExecutor;
+  }
+
   /**
    * Enqueues a task to run when the previous task (if any) completes.
    *
@@ -67,6 +100,7 @@ public static ExecutionSequencer create() {
    */
   public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
     checkNotNull(callable);
+    checkNotNull(executor);
     return submitAsync(
         new AsyncCallable<T>() {
           @Override
@@ -92,12 +126,13 @@ public String toString() {
   public <T> ListenableFuture<T> submitAsync(
       final AsyncCallable<T> callable, final Executor executor) {
     checkNotNull(callable);
-    final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
+    checkNotNull(executor);
+    final TaskNonReentrantExecutor taskExecutor = new TaskNonReentrantExecutor(executor, this);
     final AsyncCallable<T> task =
         new AsyncCallable<T>() {
           @Override
           public ListenableFuture<T> call() throws Exception {
-            if (!runningState.compareAndSet(NOT_RUN, STARTED)) {
+            if (!taskExecutor.trySetStarted()) {
               return immediateCancelledFuture();
             }
             return callable.call();
@@ -124,15 +159,8 @@ public String toString() {
     final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
 
     // Invoke our task once the previous future completes.
-    final ListenableFuture<T> taskFuture =
-        Futures.submitAsync(
-            task,
-            new Executor() {
-              @Override
-              public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, executor);
-              }
-            });
+    final TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);
+    oldFuture.addListener(taskFuture, taskExecutor);
 
     final ListenableFuture<T> outputFuture = Futures.nonCancellationPropagating(taskFuture);
 
@@ -144,15 +172,17 @@ public void execute(Runnable runnable) {
         new Runnable() {
           @Override
           public void run() {
-            if (taskFuture.isDone()
-                // If this CAS succeeds, we know that the provided callable will never be invoked,
-                // so when oldFuture completes it is safe to allow the next submitted task to
-                // proceed.
-                || (outputFuture.isCancelled() && runningState.compareAndSet(NOT_RUN, CANCELLED))) {
+            if (taskFuture.isDone()) {
               // Since the value of oldFuture can only ever be immediateFuture(null) or setFuture of
               // a future that eventually came from immediateFuture(null), this doesn't leak
               // throwables or completion values.
               newFuture.setFuture(oldFuture);
+            } else if (outputFuture.isCancelled() && taskExecutor.trySetCancelled()) {
+              // If this CAS succeeds, we know that the provided callable will never be invoked,
+              // so when oldFuture completes it is safe to allow the next submitted task to
+              // proceed. Doing this immediately here lets the next task run without waiting for
+              // the cancelled task's executor to run the noop AsyncCallable.
+              taskFuture.cancel(false);
             }
           }
         };
@@ -164,4 +194,163 @@ public void run() {
 
     return outputFuture;
   }
+
+  enum RunningState {
+    NOT_RUN,
+    CANCELLED,
+    STARTED,
+  }
+
+  /**
+   * This class helps avoid a StackOverflowError when large numbers of tasks are submitted with
+   * {@link MoreExecutors#directExecutor}. Normally, when the first future completes, all the other
+   * tasks would be called recursively. Here, we detect that the delegate executor is executing
+   * inline, and maintain a queue to dispatch tasks iteratively. There is one instance of this class
+   * per call to submit() or submitAsync(), and each instance supports only one call to execute().
+   *
+   * <p>This class would certainly be simpler and easier to reason about if it were built with
+   * ThreadLocal; however, ThreadLocal is not well optimized for the case where the ThreadLocal is
+   * non-static, and is initialized/removed frequently - this causes churn in the Thread specific
+   * hashmaps. Using a static ThreadLocal to avoid that overhead would mean that different
+   * ExecutionSequencer objects interfere with each other, which would be undesirable, in addition
+   * to increasing the memory footprint of every thread that interacted with it. In order to release
+   * entries in thread-specific maps when the ThreadLocal object itself is no longer referenced,
+   * ThreadLocal is usually implemented with a WeakReference, which can have negative performance
+   * properties; for example, calling WeakReference.get() on Android will block during an
+   * otherwise-concurrent GC cycle.
+   */
+  @SuppressWarnings(""ShouldNotSubclass"") // Saving an allocation here is worth it
+  private static final class TaskNonReentrantExecutor extends AtomicReference<RunningState>
+      implements Executor, Runnable {
+
+    /**
+     * Used to update and read the latestTaskQueue field. Set to null once the runnable has been run
+     * or queued.
+     */
+    ExecutionSequencer sequencer;
+
+    /**
+     * Executor the task was set to run on. Set to null when the task has been queued, run, or
+     * cancelled.
+     */
+    Executor delegate;
+
+    /**
+     * Set before calling delegate.execute(); set to null once run, so that it can be GCed; this
+     * object may live on after, if submitAsync returns an incomplete future.
+     */
+    Runnable task;
+
+    /** Thread that called execute(). Set in execute, cleared when delegate.execute() returns. */
+    Thread submitting;
+
+    private TaskNonReentrantExecutor(Executor delegate, ExecutionSequencer sequencer) {
+      super(NOT_RUN);
+      this.delegate = delegate;
+      this.sequencer = sequencer;
+    }
+
+    @Override
+    public void execute(Runnable task) {
+      // If this operation was successfully cancelled already, calling the runnable will be a noop.
+      // This also avoids a race where if outputFuture is cancelled, it will call taskFuture.cancel,
+      // which will call newFuture.setFuture(oldFuture), to allow the next task in the queue to run
+      // without waiting for the user's executor to run our submitted Runnable. However, this can
+      // interact poorly with the reentrancy-avoiding behavior of this executor - when the operation
+      // before the cancelled future completes, it will synchronously complete both the newFuture
+      // from the cancelled operation and its own. This can cause one runnable to queue two tasks,
+      // breaking the invariant this method relies on to iteratively run the next task after the
+      // previous one completes.
+      if (get() == RunningState.CANCELLED) {
+        delegate = null;
+        sequencer = null;
+        return;
+      }
+      submitting = Thread.currentThread();
+      try {
+        ThreadConfinedTaskQueue submittingTaskQueue = sequencer.latestTaskQueue;
+        if (submittingTaskQueue.thread == submitting) {
+          sequencer = null;
+          // Submit from inside a reentrant submit. We don't know if this one will be reentrant (and
+          // can't know without submitting something to the executor) so queue to run iteratively.
+          // Task must be null, since each execution on this executor can only produce one more
+          // execution.
+          checkState(submittingTaskQueue.nextTask == null);
+          submittingTaskQueue.nextTask = task;
+          submittingTaskQueue.nextExecutor = delegate;
+          delegate = null;
+        } else {
+          Executor localDelegate = delegate;
+          delegate = null;
+          this.task = task;
+          localDelegate.execute(this);
+        }
+      } finally {
+        // Important to null this out here - if we did *not* execute inline, we might still
+        // run() on the same thread that called execute() - such as in a thread pool, and think
+        // that it was happening inline. As a side benefit, avoids holding on to the Thread object
+        // longer than necessary.
+        submitting = null;
+      }
+    }
+
+    @SuppressWarnings(""ShortCircuitBoolean"")
+    @Override
+    public void run() {
+      Thread currentThread = Thread.currentThread();
+      if (currentThread != submitting) {
+        Runnable localTask = task;
+        task = null;
+        localTask.run();
+        return;
+      }
+      // Executor called reentrantly! Make sure that further calls don't overflow stack. Further
+      // reentrant calls will see that their current thread is the same as the one set in
+      // latestTaskQueue, and queue rather than calling execute() directly.
+      ThreadConfinedTaskQueue executingTaskQueue = new ThreadConfinedTaskQueue();
+      executingTaskQueue.thread = currentThread;
+      // Unconditionally set; there is no risk of throwing away a queued task from another thread,
+      // because in order for the current task to run on this executor the previous task must have
+      // already started execution. Because each task on a TaskNonReentrantExecutor can only produce
+      // one execute() call to another instance from the same ExecutionSequencer, we know by
+      // induction that the task that launched this one must not have added any other runnables to
+      // that thread's queue, and thus we cannot be replacing a TaskAndThread object that would
+      // otherwise have another task queued on to it. Note the exception to this, cancellation, is
+      // specially handled in execute() - execute() calls triggered by cancellation are no-ops, and
+      // thus don't count.
+      sequencer.latestTaskQueue = executingTaskQueue;
+      sequencer = null;
+      try {
+        Runnable localTask = task;
+        task = null;
+        localTask.run();
+        // Now check if our task attempted to reentrantly execute the next task.
+        Runnable queuedTask;
+        Executor queuedExecutor;
+        // Intentionally using non-short-circuit operator
+        while ((queuedTask = executingTaskQueue.nextTask) != null
+            & (queuedExecutor = executingTaskQueue.nextExecutor) != null) {
+          executingTaskQueue.nextTask = null;
+          executingTaskQueue.nextExecutor = null;
+          queuedExecutor.execute(queuedTask);
+        }
+      } finally {
+        // Null out the thread field, so that we don't leak a reference to Thread, and so that
+        // future `thread == currentThread()` calls from this thread don't incorrectly queue instead
+        // of executing. Don't null out the latestTaskQueue field, because the work done here
+        // may have scheduled more operations on another thread, and if those operations then
+        // trigger reentrant calls that thread will have updated the latestTaskQueue field, and
+        // we'd be interfering with their operation.
+        executingTaskQueue.thread = null;
+      }
+    }
+
+    private boolean trySetStarted() {
+      return compareAndSet(NOT_RUN, STARTED);
+    }
+
+    private boolean trySetCancelled() {
+      return compareAndSet(NOT_RUN, CANCELLED);
+    }
+  }
 }, @@ -15,6 +15,8 @@ NAMESPACE org.junit
 # ***** REAL CYCLES *****
 # Inverses (currently not solvable by weakening a reference)
 FIELD com.google.common.base.Converter.reverse
+# Cycle exists until future completes
+FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.ExecutionSequencer.TaskNonReentrantExecutor
 
 # ***** FALSE POSITIVES *****
 
@@ -38,6 +40,8 @@ FIELD com.google.common.collect.TreeTraverser.PostOrderNode.childIterator
 FIELD com.google.common.collect.TreeTraverser.PreOrderIterator.stack
 FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor.$
 FIELD com.google.common.util.concurrent.AbstractService.listeners
+# NonReentrantExecutor is not exposed to this field
+FIELD com.google.common.util.concurrent.ExecutionSequencer.ThreadConfinedTaskQueue.nextExecutor com.google.common.util.concurrent.ExecutionSequencer.TaskNonReentrantExecutor
 # Real cycle, but the runningState field is null'ed on completion of the future.
 FIELD com.google.common.util.concurrent.AggregateFuture.runningState
 FIELD java.util.AbstractMap.keySet com.google.common.collect.AbstractMapBasedMultimap.NavigableKeySet, @@ -15,11 +15,16 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.Futures.allAsList;
 import static com.google.common.util.concurrent.Futures.getDone;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.testing.GcFinalization;
 import com.google.common.testing.TestLogHandler;
+import com.google.j2objc.annotations.J2ObjCIncompatible;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -146,6 +151,36 @@ public Boolean call() {
     assertThat(getDone(future2)).isFalse();
   }
 
+  @GwtIncompatible
+  @J2ObjCIncompatible // gc
+  @AndroidIncompatible
+  public void testCancellationWithReferencedObject() throws Exception {
+    Object toBeGCed = new Object();
+    WeakReference<Object> ref = new WeakReference<>(toBeGCed);
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<?> ignored =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    serializer.submit(toStringCallable(toBeGCed), directExecutor()).cancel(true);
+    toBeGCed = null;
+    GcFinalization.awaitClear(ref);
+  }
+
+  private static Callable<String> toStringCallable(final Object object) {
+    return new Callable<String>() {
+      @Override
+      public String call() {
+        return object.toString();
+      }
+    };
+  }
+
   public void testCancellationDuringReentrancy() throws Exception {
     TestLogHandler logHandler = new TestLogHandler();
     Logger.getLogger(AbstractFuture.class.getName()).addHandler(logHandler);
@@ -191,6 +226,171 @@ public Void call() {
     assertThat(logHandler.getStoredLogRecords()).isEmpty();
   }
 
+  public void testAvoidsStackOverflow_manySubmitted() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ArrayList<ListenableFuture<Void>> results = new ArrayList<>(50_001);
+    results.add(
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor()));
+    for (int i = 0; i < 50_000; i++) {
+      results.add(serializer.submit(Callables.<Void>returning(null), directExecutor()));
+    }
+    settableFuture.set(null);
+    getDone(allAsList(results));
+  }
+
+  public void testAvoidsStackOverflow_manyCancelled() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<Void> unused =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    for (int i = 0; i < 50_000; i++) {
+      serializer.submit(Callables.<Void>returning(null), directExecutor()).cancel(true);
+    }
+    ListenableFuture<Integer> stackDepthCheck =
+        serializer.submit(
+            new Callable<Integer>() {
+              @Override
+              public Integer call() {
+                return Thread.currentThread().getStackTrace().length;
+              }
+            },
+            directExecutor());
+    settableFuture.set(null);
+    assertThat(getDone(stackDepthCheck))
+        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
+  }
+
+  public void testAvoidsStackOverflow_alternatingCancelledAndSubmitted() throws Exception {
+    final SettableFuture<Void> settableFuture = SettableFuture.create();
+    ListenableFuture<Void> unused =
+        serializer.submitAsync(
+            new AsyncCallable<Void>() {
+              @Override
+              public ListenableFuture<Void> call() {
+                return settableFuture;
+              }
+            },
+            directExecutor());
+    for (int i = 0; i < 25_000; i++) {
+      serializer.submit(Callables.<Void>returning(null), directExecutor()).cancel(true);
+      unused = serializer.submit(Callables.<Void>returning(null), directExecutor());
+    }
+    ListenableFuture<Integer> stackDepthCheck =
+        serializer.submit(
+            new Callable<Integer>() {
+              @Override
+              public Integer call() {
+                return Thread.currentThread().getStackTrace().length;
+              }
+            },
+            directExecutor());
+    settableFuture.set(null);
+    assertThat(getDone(stackDepthCheck))
+        .isLessThan(Thread.currentThread().getStackTrace().length + 100);
+  }
+
+  private static final class LongHolder {
+    long count;
+  }
+
+  private static final int ITERATION_COUNT = 50_000;
+  private static final int DIRECT_EXECUTIONS_PER_THREAD = 100;
+
+  @GwtIncompatible // threads
+
+  public void testAvoidsStackOverflow_multipleThreads() throws Exception {
+    final LongHolder holder = new LongHolder();
+    final ArrayList<ListenableFuture<Integer>> lengthChecks = new ArrayList<>();
+    final List<Integer> completeLengthChecks;
+    final int baseStackDepth;
+    ExecutorService service = Executors.newFixedThreadPool(5);
+    try {
+      // Avoid counting frames from the executor itself, or the ExecutionSequencer
+      baseStackDepth =
+          serializer
+              .submit(
+                  new Callable<Integer>() {
+                    @Override
+                    public Integer call() {
+                      return Thread.currentThread().getStackTrace().length;
+                    }
+                  },
+                  service)
+              .get();
+      final SettableFuture<Void> settableFuture = SettableFuture.create();
+      ListenableFuture<?> unused =
+          serializer.submitAsync(
+              new AsyncCallable<Void>() {
+                @Override
+                public ListenableFuture<Void> call() {
+                  return settableFuture;
+                }
+              },
+              directExecutor());
+      for (int i = 0; i < 50_000; i++) {
+        if (i % DIRECT_EXECUTIONS_PER_THREAD == 0) {
+          // after some number of iterations, switch threads
+          unused =
+              serializer.submit(
+                  new Callable<Void>() {
+                    @Override
+                    public Void call() {
+                      holder.count++;
+                      return null;
+                    }
+                  },
+                  service);
+        } else if (i % DIRECT_EXECUTIONS_PER_THREAD == DIRECT_EXECUTIONS_PER_THREAD - 1) {
+          // When at max depth, record stack trace depth
+          lengthChecks.add(
+              serializer.submit(
+                  new Callable<Integer>() {
+                    @Override
+                    public Integer call() {
+                      holder.count++;
+                      return Thread.currentThread().getStackTrace().length;
+                    }
+                  },
+                  directExecutor()));
+        } else {
+          // Otherwise, schedule a task on directExecutor
+          unused =
+              serializer.submit(
+                  new Callable<Void>() {
+                    @Override
+                    public Void call() {
+                      holder.count++;
+                      return null;
+                    }
+                  },
+                  directExecutor());
+        }
+      }
+      settableFuture.set(null);
+      completeLengthChecks = allAsList(lengthChecks).get();
+    } finally {
+      service.shutdown();
+    }
+    assertThat(holder.count).isEqualTo(ITERATION_COUNT);
+    for (int length : completeLengthChecks) {
+      // Verify that at max depth, less than one stack frame per submitted task was consumed
+      assertThat(length - baseStackDepth).isLessThan(DIRECT_EXECUTIONS_PER_THREAD / 2);
+    }
+  }
+
   public void testToString() {
     Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());, @@ -15,6 +15,7 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.CANCELLED;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.NOT_RUN;
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
@@ -48,16 +49,48 @@ public static ExecutionSequencer create() {
     return new ExecutionSequencer();
   }
 
-  enum RunningState {
-    NOT_RUN,
-    CANCELLED,
-    STARTED,
-  }
-
   /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
   private final AtomicReference<ListenableFuture<Object>> ref =
       new AtomicReference<>(immediateFuture(null));
 
+  private ThreadConfinedTaskQueue latestTaskQueue = new ThreadConfinedTaskQueue();
+
+  /**
+   * This object is unsafely published, but avoids problematic races by relying exclusively on the
+   * identity equality of its Thread field so that the task field is only accessed by a single
+   * thread.
+   */
+  private static final class ThreadConfinedTaskQueue {
+    /**
+     * This field is only used for identity comparisons with the current thread. Field assignments
+     * are atomic, but do not provide happens-before ordering; however:
+     *
+     * <ul>
+     *   <li>If this field's value == currentThread, we know that it's up to date, because write
+     *       operations in a thread always happen-before subsequent read operations in the same
+     *       thread
+     *   <li>If this field's value == null because of unsafe publication, we know that it isn't the
+     *       object associated with our thread, because if it was the publication wouldn't have been
+     *       unsafe and we'd have seen our thread as the value. This state is also why a new
+     *       ThreadConfinedTaskQueue object must be created for each inline execution, because
+     *       observing a null thread does not mean the object is safe to reuse.
+     *   <li>If this field's value is some other thread object, we know that it's not our thread.
+     *   <li>If this field's value == null because it originally belonged to another thread and that
+     *       thread cleared it, we still know that it's not associated with our thread
+     *   <li>If this field's value == null because it was associated with our thread and was
+     *       cleared, we know that we're not executing inline any more
+     * </ul>
+     *
+     * All the states where thread != currentThread are identical for our purposes, and so even
+     * though it's racy, we don't care which of those values we get, so no need to synchronize.
+     */
+    Thread thread;
+    /** Only used by the thread associated with this object */
+    Runnable nextTask;
+    /** Only used by the thread associated with this object */
+    Executor nextExecutor;
+  }
+
   /**
    * Enqueues a task to run when the previous task (if any) completes.
    *
@@ -67,6 +100,7 @@ public static ExecutionSequencer create() {
    */
   public <T> ListenableFuture<T> submit(final Callable<T> callable, Executor executor) {
     checkNotNull(callable);
+    checkNotNull(executor);
     return submitAsync(
         new AsyncCallable<T>() {
           @Override
@@ -92,12 +126,13 @@ public String toString() {
   public <T> ListenableFuture<T> submitAsync(
       final AsyncCallable<T> callable, final Executor executor) {
     checkNotNull(callable);
-    final AtomicReference<RunningState> runningState = new AtomicReference<>(NOT_RUN);
+    checkNotNull(executor);
+    final TaskNonReentrantExecutor taskExecutor = new TaskNonReentrantExecutor(executor, this);
     final AsyncCallable<T> task =
         new AsyncCallable<T>() {
           @Override
           public ListenableFuture<T> call() throws Exception {
-            if (!runningState.compareAndSet(NOT_RUN, STARTED)) {
+            if (!taskExecutor.trySetStarted()) {
               return immediateCancelledFuture();
             }
             return callable.call();
@@ -124,15 +159,8 @@ public String toString() {
     final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
 
     // Invoke our task once the previous future completes.
-    final ListenableFuture<T> taskFuture =
-        Futures.submitAsync(
-            task,
-            new Executor() {
-              @Override
-              public void execute(Runnable runnable) {
-                oldFuture.addListener(runnable, executor);
-              }
-            });
+    final TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);
+    oldFuture.addListener(taskFuture, taskExecutor);
 
     final ListenableFuture<T> outputFuture = Futures.nonCancellationPropagating(taskFuture);
 
@@ -144,15 +172,17 @@ public void execute(Runnable runnable) {
         new Runnable() {
           @Override
           public void run() {
-            if (taskFuture.isDone()
-                // If this CAS succeeds, we know that the provided callable will never be invoked,
-                // so when oldFuture completes it is safe to allow the next submitted task to
-                // proceed.
-                || (outputFuture.isCancelled() && runningState.compareAndSet(NOT_RUN, CANCELLED))) {
+            if (taskFuture.isDone()) {
               // Since the value of oldFuture can only ever be immediateFuture(null) or setFuture of
               // a future that eventually came from immediateFuture(null), this doesn't leak
               // throwables or completion values.
               newFuture.setFuture(oldFuture);
+            } else if (outputFuture.isCancelled() && taskExecutor.trySetCancelled()) {
+              // If this CAS succeeds, we know that the provided callable will never be invoked,
+              // so when oldFuture completes it is safe to allow the next submitted task to
+              // proceed. Doing this immediately here lets the next task run without waiting for
+              // the cancelled task's executor to run the noop AsyncCallable.
+              taskFuture.cancel(false);
             }
           }
         };
@@ -164,4 +194,163 @@ public void run() {
 
     return outputFuture;
   }
+
+  enum RunningState {
+    NOT_RUN,
+    CANCELLED,
+    STARTED,
+  }
+
+  /**
+   * This class helps avoid a StackOverflowError when large numbers of tasks are submitted with
+   * {@link MoreExecutors#directExecutor}. Normally, when the first future completes, all the other
+   * tasks would be called recursively. Here, we detect that the delegate executor is executing
+   * inline, and maintain a queue to dispatch tasks iteratively. There is one instance of this class
+   * per call to submit() or submitAsync(), and each instance supports only one call to execute().
+   *
+   * <p>This class would certainly be simpler and easier to reason about if it were built with
+   * ThreadLocal; however, ThreadLocal is not well optimized for the case where the ThreadLocal is
+   * non-static, and is initialized/removed frequently - this causes churn in the Thread specific
+   * hashmaps. Using a static ThreadLocal to avoid that overhead would mean that different
+   * ExecutionSequencer objects interfere with each other, which would be undesirable, in addition
+   * to increasing the memory footprint of every thread that interacted with it. In order to release
+   * entries in thread-specific maps when the ThreadLocal object itself is no longer referenced,
+   * ThreadLocal is usually implemented with a WeakReference, which can have negative performance
+   * properties; for example, calling WeakReference.get() on Android will block during an
+   * otherwise-concurrent GC cycle.
+   */
+  @SuppressWarnings(""ShouldNotSubclass"") // Saving an allocation here is worth it
+  private static final class TaskNonReentrantExecutor extends AtomicReference<RunningState>
+      implements Executor, Runnable {
+
+    /**
+     * Used to update and read the latestTaskQueue field. Set to null once the runnable has been run
+     * or queued.
+     */
+    ExecutionSequencer sequencer;
+
+    /**
+     * Executor the task was set to run on. Set to null when the task has been queued, run, or
+     * cancelled.
+     */
+    Executor delegate;
+
+    /**
+     * Set before calling delegate.execute(); set to null once run, so that it can be GCed; this
+     * object may live on after, if submitAsync returns an incomplete future.
+     */
+    Runnable task;
+
+    /** Thread that called execute(). Set in execute, cleared when delegate.execute() returns. */
+    Thread submitting;
+
+    private TaskNonReentrantExecutor(Executor delegate, ExecutionSequencer sequencer) {
+      super(NOT_RUN);
+      this.delegate = delegate;
+      this.sequencer = sequencer;
+    }
+
+    @Override
+    public void execute(Runnable task) {
+      // If this operation was successfully cancelled already, calling the runnable will be a noop.
+      // This also avoids a race where if outputFuture is cancelled, it will call taskFuture.cancel,
+      // which will call newFuture.setFuture(oldFuture), to allow the next task in the queue to run
+      // without waiting for the user's executor to run our submitted Runnable. However, this can
+      // interact poorly with the reentrancy-avoiding behavior of this executor - when the operation
+      // before the cancelled future completes, it will synchronously complete both the newFuture
+      // from the cancelled operation and its own. This can cause one runnable to queue two tasks,
+      // breaking the invariant this method relies on to iteratively run the next task after the
+      // previous one completes.
+      if (get() == RunningState.CANCELLED) {
+        delegate = null;
+        sequencer = null;
+        return;
+      }
+      submitting = Thread.currentThread();
+      try {
+        ThreadConfinedTaskQueue submittingTaskQueue = sequencer.latestTaskQueue;
+        if (submittingTaskQueue.thread == submitting) {
+          sequencer = null;
+          // Submit from inside a reentrant submit. We don't know if this one will be reentrant (and
+          // can't know without submitting something to the executor) so queue to run iteratively.
+          // Task must be null, since each execution on this executor can only produce one more
+          // execution.
+          checkState(submittingTaskQueue.nextTask == null);
+          submittingTaskQueue.nextTask = task;
+          submittingTaskQueue.nextExecutor = delegate;
+          delegate = null;
+        } else {
+          Executor localDelegate = delegate;
+          delegate = null;
+          this.task = task;
+          localDelegate.execute(this);
+        }
+      } finally {
+        // Important to null this out here - if we did *not* execute inline, we might still
+        // run() on the same thread that called execute() - such as in a thread pool, and think
+        // that it was happening inline. As a side benefit, avoids holding on to the Thread object
+        // longer than necessary.
+        submitting = null;
+      }
+    }
+
+    @SuppressWarnings(""ShortCircuitBoolean"")
+    @Override
+    public void run() {
+      Thread currentThread = Thread.currentThread();
+      if (currentThread != submitting) {
+        Runnable localTask = task;
+        task = null;
+        localTask.run();
+        return;
+      }
+      // Executor called reentrantly! Make sure that further calls don't overflow stack. Further
+      // reentrant calls will see that their current thread is the same as the one set in
+      // latestTaskQueue, and queue rather than calling execute() directly.
+      ThreadConfinedTaskQueue executingTaskQueue = new ThreadConfinedTaskQueue();
+      executingTaskQueue.thread = currentThread;
+      // Unconditionally set; there is no risk of throwing away a queued task from another thread,
+      // because in order for the current task to run on this executor the previous task must have
+      // already started execution. Because each task on a TaskNonReentrantExecutor can only produce
+      // one execute() call to another instance from the same ExecutionSequencer, we know by
+      // induction that the task that launched this one must not have added any other runnables to
+      // that thread's queue, and thus we cannot be replacing a TaskAndThread object that would
+      // otherwise have another task queued on to it. Note the exception to this, cancellation, is
+      // specially handled in execute() - execute() calls triggered by cancellation are no-ops, and
+      // thus don't count.
+      sequencer.latestTaskQueue = executingTaskQueue;
+      sequencer = null;
+      try {
+        Runnable localTask = task;
+        task = null;
+        localTask.run();
+        // Now check if our task attempted to reentrantly execute the next task.
+        Runnable queuedTask;
+        Executor queuedExecutor;
+        // Intentionally using non-short-circuit operator
+        while ((queuedTask = executingTaskQueue.nextTask) != null
+            & (queuedExecutor = executingTaskQueue.nextExecutor) != null) {
+          executingTaskQueue.nextTask = null;
+          executingTaskQueue.nextExecutor = null;
+          queuedExecutor.execute(queuedTask);
+        }
+      } finally {
+        // Null out the thread field, so that we don't leak a reference to Thread, and so that
+        // future `thread == currentThread()` calls from this thread don't incorrectly queue instead
+        // of executing. Don't null out the latestTaskQueue field, because the work done here
+        // may have scheduled more operations on another thread, and if those operations then
+        // trigger reentrant calls that thread will have updated the latestTaskQueue field, and
+        // we'd be interfering with their operation.
+        executingTaskQueue.thread = null;
+      }
+    }
+
+    private boolean trySetStarted() {
+      return compareAndSet(NOT_RUN, STARTED);
+    }
+
+    private boolean trySetCancelled() {
+      return compareAndSet(NOT_RUN, CANCELLED);
+    }
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Avoid reentrancy in ExecutionSequencer.

37d4506a2874cd223d88ebf98e8d28ff333c11de",MOE Sync 2020-06-22
3942,Kurt Alfred Kluever,"['cycle_whitelist.txt', 'guava/src/com/google/common/collect/SingletonImmutableBiMap.java']","@@ -13,8 +13,6 @@ NAMESPACE junit.framework
 NAMESPACE org.junit
 
 # ***** REAL CYCLES *****
-# Inverses (currently not solvable by weakening a reference)
-FIELD com.google.common.base.Converter.reverse
 # Cycle exists until future completes
 FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.ExecutionSequencer.TaskNonReentrantExecutor
 
@@ -23,6 +21,7 @@ FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.goo
 # The Runnable type is so generic that it produces too many false positives.
 TYPE java.lang.Runnable
 
+FIELD com.google.common.base.Converter.reverse
 FIELD com.google.common.collect.AbstractBiMap.EntrySet.iterator.$.entry com.google.common.collect.AbstractBiMap.EntrySet.iterator.$.next.$
 FIELD com.google.common.collect.AbstractMapBasedMultimap.map
 FIELD com.google.common.collect.AbstractMultimap.asMap com.google.common.collect.AbstractMapBasedMultimap.NavigableAsMap
@@ -36,6 +35,7 @@ FIELD com.google.common.collect.ImmutableRangeSet.ranges
 FIELD com.google.common.collect.ImmutableSet.asList
 FIELD com.google.common.collect.Maps.FilteredMapValues.unfiltered
 FIELD com.google.common.collect.Sets.SubSet.inputSet
+FIELD com.google.common.collect.SingletonImmutableBiMap.inverse
 FIELD com.google.common.collect.TreeTraverser.PostOrderNode.childIterator
 FIELD com.google.common.collect.TreeTraverser.PreOrderIterator.stack
 FIELD com.google.common.util.concurrent.AbstractFuture.Listener.executor com.google.common.util.concurrent.MoreExecutors.rejectionPropagatingExecutor.$, @@ -42,6 +42,7 @@
     checkEntryNotNull(singleKey, singleValue);
     this.singleKey = singleKey;
     this.singleValue = singleValue;
+    this.inverse = null;
   }
 
   private SingletonImmutableBiMap(K singleKey, V singleValue, ImmutableBiMap<V, K> inverse) {
@@ -90,16 +91,21 @@ boolean isPartialView() {
     return ImmutableSet.of(singleKey);
   }
 
-  @LazyInit @RetainedWith transient ImmutableBiMap<V, K> inverse;
+  private final transient @Nullable ImmutableBiMap<V, K> inverse;
+  @LazyInit @RetainedWith private transient @Nullable ImmutableBiMap<V, K> lazyInverse;
 
   @Override
   public ImmutableBiMap<V, K> inverse() {
-    // racy single-check idiom
-    ImmutableBiMap<V, K> result = inverse;
-    if (result == null) {
-      return inverse = new SingletonImmutableBiMap<>(singleValue, singleKey, this);
+    if (inverse != null) {
+      return inverse;
     } else {
-      return result;
+      // racy single-check idiom
+      ImmutableBiMap<V, K> result = lazyInverse;
+      if (result == null) {
+        return lazyInverse = new SingletonImmutableBiMap<>(singleValue, singleKey, this);
+      } else {
+        return result;
+      }
     }
   }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix memory leak in SingletonImmutableBiMap which would appear in transpiled J2ObjC code.

The @RetainedWith annotation can not be used on both sides of the retain-cycle. The RegularImmutableBiMap does not have this problem, because it uses Inverse inner class. This CL applies similar trick in SingletonImmutableBiMap, although without additional inner class.

RELNOTES=Update SingletonImmutableBiMap to avoid retain-cycle in transpiled Obj-C code.

d7d07d50c7ae699b71c9a239212f4c3728180327",MOE Sync 2020-06-23
3947,Kurt Alfred Kluever,"['android/guava-tests/benchmark/com/google/common/math/BigIntegerMathRoundingBenchmark.java', 'android/guava-tests/test/com/google/common/math/BigDecimalMathTest.java', 'android/guava/src/com/google/common/math/BigDecimalMath.java', 'android/guava/src/com/google/common/math/BigIntegerMath.java', 'android/guava/src/com/google/common/math/ToDoubleRounder.java', 'guava-gwt/test/com/google/common/math/BigDecimalMathTest_gwt.java', 'guava-tests/benchmark/com/google/common/math/BigIntegerMathRoundingBenchmark.java', 'guava-tests/test/com/google/common/math/BigDecimalMathTest.java', 'guava/src/com/google/common/math/BigDecimalMath.java', 'guava/src/com/google/common/math/BigIntegerMath.java', 'guava/src/com/google/common/math/ToDoubleRounder.java']","@@ -88,4 +88,14 @@ int divide(int reps) {
     }
     return tmp;
   }
+
+  @Benchmark
+  long roundToDouble(int reps) {
+    long tmp = 0;
+    for (int i = 0; i < reps; i++) {
+      int j = i & ARRAY_MASK;
+      tmp += Double.doubleToRawLongBits(BigIntegerMath.roundToDouble(nonzero1[j], mode));
+    }
+    return tmp;
+  }
 }, @@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static java.math.RoundingMode.CEILING;
+import static java.math.RoundingMode.DOWN;
+import static java.math.RoundingMode.FLOOR;
+import static java.math.RoundingMode.HALF_DOWN;
+import static java.math.RoundingMode.HALF_EVEN;
+import static java.math.RoundingMode.HALF_UP;
+import static java.math.RoundingMode.UNNECESSARY;
+import static java.math.RoundingMode.UP;
+import static java.math.RoundingMode.values;
+
+import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
+import java.math.BigDecimal;
+import java.math.MathContext;
+import java.math.RoundingMode;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import junit.framework.TestCase;
+
+@GwtCompatible(emulated = true)
+public class BigDecimalMathTest extends TestCase {
+  @GwtIncompatible
+  private static final class RoundToDoubleTester {
+    private final BigDecimal input;
+    private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
+    private boolean unnecessaryShouldThrow = false;
+
+    RoundToDoubleTester(BigDecimal input) {
+      this.input = input;
+    }
+
+    RoundToDoubleTester setExpectation(double expectedValue, RoundingMode... modes) {
+      for (RoundingMode mode : modes) {
+        Double previous = expectedValues.put(mode, expectedValue);
+        if (previous != null) {
+          throw new AssertionError();
+        }
+      }
+      return this;
+    }
+
+    public RoundToDoubleTester roundUnnecessaryShouldThrow() {
+      unnecessaryShouldThrow = true;
+      return this;
+    }
+
+    public void test() {
+      assertThat(expectedValues.keySet())
+          .containsAtLeastElementsIn(EnumSet.complementOf(EnumSet.of(UNNECESSARY)));
+      for (Map.Entry<RoundingMode, Double> entry : expectedValues.entrySet()) {
+        RoundingMode mode = entry.getKey();
+        Double expectation = entry.getValue();
+        assertWithMessage(""roundToDouble("" + input + "", "" + mode + "")"")
+            .that(BigDecimalMath.roundToDouble(input, mode))
+            .isEqualTo(expectation);
+      }
+
+      if (!expectedValues.containsKey(UNNECESSARY)) {
+        assertWithMessage(""Expected roundUnnecessaryShouldThrow call"")
+            .that(unnecessaryShouldThrow)
+            .isTrue();
+        try {
+          BigDecimalMath.roundToDouble(input, UNNECESSARY);
+          fail(""Expected ArithmeticException for roundToDouble("" + input + "", UNNECESSARY)"");
+        } catch (ArithmeticException expected) {
+          // expected
+        }
+      }
+    }
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_zero() {
+    new RoundToDoubleTester(BigDecimal.ZERO).setExpectation(0.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_oneThird() {
+    new RoundToDoubleTester(
+            BigDecimal.ONE.divide(BigDecimal.valueOf(3), new MathContext(50, HALF_EVEN)))
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(0.33333333333333337, UP, CEILING)
+        .setExpectation(0.3333333333333333, HALF_EVEN, FLOOR, DOWN, HALF_UP, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_halfMinDouble() {
+    BigDecimal minDouble = new BigDecimal(Double.MIN_VALUE);
+    BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
+    new RoundToDoubleTester(halfMinDouble)
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(Double.MIN_VALUE, UP, CEILING, HALF_UP)
+        .setExpectation(0.0, HALF_EVEN, FLOOR, DOWN, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_halfNegativeMinDouble() {
+    BigDecimal minDouble = new BigDecimal(-Double.MIN_VALUE);
+    BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
+    new RoundToDoubleTester(halfMinDouble)
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(-Double.MIN_VALUE, UP, FLOOR, HALF_UP)
+        .setExpectation(-0.0, HALF_EVEN, CEILING, DOWN, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallPositive() {
+    new RoundToDoubleTester(BigDecimal.valueOf(16)).setExpectation(16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentable() {
+    new RoundToDoubleTester(BigDecimal.valueOf(1L << 53))
+        .setExpectation(Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
+    double twoToThe53 = Math.pow(2, 53);
+    // the representable doubles are 2^53 and 2^53 + 2.
+    // 2^53+1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 53) + 1))
+        .setExpectation(twoToThe53, DOWN, FLOOR, HALF_DOWN, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe53), CEILING, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOne() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 1))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOneHalf() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigDecimal.valueOf(1L << 54).add(new BigDecimal(0.5)))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusThree() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+3 is more than halfway between, so HALF_DOWN and HALF_UP will both go up.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 3))
+        .setExpectation(twoToThe54, DOWN, FLOOR)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusFour() {
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 4))
+        .setExpectation(Math.pow(2, 54) + 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDouble() {
+    BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE);
+    new RoundToDoubleTester(maxDoubleAsBD).setExpectation(Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDoublePlusOne() {
+    BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE).add(BigDecimal.ONE);
+    new RoundToDoubleTester(maxDoubleAsBD)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_wayTooBig() {
+    BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT);
+    new RoundToDoubleTester(bi)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallNegative() {
+    new RoundToDoubleTester(BigDecimal.valueOf(-16)).setExpectation(-16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentable() {
+    new RoundToDoubleTester(BigDecimal.valueOf(-1L << 53))
+        .setExpectation(-Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
+    // the representable doubles are -2^53 and -2^53 - 2.
+    // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 53) - 1))
+        .setExpectation(-Math.pow(2, 53), DOWN, CEILING, HALF_DOWN, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 53)), FLOOR, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusOne() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 1))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusThree() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 3))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
+        .setExpectation(
+            DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusFour() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 4))
+        .setExpectation(-Math.pow(2, 54) - 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDouble() {
+    BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE);
+    new RoundToDoubleTester(minDoubleAsBD).setExpectation(-Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDoubleMinusOne() {
+    BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE).subtract(BigDecimal.ONE);
+    new RoundToDoubleTester(minDoubleAsBD)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeWayTooBig() {
+    BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT).negate();
+    new RoundToDoubleTester(bi)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+}, @@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+
+/**
+ * A class for arithmetic on {@link BigDecimal} that is not covered by its built-in methods.
+ *
+ * @author Louis Wasserman
+ * @since NEXT
+ */
+@GwtIncompatible
+public class BigDecimalMath {
+  private BigDecimalMath() {}
+
+  /**
+   * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
+   * is precisely representable as a {@code double}, its {@code double} value will be returned;
+   * otherwise, the rounding will choose between the two nearest representable values with {@code
+   * mode}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
+   * infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
+   * representable as a double, but {@code roundToDouble(BigDecimal.valueOf(2).pow(2000), HALF_UP)}
+   * will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
+   * default rounding mode: if the two nearest representable values are equally near, the one with
+   * the least significant bit zero is chosen. (In such cases, both of the nearest representable
+   * values are even integers; this method returns the one that is a multiple of a greater power of
+   * two.)
+   *
+   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
+   *     is not precisely representable as a {@code double}
+   * @since NEXT
+   */
+  public static double roundToDouble(BigDecimal x, RoundingMode mode) {
+    return BigDecimalToDoubleRounder.INSTANCE.roundToDouble(x, mode);
+  }
+
+  private static class BigDecimalToDoubleRounder extends ToDoubleRounder<BigDecimal> {
+    static final BigDecimalToDoubleRounder INSTANCE = new BigDecimalToDoubleRounder();
+
+    private BigDecimalToDoubleRounder() {}
+
+    @Override
+    double roundToDoubleArbitrarily(BigDecimal bigDecimal) {
+      return bigDecimal.doubleValue();
+    }
+
+    @Override
+    int sign(BigDecimal bigDecimal) {
+      return bigDecimal.signum();
+    }
+
+    @Override
+    BigDecimal toX(double d, RoundingMode mode) {
+      return new BigDecimal(d);
+    }
+
+    @Override
+    BigDecimal minus(BigDecimal a, BigDecimal b) {
+      return a.subtract(b);
+    }
+  }
+}, @@ -336,7 +336,9 @@ public static double roundToDouble(BigInteger x, RoundingMode mode) {
 
   @GwtIncompatible
   private static class BigIntegerToDoubleRounder extends ToDoubleRounder<BigInteger> {
-    private static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+    static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+
+    private BigIntegerToDoubleRounder() {}
 
     @Override
     double roundToDoubleArbitrarily(BigInteger bigInteger) {, @@ -133,7 +133,9 @@ final double roundToDouble(X x, RoundingMode mode) {
           // halfway between the representable values; do the half-whatever logic
           switch (mode) {
             case HALF_EVEN:
-              return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0)
+              // roundFloorAsDouble and roundCeilingAsDouble are neighbors, so precisely
+              // one of them should have an even long representation
+              return ((Double.doubleToRawLongBits(roundFloorAsDouble) & 1L) == 0)
                   ? roundFloorAsDouble
                   : roundCeilingAsDouble;
             case HALF_DOWN:, @@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2008 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.common.math;
+public class BigDecimalMathTest_gwt extends com.google.gwt.junit.client.GWTTestCase {
+@Override public String getModuleName() {
+  return ""com.google.common.math.testModule"";
+}
+}, @@ -88,4 +88,14 @@ int divide(int reps) {
     }
     return tmp;
   }
+
+  @Benchmark
+  long roundToDouble(int reps) {
+    long tmp = 0;
+    for (int i = 0; i < reps; i++) {
+      int j = i & ARRAY_MASK;
+      tmp += Double.doubleToRawLongBits(BigIntegerMath.roundToDouble(nonzero1[j], mode));
+    }
+    return tmp;
+  }
 }, @@ -0,0 +1,295 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static java.math.RoundingMode.CEILING;
+import static java.math.RoundingMode.DOWN;
+import static java.math.RoundingMode.FLOOR;
+import static java.math.RoundingMode.HALF_DOWN;
+import static java.math.RoundingMode.HALF_EVEN;
+import static java.math.RoundingMode.HALF_UP;
+import static java.math.RoundingMode.UNNECESSARY;
+import static java.math.RoundingMode.UP;
+import static java.math.RoundingMode.values;
+
+import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
+import java.math.BigDecimal;
+import java.math.MathContext;
+import java.math.RoundingMode;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.Map;
+import junit.framework.TestCase;
+
+@GwtCompatible(emulated = true)
+public class BigDecimalMathTest extends TestCase {
+  @GwtIncompatible
+  private static final class RoundToDoubleTester {
+    private final BigDecimal input;
+    private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
+    private boolean unnecessaryShouldThrow = false;
+
+    RoundToDoubleTester(BigDecimal input) {
+      this.input = input;
+    }
+
+    RoundToDoubleTester setExpectation(double expectedValue, RoundingMode... modes) {
+      for (RoundingMode mode : modes) {
+        Double previous = expectedValues.put(mode, expectedValue);
+        if (previous != null) {
+          throw new AssertionError();
+        }
+      }
+      return this;
+    }
+
+    public RoundToDoubleTester roundUnnecessaryShouldThrow() {
+      unnecessaryShouldThrow = true;
+      return this;
+    }
+
+    public void test() {
+      assertThat(expectedValues.keySet())
+          .containsAtLeastElementsIn(EnumSet.complementOf(EnumSet.of(UNNECESSARY)));
+      for (Map.Entry<RoundingMode, Double> entry : expectedValues.entrySet()) {
+        RoundingMode mode = entry.getKey();
+        Double expectation = entry.getValue();
+        assertWithMessage(""roundToDouble("" + input + "", "" + mode + "")"")
+            .that(BigDecimalMath.roundToDouble(input, mode))
+            .isEqualTo(expectation);
+      }
+
+      if (!expectedValues.containsKey(UNNECESSARY)) {
+        assertWithMessage(""Expected roundUnnecessaryShouldThrow call"")
+            .that(unnecessaryShouldThrow)
+            .isTrue();
+        try {
+          BigDecimalMath.roundToDouble(input, UNNECESSARY);
+          fail(""Expected ArithmeticException for roundToDouble("" + input + "", UNNECESSARY)"");
+        } catch (ArithmeticException expected) {
+          // expected
+        }
+      }
+    }
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_zero() {
+    new RoundToDoubleTester(BigDecimal.ZERO).setExpectation(0.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_oneThird() {
+    new RoundToDoubleTester(
+            BigDecimal.ONE.divide(BigDecimal.valueOf(3), new MathContext(50, HALF_EVEN)))
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(0.33333333333333337, UP, CEILING)
+        .setExpectation(0.3333333333333333, HALF_EVEN, FLOOR, DOWN, HALF_UP, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_halfMinDouble() {
+    BigDecimal minDouble = new BigDecimal(Double.MIN_VALUE);
+    BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
+    new RoundToDoubleTester(halfMinDouble)
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(Double.MIN_VALUE, UP, CEILING, HALF_UP)
+        .setExpectation(0.0, HALF_EVEN, FLOOR, DOWN, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_halfNegativeMinDouble() {
+    BigDecimal minDouble = new BigDecimal(-Double.MIN_VALUE);
+    BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
+    new RoundToDoubleTester(halfMinDouble)
+        .roundUnnecessaryShouldThrow()
+        .setExpectation(-Double.MIN_VALUE, UP, FLOOR, HALF_UP)
+        .setExpectation(-0.0, HALF_EVEN, CEILING, DOWN, HALF_DOWN)
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallPositive() {
+    new RoundToDoubleTester(BigDecimal.valueOf(16)).setExpectation(16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentable() {
+    new RoundToDoubleTester(BigDecimal.valueOf(1L << 53))
+        .setExpectation(Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
+    double twoToThe53 = Math.pow(2, 53);
+    // the representable doubles are 2^53 and 2^53 + 2.
+    // 2^53+1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 53) + 1))
+        .setExpectation(twoToThe53, DOWN, FLOOR, HALF_DOWN, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe53), CEILING, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOne() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 1))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusOneHalf() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+1 is less than halfway between, so HALF_DOWN and HALF_UP will both go down.
+    new RoundToDoubleTester(BigDecimal.valueOf(1L << 54).add(new BigDecimal(0.5)))
+        .setExpectation(twoToThe54, DOWN, FLOOR, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusThree() {
+    double twoToThe54 = Math.pow(2, 54);
+    // the representable doubles are 2^54 and 2^54 + 4
+    // 2^54+3 is more than halfway between, so HALF_DOWN and HALF_UP will both go up.
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 3))
+        .setExpectation(twoToThe54, DOWN, FLOOR)
+        .setExpectation(Math.nextUp(twoToThe54), CEILING, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_twoToThe54PlusFour() {
+    new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 4))
+        .setExpectation(Math.pow(2, 54) + 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDouble() {
+    BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE);
+    new RoundToDoubleTester(maxDoubleAsBD).setExpectation(Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_maxDoublePlusOne() {
+    BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE).add(BigDecimal.ONE);
+    new RoundToDoubleTester(maxDoubleAsBD)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_wayTooBig() {
+    BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT);
+    new RoundToDoubleTester(bi)
+        .setExpectation(Double.MAX_VALUE, DOWN, FLOOR, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.POSITIVE_INFINITY, UP, CEILING)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_smallNegative() {
+    new RoundToDoubleTester(BigDecimal.valueOf(-16)).setExpectation(-16.0, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentable() {
+    new RoundToDoubleTester(BigDecimal.valueOf(-1L << 53))
+        .setExpectation(-Math.pow(2, 53), values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
+    // the representable doubles are -2^53 and -2^53 - 2.
+    // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 53) - 1))
+        .setExpectation(-Math.pow(2, 53), DOWN, CEILING, HALF_DOWN, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 53)), FLOOR, UP, HALF_UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusOne() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 1))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .setExpectation(DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusThree() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 3))
+        .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
+        .setExpectation(
+            DoubleUtils.nextDown(-Math.pow(2, 54)), FLOOR, UP, HALF_DOWN, HALF_UP, HALF_EVEN)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeTwoToThe54MinusFour() {
+    new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 4))
+        .setExpectation(-Math.pow(2, 54) - 4, values())
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDouble() {
+    BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE);
+    new RoundToDoubleTester(minDoubleAsBD).setExpectation(-Double.MAX_VALUE, values()).test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_minDoubleMinusOne() {
+    BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE).subtract(BigDecimal.ONE);
+    new RoundToDoubleTester(minDoubleAsBD)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+
+  @GwtIncompatible
+  public void testRoundToDouble_negativeWayTooBig() {
+    BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT).negate();
+    new RoundToDoubleTester(bi)
+        .setExpectation(-Double.MAX_VALUE, DOWN, CEILING, HALF_EVEN, HALF_UP, HALF_DOWN)
+        .setExpectation(Double.NEGATIVE_INFINITY, UP, FLOOR)
+        .roundUnnecessaryShouldThrow()
+        .test();
+  }
+}, @@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.math;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
+
+/**
+ * A class for arithmetic on {@link BigDecimal} that is not covered by its built-in methods.
+ *
+ * @author Louis Wasserman
+ * @since NEXT
+ */
+@GwtIncompatible
+public class BigDecimalMath {
+  private BigDecimalMath() {}
+
+  /**
+   * Returns {@code x}, rounded to a {@code double} with the specified rounding mode. If {@code x}
+   * is precisely representable as a {@code double}, its {@code double} value will be returned;
+   * otherwise, the rounding will choose between the two nearest representable values with {@code
+   * mode}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_DOWN}, {@code HALF_UP}, and {@code HALF_EVEN},
+   * infinite {@code double} values are considered infinitely far away. For example, 2^2000 is not
+   * representable as a double, but {@code roundToDouble(BigDecimal.valueOf(2).pow(2000), HALF_UP)}
+   * will return {@code Double.MAX_VALUE}, not {@code Double.POSITIVE_INFINITY}.
+   *
+   * <p>For the case of {@link RoundingMode#HALF_EVEN}, this implementation uses the IEEE 754
+   * default rounding mode: if the two nearest representable values are equally near, the one with
+   * the least significant bit zero is chosen. (In such cases, both of the nearest representable
+   * values are even integers; this method returns the one that is a multiple of a greater power of
+   * two.)
+   *
+   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}
+   *     is not precisely representable as a {@code double}
+   * @since NEXT
+   */
+  public static double roundToDouble(BigDecimal x, RoundingMode mode) {
+    return BigDecimalToDoubleRounder.INSTANCE.roundToDouble(x, mode);
+  }
+
+  private static class BigDecimalToDoubleRounder extends ToDoubleRounder<BigDecimal> {
+    static final BigDecimalToDoubleRounder INSTANCE = new BigDecimalToDoubleRounder();
+
+    private BigDecimalToDoubleRounder() {}
+
+    @Override
+    double roundToDoubleArbitrarily(BigDecimal bigDecimal) {
+      return bigDecimal.doubleValue();
+    }
+
+    @Override
+    int sign(BigDecimal bigDecimal) {
+      return bigDecimal.signum();
+    }
+
+    @Override
+    BigDecimal toX(double d, RoundingMode mode) {
+      return new BigDecimal(d);
+    }
+
+    @Override
+    BigDecimal minus(BigDecimal a, BigDecimal b) {
+      return a.subtract(b);
+    }
+  }
+}, @@ -336,7 +336,9 @@ public static double roundToDouble(BigInteger x, RoundingMode mode) {
 
   @GwtIncompatible
   private static class BigIntegerToDoubleRounder extends ToDoubleRounder<BigInteger> {
-    private static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+    static final BigIntegerToDoubleRounder INSTANCE = new BigIntegerToDoubleRounder();
+
+    private BigIntegerToDoubleRounder() {}
 
     @Override
     double roundToDoubleArbitrarily(BigInteger bigInteger) {, @@ -133,7 +133,9 @@ final double roundToDouble(X x, RoundingMode mode) {
           // halfway between the representable values; do the half-whatever logic
           switch (mode) {
             case HALF_EVEN:
-              return ((DoubleUtils.getSignificand(roundFloorAsDouble) & 1L) == 0)
+              // roundFloorAsDouble and roundCeilingAsDouble are neighbors, so precisely
+              // one of them should have an even long representation
+              return ((Double.doubleToRawLongBits(roundFloorAsDouble) & 1L) == 0)
                   ? roundFloorAsDouble
                   : roundCeilingAsDouble;
             case HALF_DOWN:, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct LongMath.roundToDouble for values at and near Long.MAX_VALUE

3d88ea8f940ecadea86d12f8993ac58f99684e6b

-------

<p> In ImmutableDoubleArray and ImmutableLongArray, use Arrays.copyOf when expanding the internal array.

In ImmutableIntArray, where we already made this change, remove an inconsistent `this.`.

6a8cfb3c83f7bc2a6cbec83e0ce240988f20997e

-------

<p> Implement BigDecimalMath.roundToDouble.

RELNOTES=Add BigDecimalMath.roundToDouble.

690b2a6b02bddcaab0a4050a92f490546c71e2ee",MOE Sync 2020-06-29
3949,Kurt Alfred Kluever,"['android/guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/Converter.java']","@@ -118,7 +118,7 @@
   private final boolean handleNullAutomatically;
 
   // We lazily cache the reverse view to avoid allocating on every call to reverse().
-  @LazyInit @NullableDecl private transient Converter<B, A> reverse;
+  @LazyInit @RetainedWith @NullableDecl private transient Converter<B, A> reverse;
 
   /** Constructor for use by subclasses. */
   protected Converter() {
@@ -242,7 +242,7 @@ public void remove() {
 
   private static final class ReverseConverter<A, B> extends Converter<B, A>
       implements Serializable {
-    @RetainedWith final Converter<A, B> original;
+    final Converter<A, B> original;
 
     ReverseConverter(Converter<A, B> original) {
       this.original = original;, @@ -118,7 +118,7 @@
   private final boolean handleNullAutomatically;
 
   // We lazily cache the reverse view to avoid allocating on every call to reverse().
-  @LazyInit private transient @Nullable Converter<B, A> reverse;
+  @LazyInit @RetainedWith private transient @Nullable Converter<B, A> reverse;
 
   /** Constructor for use by subclasses. */
   protected Converter() {
@@ -241,7 +241,7 @@ public void remove() {
 
   private static final class ReverseConverter<A, B> extends Converter<B, A>
       implements Serializable {
-    @RetainedWith final Converter<A, B> original;
+    final Converter<A, B> original;
 
     ReverseConverter(Converter<A, B> original) {
       this.original = original;, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix Converter.java by moving @RetainedWith annotation to the correct side of the cycle.

The annotation should be placed inside the ""parent"" object, and not the ""child"" object.

Reference: https://developers.google.com/j2objc/javadoc/annotations/reference/com/google/j2objc/annotations/RetainedWith

RELNOTES=N/A

58ad44a9ac2fde40095f28c504c95c6fed902d1f",MOE Sync 2020-06-30
3950,Kurt Alfred Kluever,"['android/guava/src/com/google/common/hash/BloomFilter.java', 'guava/src/com/google/common/hash/BloomFilter.java']","@@ -176,7 +176,6 @@ public boolean put(T object) {
    * @since 14.0 (since 11.0 as expectedFalsePositiveProbability())
    */
   public double expectedFpp() {
-    // You down with FPP? (Yeah you know me!) Who's down with FPP? (Every last homie!)
     return Math.pow((double) bits.bitCount() / bitSize(), numHashFunctions);
   }
 , @@ -177,7 +177,6 @@ public boolean put(T object) {
    * @since 14.0 (since 11.0 as expectedFalsePositiveProbability())
    */
   public double expectedFpp() {
-    // You down with FPP? (Yeah you know me!) Who's down with FPP? (Every last homie!)
     return Math.pow((double) bits.bitCount() / bitSize(), numHashFunctions);
   }
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove unnecessary comment.

a3084e48846ebddfc9d046670f7be8c0f60e6cb3",MOE Sync 2020-07-01
3954,,"['android/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java', 'guava/src/com/google/common/util/concurrent/ExecutionSequencer.java']","@@ -21,6 +21,7 @@
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
+import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.annotations.Beta;
@@ -50,8 +51,8 @@ public static ExecutionSequencer create() {
   }
 
   /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
-  private final AtomicReference<ListenableFuture<Object>> ref =
-      new AtomicReference<>(immediateFuture(null));
+  private final AtomicReference<ListenableFuture<Void>> ref =
+      new AtomicReference<>(immediateVoidFuture());
 
   private ThreadConfinedTaskQueue latestTaskQueue = new ThreadConfinedTaskQueue();
 
@@ -154,9 +155,9 @@ public String toString() {
      * have completed - namely after oldFuture is done, and taskFuture has either completed or been
      * cancelled before the callable started execution.
      */
-    final SettableFuture<Object> newFuture = SettableFuture.create();
+    final SettableFuture<Void> newFuture = SettableFuture.create();
 
-    final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
+    final ListenableFuture<Void> oldFuture = ref.getAndSet(newFuture);
 
     // Invoke our task once the previous future completes.
     final TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);, @@ -21,6 +21,7 @@
 import static com.google.common.util.concurrent.ExecutionSequencer.RunningState.STARTED;
 import static com.google.common.util.concurrent.Futures.immediateCancelledFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
+import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
 import com.google.common.annotations.Beta;
@@ -50,8 +51,8 @@ public static ExecutionSequencer create() {
   }
 
   /** This reference acts as a pointer tracking the head of a linked list of ListenableFutures. */
-  private final AtomicReference<ListenableFuture<Object>> ref =
-      new AtomicReference<>(immediateFuture(null));
+  private final AtomicReference<ListenableFuture<Void>> ref =
+      new AtomicReference<>(immediateVoidFuture());
 
   private ThreadConfinedTaskQueue latestTaskQueue = new ThreadConfinedTaskQueue();
 
@@ -154,9 +155,9 @@ public String toString() {
      * have completed - namely after oldFuture is done, and taskFuture has either completed or been
      * cancelled before the callable started execution.
      */
-    final SettableFuture<Object> newFuture = SettableFuture.create();
+    final SettableFuture<Void> newFuture = SettableFuture.create();
 
-    final ListenableFuture<?> oldFuture = ref.getAndSet(newFuture);
+    final ListenableFuture<Void> oldFuture = ref.getAndSet(newFuture);
 
     // Invoke our task once the previous future completes.
     final TrustedListenableFutureTask<T> taskFuture = TrustedListenableFutureTask.create(task);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Hint with the type that `oldFuture` / `newFuture` / `ref`'s `Future` never contains a value.

Being clear may become slightly more valuable when we put nullness type annotations on this code.

e655aa8df4bd53a11edf8bb99e8b35f746f54196",MOE Sync 2020-07-06
3956,,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix annotation positions in Guava.

795b357bddc097c87340f0ce573160b2d39e97c6

-------

<p> Update Public Suffix data.

The [] copy is typically updated whenever Chrome's copy is updated, which
is roughly every 6 weeks. Subscribe to the Chrome Milestone Calendar to see the
dates.

For this update, []

8ec74f444b4903871face31bf10139375749358b",MOE Sync 2020-07-08
3958,,"['android/guava/src/com/google/common/io/ByteStreams.java', 'guava/src/com/google/common/io/ByteStreams.java']","@@ -40,7 +40,7 @@
 import java.nio.channels.WritableByteChannel;
 import java.util.ArrayDeque;
 import java.util.Arrays;
-import java.util.Deque;
+import java.util.Queue;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -165,7 +165,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
    * input stream.
    */
-  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
+  private static byte[] toByteArrayInternal(InputStream in, Queue<byte[]> bufs, int totalLen)
       throws IOException {
     // Starting with an 8k buffer, double the size of each sucessive buffer. Buffers are retained
     // in a deque so that there's no copying between buffers while reading and so all of the bytes
@@ -196,11 +196,11 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
   }
 
-  private static byte[] combineBuffers(Deque<byte[]> bufs, int totalLen) {
+  private static byte[] combineBuffers(Queue<byte[]> bufs, int totalLen) {
     byte[] result = new byte[totalLen];
     int remaining = totalLen;
     while (remaining > 0) {
-      byte[] buf = bufs.removeFirst();
+      byte[] buf = bufs.remove();
       int bytesToCopy = Math.min(remaining, buf.length);
       int resultOffset = totalLen - remaining;
       System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
@@ -253,7 +253,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
+    Queue<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
     bufs.add(bytes);
     bufs.add(new byte[] {(byte) b});
     return toByteArrayInternal(in, bufs, bytes.length + 1);, @@ -40,7 +40,7 @@
 import java.nio.channels.WritableByteChannel;
 import java.util.ArrayDeque;
 import java.util.Arrays;
-import java.util.Deque;
+import java.util.Queue;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -165,7 +165,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
    * a total combined length of {@code totalLen} bytes) followed by all bytes remaining in the given
    * input stream.
    */
-  private static byte[] toByteArrayInternal(InputStream in, Deque<byte[]> bufs, int totalLen)
+  private static byte[] toByteArrayInternal(InputStream in, Queue<byte[]> bufs, int totalLen)
       throws IOException {
     // Starting with an 8k buffer, double the size of each sucessive buffer. Buffers are retained
     // in a deque so that there's no copying between buffers while reading and so all of the bytes
@@ -196,11 +196,11 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
   }
 
-  private static byte[] combineBuffers(Deque<byte[]> bufs, int totalLen) {
+  private static byte[] combineBuffers(Queue<byte[]> bufs, int totalLen) {
     byte[] result = new byte[totalLen];
     int remaining = totalLen;
     while (remaining > 0) {
-      byte[] buf = bufs.removeFirst();
+      byte[] buf = bufs.remove();
       int bytesToCopy = Math.min(remaining, buf.length);
       int resultOffset = totalLen - remaining;
       System.arraycopy(buf, 0, result, resultOffset, bytesToCopy);
@@ -253,7 +253,7 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     }
 
     // the stream was longer, so read the rest normally
-    Deque<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
+    Queue<byte[]> bufs = new ArrayDeque<byte[]>(TO_BYTE_ARRAY_DEQUE_SIZE + 2);
     bufs.add(bytes);
     bufs.add(new byte[] {(byte) b});
     return toByteArrayInternal(in, bufs, bytes.length + 1);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Declare static types as Queue instead of Deque.

This may slightly clarify how the object is used.

(I was looking through com.google.common for Deque instances that were used as stacks, so I noticed this one that was used only as a queue.)

752dd15c34f206b2103e2bd338610177088c4feb",MOE Sync 2020-07-10
3962,David P. Baker,"['android/guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java', 'android/guava/src/com/google/common/util/concurrent/SequentialExecutor.java', 'guava-tests/test/com/google/common/util/concurrent/SequentialExecutorTest.java', 'guava/src/com/google/common/util/concurrent/SequentialExecutor.java']","@@ -351,10 +351,15 @@ public void run() {
   }
 
   public void testToString() {
-    Executor delegate =
+    final Runnable[] currentTask = new Runnable[1];
+    final Executor delegate =
         new Executor() {
           @Override
-          public void execute(Runnable task) {}
+          public void execute(Runnable task) {
+            currentTask[0] = task;
+            task.run();
+            currentTask[0] = null;
+          }
 
           @Override
           public String toString() {
@@ -365,5 +370,19 @@ public String toString() {
     Executor sequential2 = newSequentialExecutor(delegate);
     assertThat(sequential1.toString()).contains(""theDelegate"");
     assertThat(sequential1.toString()).isNotEqualTo(sequential2.toString());
+    final String[] whileRunningToString = new String[1];
+    sequential1.execute(
+        new Runnable() {
+          @Override
+          public void run() {
+            whileRunningToString[0] = """" + currentTask[0];
+          }
+
+          @Override
+          public String toString() {
+            return ""my runnable's toString"";
+          }
+        });
+    assertThat(whileRunningToString[0]).contains(""my runnable's toString"");
   }
 }, @@ -120,6 +120,11 @@ public void execute(final Runnable task) {
             public void run() {
               task.run();
             }
+
+            @Override
+            public String toString() {
+              return task.toString();
+            }
           };
       queue.add(submittedTask);
       workerRunningState = QUEUING;
@@ -165,6 +170,8 @@ public void run() {
 
   /** Worker that runs tasks from {@link #queue} until it is empty. */
   private final class QueueWorker implements Runnable {
+    Runnable task;
+
     @Override
     public void run() {
       try {
@@ -196,7 +203,6 @@ private void workOnQueue() {
       boolean hasSetRunning = false;
       try {
         while (true) {
-          Runnable task;
           synchronized (queue) {
             // Choose whether this thread will run or not after acquiring the lock on the first
             // iteration
@@ -227,6 +233,8 @@ private void workOnQueue() {
             task.run();
           } catch (RuntimeException e) {
             log.log(Level.SEVERE, ""Exception while executing runnable "" + task, e);
+          } finally {
+            task = null;
           }
         }
       } finally {
@@ -238,6 +246,16 @@ private void workOnQueue() {
         }
       }
     }
+
+    @SuppressWarnings(""GuardedBy"")
+    @Override
+    public String toString() {
+      Runnable currentlyRunning = task;
+      if (currentlyRunning != null) {
+        return ""SequentialExecutorWorker{running="" + currentlyRunning + ""}"";
+      }
+      return ""SequentialExecutorWorker{state="" + workerRunningState + ""}"";
+    }
   }
 
   @Override, @@ -351,10 +351,15 @@ public void run() {
   }
 
   public void testToString() {
-    Executor delegate =
+    final Runnable[] currentTask = new Runnable[1];
+    final Executor delegate =
         new Executor() {
           @Override
-          public void execute(Runnable task) {}
+          public void execute(Runnable task) {
+            currentTask[0] = task;
+            task.run();
+            currentTask[0] = null;
+          }
 
           @Override
           public String toString() {
@@ -365,5 +370,19 @@ public String toString() {
     Executor sequential2 = newSequentialExecutor(delegate);
     assertThat(sequential1.toString()).contains(""theDelegate"");
     assertThat(sequential1.toString()).isNotEqualTo(sequential2.toString());
+    final String[] whileRunningToString = new String[1];
+    sequential1.execute(
+        new Runnable() {
+          @Override
+          public void run() {
+            whileRunningToString[0] = """" + currentTask[0];
+          }
+
+          @Override
+          public String toString() {
+            return ""my runnable's toString"";
+          }
+        });
+    assertThat(whileRunningToString[0]).contains(""my runnable's toString"");
   }
 }, @@ -120,6 +120,11 @@ public void execute(final Runnable task) {
             public void run() {
               task.run();
             }
+
+            @Override
+            public String toString() {
+              return task.toString();
+            }
           };
       queue.add(submittedTask);
       workerRunningState = QUEUING;
@@ -165,6 +170,8 @@ public void run() {
 
   /** Worker that runs tasks from {@link #queue} until it is empty. */
   private final class QueueWorker implements Runnable {
+    Runnable task;
+
     @Override
     public void run() {
       try {
@@ -196,7 +203,6 @@ private void workOnQueue() {
       boolean hasSetRunning = false;
       try {
         while (true) {
-          Runnable task;
           synchronized (queue) {
             // Choose whether this thread will run or not after acquiring the lock on the first
             // iteration
@@ -227,6 +233,8 @@ private void workOnQueue() {
             task.run();
           } catch (RuntimeException e) {
             log.log(Level.SEVERE, ""Exception while executing runnable "" + task, e);
+          } finally {
+            task = null;
           }
         }
       } finally {
@@ -238,6 +246,16 @@ private void workOnQueue() {
         }
       }
     }
+
+    @SuppressWarnings(""GuardedBy"")
+    @Override
+    public String toString() {
+      Runnable currentlyRunning = task;
+      if (currentlyRunning != null) {
+        return ""SequentialExecutorWorker{running="" + currentlyRunning + ""}"";
+      }
+      return ""SequentialExecutorWorker{state="" + workerRunningState + ""}"";
+    }
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Speed up Traverser and cut about 30 lines of code.

When stacked against the unsubmitted Walker, before the change:
   breadthFirst was roughly on par;
   preOrder/postOrder were about 70% slower (1359 vs. 2358);

After adopting the Walker impl, the tree traversal preorder/postorder are improved close to Walker impl.

There is still about 10% slowness (2405 vs. 2268) remaining, which I suspect is due to Iterator being slower than Spliterator, because with Spliterator, we can tryAdvance() once for each element, while with Iterator, we have to call both hasNext() and next().

The graph traversal adoption is similar, with about 15% remaining slowness compared to Walker (1583 vs. 1338), which is likely result of Spliterator.tryAdvance() vs. Iterator.hasNext() + next().

Did not adopt the Walker's breadth-first impl for the following reasons:

1. Adopting the Walker's breadth-first impl contributed about 10% slowdown compared to the current impl. I think this is likely due to the eager foreach loop of the successors in the current breadth-first iterator. In the full traversal benchmark, it's likely faster than consuming the successor iterator lazily.

On the other hand, the breadth-first iterator is inconsistent with the depth-first iterators that consume the successor iterators lazily.

For follow-up: It might be better to go complete lazy for breadth-first, even at the cost of 10% slowdown in the full-traversal benchmark. Plus we can reuse code and delete the two existing BreadthFirstIterator classes.

I'm going to add the benchmark class in the the labs directory to compare between Iteration and Traverser.

RELNOTES=Optimize Traverser

e81f5012d5207c4f07b49007eeff3d19ae618cf8

-------

<p> Add toString() for SequentialExecutor's worker runnable

1facb168dc541be1afa2bf26e15340b0a2e3cffe",MOE Sync 2020-07-13
3964,David P. Baker,"['android/guava-tests/test/com/google/common/graph/TraverserTest.java', 'android/guava/src/com/google/common/graph/Traverser.java', 'guava-tests/test/com/google/common/graph/TraverserTest.java', 'guava/src/com/google/common/graph/Traverser.java']","@@ -184,6 +184,13 @@ public void forGraph_breadthFirstIterable_javadocExample_canBeIteratedMultipleTi
     assertEqualCharNodes(result, ""bfaecd"");
   }
 
+  @Test
+  public void forGraph_breadthFirst_infinite() {
+    Iterable<Integer> result =
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 4)).containsExactly(0, 1, 2, 3).inOrder();
+  }
+
   @Test
   public void forGraph_breadthFirst_diamond() {
     Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);
@@ -373,6 +380,13 @@ public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMult
     assertEqualCharNodes(result, ""bacefd"");
   }
 
+  @Test
+  public void forGraph_depthFirstPreOrder_infinite() {
+    Iterable<Integer> result =
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();
+  }
+
   @Test
   public void forGraph_depthFirstPreOrder_diamond() {
     Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);
@@ -784,6 +798,13 @@ public void forTree_withUndirectedNetwork_throws() throws Exception {
     }
   }
 
+  @Test
+  public void forTree_breadthFirst_infinite() {
+    Iterable<Integer> result =
+        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 8)).containsExactly(0, 1, 2, 3, 1, 2, 3, 1).inOrder();
+  }
+
   @Test
   public void forTree_breadthFirst_tree() throws Exception {
     Traverser<Character> traverser = Traverser.forTree(TREE);
@@ -912,6 +933,13 @@ public void forTree_breadthFirstIterable_iterableIsLazy() {
     assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');
   }
 
+  @Test
+  public void forTree_depthFirstPreOrder_infinite() {
+    Iterable<Integer> result =
+        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
+    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 1).inOrder();
+  }
+
   @Test
   public void forTree_depthFirstPreOrderIterable_tree() throws Exception {
     Traverser<Character> traverser = Traverser.forTree(TREE);
@@ -1238,4 +1266,13 @@ private static void assertEqualCharNodes(Iterable<Character> result, String expe
       return delegate.successors(node);
     }
   }
+
+  private static <N> SuccessorsFunction<N> fixedSuccessors(final Iterable<N> successors) {
+    return new SuccessorsFunction<N>() {
+      @Override
+      public Iterable<N> successors(N n) {
+        return successors;
+      }
+    };
+  }
 }, @@ -22,13 +22,10 @@
 import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.UnmodifiableIterator;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.Queue;
 import java.util.Set;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
@@ -63,6 +60,11 @@
  */
 @Beta
 public abstract class Traverser<N> {
+  private final SuccessorsFunction<N> successorFunction;
+
+  private Traverser(SuccessorsFunction<N> successorFunction) {
+    this.successorFunction = checkNotNull(successorFunction);
+  }
 
   /**
    * Creates a new traverser for the given general {@code graph}.
@@ -88,9 +90,13 @@
    *
    * @param graph {@link SuccessorsFunction} representing a general graph that may have cycles.
    */
-  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {
-    checkNotNull(graph);
-    return new GraphTraverser<>(graph);
+  public static <N> Traverser<N> forGraph(final SuccessorsFunction<N> graph) {
+    return new Traverser<N>(graph) {
+      @Override
+      Traversal<N> newTraversal() {
+        return Traversal.inGraph(graph);
+      }
+    };
   }
 
   /**
@@ -166,15 +172,19 @@
    * @param tree {@link SuccessorsFunction} representing a directed acyclic graph that has at most
    *     one path between any two nodes
    */
-  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {
-    checkNotNull(tree);
+  public static <N> Traverser<N> forTree(final SuccessorsFunction<N> tree) {
     if (tree instanceof BaseGraph) {
       checkArgument(((BaseGraph<?>) tree).isDirected(), ""Undirected graphs can never be trees."");
     }
     if (tree instanceof Network) {
       checkArgument(((Network<?, ?>) tree).isDirected(), ""Undirected networks can never be trees."");
     }
-    return new TreeTraverser<>(tree);
+    return new Traverser<N>(tree) {
+      @Override
+      Traversal<N> newTraversal() {
+        return Traversal.inTree(tree);
+      }
+    };
   }
 
   /**
@@ -208,7 +218,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> breadthFirst(N startNode);
+  public final Iterable<N> breadthFirst(N startNode) {
+    return breadthFirst(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -220,7 +232,15 @@
    * @see #breadthFirst(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);
+  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
+      @Override
+      public Iterator<N> iterator() {
+        return newTraversal().breadthFirst(validated.iterator());
+      }
+    };
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
@@ -253,7 +273,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> depthFirstPreOrder(N startNode);
+  public final Iterable<N> depthFirstPreOrder(N startNode) {
+    return depthFirstPreOrder(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -265,7 +287,15 @@
    * @see #depthFirstPreOrder(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);
+  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
+      @Override
+      public Iterator<N> iterator() {
+        return newTraversal().preOrder(validated.iterator());
+      }
+    };
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
@@ -298,7 +328,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> depthFirstPostOrder(N startNode);
+  public final Iterable<N> depthFirstPostOrder(N startNode) {
+    return depthFirstPostOrder(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -310,246 +342,42 @@
    * @see #depthFirstPostOrder(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);
-
-  // Avoid subclasses outside of this class
-  private Traverser() {}
-
-  private static final class GraphTraverser<N> extends Traverser<N> {
-    private final SuccessorsFunction<N> graph;
-
-    GraphTraverser(SuccessorsFunction<N> graph) {
-      this.graph = checkNotNull(graph);
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final N startNode) {
-      checkNotNull(startNode);
-      return breadthFirst(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return new BreadthFirstIterator(startNodes);
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPreOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inGraph(graph).preOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPostOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inGraph(graph).postOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @SuppressWarnings(""CheckReturnValue"")
-    private void checkThatNodeIsInGraph(N startNode) {
-      // successors() throws an IllegalArgumentException for nodes that are not an element of the
-      // graph.
-      graph.successors(startNode);
-    }
-
-    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {
-      private final Queue<N> queue = new ArrayDeque<>();
-      private final Set<N> visited = new HashSet<>();
-
-      BreadthFirstIterator(Iterable<? extends N> roots) {
-        for (N root : roots) {
-          // add all roots to the queue, skipping duplicates
-          if (visited.add(root)) {
-            queue.add(root);
-          }
-        }
-      }
-
+  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
       @Override
-      public boolean hasNext() {
-        return !queue.isEmpty();
+      public Iterator<N> iterator() {
+        return newTraversal().postOrder(validated.iterator());
       }
-
-      @Override
-      public N next() {
-        N current = queue.remove();
-        for (N neighbor : graph.successors(current)) {
-          if (visited.add(neighbor)) {
-            queue.add(neighbor);
-          }
-        }
-        return current;
-      }
-    }
+    };
   }
 
-  private static final class TreeTraverser<N> extends Traverser<N> {
-    private final SuccessorsFunction<N> tree;
-
-    TreeTraverser(SuccessorsFunction<N> tree) {
-      this.tree = checkNotNull(tree);
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final N startNode) {
-      checkNotNull(startNode);
-      return breadthFirst(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInTree(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return new BreadthFirstIterator(startNodes);
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPreOrder(ImmutableSet.of(startNode));
-    }
+  abstract Traversal<N> newTraversal();
 
-    @Override
-    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N node : startNodes) {
-        checkThatNodeIsInTree(node);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inTree(tree).preOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPostOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInTree(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inTree(tree).postOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @SuppressWarnings(""CheckReturnValue"")
-    private void checkThatNodeIsInTree(N startNode) {
-      // successors() throws an IllegalArgumentException for nodes that are not an element of the
-      // graph.
-      tree.successors(startNode);
-    }
-
-    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {
-      private final Queue<N> queue = new ArrayDeque<>();
-
-      BreadthFirstIterator(Iterable<? extends N> roots) {
-        for (N root : roots) {
-          queue.add(root);
-        }
-      }
-
-      @Override
-      public boolean hasNext() {
-        return !queue.isEmpty();
-      }
-
-      @Override
-      public N next() {
-        N current = queue.remove();
-        Iterables.addAll(queue, tree.successors(current));
-        return current;
-      }
+  @SuppressWarnings(""CheckReturnValue"")
+  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {
+    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);
+    for (N node : copy) {
+      successorFunction.successors(node); // Will throw if node doesn't exist
     }
+    return copy;
   }
 
   /**
    * Abstracts away the difference between traversing a graph vs. a tree. For a tree, we just take
    * the next element from the next non-empty iterator; for graph, we need to loop through the next
    * non-empty iterator to find first unvisited node.
    */
-  private abstract static class Walker<N> {
+  private abstract static class Traversal<N> {
     final SuccessorsFunction<N> successorFunction;
 
-    Walker(SuccessorsFunction<N> successorFunction) {
-      this.successorFunction = checkNotNull(successorFunction);
+    Traversal(SuccessorsFunction<N> successorFunction) {
+      this.successorFunction = successorFunction;
     }
 
-    static <N> Walker<N> inGraph(SuccessorsFunction<N> graph) {
+    static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {
       final Set<N> visited = new HashSet<>();
-      return new Walker<N>(graph) {
+      return new Traversal<N>(graph) {
         @Override
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
@@ -565,8 +393,8 @@ N visitNext(Deque<Iterator<? extends N>> horizon) {
       };
     }
 
-    static <N> Walker<N> inTree(SuccessorsFunction<N> tree) {
-      return new Walker<N>(tree) {
+    static <N> Traversal<N> inTree(SuccessorsFunction<N> tree) {
+      return new Traversal<N>(tree) {
         @Override
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
@@ -579,9 +407,23 @@ N visitNext(Deque<Iterator<? extends N>> horizon) {
       };
     }
 
+    final Iterator<N> breadthFirst(Iterator<? extends N> startNodes) {
+      return topDown(startNodes, InsertionOrder.BACK);
+    }
+
     final Iterator<N> preOrder(Iterator<? extends N> startNodes) {
+      return topDown(startNodes, InsertionOrder.FRONT);
+    }
+
+    /**
+     * In top-down traversal, an ancestor node is always traversed before any of its descendant
+     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are
+     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before
+     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.
+     */
+    private Iterator<N> topDown(Iterator<? extends N> startNodes, final InsertionOrder order) {
       final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
-      horizon.addFirst(startNodes);
+      horizon.add(startNodes);
       return new AbstractIterator<N>() {
         @Override
         protected N computeNext() {
@@ -590,7 +432,9 @@ protected N computeNext() {
             if (next != null) {
               Iterator<? extends N> successors = successorFunction.successors(next).iterator();
               if (successors.hasNext()) {
-                horizon.addFirst(successors);
+                // BFS: horizon.addLast(successors)
+                // Pre-order: horizon.addFirst(successors)
+                order.insertInto(horizon, successors);
               }
               return next;
             }
@@ -601,9 +445,9 @@ protected N computeNext() {
     }
 
     final Iterator<N> postOrder(Iterator<? extends N> startNodes) {
-      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
-      horizon.addFirst(startNodes);
       final Deque<N> ancestorStack = new ArrayDeque<>();
+      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
+      horizon.add(startNodes);
       return new AbstractIterator<N>() {
         @Override
         protected N computeNext() {
@@ -622,9 +466,7 @@ protected N computeNext() {
 
     /**
      * Visits the next node from the top iterator of {@code horizon} and returns the visited node.
-     * Null is returned to indicate reaching the end of the top iterator, which can be used by the
-     * traversal strategies to decide what to return in such case: in pre-order, continue to poll
-     * the next top iterator with {@code visitNext()}; in post-order, return the parent node.
+     * Null is returned to indicate reaching the end of the top iterator.
      *
      * <p>For example, if horizon is {@code [[a, b], [c, d], [e]]}, {@code visitNext()} will return
      * {@code [a, b, null, c, d, null, e, null]} sequentially, encoding the topological structure.
@@ -635,4 +477,22 @@ protected N computeNext() {
     @NullableDecl
     abstract N visitNext(Deque<Iterator<? extends N>> horizon);
   }
+
+  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */
+  private enum InsertionOrder {
+    FRONT {
+      @Override
+      <T> void insertInto(Deque<T> deque, T value) {
+        deque.addFirst(value);
+      }
+    },
+    BACK {
+      @Override
+      <T> void insertInto(Deque<T> deque, T value) {
+        deque.addLast(value);
+      }
+    };
+
+    abstract <T> void insertInto(Deque<T> deque, T value);
+  }
 }, @@ -184,6 +184,13 @@ public void forGraph_breadthFirstIterable_javadocExample_canBeIteratedMultipleTi
     assertEqualCharNodes(result, ""bfaecd"");
   }
 
+  @Test
+  public void forGraph_breadthFirst_infinite() {
+    Iterable<Integer> result =
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 4)).containsExactly(0, 1, 2, 3).inOrder();
+  }
+
   @Test
   public void forGraph_breadthFirst_diamond() {
     Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);
@@ -373,6 +380,13 @@ public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMult
     assertEqualCharNodes(result, ""bacefd"");
   }
 
+  @Test
+  public void forGraph_depthFirstPreOrder_infinite() {
+    Iterable<Integer> result =
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();
+  }
+
   @Test
   public void forGraph_depthFirstPreOrder_diamond() {
     Traverser<Character> traverser = Traverser.forGraph(DIAMOND_GRAPH);
@@ -784,6 +798,13 @@ public void forTree_withUndirectedNetwork_throws() throws Exception {
     }
   }
 
+  @Test
+  public void forTree_breadthFirst_infinite() {
+    Iterable<Integer> result =
+        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
+    assertThat(Iterables.limit(result, 8)).containsExactly(0, 1, 2, 3, 1, 2, 3, 1).inOrder();
+  }
+
   @Test
   public void forTree_breadthFirst_tree() throws Exception {
     Traverser<Character> traverser = Traverser.forTree(TREE);
@@ -912,6 +933,13 @@ public void forTree_breadthFirstIterable_iterableIsLazy() {
     assertThat(graph.requestedNodes).containsExactly('a', 'a', 'd', 'd', 'd', 'g', 'g', 'g');
   }
 
+  @Test
+  public void forTree_depthFirstPreOrder_infinite() {
+    Iterable<Integer> result =
+        Traverser.forTree(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
+    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 1).inOrder();
+  }
+
   @Test
   public void forTree_depthFirstPreOrderIterable_tree() throws Exception {
     Traverser<Character> traverser = Traverser.forTree(TREE);
@@ -1238,4 +1266,13 @@ private static void assertEqualCharNodes(Iterable<Character> result, String expe
       return delegate.successors(node);
     }
   }
+
+  private static <N> SuccessorsFunction<N> fixedSuccessors(final Iterable<N> successors) {
+    return new SuccessorsFunction<N>() {
+      @Override
+      public Iterable<N> successors(N n) {
+        return successors;
+      }
+    };
+  }
 }, @@ -22,13 +22,10 @@
 import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.UnmodifiableIterator;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.Queue;
 import java.util.Set;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -63,6 +60,11 @@
  */
 @Beta
 public abstract class Traverser<N> {
+  private final SuccessorsFunction<N> successorFunction;
+
+  private Traverser(SuccessorsFunction<N> successorFunction) {
+    this.successorFunction = checkNotNull(successorFunction);
+  }
 
   /**
    * Creates a new traverser for the given general {@code graph}.
@@ -88,9 +90,13 @@
    *
    * @param graph {@link SuccessorsFunction} representing a general graph that may have cycles.
    */
-  public static <N> Traverser<N> forGraph(SuccessorsFunction<N> graph) {
-    checkNotNull(graph);
-    return new GraphTraverser<>(graph);
+  public static <N> Traverser<N> forGraph(final SuccessorsFunction<N> graph) {
+    return new Traverser<N>(graph) {
+      @Override
+      Traversal<N> newTraversal() {
+        return Traversal.inGraph(graph);
+      }
+    };
   }
 
   /**
@@ -166,15 +172,19 @@
    * @param tree {@link SuccessorsFunction} representing a directed acyclic graph that has at most
    *     one path between any two nodes
    */
-  public static <N> Traverser<N> forTree(SuccessorsFunction<N> tree) {
-    checkNotNull(tree);
+  public static <N> Traverser<N> forTree(final SuccessorsFunction<N> tree) {
     if (tree instanceof BaseGraph) {
       checkArgument(((BaseGraph<?>) tree).isDirected(), ""Undirected graphs can never be trees."");
     }
     if (tree instanceof Network) {
       checkArgument(((Network<?, ?>) tree).isDirected(), ""Undirected networks can never be trees."");
     }
-    return new TreeTraverser<>(tree);
+    return new Traverser<N>(tree) {
+      @Override
+      Traversal<N> newTraversal() {
+        return Traversal.inTree(tree);
+      }
+    };
   }
 
   /**
@@ -208,7 +218,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> breadthFirst(N startNode);
+  public final Iterable<N> breadthFirst(N startNode) {
+    return breadthFirst(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -220,7 +232,15 @@
    * @see #breadthFirst(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> breadthFirst(Iterable<? extends N> startNodes);
+  public final Iterable<N> breadthFirst(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
+      @Override
+      public Iterator<N> iterator() {
+        return newTraversal().breadthFirst(validated.iterator());
+      }
+    };
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
@@ -253,7 +273,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> depthFirstPreOrder(N startNode);
+  public final Iterable<N> depthFirstPreOrder(N startNode) {
+    return depthFirstPreOrder(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -265,7 +287,15 @@
    * @see #depthFirstPreOrder(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes);
+  public final Iterable<N> depthFirstPreOrder(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
+      @Override
+      public Iterator<N> iterator() {
+        return newTraversal().preOrder(validated.iterator());
+      }
+    };
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from {@code startNode}, in
@@ -298,7 +328,9 @@
    *
    * @throws IllegalArgumentException if {@code startNode} is not an element of the graph
    */
-  public abstract Iterable<N> depthFirstPostOrder(N startNode);
+  public final Iterable<N> depthFirstPostOrder(N startNode) {
+    return depthFirstPostOrder(ImmutableSet.of(startNode));
+  }
 
   /**
    * Returns an unmodifiable {@code Iterable} over the nodes reachable from any of the {@code
@@ -310,246 +342,42 @@
    * @see #depthFirstPostOrder(Object)
    * @since 24.1
    */
-  public abstract Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes);
-
-  // Avoid subclasses outside of this class
-  private Traverser() {}
-
-  private static final class GraphTraverser<N> extends Traverser<N> {
-    private final SuccessorsFunction<N> graph;
-
-    GraphTraverser(SuccessorsFunction<N> graph) {
-      this.graph = checkNotNull(graph);
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final N startNode) {
-      checkNotNull(startNode);
-      return breadthFirst(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return new BreadthFirstIterator(startNodes);
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPreOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inGraph(graph).preOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPostOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInGraph(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inGraph(graph).postOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @SuppressWarnings(""CheckReturnValue"")
-    private void checkThatNodeIsInGraph(N startNode) {
-      // successors() throws an IllegalArgumentException for nodes that are not an element of the
-      // graph.
-      graph.successors(startNode);
-    }
-
-    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {
-      private final Queue<N> queue = new ArrayDeque<>();
-      private final Set<N> visited = new HashSet<>();
-
-      BreadthFirstIterator(Iterable<? extends N> roots) {
-        for (N root : roots) {
-          // add all roots to the queue, skipping duplicates
-          if (visited.add(root)) {
-            queue.add(root);
-          }
-        }
-      }
-
+  public final Iterable<N> depthFirstPostOrder(Iterable<? extends N> startNodes) {
+    final ImmutableSet<N> validated = validate(startNodes);
+    return new Iterable<N>() {
       @Override
-      public boolean hasNext() {
-        return !queue.isEmpty();
+      public Iterator<N> iterator() {
+        return newTraversal().postOrder(validated.iterator());
       }
-
-      @Override
-      public N next() {
-        N current = queue.remove();
-        for (N neighbor : graph.successors(current)) {
-          if (visited.add(neighbor)) {
-            queue.add(neighbor);
-          }
-        }
-        return current;
-      }
-    }
+    };
   }
 
-  private static final class TreeTraverser<N> extends Traverser<N> {
-    private final SuccessorsFunction<N> tree;
-
-    TreeTraverser(SuccessorsFunction<N> tree) {
-      this.tree = checkNotNull(tree);
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final N startNode) {
-      checkNotNull(startNode);
-      return breadthFirst(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> breadthFirst(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInTree(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return new BreadthFirstIterator(startNodes);
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPreOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPreOrder(ImmutableSet.of(startNode));
-    }
+  abstract Traversal<N> newTraversal();
 
-    @Override
-    public Iterable<N> depthFirstPreOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N node : startNodes) {
-        checkThatNodeIsInTree(node);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inTree(tree).preOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final N startNode) {
-      checkNotNull(startNode);
-      return depthFirstPostOrder(ImmutableSet.of(startNode));
-    }
-
-    @Override
-    public Iterable<N> depthFirstPostOrder(final Iterable<? extends N> startNodes) {
-      checkNotNull(startNodes);
-      if (Iterables.isEmpty(startNodes)) {
-        return ImmutableSet.of();
-      }
-      for (N startNode : startNodes) {
-        checkThatNodeIsInTree(startNode);
-      }
-      return new Iterable<N>() {
-        @Override
-        public Iterator<N> iterator() {
-          return Walker.inTree(tree).postOrder(startNodes.iterator());
-        }
-      };
-    }
-
-    @SuppressWarnings(""CheckReturnValue"")
-    private void checkThatNodeIsInTree(N startNode) {
-      // successors() throws an IllegalArgumentException for nodes that are not an element of the
-      // graph.
-      tree.successors(startNode);
-    }
-
-    private final class BreadthFirstIterator extends UnmodifiableIterator<N> {
-      private final Queue<N> queue = new ArrayDeque<>();
-
-      BreadthFirstIterator(Iterable<? extends N> roots) {
-        for (N root : roots) {
-          queue.add(root);
-        }
-      }
-
-      @Override
-      public boolean hasNext() {
-        return !queue.isEmpty();
-      }
-
-      @Override
-      public N next() {
-        N current = queue.remove();
-        Iterables.addAll(queue, tree.successors(current));
-        return current;
-      }
+  @SuppressWarnings(""CheckReturnValue"")
+  private ImmutableSet<N> validate(Iterable<? extends N> startNodes) {
+    ImmutableSet<N> copy = ImmutableSet.copyOf(startNodes);
+    for (N node : copy) {
+      successorFunction.successors(node); // Will throw if node doesn't exist
     }
+    return copy;
   }
 
   /**
    * Abstracts away the difference between traversing a graph vs. a tree. For a tree, we just take
    * the next element from the next non-empty iterator; for graph, we need to loop through the next
    * non-empty iterator to find first unvisited node.
    */
-  private abstract static class Walker<N> {
+  private abstract static class Traversal<N> {
     final SuccessorsFunction<N> successorFunction;
 
-    Walker(SuccessorsFunction<N> successorFunction) {
-      this.successorFunction = checkNotNull(successorFunction);
+    Traversal(SuccessorsFunction<N> successorFunction) {
+      this.successorFunction = successorFunction;
     }
 
-    static <N> Walker<N> inGraph(SuccessorsFunction<N> graph) {
+    static <N> Traversal<N> inGraph(SuccessorsFunction<N> graph) {
       final Set<N> visited = new HashSet<>();
-      return new Walker<N>(graph) {
+      return new Traversal<N>(graph) {
         @Override
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
@@ -565,8 +393,8 @@ N visitNext(Deque<Iterator<? extends N>> horizon) {
       };
     }
 
-    static <N> Walker<N> inTree(SuccessorsFunction<N> tree) {
-      return new Walker<N>(tree) {
+    static <N> Traversal<N> inTree(SuccessorsFunction<N> tree) {
+      return new Traversal<N>(tree) {
         @Override
         N visitNext(Deque<Iterator<? extends N>> horizon) {
           Iterator<? extends N> top = horizon.getFirst();
@@ -579,9 +407,23 @@ N visitNext(Deque<Iterator<? extends N>> horizon) {
       };
     }
 
+    final Iterator<N> breadthFirst(Iterator<? extends N> startNodes) {
+      return topDown(startNodes, InsertionOrder.BACK);
+    }
+
     final Iterator<N> preOrder(Iterator<? extends N> startNodes) {
+      return topDown(startNodes, InsertionOrder.FRONT);
+    }
+
+    /**
+     * In top-down traversal, an ancestor node is always traversed before any of its descendant
+     * nodes. The traversal order among descendant nodes (particularly aunts and nieces) are
+     * determined by the {@code InsertionOrder} parameter: nieces are placed at the FRONT before
+     * aunts for pre-order; while in BFS they are placed at the BACK after aunts.
+     */
+    private Iterator<N> topDown(Iterator<? extends N> startNodes, final InsertionOrder order) {
       final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
-      horizon.addFirst(startNodes);
+      horizon.add(startNodes);
       return new AbstractIterator<N>() {
         @Override
         protected N computeNext() {
@@ -590,7 +432,9 @@ protected N computeNext() {
             if (next != null) {
               Iterator<? extends N> successors = successorFunction.successors(next).iterator();
               if (successors.hasNext()) {
-                horizon.addFirst(successors);
+                // BFS: horizon.addLast(successors)
+                // Pre-order: horizon.addFirst(successors)
+                order.insertInto(horizon, successors);
               }
               return next;
             }
@@ -601,9 +445,9 @@ protected N computeNext() {
     }
 
     final Iterator<N> postOrder(Iterator<? extends N> startNodes) {
-      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
-      horizon.addFirst(startNodes);
       final Deque<N> ancestorStack = new ArrayDeque<>();
+      final Deque<Iterator<? extends N>> horizon = new ArrayDeque<>();
+      horizon.add(startNodes);
       return new AbstractIterator<N>() {
         @Override
         protected N computeNext() {
@@ -622,9 +466,7 @@ protected N computeNext() {
 
     /**
      * Visits the next node from the top iterator of {@code horizon} and returns the visited node.
-     * Null is returned to indicate reaching the end of the top iterator, which can be used by the
-     * traversal strategies to decide what to return in such case: in pre-order, continue to poll
-     * the next top iterator with {@code visitNext()}; in post-order, return the parent node.
+     * Null is returned to indicate reaching the end of the top iterator.
      *
      * <p>For example, if horizon is {@code [[a, b], [c, d], [e]]}, {@code visitNext()} will return
      * {@code [a, b, null, c, d, null, e, null]} sequentially, encoding the topological structure.
@@ -635,4 +477,22 @@ protected N computeNext() {
     @Nullable
     abstract N visitNext(Deque<Iterator<? extends N>> horizon);
   }
+
+  /** Poor man's method reference for {@code Deque::addFirst} and {@code Deque::addLast}. */
+  private enum InsertionOrder {
+    FRONT {
+      @Override
+      <T> void insertInto(Deque<T> deque, T value) {
+        deque.addFirst(value);
+      }
+    },
+    BACK {
+      @Override
+      <T> void insertInto(Deque<T> deque, T value) {
+        deque.addLast(value);
+      }
+    };
+
+    abstract <T> void insertInto(Deque<T> deque, T value);
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make breadth-first iterators consume the successor iterators lazily, and refactor to  cut about 150 lines of code.

RELNOTES=Lazier Traverser#breadthFirst().

579c06dc9453fc7b09c8b392507cba09e239c363",MOE Sync 2020-07-14
3967,David P. Baker,"['android/guava-tests/test/com/google/common/graph/TraverserTest.java', 'android/guava/src/com/google/common/graph/Traverser.java', 'guava-tests/test/com/google/common/graph/TraverserTest.java', 'guava/src/com/google/common/graph/Traverser.java']","@@ -383,8 +383,8 @@ public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMult
   @Test
   public void forGraph_depthFirstPreOrder_infinite() {
     Iterable<Integer> result =
-        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
-    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
+    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 2).inOrder();
   }
 
   @Test, @@ -22,6 +22,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.DoNotMock;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
@@ -59,6 +60,9 @@
  * @since 23.1
  */
 @Beta
+@DoNotMock(
+    ""Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with""
+        + "" GraphBuilder)"")
 public abstract class Traverser<N> {
   private final SuccessorsFunction<N> successorFunction;
 , @@ -383,8 +383,8 @@ public void forGraph_depthFirstPreOrderIterable_javadocExample_canBeIteratedMult
   @Test
   public void forGraph_depthFirstPreOrder_infinite() {
     Iterable<Integer> result =
-        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).breadthFirst(0);
-    assertThat(Iterables.limit(result, 2)).containsExactly(0, 1).inOrder();
+        Traverser.forGraph(fixedSuccessors(Iterables.cycle(1, 2, 3))).depthFirstPreOrder(0);
+    assertThat(Iterables.limit(result, 3)).containsExactly(0, 1, 2).inOrder();
   }
 
   @Test, @@ -22,6 +22,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.DoNotMock;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
@@ -59,6 +60,9 @@
  * @since 23.1
  */
 @Beta
+@DoNotMock(
+    ""Call forGraph or forTree, passing a lambda or a Graph with the desired edges (built with""
+        + "" GraphBuilder)"")
 public abstract class Traverser<N> {
   private final SuccessorsFunction<N> successorFunction;
 , ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Unconditionally call setException for RejectedExecutionException.

Under JDK11, the write to thrownByExecute / thrownFromDelegate is upsetting TSAN. I *suspect* that TSAN is incorrect (and that it is likely to identify the same ""problem"" in other code).

However, we years ago questioned whether the code I'm removing served any real purpose...
(fixes https://github.com/google/guava/issues/2877)
...so now seems like a good time to get rid of it and, at minimum, hopefully eliminate the current TSAN failure.

The code that we're running in the executor is under our control. (That is, we're the ones who implement Runnable.run().) We're catching exceptions (and thus any RejectedExecutionException) in the obvious places. Occasionally we do call listeners, but naturally we do that only after completing the future or at least calling setFuture (after which a stray setException(rejectedExecutionException) would be a no-op).

The one(?) exception to that is that InterruptibleTask.run() can call currentThread.interrupt(), which we learned a few years ago can call arbitrary code through nio callbacks. At some point, though, I throw my hands up and say ""whatever.""

(If the interrupt were to be a problem, it would have to be with an executor that executes tasks inline, like directExecutor. But I note that rejectionPropagatingExecutor, at least, already defends against this for directExecutor itself (by skipping the RejectedExecutionException logic entirely). So the danger exists only with CombinedFutureInterruptibleTask or with a non-directExecutor that can execute tasks inline without catching exceptions -- and again, only in concert with nio interrupt callbacks. I think.)

238c383c13d05a75bb6b590f1542e5f4b11f0634

-------

<p> Add @DoNotMock to Traverser.

RELNOTES=Add @DoNotMock to Traverser

83e545cd90bbd64b71ac66ff51267bca670bf8f9",MOE Sync 2020-07-16
3970,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'android/guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'android/guava/src/com/google/common/util/concurrent/MoreExecutors.java', 'futures/listenablefuture1/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava/src/com/google/common/util/concurrent/MoreExecutors.java']","@@ -595,6 +595,9 @@ public boolean isCancelled() {
    * #wasInterrupted} as necessary. This ensures that the work is done even if the future is
    * cancelled without a call to {@code cancel}, such as by calling {@code
    * setFuture(cancelledFuture)}.
+   *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
    */
   @CanIgnoreReturnValue
   @Override
@@ -728,6 +731,9 @@ public void addListener(Runnable listener, Executor executor) {
    * yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
    * method, only by a call to {@link #cancel}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param value the value to be used as the result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
@@ -750,6 +756,9 @@ protected boolean set(@NullableDecl V value) {
    * known yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
    * method, only by a call to {@link #cancel}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param throwable the exception to be used as the failed result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
@@ -784,6 +793,9 @@ protected boolean setException(Throwable throwable) {
    * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not
    * return {@code true}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param future the future to delegate to
    * @return true if the attempt was accepted, indicating that the {@code Future} was not previously
    *     cancelled or set., @@ -256,9 +256,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * @param input the primary input {@code Future}
    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
@@ -323,11 +321,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid
-   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should
-   * occur in other threads responsible for completing the returned {@code Future}.)
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * @param input the primary input {@code Future}
    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
@@ -395,11 +389,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid
-   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should
-   * occur in other threads responsible for completing the returned {@code Future}.)
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
    * input future and that of the future returned by the chain function. That is, if the returned
@@ -435,9 +425,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
    * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel
@@ -1003,9 +991,7 @@ private void recordCompletion() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * callbacks passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link
    * ListenableFuture#addListener addListener}., @@ -114,20 +114,10 @@
    * thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and
    * logged.
    *
-   * <p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider
-   * {@link MoreExecutors#directExecutor}. Otherwise, avoid it. Heavyweight {@code directExecutor}
-   * listeners can cause problems, and these problems can be difficult to reproduce because they
-   * depend on timing. For example:
-   *
-   * <ul>
-   *   <li>The listener may be executed by the caller of {@code addListener}. That caller may be a
-   *       UI thread or other latency-sensitive thread. This can harm UI responsiveness.
-   *   <li>The listener may be executed by the thread that completes this {@code Future}. That
-   *       thread may be an internal system thread such as an RPC network thread. Blocking that
-   *       thread may stall progress of the whole system. It may even cause a deadlock.
-   *   <li>The listener may delay other listeners, even listeners that are not themselves {@code
-   *       directExecutor} listeners.
-   * </ul>
+   * <p>Note: If your listener is lightweight -- and will not cause stack overflow by completing
+   * more futures or adding more {@code directExecutor()} listeners inline -- consider {@link
+   * MoreExecutors#directExecutor}. Otherwise, avoid it: See the warnings on the docs for {@code
+   * directExecutor}.
    *
    * <p>This is the most general listener interface. For common operations performed using
    * listeners, see {@link Futures}. For a simplified but general listener interface, see {@link, @@ -372,6 +372,32 @@ public static ListeningExecutorService newDirectExecutorService() {
    * Returns an {@link Executor} that runs each task in the thread that invokes {@link
    * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.
    *
+   * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.
+   * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be
+   * difficult to reproduce because they depend on timing. For example:
+   *
+   * <ul>
+   *   <li>A call like {@code future.transform(function, directExecutor())} may execute the function
+   *       immediately in the thread that is calling {@code transform}. (This specific case happens
+   *       if the future is already completed.) If {@code transform} call was made from a UI thread
+   *       or other latency-sensitive thread, a heavyweight function can harm responsiveness.
+   *   <li>If the task will be executed later, consider which thread will trigger the execution --
+   *       since that thread will execute the task inline. If the thread is a shared system thread
+   *       like an RPC network thread, a heavyweight task can stall progress of the whole system or
+   *       even deadlock it.
+   *   <li>If many tasks will be triggered by the same event, one heavyweight task may delay other
+   *       tasks -- even tasks that are not themselves {@code directExecutor} tasks.
+   *   <li>If many such tasks are chained together (such as with {@code
+   *       future.transform(...).transform(...).transform(...)....}), they may overflow the stack.
+   *       (In simple cases, callers can avoid this by registering all tasks with the same {@link
+   *       MoreExecutors#newSequentialExecutor} wrapper around {@code directExecutor()}. More
+   *       complex cases may require using thread pools or making deeper changes.)
+   * </ul>
+   *
+   * Additionally, beware of executing tasks with {@code directExecutor} while holding a lock. Since
+   * the task you submit to the executor (or any other arbitrary work the executor does) may do slow
+   * work or acquire other locks, you risk deadlocks.
+   *
    * <p>This instance is equivalent to:
    *
    * <pre>{@code, @@ -114,20 +114,10 @@
    * thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and
    * logged.
    *
-   * <p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider
-   * {@link MoreExecutors#directExecutor}. Otherwise, avoid it. Heavyweight {@code directExecutor}
-   * listeners can cause problems, and these problems can be difficult to reproduce because they
-   * depend on timing. For example:
-   *
-   * <ul>
-   *   <li>The listener may be executed by the caller of {@code addListener}. That caller may be a
-   *       UI thread or other latency-sensitive thread. This can harm UI responsiveness.
-   *   <li>The listener may be executed by the thread that completes this {@code Future}. That
-   *       thread may be an internal system thread such as an RPC network thread. Blocking that
-   *       thread may stall progress of the whole system. It may even cause a deadlock.
-   *   <li>The listener may delay other listeners, even listeners that are not themselves {@code
-   *       directExecutor} listeners.
-   * </ul>
+   * <p>Note: If your listener is lightweight -- and will not cause stack overflow by completing
+   * more futures or adding more {@code directExecutor()} listeners inline -- consider {@link
+   * MoreExecutors#directExecutor}. Otherwise, avoid it: See the warnings on the docs for {@code
+   * directExecutor}.
    *
    * <p>This is the most general listener interface. For common operations performed using
    * listeners, see {@link Futures}. For a simplified but general listener interface, see {@link, @@ -595,6 +595,9 @@ public boolean isCancelled() {
    * #wasInterrupted} as necessary. This ensures that the work is done even if the future is
    * cancelled without a call to {@code cancel}, such as by calling {@code
    * setFuture(cancelledFuture)}.
+   *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
    */
   @CanIgnoreReturnValue
   @Override
@@ -728,6 +731,9 @@ public void addListener(Runnable listener, Executor executor) {
    * yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
    * method, only by a call to {@link #cancel}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param value the value to be used as the result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
@@ -750,6 +756,9 @@ protected boolean set(@Nullable V value) {
    * known yet. That result, though not yet known, cannot be overridden by a call to a {@code set*}
    * method, only by a call to {@link #cancel}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param throwable the exception to be used as the failed result
    * @return true if the attempt was accepted, completing the {@code Future}
    */
@@ -784,6 +793,9 @@ protected boolean setException(Throwable throwable) {
    * invoke the {@link #interruptTask} method, and the {@link #wasInterrupted} method will not
    * return {@code true}.
    *
+   * <p>Beware of completing a future while holding a lock. Its listeners may do slow work or
+   * acquire other locks, risking deadlocks.
+   *
    * @param future the future to delegate to
    * @return true if the attempt was accepted, indicating that the {@code Future} was not previously
    *     cancelled or set., @@ -271,9 +271,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * @param input the primary input {@code Future}
    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
@@ -338,11 +336,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid
-   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should
-   * occur in other threads responsible for completing the returned {@code Future}.)
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * @param input the primary input {@code Future}
    * @param exceptionType the exception type that triggers use of {@code fallback}. The exception
@@ -428,11 +422,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method. (Specifically, {@code directExecutor} functions should avoid
-   * heavyweight operations inside {@code AsyncFunction.apply}. Any heavyweight operations should
-   * occur in other threads responsible for completing the returned {@code Future}.)
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
    * input future and that of the future returned by the chain function. That is, if the returned
@@ -468,9 +458,7 @@ public void run() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * functions passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>The returned {@code Future} attempts to keep its cancellation state in sync with that of the
    * input future. That is, if the returned {@code Future} is cancelled, it will attempt to cancel
@@ -1036,9 +1024,7 @@ private void recordCompletion() {
    * }</pre>
    *
    * <p>When selecting an executor, note that {@code directExecutor} is dangerous in some cases. See
-   * the discussion in the {@link ListenableFuture#addListener ListenableFuture.addListener}
-   * documentation. All its warnings about heavyweight listeners are also applicable to heavyweight
-   * callbacks passed to this method.
+   * the warnings the {@link MoreExecutors#directExecutor} documentation.
    *
    * <p>For a more general interface to attach a completion listener to a {@code Future}, see {@link
    * ListenableFuture#addListener addListener}., @@ -114,20 +114,10 @@
    * thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught and
    * logged.
    *
-   * <p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider
-   * {@link MoreExecutors#directExecutor}. Otherwise, avoid it. Heavyweight {@code directExecutor}
-   * listeners can cause problems, and these problems can be difficult to reproduce because they
-   * depend on timing. For example:
-   *
-   * <ul>
-   *   <li>The listener may be executed by the caller of {@code addListener}. That caller may be a
-   *       UI thread or other latency-sensitive thread. This can harm UI responsiveness.
-   *   <li>The listener may be executed by the thread that completes this {@code Future}. That
-   *       thread may be an internal system thread such as an RPC network thread. Blocking that
-   *       thread may stall progress of the whole system. It may even cause a deadlock.
-   *   <li>The listener may delay other listeners, even listeners that are not themselves {@code
-   *       directExecutor} listeners.
-   * </ul>
+   * <p>Note: If your listener is lightweight -- and will not cause stack overflow by completing
+   * more futures or adding more {@code directExecutor()} listeners inline -- consider {@link
+   * MoreExecutors#directExecutor}. Otherwise, avoid it: See the warnings on the docs for {@code
+   * directExecutor}.
    *
    * <p>This is the most general listener interface. For common operations performed using
    * listeners, see {@link Futures}. For a simplified but general listener interface, see {@link, @@ -433,6 +433,32 @@ public static ListeningExecutorService newDirectExecutorService() {
    * Returns an {@link Executor} that runs each task in the thread that invokes {@link
    * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.
    *
+   * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.
+   * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be
+   * difficult to reproduce because they depend on timing. For example:
+   *
+   * <ul>
+   *   <li>A call like {@code future.transform(function, directExecutor())} may execute the function
+   *       immediately in the thread that is calling {@code transform}. (This specific case happens
+   *       if the future is already completed.) If {@code transform} call was made from a UI thread
+   *       or other latency-sensitive thread, a heavyweight function can harm responsiveness.
+   *   <li>If the task will be executed later, consider which thread will trigger the execution --
+   *       since that thread will execute the task inline. If the thread is a shared system thread
+   *       like an RPC network thread, a heavyweight task can stall progress of the whole system or
+   *       even deadlock it.
+   *   <li>If many tasks will be triggered by the same event, one heavyweight task may delay other
+   *       tasks -- even tasks that are not themselves {@code directExecutor} tasks.
+   *   <li>If many such tasks are chained together (such as with {@code
+   *       future.transform(...).transform(...).transform(...)....}), they may overflow the stack.
+   *       (In simple cases, callers can avoid this by registering all tasks with the same {@link
+   *       MoreExecutors#newSequentialExecutor} wrapper around {@code directExecutor()}. More
+   *       complex cases may require using thread pools or making deeper changes.)
+   * </ul>
+   *
+   * Additionally, beware of executing tasks with {@code directExecutor} while holding a lock. Since
+   * the task you submit to the executor (or any other arbitrary work the executor does) may do slow
+   * work or acquire other locks, you risk deadlocks.
+   *
    * <p>This instance is equivalent to:
    *
    * <pre>{@code, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Warn about stack overflows from directExecutor, add more warnings (including on AbstractFuture.set* and cancel), and move warnings to directExecutor itself.

e649a158d3202beefd3375c1774db90a31228708",MOE Sync 2020-07-22
3971,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/UninterruptiblesTest.java', 'android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java', 'guava-tests/test/com/google/common/util/concurrent/UninterruptiblesTest.java', 'guava/src/com/google/common/util/concurrent/Uninterruptibles.java']","@@ -17,12 +17,14 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.InterruptionUtil.repeatedlyInterruptTestThread;
+import static com.google.common.util.concurrent.Uninterruptibles.awaitTerminationUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.joinUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.putUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.takeUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryAcquireUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryLockUninterruptibly;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -36,6 +38,7 @@
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
@@ -465,6 +468,37 @@ public void testTryAcquireTimeoutMultiInterruptExpiredMultiPermit() {
     assertInterrupted();
   }
 
+  // executor.awaitTermination Testcases
+  public void testTryAwaitTerminationUninterruptiblyLongTimeUnit_success() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(1000));
+    executor.shutdown();
+    assertTrue(awaitTerminationUninterruptibly(executor, LONG_DELAY_MS, MILLISECONDS));
+    assertTrue(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationUninterruptiblyLongTimeUnit_failure() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(10000));
+    executor.shutdown();
+    assertFalse(awaitTerminationUninterruptibly(executor, 1000, MILLISECONDS));
+    assertFalse(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationInfiniteTimeout() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(1000));
+    executor.shutdown();
+    awaitTerminationUninterruptibly(executor);
+    assertTrue(executor.isTerminated());
+    assertInterrupted();
+  }
+
   /**
    * Wrapper around {@link Stopwatch} which also contains an ""expected completion time."" Creating a
    * {@code Completion} starts the underlying stopwatch.
@@ -754,6 +788,15 @@ protected void doAction() {
     }
   }
 
+  private static final class SleepTask extends DelayedActionRunnable {
+    SleepTask(long tMinus) {
+      super(tMinus);
+    }
+
+    @Override
+    protected void doAction() {}
+  }
+
   private static void sleepSuccessfully(long sleepMillis) {
     Completion completed = new Completion(sleepMillis - SLEEP_SLACK);
     Uninterruptibles.sleepUninterruptibly(sleepMillis, MILLISECONDS);, @@ -14,8 +14,10 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.base.Verify.verify;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
+import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
@@ -24,6 +26,7 @@
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
@@ -396,6 +399,50 @@ public static boolean tryLockUninterruptibly(Lock lock, long timeout, TimeUnit u
     }
   }
 
+  /**
+   * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
+   * awaitTermination(long, TimeUnit)} uninterruptibly with no timeout.
+   *
+   * @since NEXT
+   */
+  @Beta
+  @GwtIncompatible // concurrency
+  public static void awaitTerminationUninterruptibly(ExecutorService executor) {
+    // TODO(cpovirk): We could optimize this to avoid calling nanoTime() at all.
+    verify(awaitTerminationUninterruptibly(executor, Long.MAX_VALUE, NANOSECONDS));
+  }
+
+  /**
+   * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
+   * awaitTermination(long, TimeUnit)} uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @Beta
+  @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"")
+  public static boolean awaitTerminationUninterruptibly(
+      ExecutorService executor, long timeout, TimeUnit unit) {
+    boolean interrupted = false;
+    try {
+      long remainingNanos = unit.toNanos(timeout);
+      long end = System.nanoTime() + remainingNanos;
+
+      while (true) {
+        try {
+          return executor.awaitTermination(remainingNanos, NANOSECONDS);
+        } catch (InterruptedException e) {
+          interrupted = true;
+          remainingNanos = end - System.nanoTime();
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   // TODO(user): Add support for waitUninterruptibly.
 
   private Uninterruptibles() {}, @@ -17,12 +17,14 @@
 package com.google.common.util.concurrent;
 
 import static com.google.common.util.concurrent.InterruptionUtil.repeatedlyInterruptTestThread;
+import static com.google.common.util.concurrent.Uninterruptibles.awaitTerminationUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.joinUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.putUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.takeUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryAcquireUninterruptibly;
 import static com.google.common.util.concurrent.Uninterruptibles.tryLockUninterruptibly;
+import static java.util.concurrent.Executors.newFixedThreadPool;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -32,10 +34,12 @@
 import com.google.common.testing.TearDown;
 import com.google.common.testing.TearDownStack;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.time.Duration;
 import java.util.Date;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
@@ -465,6 +469,57 @@ public void testTryAcquireTimeoutMultiInterruptExpiredMultiPermit() {
     assertInterrupted();
   }
 
+  // executor.awaitTermination Testcases
+  public void testTryAwaitTerminationUninterruptiblyDuration_success() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(1000));
+    executor.shutdown();
+    assertTrue(awaitTerminationUninterruptibly(executor, Duration.ofMillis(LONG_DELAY_MS)));
+    assertTrue(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationUninterruptiblyDuration_failure() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(10000));
+    executor.shutdown();
+    assertFalse(awaitTerminationUninterruptibly(executor, Duration.ofMillis(1000)));
+    assertFalse(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationUninterruptiblyLongTimeUnit_success() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(1000));
+    executor.shutdown();
+    assertTrue(awaitTerminationUninterruptibly(executor, LONG_DELAY_MS, MILLISECONDS));
+    assertTrue(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationUninterruptiblyLongTimeUnit_failure() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(10000));
+    executor.shutdown();
+    assertFalse(awaitTerminationUninterruptibly(executor, 1000, MILLISECONDS));
+    assertFalse(executor.isTerminated());
+    assertInterrupted();
+  }
+
+  public void testTryAwaitTerminationInfiniteTimeout() {
+    ExecutorService executor = newFixedThreadPool(1);
+    requestInterruptIn(500);
+    executor.execute(new SleepTask(1000));
+    executor.shutdown();
+    awaitTerminationUninterruptibly(executor);
+    assertTrue(executor.isTerminated());
+    assertInterrupted();
+  }
+
   /**
    * Wrapper around {@link Stopwatch} which also contains an ""expected completion time."" Creating a
    * {@code Completion} starts the underlying stopwatch.
@@ -754,6 +809,15 @@ protected void doAction() {
     }
   }
 
+  private static final class SleepTask extends DelayedActionRunnable {
+    SleepTask(long tMinus) {
+      super(tMinus);
+    }
+
+    @Override
+    protected void doAction() {}
+  }
+
   private static void sleepSuccessfully(long sleepMillis) {
     Completion completed = new Completion(sleepMillis - SLEEP_SLACK);
     Uninterruptibles.sleepUninterruptibly(sleepMillis, MILLISECONDS);, @@ -14,6 +14,7 @@
 
 package com.google.common.util.concurrent;
 
+import static com.google.common.base.Verify.verify;
 import static com.google.common.util.concurrent.Internal.toNanosSaturated;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
@@ -27,6 +28,7 @@
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
@@ -513,6 +515,63 @@ public static boolean tryLockUninterruptibly(Lock lock, long timeout, TimeUnit u
     }
   }
 
+  /**
+   * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
+   * awaitTermination(long, TimeUnit)} uninterruptibly with no timeout.
+   *
+   * @since NEXT
+   */
+  @Beta
+  @GwtIncompatible // concurrency
+  public static void awaitTerminationUninterruptibly(ExecutorService executor) {
+    // TODO(cpovirk): We could optimize this to avoid calling nanoTime() at all.
+    verify(awaitTerminationUninterruptibly(executor, Long.MAX_VALUE, NANOSECONDS));
+  }
+
+  /**
+   * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
+   * awaitTermination(long, TimeUnit)} uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @Beta
+  @GwtIncompatible // concurrency
+  public static boolean awaitTerminationUninterruptibly(
+      ExecutorService executor, Duration timeout) {
+    return awaitTerminationUninterruptibly(executor, toNanosSaturated(timeout), NANOSECONDS);
+  }
+
+  /**
+   * Invokes {@code executor.}{@link ExecutorService#awaitTermination(long, TimeUnit)
+   * awaitTermination(long, TimeUnit)} uninterruptibly.
+   *
+   * @since NEXT
+   */
+  @Beta
+  @GwtIncompatible // concurrency
+  @SuppressWarnings(""GoodTime"")
+  public static boolean awaitTerminationUninterruptibly(
+      ExecutorService executor, long timeout, TimeUnit unit) {
+    boolean interrupted = false;
+    try {
+      long remainingNanos = unit.toNanos(timeout);
+      long end = System.nanoTime() + remainingNanos;
+
+      while (true) {
+        try {
+          return executor.awaitTermination(remainingNanos, NANOSECONDS);
+        } catch (InterruptedException e) {
+          interrupted = true;
+          remainingNanos = end - System.nanoTime();
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt();
+      }
+    }
+  }
+
   // TODO(user): Add support for waitUninterruptibly.
 
   private Uninterruptibles() {}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add awaitTerminationUninterruptibly.

Fixes #3908
Fixes #1315
Somewhat relevant to https://github.com/google/guava/issues/3655
Vaguely relevant to https://github.com/google/error-prone/issues/1490, since it creates a `@CheckReturnValue` variant of a `java.util.concurrent` method that returns `false` to indicate timeout.

RELNOTES=`util.concurrent`: Added `awaitTerminationUninterruptibly`.

1ec90b045a45b4603ea5bd1c296f284ec1c438db",MOE Sync 2020-07-22
3973,Chris Povirk,"['guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableBiMap.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableList.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableMap.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSet.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedMap.java', 'guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/ImmutableSortedSet.java']","@@ -18,7 +18,6 @@
 
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 
-import com.google.common.annotations.Beta;
 import java.util.Comparator;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -32,7 +31,6 @@
  */
 public abstract class ImmutableBiMap<K, V> extends ForwardingImmutableMap<K, V>
     implements BiMap<K, V> {
-  @Beta
   public static <T, K, V> Collector<T, ?, ImmutableBiMap<K, V>> toImmutableBiMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {, @@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.ObjectArrays.checkElementsNotNull;
 
-import com.google.common.annotations.Beta;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -45,7 +44,6 @@
 
   ImmutableList() {}
 
-  @Beta
   public static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() {
     return CollectCollectors.toImmutableList();
   }, @@ -21,7 +21,6 @@
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 
-import com.google.common.annotations.Beta;
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Collections;
@@ -73,14 +72,12 @@
 
   ImmutableMap() {}
 
-  @Beta
   public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
     return CollectCollectors.toImmutableMap(keyFunction, valueFunction);
   }
 
-  @Beta
   public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction,, @@ -18,7 +18,6 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -41,7 +40,6 @@
 public abstract class ImmutableSet<E> extends ImmutableCollection<E> implements Set<E> {
   ImmutableSet() {}
 
-  @Beta
   public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {
     return CollectCollectors.toImmutableSet();
   }, @@ -22,7 +22,6 @@
 import static java.util.Collections.singletonMap;
 import static java.util.Collections.unmodifiableSortedMap;
 
-import com.google.common.annotations.Beta;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.Map;
@@ -67,15 +66,13 @@
     this.sortedDelegate = delegate;
   }
 
-  @Beta
   public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
       Comparator<? super K> comparator,
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction) {
     return CollectCollectors.toImmutableSortedMap(comparator, keyFunction, valueFunction);
   }
 
-  @Beta
   public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
       Comparator<? super K> comparator,
       Function<? super T, ? extends K> keyFunction,, @@ -19,7 +19,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
-import com.google.common.annotations.Beta;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -68,7 +67,6 @@
     }
   }
 
-  @Beta
   public static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(
       Comparator<? super E> comparator) {
     return CollectCollectors.toImmutableSortedSet(comparator);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Shorten toString for AbstractFuture implementations inside util.concurrent.

9da95c25c87f8ae009bfa56410db470ed0760f14

-------

<p> De-beta toImmutable* methods in GWT variants(""emulated"") of common.collect.

4e12478cc5955c20ea34095acf274a2c8172a2c2",MOE Sync 2020-07-23
3982,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/collect/ImmutableMapTest.java', 'android/guava-tests/test/com/google/common/collect/LenientSerializableTester.java', 'android/guava/src/com/google/common/collect/ImmutableBiMap.java', 'android/guava/src/com/google/common/collect/ImmutableMap.java', 'android/guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava-tests/test/com/google/common/collect/ImmutableMapTest.java', 'guava-tests/test/com/google/common/collect/LenientSerializableTester.java', 'guava/src/com/google/common/collect/ImmutableBiMap.java', 'guava/src/com/google/common/collect/ImmutableMap.java', 'guava/src/com/google/common/collect/ImmutableMapKeySet.java', 'guava/src/com/google/common/collect/ImmutableMapValues.java', 'guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava/src/com/google/common/collect/RegularImmutableMap.java']","@@ -17,6 +17,7 @@
 package com.google.common.collect;
 
 import static com.google.common.testing.SerializableTester.reserialize;
+import static com.google.common.truth.Truth.assertThat;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
@@ -45,12 +46,15 @@
 import com.google.common.testing.EqualsTester;
 import com.google.common.testing.NullPointerTester;
 import com.google.common.testing.SerializableTester;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
@@ -768,6 +772,58 @@ public void testViewSerialization() {
     assertTrue(reserializedValues instanceof ImmutableCollection);
   }
 
+  @GwtIncompatible // SerializableTester
+  public void testKeySetIsSerializable_regularImmutableMap() {
+    class NonSerializableClass {}
+
+    Map<String, NonSerializableClass> map =
+        RegularImmutableMap.create(1, new Object[] {""one"", new NonSerializableClass()});
+    Set<String> set = map.keySet();
+
+    LenientSerializableTester.reserializeAndAssertLenient(set);
+  }
+
+  @GwtIncompatible // SerializableTester
+  public void testValuesCollectionIsSerializable_regularImmutableMap() {
+    class NonSerializableClass {}
+
+    Map<NonSerializableClass, String> map =
+        RegularImmutableMap.create(1, new Object[] {new NonSerializableClass(), ""value""});
+    Collection<String> collection = map.values();
+
+    LenientSerializableTester.reserializeAndAssertElementsEqual(collection);
+  }
+
+  // TODO: Re-enable this test after moving to new serialization format in ImmutableMap.
+  @GwtIncompatible // SerializableTester
+  @SuppressWarnings(""unchecked"")
+  public void ignore_testSerializationNoDuplication_regularImmutableMap() throws Exception {
+    // Tests that searializing a map, its keySet, and values only writes the underlying data once.
+
+    Object[] entries = new Object[2000];
+    for (int i = 0; i < entries.length; i++) {
+      entries[i] = i;
+    }
+
+    ImmutableMap<Integer, Integer> map = RegularImmutableMap.create(entries.length / 2, entries);
+    Set<Integer> keySet = map.keySet();
+    Collection<Integer> values = map.values();
+
+    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+    ObjectOutputStream oos = new ObjectOutputStream(bytes);
+    oos.writeObject(map);
+    oos.flush();
+
+    int mapSize = bytes.size();
+    oos.writeObject(keySet);
+    oos.writeObject(values);
+    oos.close();
+
+    int finalSize = bytes.size();
+
+    assertThat(finalSize - mapSize).isLessThan(100);
+  }
+
   public void testEquals() {
     new EqualsTester()
         .addEqualityGroup(ImmutableMap.of(), ImmutableMap.builder().build()), @@ -24,6 +24,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.testing.SerializableTester;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Collection;
 import java.util.Set;
 
 /**
@@ -60,5 +61,14 @@
     return copy;
   }
 
+  @CanIgnoreReturnValue
+  @GwtIncompatible // SerializableTester
+  static <E> Collection<E> reserializeAndAssertElementsEqual(Collection<E> original) {
+    Collection<E> copy = reserialize(original);
+    assertTrue(Iterables.elementsEqual(original, copy));
+    assertTrue(copy instanceof ImmutableCollection);
+    return copy;
+  }
+
   private LenientSerializableTester() {}
 }, @@ -351,22 +351,21 @@ public V forcePut(K key, V value) {
    * <p>Since the bimap is immutable, ImmutableBiMap doesn't require special logic for keeping the
    * bimap and its inverse in sync during serialization, the way AbstractBiMap does.
    */
-  private static class SerializedForm extends ImmutableMap.SerializedForm {
-    SerializedForm(ImmutableBiMap<?, ?> bimap) {
+  private static class SerializedForm<K, V> extends ImmutableMap.SerializedForm<K, V> {
+    SerializedForm(ImmutableBiMap<K, V> bimap) {
       super(bimap);
     }
 
     @Override
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>();
-      return createMap(builder);
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(size);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   @Override
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 }, @@ -706,37 +706,85 @@ public String toString() {
    * reconstructed using public factory methods. This ensures that the implementation types remain
    * as implementation details.
    */
-  static class SerializedForm implements Serializable {
-    private final Object[] keys;
-    private final Object[] values;
-
-    SerializedForm(ImmutableMap<?, ?> map) {
-      keys = new Object[map.size()];
-      values = new Object[map.size()];
-      int i = 0;
-      for (Entry<?, ?> entry : map.entrySet()) {
-        keys[i] = entry.getKey();
-        values[i] = entry.getValue();
-        i++;
+  static class SerializedForm<K, V> implements Serializable {
+    // This object retains references to collections returned by keySet() and value(). This saves
+    // bytes when the both the map and its keySet or value collection are written to the same
+    // instance of ObjectOutputStream.
+
+    // TODO(b/160980469): remove support for the old serialization format after some time
+    private static final boolean USE_LEGACY_SERIALIZATION = true;
+
+    private final Object keys;
+    private final Object values;
+
+    SerializedForm(ImmutableMap<K, V> map) {
+      if (USE_LEGACY_SERIALIZATION) {
+        Object[] keys = new Object[map.size()];
+        Object[] values = new Object[map.size()];
+        int i = 0;
+        for (Entry<?, ?> entry : map.entrySet()) {
+          keys[i] = entry.getKey();
+          values[i] = entry.getValue();
+          i++;
+        }
+        this.keys = keys;
+        this.values = values;
+        return;
       }
+      this.keys = map.keySet();
+      this.values = map.values();
     }
 
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>(keys.length);
-      return createMap(builder);
+    @SuppressWarnings(""unchecked"")
+    final Object readResolve() {
+      if (!(this.keys instanceof ImmutableSet)) {
+        return legacyReadResolve();
+      }
+
+      ImmutableSet<K> keySet = (ImmutableSet<K>) this.keys;
+      ImmutableCollection<V> values = (ImmutableCollection<V>) this.values;
+
+      Builder<K, V> builder = makeBuilder(keySet.size());
+
+      UnmodifiableIterator<K> keyIter = keySet.iterator();
+      UnmodifiableIterator<V> valueIter = values.iterator();
+
+      while (keyIter.hasNext()) {
+        builder.put(keyIter.next(), valueIter.next());
+      }
+
+      return builder.build();
     }
 
-    Object createMap(Builder<Object, Object> builder) {
+    @SuppressWarnings(""unchecked"")
+    final Object legacyReadResolve() {
+      K[] keys = (K[]) this.keys;
+      V[] values = (V[]) this.values;
+
+      Builder<K, V> builder = makeBuilder(keys.length);
+
       for (int i = 0; i < keys.length; i++) {
         builder.put(keys[i], values[i]);
       }
       return builder.build();
     }
 
+    /**
+     * Returns a builder that builds the unserialized type. Subclasses should override this method.
+     */
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(size);
+    }
+
     private static final long serialVersionUID = 0;
   }
 
+  /**
+   * Returns a serializable form of this object. Non-public subclasses should not override this
+   * method. Publicly-accessible subclasses must override this method and should return a subclass
+   * of SerializedForm whose readResolve() method returns objects of the subclass type.
+   */
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 }, @@ -881,27 +881,25 @@ public K higherKey(K key) {
    * are reconstructed using public factory methods. This ensures that the implementation types
    * remain as implementation details.
    */
-  private static class SerializedForm extends ImmutableMap.SerializedForm {
-    private final Comparator<Object> comparator;
+  private static class SerializedForm<K, V> extends ImmutableMap.SerializedForm<K, V> {
+    private final Comparator<? super K> comparator;
 
-    @SuppressWarnings(""unchecked"")
-    SerializedForm(ImmutableSortedMap<?, ?> sortedMap) {
+    SerializedForm(ImmutableSortedMap<K, V> sortedMap) {
       super(sortedMap);
-      comparator = (Comparator<Object>) sortedMap.comparator();
+      comparator = sortedMap.comparator();
     }
 
     @Override
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>(comparator);
-      return createMap(builder);
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(comparator);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   @Override
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 
   // This class is never actually serialized directly, but we have to make the, @@ -51,6 +51,8 @@
 import com.google.common.testing.EqualsTester;
 import com.google.common.testing.NullPointerTester;
 import com.google.common.testing.SerializableTester;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.AbstractMap;
 import java.util.Arrays;
@@ -61,6 +63,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.stream.Collector;
 import java.util.stream.Stream;
 import junit.framework.Test;
@@ -817,6 +820,119 @@ public void testViewSerialization() {
     assertTrue(reserializedValues instanceof ImmutableCollection);
   }
 
+  @GwtIncompatible // SerializableTester
+  public void testKeySetIsSerializable_regularImmutableMap() {
+    class NonSerializableClass {}
+
+    Map<String, NonSerializableClass> map =
+        RegularImmutableMap.fromEntries(ImmutableMap.entryOf(""one"", new NonSerializableClass()));
+    Set<String> set = map.keySet();
+
+    LenientSerializableTester.reserializeAndAssertLenient(set);
+  }
+
+  @GwtIncompatible // SerializableTester
+  public void testKeySetIsSerializable_jdkBackedImmutableMap() {
+    class NonSerializableClass {}
+
+    Entry<String, NonSerializableClass>[] entries =
+        arrayOf(ImmutableMap.entryOf(""one"", new NonSerializableClass()));
+
+    Map<String, NonSerializableClass> map = JdkBackedImmutableMap.create(1, entries);
+    Set<String> set = map.keySet();
+
+    LenientSerializableTester.reserializeAndAssertLenient(set);
+  }
+
+  @GwtIncompatible // SerializableTester
+  public void testValuesCollectionIsSerializable_regularImmutableMap() {
+    class NonSerializableClass {}
+
+    Map<NonSerializableClass, String> map =
+        RegularImmutableMap.fromEntries(ImmutableMap.entryOf(new NonSerializableClass(), ""value""));
+    Collection<String> collection = map.values();
+
+    LenientSerializableTester.reserializeAndAssertElementsEqual(collection);
+  }
+
+  @GwtIncompatible // SerializableTester
+  public void testValuesCollectionIsSerializable_jdkBackedImmutableMap() {
+    class NonSerializableClass {}
+
+    Entry<NonSerializableClass, String>[] entries =
+        arrayOf(ImmutableMap.entryOf(new NonSerializableClass(), ""value""));
+
+    Map<NonSerializableClass, String> map = JdkBackedImmutableMap.create(1, entries);
+    Collection<String> collection = map.values();
+
+    LenientSerializableTester.reserializeAndAssertElementsEqual(collection);
+  }
+
+  // TODO: Re-enable this test after moving to new serialization format in ImmutableMap.
+  @GwtIncompatible // SerializableTester
+  @SuppressWarnings(""unchecked"")
+  public void ignore_testSerializationNoDuplication_regularImmutableMap() throws Exception {
+    // Tests that searializing a map, its keySet, and values only writes the underlying data once.
+
+    Entry<Integer, Integer>[] entries = (Entry<Integer, Integer>[]) new Entry<?, ?>[1000];
+    for (int i = 0; i < 1000; i++) {
+      entries[i] = ImmutableMap.entryOf(i, i);
+    }
+
+    ImmutableMap<Integer, Integer> map = RegularImmutableMap.fromEntries(entries);
+    Set<Integer> keySet = map.keySet();
+    Collection<Integer> values = map.values();
+
+    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+    ObjectOutputStream oos = new ObjectOutputStream(bytes);
+    oos.writeObject(map);
+    oos.flush();
+
+    int mapSize = bytes.size();
+    oos.writeObject(keySet);
+    oos.writeObject(values);
+    oos.close();
+
+    int finalSize = bytes.size();
+
+    assertThat(finalSize - mapSize).isLessThan(100);
+  }
+
+  // TODO: Re-enable this test after moving to new serialization format in ImmutableMap.
+  @GwtIncompatible // SerializableTester
+  @SuppressWarnings(""unchecked"")
+  public void ignore_testSerializationNoDuplication_jdkBackedImmutableMap() throws Exception {
+    // Tests that searializing a map, its keySet, and values only writes
+    // the underlying data once.
+
+    Entry<Integer, Integer>[] entries = (Entry<Integer, Integer>[]) new Entry<?, ?>[1000];
+    for (int i = 0; i < 1000; i++) {
+      entries[i] = ImmutableMap.entryOf(i, i);
+    }
+
+    ImmutableMap<Integer, Integer> map = JdkBackedImmutableMap.create(entries.length, entries);
+    Set<Integer> keySet = map.keySet();
+    Collection<Integer> values = map.values();
+
+    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+    ObjectOutputStream oos = new ObjectOutputStream(bytes);
+    oos.writeObject(map);
+    oos.flush();
+
+    int mapSize = bytes.size();
+    oos.writeObject(keySet);
+    oos.writeObject(values);
+    oos.close();
+
+    int finalSize = bytes.size();
+
+    assertThat(finalSize - mapSize).isLessThan(100);
+  }
+
+  private static <T> T[] arrayOf(T... objs) {
+    return objs;
+  }
+
   @GwtIncompatible(""assumptions about splitting"")
   public void testKeySetSplittable() {
     ImmutableMap<Integer, Integer> map =, @@ -24,6 +24,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.testing.SerializableTester;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Collection;
 import java.util.Set;
 
 /**
@@ -60,5 +61,14 @@
     return copy;
   }
 
+  @CanIgnoreReturnValue
+  @GwtIncompatible // SerializableTester
+  static <E> Collection<E> reserializeAndAssertElementsEqual(Collection<E> original) {
+    Collection<E> copy = reserialize(original);
+    assertTrue(Iterables.elementsEqual(original, copy));
+    assertTrue(copy instanceof ImmutableCollection);
+    return copy;
+  }
+
   private LenientSerializableTester() {}
 }, @@ -413,22 +413,21 @@ public V forcePut(K key, V value) {
    * <p>Since the bimap is immutable, ImmutableBiMap doesn't require special logic for keeping the
    * bimap and its inverse in sync during serialization, the way AbstractBiMap does.
    */
-  private static class SerializedForm extends ImmutableMap.SerializedForm {
-    SerializedForm(ImmutableBiMap<?, ?> bimap) {
+  private static class SerializedForm<K, V> extends ImmutableMap.SerializedForm<K, V> {
+    SerializedForm(ImmutableBiMap<K, V> bimap) {
       super(bimap);
     }
 
     @Override
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>();
-      return createMap(builder);
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(size);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   @Override
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 }, @@ -891,37 +891,85 @@ public String toString() {
    * reconstructed using public factory methods. This ensures that the implementation types remain
    * as implementation details.
    */
-  static class SerializedForm implements Serializable {
-    private final Object[] keys;
-    private final Object[] values;
-
-    SerializedForm(ImmutableMap<?, ?> map) {
-      keys = new Object[map.size()];
-      values = new Object[map.size()];
-      int i = 0;
-      for (Entry<?, ?> entry : map.entrySet()) {
-        keys[i] = entry.getKey();
-        values[i] = entry.getValue();
-        i++;
+  static class SerializedForm<K, V> implements Serializable {
+    // This object retains references to collections returned by keySet() and value(). This saves
+    // bytes when the both the map and its keySet or value collection are written to the same
+    // instance of ObjectOutputStream.
+
+    // TODO(b/160980469): remove support for the old serialization format after some time
+    private static final boolean USE_LEGACY_SERIALIZATION = true;
+
+    private final Object keys;
+    private final Object values;
+
+    SerializedForm(ImmutableMap<K, V> map) {
+      if (USE_LEGACY_SERIALIZATION) {
+        Object[] keys = new Object[map.size()];
+        Object[] values = new Object[map.size()];
+        int i = 0;
+        for (Entry<?, ?> entry : map.entrySet()) {
+          keys[i] = entry.getKey();
+          values[i] = entry.getValue();
+          i++;
+        }
+        this.keys = keys;
+        this.values = values;
+        return;
       }
+      this.keys = map.keySet();
+      this.values = map.values();
     }
 
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>(keys.length);
-      return createMap(builder);
+    @SuppressWarnings(""unchecked"")
+    final Object readResolve() {
+      if (!(this.keys instanceof ImmutableSet)) {
+        return legacyReadResolve();
+      }
+
+      ImmutableSet<K> keySet = (ImmutableSet<K>) this.keys;
+      ImmutableCollection<V> values = (ImmutableCollection<V>) this.values;
+
+      Builder<K, V> builder = makeBuilder(keySet.size());
+
+      UnmodifiableIterator<K> keyIter = keySet.iterator();
+      UnmodifiableIterator<V> valueIter = values.iterator();
+
+      while (keyIter.hasNext()) {
+        builder.put(keyIter.next(), valueIter.next());
+      }
+
+      return builder.build();
     }
 
-    Object createMap(Builder<Object, Object> builder) {
+    @SuppressWarnings(""unchecked"")
+    final Object legacyReadResolve() {
+      K[] keys = (K[]) this.keys;
+      V[] values = (V[]) this.values;
+
+      Builder<K, V> builder = makeBuilder(keys.length);
+
       for (int i = 0; i < keys.length; i++) {
         builder.put(keys[i], values[i]);
       }
       return builder.build();
     }
 
+    /**
+     * Returns a builder that builds the unserialized type. Subclasses should override this method.
+     */
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(size);
+    }
+
     private static final long serialVersionUID = 0;
   }
 
+  /**
+   * Returns a serializable form of this object. Non-public subclasses should not override this
+   * method. Publicly-accessible subclasses must override this method and should return a subclass
+   * of SerializedForm whose readResolve() method returns objects of the subclass type.
+   */
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 }, @@ -19,8 +19,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
-import java.io.Serializable;
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -74,25 +72,4 @@ public void forEach(Consumer<? super K> action) {
   boolean isPartialView() {
     return true;
   }
-
-  @GwtIncompatible // serialization
-  @Override
-  Object writeReplace() {
-    return new KeySetSerializedForm<K>(map);
-  }
-
-  @GwtIncompatible // serialization
-  private static class KeySetSerializedForm<K> implements Serializable {
-    final ImmutableMap<K, ?> map;
-
-    KeySetSerializedForm(ImmutableMap<K, ?> map) {
-      this.map = map;
-    }
-
-    Object readResolve() {
-      return map.keySet();
-    }
-
-    private static final long serialVersionUID = 0;
-  }
 }, @@ -20,7 +20,6 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
-import java.io.Serializable;
 import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.function.Consumer;
@@ -99,25 +98,4 @@ public void forEach(Consumer<? super V> action) {
     checkNotNull(action);
     map.forEach((k, v) -> action.accept(v));
   }
-
-  @GwtIncompatible // serialization
-  @Override
-  Object writeReplace() {
-    return new SerializedForm<V>(map);
-  }
-
-  @GwtIncompatible // serialization
-  private static class SerializedForm<V> implements Serializable {
-    final ImmutableMap<?, V> map;
-
-    SerializedForm(ImmutableMap<?, V> map) {
-      this.map = map;
-    }
-
-    Object readResolve() {
-      return map.values();
-    }
-
-    private static final long serialVersionUID = 0;
-  }
 }, @@ -916,27 +916,25 @@ public K higherKey(K key) {
    * are reconstructed using public factory methods. This ensures that the implementation types
    * remain as implementation details.
    */
-  private static class SerializedForm extends ImmutableMap.SerializedForm {
-    private final Comparator<Object> comparator;
+  private static class SerializedForm<K, V> extends ImmutableMap.SerializedForm<K, V> {
+    private final Comparator<? super K> comparator;
 
-    @SuppressWarnings(""unchecked"")
-    SerializedForm(ImmutableSortedMap<?, ?> sortedMap) {
+    SerializedForm(ImmutableSortedMap<K, V> sortedMap) {
       super(sortedMap);
-      comparator = (Comparator<Object>) sortedMap.comparator();
+      comparator = sortedMap.comparator();
     }
 
     @Override
-    Object readResolve() {
-      Builder<Object, Object> builder = new Builder<>(comparator);
-      return createMap(builder);
+    Builder<K, V> makeBuilder(int size) {
+      return new Builder<>(comparator);
     }
 
     private static final long serialVersionUID = 0;
   }
 
   @Override
   Object writeReplace() {
-    return new SerializedForm(this);
+    return new SerializedForm<>(this);
   }
 
   // This class is never actually serialized directly, but we have to make the, @@ -22,11 +22,9 @@
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMapEntry.NonTerminalImmutableMapEntry;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import java.io.Serializable;
 import java.util.function.BiConsumer;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -207,10 +205,10 @@ boolean isPartialView() {
   }
 
   @GwtCompatible(emulated = true)
-  private static final class KeySet<K, V> extends IndexedImmutableSet<K> {
-    private final RegularImmutableMap<K, V> map;
+  private static final class KeySet<K> extends IndexedImmutableSet<K> {
+    private final RegularImmutableMap<K, ?> map;
 
-    KeySet(RegularImmutableMap<K, V> map) {
+    KeySet(RegularImmutableMap<K, ?> map) {
       this.map = map;
     }
 
@@ -233,27 +231,6 @@ boolean isPartialView() {
     public int size() {
       return map.size();
     }
-
-    @GwtIncompatible // serialization
-    @Override
-    Object writeReplace() {
-      return new SerializedForm<K>(map);
-    }
-
-    @GwtIncompatible // serialization
-    private static class SerializedForm<K> implements Serializable {
-      final ImmutableMap<K, ?> map;
-
-      SerializedForm(ImmutableMap<K, ?> map) {
-        this.map = map;
-      }
-
-      Object readResolve() {
-        return map.keySet();
-      }
-
-      private static final long serialVersionUID = 0;
-    }
   }
 
   @Override
@@ -283,27 +260,6 @@ public int size() {
     boolean isPartialView() {
       return true;
     }
-
-    @GwtIncompatible // serialization
-    @Override
-    Object writeReplace() {
-      return new SerializedForm<V>(map);
-    }
-
-    @GwtIncompatible // serialization
-    private static class SerializedForm<V> implements Serializable {
-      final ImmutableMap<?, V> map;
-
-      SerializedForm(ImmutableMap<?, V> map) {
-        this.map = map;
-      }
-
-      Object readResolve() {
-        return map.values();
-      }
-
-      private static final long serialVersionUID = 0;
-    }
   }
 
   // This class is never actually serialized directly, but we have to make the, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Ensure that the set returned by ImmutableMap<K, V>.keySet() is serializable when K is serializable, and similarly for values().

Set<T> should be serializable when T is serializable but that is not always the case for the set returned by ImmutableMap.keySet() due to a reference from the returned set back to the original map. When serializing this set, the original map is serialized is well. This change changes this so that only the keys are serialized.

RELNOTES=`collect`: Ensure that the set returned by `ImmutableMap<K, V>.keySet()` is serializable when `K` is serializable (and similarly for `values()`).

cf94f5601b32662a236f5534c1a7d4ceab132e76",MOE Sync 2020-08-04
3983,Kurt Alfred Kluever,"['android/guava/src/com/google/common/cache/LocalCache.java', 'guava/src/com/google/common/cache/LocalCache.java']","@@ -50,8 +50,8 @@
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.google.common.util.concurrent.Uninterruptibles;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
+import com.google.j2objc.annotations.RetainedWith;
 import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -993,7 +993,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1006,7 +1006,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1039,7 +1039,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1052,7 +1052,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1085,7 +1085,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1098,7 +1098,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1125,7 +1125,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1138,7 +1138,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1281,7 +1281,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1294,7 +1294,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1328,7 +1328,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1341,7 +1341,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1375,7 +1375,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1388,7 +1388,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1415,7 +1415,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1428,7 +1428,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -3525,7 +3525,7 @@ public long getWriteTime() {
           @Override
           public void setWriteTime(long time) {}
 
-          ReferenceEntry<K, V> nextWrite = this;
+          @Weak ReferenceEntry<K, V> nextWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -3537,7 +3537,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
             this.nextWrite = next;
           }
 
-          ReferenceEntry<K, V> previousWrite = this;
+          @Weak ReferenceEntry<K, V> previousWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -3664,7 +3664,7 @@ public long getAccessTime() {
           @Override
           public void setAccessTime(long time) {}
 
-          ReferenceEntry<K, V> nextAccess = this;
+          @Weak ReferenceEntry<K, V> nextAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -3676,7 +3676,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
             this.nextAccess = next;
           }
 
-          ReferenceEntry<K, V> previousAccess = this;
+          @Weak ReferenceEntry<K, V> previousAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -4146,32 +4146,32 @@ void invalidateAll(Iterable<?> keys) {
     }
   }
 
-  @NullableDecl Set<K> keySet;
+  @RetainedWith @NullableDecl Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
     // does not impact recency ordering
     Set<K> ks = keySet;
-    return (ks != null) ? ks : (keySet = new KeySet(this));
+    return (ks != null) ? ks : (keySet = new KeySet());
   }
 
-  @NullableDecl Collection<V> values;
+  @RetainedWith @NullableDecl Collection<V> values;
 
   @Override
   public Collection<V> values() {
     // does not impact recency ordering
     Collection<V> vs = values;
-    return (vs != null) ? vs : (values = new Values(this));
+    return (vs != null) ? vs : (values = new Values());
   }
 
-  @NullableDecl Set<Entry<K, V>> entrySet;
+  @RetainedWith @NullableDecl Set<Entry<K, V>> entrySet;
 
   @Override
   @GwtIncompatible // Not supported.
   public Set<Entry<K, V>> entrySet() {
     // does not impact recency ordering
     Set<Entry<K, V>> es = entrySet;
-    return (es != null) ? es : (entrySet = new EntrySet(this));
+    return (es != null) ? es : (entrySet = new EntrySet());
   }
 
   // Iterator Support
@@ -4362,25 +4362,19 @@ public String toString() {
   }
 
   abstract class AbstractCacheSet<T> extends AbstractSet<T> {
-    @Weak final ConcurrentMap<?, ?> map;
-
-    AbstractCacheSet(ConcurrentMap<?, ?> map) {
-      this.map = map;
-    }
-
     @Override
     public int size() {
-      return map.size();
+      return LocalCache.this.size();
     }
 
     @Override
     public boolean isEmpty() {
-      return map.isEmpty();
+      return LocalCache.this.isEmpty();
     }
 
     @Override
     public void clear() {
-      map.clear();
+      LocalCache.this.clear();
     }
 
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
@@ -4404,50 +4398,38 @@ public void clear() {
     return result;
   }
 
-  @WeakOuter
   final class KeySet extends AbstractCacheSet<K> {
 
-    KeySet(ConcurrentMap<?, ?> map) {
-      super(map);
-    }
-
     @Override
     public Iterator<K> iterator() {
       return new KeyIterator();
     }
 
     @Override
     public boolean contains(Object o) {
-      return map.containsKey(o);
+      return LocalCache.this.containsKey(o);
     }
 
     @Override
     public boolean remove(Object o) {
-      return map.remove(o) != null;
+      return LocalCache.this.remove(o) != null;
     }
   }
 
-  @WeakOuter
   final class Values extends AbstractCollection<V> {
-    private final ConcurrentMap<?, ?> map;
-
-    Values(ConcurrentMap<?, ?> map) {
-      this.map = map;
-    }
-
     @Override
     public int size() {
-      return map.size();
+      return LocalCache.this.size();
     }
 
     @Override
     public boolean isEmpty() {
-      return map.isEmpty();
+      return LocalCache.this.isEmpty();
     }
 
     @Override
     public void clear() {
-      map.clear();
+      LocalCache.this.clear();
     }
 
     @Override
@@ -4457,7 +4439,7 @@ public void clear() {
 
     @Override
     public boolean contains(Object o) {
-      return map.containsValue(o);
+      return LocalCache.this.containsValue(o);
     }
 
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
@@ -4474,13 +4456,8 @@ public boolean contains(Object o) {
     }
   }
 
-  @WeakOuter
   final class EntrySet extends AbstractCacheSet<Entry<K, V>> {
 
-    EntrySet(ConcurrentMap<?, ?> map) {
-      super(map);
-    }
-
     @Override
     public Iterator<Entry<K, V>> iterator() {
       return new EntryIterator();, @@ -50,8 +50,8 @@
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.google.common.util.concurrent.Uninterruptibles;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
+import com.google.j2objc.annotations.RetainedWith;
 import com.google.j2objc.annotations.Weak;
-import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -997,7 +997,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1010,7 +1010,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1043,7 +1043,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1056,7 +1056,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1089,7 +1089,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1102,7 +1102,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1129,7 +1129,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1142,7 +1142,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1284,7 +1284,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1297,7 +1297,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1330,7 +1330,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1343,7 +1343,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -1377,7 +1377,7 @@ public void setAccessTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> nextAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -1390,7 +1390,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousAccess = nullEntry();
+    @Weak ReferenceEntry<K, V> previousAccess = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -1417,7 +1417,7 @@ public void setWriteTime(long time) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> nextWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> nextWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -1430,7 +1430,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
     }
 
     // Guarded By Segment.this
-    ReferenceEntry<K, V> previousWrite = nullEntry();
+    @Weak ReferenceEntry<K, V> previousWrite = nullEntry();
 
     @Override
     public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -3628,7 +3628,7 @@ public long getWriteTime() {
           @Override
           public void setWriteTime(long time) {}
 
-          ReferenceEntry<K, V> nextWrite = this;
+          @Weak ReferenceEntry<K, V> nextWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInWriteQueue() {
@@ -3640,7 +3640,7 @@ public void setNextInWriteQueue(ReferenceEntry<K, V> next) {
             this.nextWrite = next;
           }
 
-          ReferenceEntry<K, V> previousWrite = this;
+          @Weak ReferenceEntry<K, V> previousWrite = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInWriteQueue() {
@@ -3767,7 +3767,7 @@ public long getAccessTime() {
           @Override
           public void setAccessTime(long time) {}
 
-          ReferenceEntry<K, V> nextAccess = this;
+          @Weak ReferenceEntry<K, V> nextAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getNextInAccessQueue() {
@@ -3779,7 +3779,7 @@ public void setNextInAccessQueue(ReferenceEntry<K, V> next) {
             this.nextAccess = next;
           }
 
-          ReferenceEntry<K, V> previousAccess = this;
+          @Weak ReferenceEntry<K, V> previousAccess = this;
 
           @Override
           public ReferenceEntry<K, V> getPreviousInAccessQueue() {
@@ -4278,32 +4278,32 @@ void invalidateAll(Iterable<?> keys) {
     }
   }
 
-  @Nullable Set<K> keySet;
+  @RetainedWith @Nullable Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
     // does not impact recency ordering
     Set<K> ks = keySet;
-    return (ks != null) ? ks : (keySet = new KeySet(this));
+    return (ks != null) ? ks : (keySet = new KeySet());
   }
 
-  @Nullable Collection<V> values;
+  @RetainedWith @Nullable Collection<V> values;
 
   @Override
   public Collection<V> values() {
     // does not impact recency ordering
     Collection<V> vs = values;
-    return (vs != null) ? vs : (values = new Values(this));
+    return (vs != null) ? vs : (values = new Values());
   }
 
-  @Nullable Set<Entry<K, V>> entrySet;
+  @RetainedWith @Nullable Set<Entry<K, V>> entrySet;
 
   @Override
   @GwtIncompatible // Not supported.
   public Set<Entry<K, V>> entrySet() {
     // does not impact recency ordering
     Set<Entry<K, V>> es = entrySet;
-    return (es != null) ? es : (entrySet = new EntrySet(this));
+    return (es != null) ? es : (entrySet = new EntrySet());
   }
 
   // Iterator Support
@@ -4494,25 +4494,19 @@ public String toString() {
   }
 
   abstract class AbstractCacheSet<T> extends AbstractSet<T> {
-    @Weak final ConcurrentMap<?, ?> map;
-
-    AbstractCacheSet(ConcurrentMap<?, ?> map) {
-      this.map = map;
-    }
-
     @Override
     public int size() {
-      return map.size();
+      return LocalCache.this.size();
     }
 
     @Override
     public boolean isEmpty() {
-      return map.isEmpty();
+      return LocalCache.this.isEmpty();
     }
 
     @Override
     public void clear() {
-      map.clear();
+      LocalCache.this.clear();
     }
 
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
@@ -4553,50 +4547,38 @@ boolean removeIf(BiPredicate<? super K, ? super V> filter) {
     return changed;
   }
 
-  @WeakOuter
   final class KeySet extends AbstractCacheSet<K> {
 
-    KeySet(ConcurrentMap<?, ?> map) {
-      super(map);
-    }
-
     @Override
     public Iterator<K> iterator() {
       return new KeyIterator();
     }
 
     @Override
     public boolean contains(Object o) {
-      return map.containsKey(o);
+      return LocalCache.this.containsKey(o);
     }
 
     @Override
     public boolean remove(Object o) {
-      return map.remove(o) != null;
+      return LocalCache.this.remove(o) != null;
     }
   }
 
-  @WeakOuter
   final class Values extends AbstractCollection<V> {
-    private final ConcurrentMap<?, ?> map;
-
-    Values(ConcurrentMap<?, ?> map) {
-      this.map = map;
-    }
-
     @Override
     public int size() {
-      return map.size();
+      return LocalCache.this.size();
     }
 
     @Override
     public boolean isEmpty() {
-      return map.isEmpty();
+      return LocalCache.this.isEmpty();
     }
 
     @Override
     public void clear() {
-      map.clear();
+      LocalCache.this.clear();
     }
 
     @Override
@@ -4612,7 +4594,7 @@ public boolean removeIf(Predicate<? super V> filter) {
 
     @Override
     public boolean contains(Object o) {
-      return map.containsValue(o);
+      return LocalCache.this.containsValue(o);
     }
 
     // super.toArray() may misbehave if size() is inaccurate, at least on old versions of Android.
@@ -4629,13 +4611,8 @@ public boolean contains(Object o) {
     }
   }
 
-  @WeakOuter
   final class EntrySet extends AbstractCacheSet<Entry<K, V>> {
 
-    EntrySet(ConcurrentMap<?, ?> map) {
-      super(map);
-    }
-
     @Override
     public Iterator<Entry<K, V>> iterator() {
       return new EntryIterator();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix memory-leaks in LocalCache on iOS, caused by:

1. Retain-cycle between outer LocalCache instance and inner Values, KeySet and EntrySet instances. The use of @Weak and @WeakOuter is incorrect there, since inner instances can outlive outer LocalCache instance. The correct solution is to use @RetainedWith annotation to inner-classes.

2. Retain-cycle between ReferenceEntry objects which internally form a doubly-linked list. Fixed by adding @Weak annotation to ""next"" and ""previous"" links. This is correct, since ReferenceEntry instances are already retained by Segments.

The unit test for leak detection is added inside Xplat, because the required testing infrastructure is not present inside ""google_common"" (the IosAsserts class). Eventually, everything should be moved to ""google_common"".

RELNOTES=Fix memory-leak in LocalCache on iOS

8fb1cada24cae186226f0d3785704fc19ea2e9fa",MOE Sync 2020-08-06
3985,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/net/InetAddressesTest.java', 'android/guava/src/com/google/common/net/InetAddresses.java', 'guava-tests/test/com/google/common/net/InetAddressesTest.java', 'guava/src/com/google/common/net/InetAddresses.java']","@@ -63,6 +63,7 @@ public void testForStringBogusInput() {
             ""42.42.42.42."",
             ""42.42.42.42..."",
             "".42.42.42.42"",
+            "".42.42.42"",
             ""...42.42.42.42"",
             ""42.42.42.-0"",
             ""42.42.42.+0"",, @@ -19,6 +19,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.base.CharMatcher;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Splitter;
 import com.google.common.collect.Iterables;
@@ -102,7 +103,8 @@
 public final class InetAddresses {
   private static final int IPV4_PART_COUNT = 4;
   private static final int IPV6_PART_COUNT = 8;
-  private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);
+  private static final char IPV4_DELIMITER = '.';
+  private static final CharMatcher IPV4_DELIMITER_MATCHER = CharMatcher.is(IPV4_DELIMITER);
   private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);
   private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(""127.0.0.1"");
   private static final Inet4Address ANY4 = (Inet4Address) forString(""0.0.0.0"");
@@ -197,24 +199,38 @@ public static boolean isInetAddress(String ipString) {
       }
       return textToNumericFormatV6(ipString);
     } else if (hasDot) {
+      if (percentIndex != -1) {
+        return null; // Scope IDs are not supported for IPV4
+      }
       return textToNumericFormatV4(ipString);
     }
     return null;
   }
 
   @NullableDecl
   private static byte[] textToNumericFormatV4(String ipString) {
+    if (IPV4_DELIMITER_MATCHER.countIn(ipString) + 1 != IPV4_PART_COUNT) {
+      return null; // Wrong number of parts
+    }
+
     byte[] bytes = new byte[IPV4_PART_COUNT];
-    int i = 0;
-    try {
-      for (String octet : IPV4_SPLITTER.split(ipString)) {
-        bytes[i++] = parseOctet(octet);
+    int start = 0;
+    // Iterate through the parts of the ip string.
+    // Invariant: start is always the beginning of an octet.
+    for (int i = 0; i < IPV4_PART_COUNT; i++) {
+      int end = ipString.indexOf(IPV4_DELIMITER, start);
+      if (end == -1) {
+        end = ipString.length();
       }
-    } catch (NumberFormatException ex) {
-      return null;
+      try {
+        bytes[i] = parseOctet(ipString, start, end);
+      } catch (NumberFormatException ex) {
+        return null;
+      }
+      start = end + 1;
     }
 
-    return i == IPV4_PART_COUNT ? bytes : null;
+    return bytes;
   }
 
   @NullableDecl
@@ -295,10 +311,6 @@ private static String convertDottedQuadToHex(String ipString) {
     return initialPart + penultimate + "":"" + ultimate;
   }
 
-  private static byte parseOctet(String ipPart) {
-    return parseOctet(ipPart, 0, ipPart.length());
-  }
-
   private static byte parseOctet(String ipString, int start, int end) {
     // Note: we already verified that this string contains only hex digits, but the string may still
     // contain non-decimal characters., @@ -63,6 +63,7 @@ public void testForStringBogusInput() {
             ""42.42.42.42."",
             ""42.42.42.42..."",
             "".42.42.42.42"",
+            "".42.42.42"",
             ""...42.42.42.42"",
             ""42.42.42.-0"",
             ""42.42.42.+0"",, @@ -19,6 +19,7 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.base.CharMatcher;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Splitter;
 import com.google.common.collect.Iterables;
@@ -102,7 +103,8 @@
 public final class InetAddresses {
   private static final int IPV4_PART_COUNT = 4;
   private static final int IPV6_PART_COUNT = 8;
-  private static final Splitter IPV4_SPLITTER = Splitter.on('.').limit(IPV4_PART_COUNT);
+  private static final char IPV4_DELIMITER = '.';
+  private static final CharMatcher IPV4_DELIMITER_MATCHER = CharMatcher.is(IPV4_DELIMITER);
   private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);
   private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(""127.0.0.1"");
   private static final Inet4Address ANY4 = (Inet4Address) forString(""0.0.0.0"");
@@ -196,23 +198,37 @@ public static boolean isInetAddress(String ipString) {
       }
       return textToNumericFormatV6(ipString);
     } else if (hasDot) {
+      if (percentIndex != -1) {
+        return null; // Scope IDs are not supported for IPV4
+      }
       return textToNumericFormatV4(ipString);
     }
     return null;
   }
 
   private static byte @Nullable [] textToNumericFormatV4(String ipString) {
+    if (IPV4_DELIMITER_MATCHER.countIn(ipString) + 1 != IPV4_PART_COUNT) {
+      return null; // Wrong number of parts
+    }
+
     byte[] bytes = new byte[IPV4_PART_COUNT];
-    int i = 0;
-    try {
-      for (String octet : IPV4_SPLITTER.split(ipString)) {
-        bytes[i++] = parseOctet(octet);
+    int start = 0;
+    // Iterate through the parts of the ip string.
+    // Invariant: start is always the beginning of an octet.
+    for (int i = 0; i < IPV4_PART_COUNT; i++) {
+      int end = ipString.indexOf(IPV4_DELIMITER, start);
+      if (end == -1) {
+        end = ipString.length();
       }
-    } catch (NumberFormatException ex) {
-      return null;
+      try {
+        bytes[i] = parseOctet(ipString, start, end);
+      } catch (NumberFormatException ex) {
+        return null;
+      }
+      start = end + 1;
     }
 
-    return i == IPV4_PART_COUNT ? bytes : null;
+    return bytes;
   }
 
   private static byte @Nullable [] textToNumericFormatV6(String ipString) {
@@ -291,10 +307,6 @@ public static boolean isInetAddress(String ipString) {
     return initialPart + penultimate + "":"" + ultimate;
   }
 
-  private static byte parseOctet(String ipPart) {
-    return parseOctet(ipPart, 0, ipPart.length());
-  }
-
   private static byte parseOctet(String ipString, int start, int end) {
     // Note: we already verified that this string contains only hex digits, but the string may still
     // contain non-decimal characters., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> [Efficiency] Creates a variant of parseHextet and parseOctet that can work on a larger string with start and end indices.

97638e61eb63e1fb3f994cbf3079c33205fa61b9

-------

<p> [Efficiency] Modifies textToNumericFormatV4 to parse the input String in place.

0e6c0c99f06c7e7c510507b202a2546ab8026dcc",MOE Sync 2020-08-07
3987,Colin Decker,"['guava/src/com/google/common/collect/ImmutableMapKeySet.java', 'guava/src/com/google/common/collect/ImmutableMapValues.java', 'guava/src/com/google/common/collect/RegularImmutableMap.java']","@@ -19,6 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
+import java.io.Serializable;
 import java.util.Spliterator;
 import java.util.function.Consumer;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -72,4 +74,21 @@ public void forEach(Consumer<? super K> action) {
   boolean isPartialView() {
     return true;
   }
+
+  // No longer used for new writes, but kept so that old data can still be read.
+  @GwtIncompatible // serialization
+  @SuppressWarnings(""unused"")
+  private static class KeySetSerializedForm<K> implements Serializable {
+    final ImmutableMap<K, ?> map;
+
+    KeySetSerializedForm(ImmutableMap<K, ?> map) {
+      this.map = map;
+    }
+
+    Object readResolve() {
+      return map.keySet();
+    }
+
+    private static final long serialVersionUID = 0;
+  }
 }, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
+import java.io.Serializable;
 import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.function.Consumer;
@@ -98,4 +99,21 @@ public void forEach(Consumer<? super V> action) {
     checkNotNull(action);
     map.forEach((k, v) -> action.accept(v));
   }
+
+  // No longer used for new writes, but kept so that old data can still be read.
+  @GwtIncompatible // serialization
+  @SuppressWarnings(""unused"")
+  private static class SerializedForm<V> implements Serializable {
+    final ImmutableMap<?, V> map;
+
+    SerializedForm(ImmutableMap<?, V> map) {
+      this.map = map;
+    }
+
+    Object readResolve() {
+      return map.values();
+    }
+
+    private static final long serialVersionUID = 0;
+  }
 }, @@ -22,9 +22,11 @@
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 
 import com.google.common.annotations.GwtCompatible;
+import com.google.common.annotations.GwtIncompatible;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMapEntry.NonTerminalImmutableMapEntry;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.io.Serializable;
 import java.util.function.BiConsumer;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -231,6 +233,23 @@ boolean isPartialView() {
     public int size() {
       return map.size();
     }
+
+    // No longer used for new writes, but kept so that old data can still be read.
+    @GwtIncompatible // serialization
+    @SuppressWarnings(""unused"")
+    private static class SerializedForm<K> implements Serializable {
+      final ImmutableMap<K, ?> map;
+
+      SerializedForm(ImmutableMap<K, ?> map) {
+        this.map = map;
+      }
+
+      Object readResolve() {
+        return map.keySet();
+      }
+
+      private static final long serialVersionUID = 0;
+    }
   }
 
   @Override
@@ -260,6 +279,23 @@ public int size() {
     boolean isPartialView() {
       return true;
     }
+
+    // No longer used for new writes, but kept so that old data can still be read.
+    @GwtIncompatible // serialization
+    @SuppressWarnings(""unused"")
+    private static class SerializedForm<V> implements Serializable {
+      final ImmutableMap<?, V> map;
+
+      SerializedForm(ImmutableMap<?, V> map) {
+        this.map = map;
+      }
+
+      Object readResolve() {
+        return map.values();
+      }
+
+      private static final long serialVersionUID = 0;
+    }
   }
 
   // This class is never actually serialized directly, but we have to make the, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Avoid boxing in Doubles.constrainToRange() and Floats.constrainToRange().

Fixes https://github.com/google/guava/issues/3984

f850db59358a3b5f9b2da96b7feea06802077b19

-------

<p> Remove `@Beta` from `Multimaps.toMultimap`.

Fixes https://github.com/google/guava/issues/3957

RELNOTES=`collect`: Removed `@Beta` from `Multimaps.toMultimap`.

b9fe10a7b1c67518d9c6b86fc6611473943c188c

-------

<p> Bring back previously deleted SerializedForms so that old data can still be read.

RELNOTES=`collect`: Data that was previously serialized, and that originated from ImmutableMap.keySet() or .values(), is now deserializable again.

d66fda44e127d00e401cadde1834454feffade86",MOE Sync 2020-08-12
3988,Colin Decker,"['android/guava-tests/test/com/google/common/net/InetAddressesTest.java', 'android/guava/src/com/google/common/net/InetAddresses.java', 'guava-tests/test/com/google/common/net/InetAddressesTest.java', 'guava/src/com/google/common/net/InetAddresses.java']","@@ -85,6 +85,7 @@ public void testForStringBogusInput() {
             ""FEDC:9878"",
             ""+1.+2.+3.4"",
             ""1.2.3.4e0"",
+            ""6:5:4:3:2:1:0"", // too few parts
             ""::7:6:5:4:3:2:1:0"", // too many parts
             ""7:6:5:4:3:2:1:0::"", // too many parts
             ""9:8:7:6:5:4:3::2:1"", // too many parts, @@ -21,8 +21,6 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Splitter;
-import com.google.common.collect.Iterables;
 import com.google.common.hash.Hashing;
 import com.google.common.io.ByteStreams;
 import com.google.common.primitives.Ints;
@@ -33,7 +31,6 @@
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Locale;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
@@ -104,8 +101,9 @@
   private static final int IPV4_PART_COUNT = 4;
   private static final int IPV6_PART_COUNT = 8;
   private static final char IPV4_DELIMITER = '.';
+  private static final char IPV6_DELIMITER = ':';
   private static final CharMatcher IPV4_DELIMITER_MATCHER = CharMatcher.is(IPV4_DELIMITER);
-  private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);
+  private static final CharMatcher IPV6_DELIMITER_MATCHER = CharMatcher.is(IPV6_DELIMITER);
   private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(""127.0.0.1"");
   private static final Inet4Address ANY4 = (Inet4Address) forString(""0.0.0.0"");
 
@@ -235,61 +233,68 @@ public static boolean isInetAddress(String ipString) {
 
   @NullableDecl
   private static byte[] textToNumericFormatV6(String ipString) {
-    // An address can have [2..8] colons, and N colons make N+1 parts.
-    List<String> parts = IPV6_SPLITTER.splitToList(ipString);
-    if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1) {
+    // An address can have [2..8] colons.
+    int delimiterCount = IPV6_DELIMITER_MATCHER.countIn(ipString);
+    if (delimiterCount < 2 || delimiterCount > IPV6_PART_COUNT) {
       return null;
     }
-
-    // Disregarding the endpoints, find ""::"" with nothing in between.
-    // This indicates that a run of zeroes has been skipped.
-    int skipIndex = -1;
-    for (int i = 1; i < parts.size() - 1; i++) {
-      if (parts.get(i).length() == 0) {
-        if (skipIndex >= 0) {
+    int partsSkipped = IPV6_PART_COUNT - (delimiterCount + 1); // estimate; may be modified later
+    boolean hasSkip = false;
+    // Scan for the appearance of ::, to mark a skip-format IPV6 string and adjust the partsSkipped
+    // estimate.
+    for (int i = 0; i < ipString.length() - 1; i++) {
+      if (ipString.charAt(i) == IPV6_DELIMITER && ipString.charAt(i + 1) == IPV6_DELIMITER) {
+        if (hasSkip) {
           return null; // Can't have more than one ::
         }
-        skipIndex = i;
+        hasSkip = true;
+        partsSkipped++; // :: means we skipped an extra part in between the two delimiters.
+        if (i == 0) {
+          partsSkipped++; // Begins with ::, so we skipped the part preceding the first :
+        }
+        if (i == ipString.length() - 2) {
+          partsSkipped++; // Ends with ::, so we skipped the part after the last :
+        }
       }
     }
-
-    int partsHi; // Number of parts to copy from above/before the ""::""
-    int partsLo; // Number of parts to copy from below/after the ""::""
-    if (skipIndex >= 0) {
-      // If we found a ""::"", then check if it also covers the endpoints.
-      partsHi = skipIndex;
-      partsLo = parts.size() - skipIndex - 1;
-      if (parts.get(0).length() == 0 && --partsHi != 0) {
-        return null; // ^: requires ^::
-      }
-      if (Iterables.getLast(parts).length() == 0 && --partsLo != 0) {
-        return null; // :$ requires ::$
-      }
-    } else {
-      // Otherwise, allocate the entire address to partsHi. The endpoints
-      // could still be empty, but parseHextet() will check for that.
-      partsHi = parts.size();
-      partsLo = 0;
+    if (ipString.charAt(0) == IPV6_DELIMITER && ipString.charAt(1) != IPV6_DELIMITER) {
+      return null; // ^: requires ^::
     }
-
-    // If we found a ::, then we must have skipped at least one part.
-    // Otherwise, we must have exactly the right number of parts.
-    int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);
-    if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0)) {
-      return null;
+    if (ipString.charAt(ipString.length() - 1) == IPV6_DELIMITER
+        && ipString.charAt(ipString.length() - 2) != IPV6_DELIMITER) {
+      return null; // :$ requires ::$
+    }
+    if (hasSkip && partsSkipped <= 0) {
+      return null; // :: must expand to at least one '0'
+    }
+    if (!hasSkip && delimiterCount + 1 != IPV6_PART_COUNT) {
+      return null; // Incorrect number of parts
     }
 
-    // Now parse the hextets into a byte array.
     ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);
     try {
-      for (int i = 0; i < partsHi; i++) {
-        rawBytes.putShort(parseHextet(parts.get(i)));
-      }
-      for (int i = 0; i < partsSkipped; i++) {
-        rawBytes.putShort((short) 0);
+      // Iterate through the parts of the ip string.
+      // Invariant: start is always the beginning of a hextet, or the second ':' of the skip
+      // sequence ""::""
+      int start = 0;
+      if (ipString.charAt(0) == IPV6_DELIMITER) {
+        start = 1;
       }
-      for (int i = partsLo; i > 0; i--) {
-        rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));
+      while (start < ipString.length()) {
+        int end = ipString.indexOf(IPV6_DELIMITER, start);
+        if (end == -1) {
+          end = ipString.length();
+        }
+        if (ipString.charAt(start) == IPV6_DELIMITER) {
+          // expand zeroes
+          for (int i = 0; i < partsSkipped; i++) {
+            rawBytes.putShort((short) 0);
+          }
+
+        } else {
+          rawBytes.putShort(parseHextet(ipString, start, end));
+        }
+        start = end + 1;
       }
     } catch (NumberFormatException ex) {
       return null;
@@ -338,10 +343,6 @@ private static byte parseOctet(String ipString, int start, int end) {
     return (byte) octet;
   }
 
-  private static short parseHextet(String ipPart) {
-    return parseHextet(ipPart, 0, ipPart.length());
-  }
-
   // Parse a hextet out of the ipString from start (inclusive) to end (exclusive)
   private static short parseHextet(String ipString, int start, int end) {
     // Note: we already verified that this string contains only hex digits., @@ -85,6 +85,7 @@ public void testForStringBogusInput() {
             ""FEDC:9878"",
             ""+1.+2.+3.4"",
             ""1.2.3.4e0"",
+            ""6:5:4:3:2:1:0"", // too few parts
             ""::7:6:5:4:3:2:1:0"", // too many parts
             ""7:6:5:4:3:2:1:0::"", // too many parts
             ""9:8:7:6:5:4:3::2:1"", // too many parts, @@ -21,8 +21,6 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.CharMatcher;
 import com.google.common.base.MoreObjects;
-import com.google.common.base.Splitter;
-import com.google.common.collect.Iterables;
 import com.google.common.hash.Hashing;
 import com.google.common.io.ByteStreams;
 import com.google.common.primitives.Ints;
@@ -33,7 +31,6 @@
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
-import java.util.List;
 import java.util.Locale;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -104,8 +101,9 @@
   private static final int IPV4_PART_COUNT = 4;
   private static final int IPV6_PART_COUNT = 8;
   private static final char IPV4_DELIMITER = '.';
+  private static final char IPV6_DELIMITER = ':';
   private static final CharMatcher IPV4_DELIMITER_MATCHER = CharMatcher.is(IPV4_DELIMITER);
-  private static final Splitter IPV6_SPLITTER = Splitter.on(':').limit(IPV6_PART_COUNT + 2);
+  private static final CharMatcher IPV6_DELIMITER_MATCHER = CharMatcher.is(IPV6_DELIMITER);
   private static final Inet4Address LOOPBACK4 = (Inet4Address) forString(""127.0.0.1"");
   private static final Inet4Address ANY4 = (Inet4Address) forString(""0.0.0.0"");
 
@@ -232,61 +230,68 @@ public static boolean isInetAddress(String ipString) {
   }
 
   private static byte @Nullable [] textToNumericFormatV6(String ipString) {
-    // An address can have [2..8] colons, and N colons make N+1 parts.
-    List<String> parts = IPV6_SPLITTER.splitToList(ipString);
-    if (parts.size() < 3 || parts.size() > IPV6_PART_COUNT + 1) {
+    // An address can have [2..8] colons.
+    int delimiterCount = IPV6_DELIMITER_MATCHER.countIn(ipString);
+    if (delimiterCount < 2 || delimiterCount > IPV6_PART_COUNT) {
       return null;
     }
-
-    // Disregarding the endpoints, find ""::"" with nothing in between.
-    // This indicates that a run of zeroes has been skipped.
-    int skipIndex = -1;
-    for (int i = 1; i < parts.size() - 1; i++) {
-      if (parts.get(i).length() == 0) {
-        if (skipIndex >= 0) {
+    int partsSkipped = IPV6_PART_COUNT - (delimiterCount + 1); // estimate; may be modified later
+    boolean hasSkip = false;
+    // Scan for the appearance of ::, to mark a skip-format IPV6 string and adjust the partsSkipped
+    // estimate.
+    for (int i = 0; i < ipString.length() - 1; i++) {
+      if (ipString.charAt(i) == IPV6_DELIMITER && ipString.charAt(i + 1) == IPV6_DELIMITER) {
+        if (hasSkip) {
           return null; // Can't have more than one ::
         }
-        skipIndex = i;
+        hasSkip = true;
+        partsSkipped++; // :: means we skipped an extra part in between the two delimiters.
+        if (i == 0) {
+          partsSkipped++; // Begins with ::, so we skipped the part preceding the first :
+        }
+        if (i == ipString.length() - 2) {
+          partsSkipped++; // Ends with ::, so we skipped the part after the last :
+        }
       }
     }
-
-    int partsHi; // Number of parts to copy from above/before the ""::""
-    int partsLo; // Number of parts to copy from below/after the ""::""
-    if (skipIndex >= 0) {
-      // If we found a ""::"", then check if it also covers the endpoints.
-      partsHi = skipIndex;
-      partsLo = parts.size() - skipIndex - 1;
-      if (parts.get(0).length() == 0 && --partsHi != 0) {
-        return null; // ^: requires ^::
-      }
-      if (Iterables.getLast(parts).length() == 0 && --partsLo != 0) {
-        return null; // :$ requires ::$
-      }
-    } else {
-      // Otherwise, allocate the entire address to partsHi. The endpoints
-      // could still be empty, but parseHextet() will check for that.
-      partsHi = parts.size();
-      partsLo = 0;
+    if (ipString.charAt(0) == IPV6_DELIMITER && ipString.charAt(1) != IPV6_DELIMITER) {
+      return null; // ^: requires ^::
     }
-
-    // If we found a ::, then we must have skipped at least one part.
-    // Otherwise, we must have exactly the right number of parts.
-    int partsSkipped = IPV6_PART_COUNT - (partsHi + partsLo);
-    if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped == 0)) {
-      return null;
+    if (ipString.charAt(ipString.length() - 1) == IPV6_DELIMITER
+        && ipString.charAt(ipString.length() - 2) != IPV6_DELIMITER) {
+      return null; // :$ requires ::$
+    }
+    if (hasSkip && partsSkipped <= 0) {
+      return null; // :: must expand to at least one '0'
+    }
+    if (!hasSkip && delimiterCount + 1 != IPV6_PART_COUNT) {
+      return null; // Incorrect number of parts
     }
 
-    // Now parse the hextets into a byte array.
     ByteBuffer rawBytes = ByteBuffer.allocate(2 * IPV6_PART_COUNT);
     try {
-      for (int i = 0; i < partsHi; i++) {
-        rawBytes.putShort(parseHextet(parts.get(i)));
-      }
-      for (int i = 0; i < partsSkipped; i++) {
-        rawBytes.putShort((short) 0);
+      // Iterate through the parts of the ip string.
+      // Invariant: start is always the beginning of a hextet, or the second ':' of the skip
+      // sequence ""::""
+      int start = 0;
+      if (ipString.charAt(0) == IPV6_DELIMITER) {
+        start = 1;
       }
-      for (int i = partsLo; i > 0; i--) {
-        rawBytes.putShort(parseHextet(parts.get(parts.size() - i)));
+      while (start < ipString.length()) {
+        int end = ipString.indexOf(IPV6_DELIMITER, start);
+        if (end == -1) {
+          end = ipString.length();
+        }
+        if (ipString.charAt(start) == IPV6_DELIMITER) {
+          // expand zeroes
+          for (int i = 0; i < partsSkipped; i++) {
+            rawBytes.putShort((short) 0);
+          }
+
+        } else {
+          rawBytes.putShort(parseHextet(ipString, start, end));
+        }
+        start = end + 1;
       }
     } catch (NumberFormatException ex) {
       return null;
@@ -334,10 +339,6 @@ private static byte parseOctet(String ipString, int start, int end) {
     return (byte) octet;
   }
 
-  private static short parseHextet(String ipPart) {
-    return parseHextet(ipPart, 0, ipPart.length());
-  }
-
   // Parse a hextet out of the ipString from start (inclusive) to end (exclusive)
   private static short parseHextet(String ipString, int start, int end) {
     // Note: we already verified that this string contains only hex digits., ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> [Efficiency] Modifies testToNumericFormatV6 to parse the input String in place.

RELNOTES=`InetAddresses`: InetAddress parsing is now more efficient

62a8cc4512d12d7afd1960ddca07b595be3eaf55",MOE Sync 2020-08-14
3991,David P. Baker,"['guava-gwt/src/com/google/common/annotations/Annotations.gwt.xml', 'guava-gwt/src/com/google/common/base/Base.gwt.xml', 'guava-gwt/src/com/google/common/cache/Cache.gwt.xml', 'guava-gwt/src/com/google/common/collect/Collect.gwt.xml', 'guava-gwt/src/com/google/common/escape/Escape.gwt.xml', 'guava-gwt/src/com/google/common/html/Html.gwt.xml', 'guava-gwt/src/com/google/common/io/Io.gwt.xml', 'guava-gwt/src/com/google/common/math/Math.gwt.xml', 'guava-gwt/src/com/google/common/net/Net.gwt.xml', 'guava-gwt/src/com/google/common/primitives/Primitives.gwt.xml', 'guava-gwt/src/com/google/common/util/concurrent/Concurrent.gwt.xml', 'guava-gwt/src/com/google/common/xml/Xml.gwt.xml', 'guava-gwt/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.gwt.xml', 'guava-gwt/src/com/google/thirdparty/publicsuffix/PublicSuffixType.gwt.xml', 'guava-gwt/test/com/google/common/base/testModule.gwt.xml', 'guava-gwt/test/com/google/common/cache/testModule.gwt.xml', 'guava-gwt/test/com/google/common/collect/testModule.gwt.xml', 'guava-gwt/test/com/google/common/collect/testing/Testing.gwt.xml', 'guava-gwt/test/com/google/common/collect/testing/google/Google.gwt.xml', 'guava-gwt/test/com/google/common/collect/testing/testModule.gwt.xml', 'guava-gwt/test/com/google/common/escape/testModule.gwt.xml', 'guava-gwt/test/com/google/common/escape/testing/Testing.gwt.xml', 'guava-gwt/test/com/google/common/html/testModule.gwt.xml', 'guava-gwt/test/com/google/common/io/testModule.gwt.xml', 'guava-gwt/test/com/google/common/math/testModule.gwt.xml', 'guava-gwt/test/com/google/common/net/testModule.gwt.xml', 'guava-gwt/test/com/google/common/primitives/testModule.gwt.xml', 'guava-gwt/test/com/google/common/testing/Testing.gwt.xml', 'guava-gwt/test/com/google/common/testing/testModule.gwt.xml', 'guava-gwt/test/com/google/common/util/concurrent/testModule.gwt.xml', 'guava-gwt/test/com/google/common/xml/testModule.gwt.xml']","@@ -14,6 +14,7 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+      
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,8 +14,11 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.user.User""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+      
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,11 +14,17 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.math.Math""/>
+   
   <inherits name=""com.google.common.util.concurrent.Concurrent""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,11 +14,17 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.user.User""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.math.Math""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+      
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,8 +14,11 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,8 +14,11 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+     
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+   
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,10 +14,15 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.math.Math""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,9 +14,13 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,13 +14,21 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.user.User""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+   
   <inherits name=""com.google.thirdparty.publicsuffix.PublicSuffixPatterns""/>
+   
   <inherits name=""com.google.thirdparty.publicsuffix.PublicSuffixType""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,9 +14,13 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.user.User""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+      
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,10 +14,15 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""elemental2.promise.Promise""/>
+      
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -14,9 +14,13 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+    
   <inherits name=""com.google.gwt.core.Core""/>
    
 </module>, @@ -20,5 +20,11 @@
      (I hope that this workaround does not cause its own problems in the future.)
 -->
 <super-source path=""super""/>
-<inherits name=""com.google.gwt.user.User"" /><inherits name=""com.google.thirdparty.publicsuffix.PublicSuffixType"" /><inherits name=""com.google.common.annotations.Annotations"" /><inherits name=""com.google.common.base.Base"" /><inherits name=""com.google.common.collect.Collect"" /><inherits name=""com.google.gwt.core.Core"" />
+<inherits name=""com.google.gwt.user.User"" />
+
+<inherits name=""com.google.thirdparty.publicsuffix.PublicSuffixType"" />
+<inherits name=""com.google.common.annotations.Annotations"" />
+<inherits name=""com.google.common.base.Base"" />
+<inherits name=""com.google.common.collect.Collect"" />
+<inherits name=""com.google.gwt.core.Core"" />
 </module>, @@ -20,5 +20,8 @@
      (I hope that this workaround does not cause its own problems in the future.)
 -->
 <super-source path=""super""/>
-<inherits name=""com.google.gwt.user.User"" /><inherits name=""com.google.common.annotations.Annotations"" /><inherits name=""com.google.gwt.core.Core"" />
+<inherits name=""com.google.gwt.user.User"" />
+
+<inherits name=""com.google.common.annotations.Annotations"" />
+<inherits name=""com.google.gwt.core.Core"" />
 </module>, @@ -1,17 +1,24 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+            
   <inherits name=""com.google.common.truth.Truth""/>
+    
   <entry-point class=""com.google.common.base.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
   <super-source path=""super""/>
    
 </module>, @@ -1,19 +1,28 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.cache.Cache""/>
+    
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+   
   <inherits name=""com.google.common.util.concurrent.Concurrent""/>
+      
   <inherits name=""com.google.common.truth.Truth""/>
+           
   <entry-point class=""com.google.common.cache.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
   <super-source path=""super""/>
    
 </module>, @@ -1,20 +1,30 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+      
   <inherits name=""com.google.common.collect.testing.Testing""/>
+   
   <inherits name=""com.google.common.collect.testing.google.Google""/>
+   
   <inherits name=""com.google.common.io.Io""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+     
   <inherits name=""com.google.common.truth.Truth""/>
+        
   <entry-point class=""com.google.common.collect.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
   <super-source path=""super""/>
    
 </module>, @@ -14,12 +14,19 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -14,13 +14,21 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.collect.testing.Testing""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
-  <inherits name=""com.google.gwt.core.Core""/>
    
+  <inherits name=""com.google.gwt.core.Core""/>
+      
 </module>, @@ -1,15 +1,22 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.collect.testing.Testing""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+        
   <entry-point class=""com.google.common.collect.testing.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
 </module>, @@ -1,16 +1,24 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+   
   <inherits name=""com.google.common.escape.testing.Testing""/>
+   
   <inherits name=""com.google.common.html.Html""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+           
   <entry-point class=""com.google.common.escape.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
 </module>, @@ -20,5 +20,10 @@
      (I hope that this workaround does not cause its own problems in the future.)
 -->
 <super-source path=""super""/>
-<inherits name=""com.google.gwt.user.User"" /><inherits name=""com.google.gwt.junit.JUnit"" /><inherits name=""com.google.common.annotations.Annotations"" /><inherits name=""com.google.common.escape.Escape"" /><inherits name=""com.google.gwt.core.Core"" />
+<inherits name=""com.google.gwt.user.User"" />
+
+<inherits name=""com.google.gwt.junit.JUnit"" />
+<inherits name=""com.google.common.annotations.Annotations"" />
+<inherits name=""com.google.common.escape.Escape"" />
+<inherits name=""com.google.gwt.core.Core"" />
 </module>, @@ -1,14 +1,20 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.escape.testing.Testing""/>
+   
   <inherits name=""com.google.common.html.Html""/>
+      
   <inherits name=""com.google.common.truth.Truth""/>
+                    
   <entry-point class=""com.google.common.html.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
 </module>, @@ -1,19 +1,28 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.io.Io""/>
+   
   <inherits name=""com.google.common.math.Math""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+     
   <inherits name=""com.google.common.truth.Truth""/>
+           
   <entry-point class=""com.google.common.io.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
   <super-source path=""super""/>
    
 </module>, @@ -1,17 +1,25 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.math.Math""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+       
   <inherits name=""com.google.common.truth.Truth""/>
+       
   <entry-point class=""com.google.common.math.TestModuleEntryPoint""/>
-   
-  <source path=""""/>
     
   <super-source path=""super""/>
    , @@ -1,21 +1,33 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+      
   <inherits name=""com.google.common.collect.testing.Testing""/>
+   
   <inherits name=""com.google.common.collect.testing.google.Google""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+   
   <inherits name=""com.google.common.escape.testing.Testing""/>
+    
   <inherits name=""com.google.common.net.Net""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+      
   <inherits name=""com.google.common.truth.Truth""/>
+         
   <entry-point class=""com.google.common.net.TestModuleEntryPoint""/>
-   
-  <source path=""""/>
     
   <super-source path=""super""/>
    , @@ -1,15 +1,21 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.collect.testing.Testing""/>
+   
   <inherits name=""com.google.common.primitives.Primitives""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+     
   <inherits name=""com.google.common.truth.Truth""/>
+           
   <entry-point class=""com.google.common.primitives.TestModuleEntryPoint""/>
-   
-  <source path=""""/>
     
   <super-source path=""super""/>
    , @@ -14,10 +14,15 @@
   <super-source path=""super""/>
    
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+     
   <inherits name=""com.google.gwt.core.Core""/>
-   
+    
 </module>, @@ -1,15 +1,20 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+     
   <inherits name=""com.google.common.truth.Truth""/>
+        
   <entry-point class=""com.google.common.testing.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
   <super-source path=""super""/>
    
 </module>, @@ -1,17 +1,25 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.base.Base""/>
+   
   <inherits name=""com.google.common.collect.Collect""/>
+   
   <inherits name=""com.google.common.testing.Testing""/>
+   
   <inherits name=""com.google.common.util.concurrent.Concurrent""/>
+    
   <inherits name=""com.google.common.truth.Truth""/>
+               
   <entry-point class=""com.google.common.util.concurrent.TestModuleEntryPoint""/>
-   
-  <source path=""""/>
     
   <super-source path=""super""/>
    , @@ -1,15 +1,22 @@
 <?xml version=""1.0"" encoding=""utf-8""?>
 <module>
    
+  <source path=""""/>
+   
   <inherits name=""com.google.gwt.user.User""/>
+    
   <inherits name=""com.google.gwt.junit.JUnit""/>
+   
   <inherits name=""com.google.common.annotations.Annotations""/>
+   
   <inherits name=""com.google.common.escape.Escape""/>
+   
   <inherits name=""com.google.common.escape.testing.Testing""/>
+   
   <inherits name=""com.google.common.xml.Xml""/>
+      
   <inherits name=""com.google.common.truth.Truth""/>
+           
   <entry-point class=""com.google.common.xml.TestModuleEntryPoint""/>
    
-  <source path=""""/>
-    
 </module>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Switch GWT rules implementation from native to .bzl.

RELNOTES: GWT rules are now implemented in .bzl.

8f12ec7d41b28b6855397e6963789dffaf956861",MOE Sync 2020-08-19
3994,David P. Baker,"['android/guava/src/com/google/common/hash/AbstractByteHasher.java', 'android/guava/src/com/google/common/hash/AbstractCompositeHashFunction.java', 'android/guava/src/com/google/common/hash/AbstractHasher.java', 'android/guava/src/com/google/common/hash/AbstractStreamingHasher.java', 'android/guava/src/com/google/common/hash/Java8Compatibility.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'android/guava/src/com/google/common/io/CharStreams.java', 'android/guava/src/com/google/common/io/Java8Compatibility.java', 'android/guava/src/com/google/common/io/LineReader.java', 'android/guava/src/com/google/common/io/ReaderInputStream.java', 'guava/src/com/google/common/hash/AbstractByteHasher.java', 'guava/src/com/google/common/hash/AbstractCompositeHashFunction.java', 'guava/src/com/google/common/hash/AbstractHasher.java', 'guava/src/com/google/common/hash/AbstractStreamingHasher.java', 'guava/src/com/google/common/hash/Java8Compatibility.java', 'guava/src/com/google/common/io/ByteStreams.java', 'guava/src/com/google/common/io/CharStreams.java', 'guava/src/com/google/common/io/Java8Compatibility.java', 'guava/src/com/google/common/io/LineReader.java', 'guava/src/com/google/common/io/ReaderInputStream.java']","@@ -54,7 +54,7 @@ protected void update(byte[] b, int off, int len) {
   protected void update(ByteBuffer b) {
     if (b.hasArray()) {
       update(b.array(), b.arrayOffset() + b.position(), b.remaining());
-      b.position(b.limit());
+      Java8Compatibility.position(b, b.limit());
     } else {
       for (int remaining = b.remaining(); remaining > 0; remaining--) {
         update(b.get());
@@ -67,7 +67,7 @@ private Hasher update(int bytes) {
     try {
       update(scratch.array(), 0, bytes);
     } finally {
-      scratch.clear();
+      Java8Compatibility.clear(scratch);
     }
     return this;
   }, @@ -98,7 +98,7 @@ public Hasher putBytes(byte[] bytes, int off, int len) {
       public Hasher putBytes(ByteBuffer bytes) {
         int pos = bytes.position();
         for (Hasher hasher : hashers) {
-          bytes.position(pos);
+          Java8Compatibility.position(bytes, pos);
           hasher.putBytes(bytes);
         }
         return this;, @@ -73,7 +73,7 @@ public Hasher putBytes(byte[] bytes, int off, int len) {
   public Hasher putBytes(ByteBuffer b) {
     if (b.hasArray()) {
       putBytes(b.array(), b.arrayOffset() + b.position(), b.remaining());
-      b.position(b.limit());
+      Java8Compatibility.position(b, b.limit());
     } else {
       for (int remaining = b.remaining(); remaining > 0; remaining--) {
         putByte(b.get());, @@ -80,13 +80,13 @@ protected AbstractStreamingHasher(int chunkSize, int bufferSize) {
    * <p>This implementation simply pads with zeros and delegates to {@link #process(ByteBuffer)}.
    */
   protected void processRemaining(ByteBuffer bb) {
-    bb.position(bb.limit()); // move at the end
-    bb.limit(chunkSize + 7); // get ready to pad with longs
+    Java8Compatibility.position(bb, bb.limit()); // move at the end
+    Java8Compatibility.limit(bb, chunkSize + 7); // get ready to pad with longs
     while (bb.position() < chunkSize) {
       bb.putLong(0);
     }
-    bb.limit(chunkSize);
-    bb.flip();
+    Java8Compatibility.limit(bb, chunkSize);
+    Java8Compatibility.flip(bb);
     process(bb);
   }
 
@@ -179,10 +179,10 @@ public final Hasher putLong(long l) {
   @Override
   public final HashCode hash() {
     munch();
-    buffer.flip();
+    Java8Compatibility.flip(buffer);
     if (buffer.remaining() > 0) {
       processRemaining(buffer);
-      buffer.position(buffer.limit());
+      Java8Compatibility.position(buffer, buffer.limit());
     }
     return makeHash();
   }
@@ -203,7 +203,7 @@ private void munchIfFull() {
   }
 
   private void munch() {
-    buffer.flip();
+    Java8Compatibility.flip(buffer);
     while (buffer.remaining() >= chunkSize) {
       // we could limit the buffer to ensure process() does not read more than
       // chunkSize number of bytes, but we trust the implementations, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.hash;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.nio.Buffer;
+
+/**
+ * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
+ * https://github.com/google/guava/issues/3990
+ */
+@GwtIncompatible
+final class Java8Compatibility {
+  static void clear(Buffer b) {
+    b.clear();
+  }
+
+  static void flip(Buffer b) {
+    b.flip();
+  }
+
+  static void limit(Buffer b, int limit) {
+    b.limit(limit);
+  }
+
+  static void position(Buffer b, int position) {
+    b.position(position);
+  }
+
+  private Java8Compatibility() {}
+}, @@ -145,11 +145,11 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
     long total = 0;
     while (from.read(buf) != -1) {
-      buf.flip();
+      Java8Compatibility.flip(buf);
       while (buf.hasRemaining()) {
         total += to.write(buf);
       }
-      buf.clear();
+      Java8Compatibility.clear(buf);
     }
     return total;
   }, @@ -83,10 +83,10 @@ public static long copy(Readable from, Appendable to) throws IOException {
       long total = 0;
       CharBuffer buf = createBuffer();
       while (from.read(buf) != -1) {
-        buf.flip();
+        Java8Compatibility.flip(buf);
         to.append(buf);
         total += buf.remaining();
-        buf.clear();
+        Java8Compatibility.clear(buf);
       }
       return total;
     }
@@ -243,7 +243,7 @@ public static long exhaust(Readable readable) throws IOException {
     CharBuffer buf = createBuffer();
     while ((read = readable.read(buf)) != -1) {
       total += read;
-      buf.clear();
+      Java8Compatibility.clear(buf);
     }
     return total;
   }, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.io;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.nio.Buffer;
+
+/**
+ * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
+ * https://github.com/google/guava/issues/3990
+ */
+@GwtIncompatible
+final class Java8Compatibility {
+  static void clear(Buffer b) {
+    b.clear();
+  }
+
+  static void flip(Buffer b) {
+    b.flip();
+  }
+
+  static void limit(Buffer b, int limit) {
+    b.limit(limit);
+  }
+
+  static void position(Buffer b, int position) {
+    b.position(position);
+  }
+
+  private Java8Compatibility() {}
+}, @@ -70,7 +70,7 @@ public LineReader(Readable readable) {
   @CanIgnoreReturnValue // to skip a line
   public String readLine() throws IOException {
     while (lines.peek() == null) {
-      cbuf.clear();
+      Java8Compatibility.clear(cbuf);
       // The default implementation of Reader#read(CharBuffer) allocates a
       // temporary char[], so we call Reader#read(char[], int, int) instead.
       int read = (reader != null) ? reader.read(buf, 0, buf.length) : readable.read(cbuf);, @@ -104,7 +104,7 @@
     encoder.reset();
 
     charBuffer = CharBuffer.allocate(bufferSize);
-    charBuffer.flip();
+    Java8Compatibility.flip(charBuffer);
 
     byteBuffer = ByteBuffer.allocate(bufferSize);
   }
@@ -143,7 +143,7 @@ public int read(byte[] b, int off, int len) throws IOException {
           return (totalBytesRead > 0) ? totalBytesRead : -1;
         }
         draining = false;
-        byteBuffer.clear();
+        Java8Compatibility.clear(byteBuffer);
       }
 
       while (true) {
@@ -189,8 +189,8 @@ public int read(byte[] b, int off, int len) throws IOException {
   private static CharBuffer grow(CharBuffer buf) {
     char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);
     CharBuffer bigger = CharBuffer.wrap(copy);
-    bigger.position(buf.position());
-    bigger.limit(buf.limit());
+    Java8Compatibility.position(bigger, buf.position());
+    Java8Compatibility.limit(bigger, buf.limit());
     return bigger;
   }
 
@@ -207,7 +207,7 @@ private void readMoreChars() throws IOException {
     if (availableCapacity(charBuffer) == 0) {
       if (charBuffer.position() > 0) {
         // (2) There is room in the buffer. Move existing bytes to the beginning.
-        charBuffer.compact().flip();
+        Java8Compatibility.flip(charBuffer.compact());
       } else {
         // (3) Entire buffer is full, need bigger buffer.
         charBuffer = grow(charBuffer);
@@ -220,7 +220,7 @@ private void readMoreChars() throws IOException {
     if (numChars == -1) {
       endOfInput = true;
     } else {
-      charBuffer.limit(limit + numChars);
+      Java8Compatibility.limit(charBuffer, limit + numChars);
     }
   }
 
@@ -235,7 +235,7 @@ private static int availableCapacity(Buffer buffer) {
    * overflow must be due to a small output buffer.
    */
   private void startDraining(boolean overflow) {
-    byteBuffer.flip();
+    Java8Compatibility.flip(byteBuffer);
     if (overflow && byteBuffer.remaining() == 0) {
       byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);
     } else {, @@ -54,7 +54,7 @@ protected void update(byte[] b, int off, int len) {
   protected void update(ByteBuffer b) {
     if (b.hasArray()) {
       update(b.array(), b.arrayOffset() + b.position(), b.remaining());
-      b.position(b.limit());
+      Java8Compatibility.position(b, b.limit());
     } else {
       for (int remaining = b.remaining(); remaining > 0; remaining--) {
         update(b.get());
@@ -67,7 +67,7 @@ private Hasher update(int bytes) {
     try {
       update(scratch.array(), 0, bytes);
     } finally {
-      scratch.clear();
+      Java8Compatibility.clear(scratch);
     }
     return this;
   }, @@ -98,7 +98,7 @@ public Hasher putBytes(byte[] bytes, int off, int len) {
       public Hasher putBytes(ByteBuffer bytes) {
         int pos = bytes.position();
         for (Hasher hasher : hashers) {
-          bytes.position(pos);
+          Java8Compatibility.position(bytes, pos);
           hasher.putBytes(bytes);
         }
         return this;, @@ -73,7 +73,7 @@ public Hasher putBytes(byte[] bytes, int off, int len) {
   public Hasher putBytes(ByteBuffer b) {
     if (b.hasArray()) {
       putBytes(b.array(), b.arrayOffset() + b.position(), b.remaining());
-      b.position(b.limit());
+      Java8Compatibility.position(b, b.limit());
     } else {
       for (int remaining = b.remaining(); remaining > 0; remaining--) {
         putByte(b.get());, @@ -80,13 +80,13 @@ protected AbstractStreamingHasher(int chunkSize, int bufferSize) {
    * <p>This implementation simply pads with zeros and delegates to {@link #process(ByteBuffer)}.
    */
   protected void processRemaining(ByteBuffer bb) {
-    bb.position(bb.limit()); // move at the end
-    bb.limit(chunkSize + 7); // get ready to pad with longs
+    Java8Compatibility.position(bb, bb.limit()); // move at the end
+    Java8Compatibility.limit(bb, chunkSize + 7); // get ready to pad with longs
     while (bb.position() < chunkSize) {
       bb.putLong(0);
     }
-    bb.limit(chunkSize);
-    bb.flip();
+    Java8Compatibility.limit(bb, chunkSize);
+    Java8Compatibility.flip(bb);
     process(bb);
   }
 
@@ -179,10 +179,10 @@ public final Hasher putLong(long l) {
   @Override
   public final HashCode hash() {
     munch();
-    buffer.flip();
+    Java8Compatibility.flip(buffer);
     if (buffer.remaining() > 0) {
       processRemaining(buffer);
-      buffer.position(buffer.limit());
+      Java8Compatibility.position(buffer, buffer.limit());
     }
     return makeHash();
   }
@@ -203,7 +203,7 @@ private void munchIfFull() {
   }
 
   private void munch() {
-    buffer.flip();
+    Java8Compatibility.flip(buffer);
     while (buffer.remaining() >= chunkSize) {
       // we could limit the buffer to ensure process() does not read more than
       // chunkSize number of bytes, but we trust the implementations, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.hash;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.nio.Buffer;
+
+/**
+ * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
+ * https://github.com/google/guava/issues/3990
+ */
+@GwtIncompatible
+final class Java8Compatibility {
+  static void clear(Buffer b) {
+    b.clear();
+  }
+
+  static void flip(Buffer b) {
+    b.flip();
+  }
+
+  static void limit(Buffer b, int limit) {
+    b.limit(limit);
+  }
+
+  static void position(Buffer b, int position) {
+    b.position(position);
+  }
+
+  private Java8Compatibility() {}
+}, @@ -145,11 +145,11 @@ public static long copy(ReadableByteChannel from, WritableByteChannel to) throws
     ByteBuffer buf = ByteBuffer.wrap(createBuffer());
     long total = 0;
     while (from.read(buf) != -1) {
-      buf.flip();
+      Java8Compatibility.flip(buf);
       while (buf.hasRemaining()) {
         total += to.write(buf);
       }
-      buf.clear();
+      Java8Compatibility.clear(buf);
     }
     return total;
   }, @@ -83,10 +83,10 @@ public static long copy(Readable from, Appendable to) throws IOException {
       long total = 0;
       CharBuffer buf = createBuffer();
       while (from.read(buf) != -1) {
-        buf.flip();
+        Java8Compatibility.flip(buf);
         to.append(buf);
         total += buf.remaining();
-        buf.clear();
+        Java8Compatibility.clear(buf);
       }
       return total;
     }
@@ -243,7 +243,7 @@ public static long exhaust(Readable readable) throws IOException {
     CharBuffer buf = createBuffer();
     while ((read = readable.read(buf)) != -1) {
       total += read;
-      buf.clear();
+      Java8Compatibility.clear(buf);
     }
     return total;
   }, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.io;
+
+import com.google.common.annotations.GwtIncompatible;
+import java.nio.Buffer;
+
+/**
+ * Wrappers around {@link Buffer} methods that are covariantly overridden in Java 9+. See
+ * https://github.com/google/guava/issues/3990
+ */
+@GwtIncompatible
+final class Java8Compatibility {
+  static void clear(Buffer b) {
+    b.clear();
+  }
+
+  static void flip(Buffer b) {
+    b.flip();
+  }
+
+  static void limit(Buffer b, int limit) {
+    b.limit(limit);
+  }
+
+  static void position(Buffer b, int position) {
+    b.position(position);
+  }
+
+  private Java8Compatibility() {}
+}, @@ -70,7 +70,7 @@ public LineReader(Readable readable) {
   @CanIgnoreReturnValue // to skip a line
   public String readLine() throws IOException {
     while (lines.peek() == null) {
-      cbuf.clear();
+      Java8Compatibility.clear(cbuf);
       // The default implementation of Reader#read(CharBuffer) allocates a
       // temporary char[], so we call Reader#read(char[], int, int) instead.
       int read = (reader != null) ? reader.read(buf, 0, buf.length) : readable.read(cbuf);, @@ -104,7 +104,7 @@
     encoder.reset();
 
     charBuffer = CharBuffer.allocate(bufferSize);
-    charBuffer.flip();
+    Java8Compatibility.flip(charBuffer);
 
     byteBuffer = ByteBuffer.allocate(bufferSize);
   }
@@ -143,7 +143,7 @@ public int read(byte[] b, int off, int len) throws IOException {
           return (totalBytesRead > 0) ? totalBytesRead : -1;
         }
         draining = false;
-        byteBuffer.clear();
+        Java8Compatibility.clear(byteBuffer);
       }
 
       while (true) {
@@ -189,8 +189,8 @@ public int read(byte[] b, int off, int len) throws IOException {
   private static CharBuffer grow(CharBuffer buf) {
     char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);
     CharBuffer bigger = CharBuffer.wrap(copy);
-    bigger.position(buf.position());
-    bigger.limit(buf.limit());
+    Java8Compatibility.position(bigger, buf.position());
+    Java8Compatibility.limit(bigger, buf.limit());
     return bigger;
   }
 
@@ -207,7 +207,7 @@ private void readMoreChars() throws IOException {
     if (availableCapacity(charBuffer) == 0) {
       if (charBuffer.position() > 0) {
         // (2) There is room in the buffer. Move existing bytes to the beginning.
-        charBuffer.compact().flip();
+        Java8Compatibility.flip(charBuffer.compact());
       } else {
         // (3) Entire buffer is full, need bigger buffer.
         charBuffer = grow(charBuffer);
@@ -220,7 +220,7 @@ private void readMoreChars() throws IOException {
     if (numChars == -1) {
       endOfInput = true;
     } else {
-      charBuffer.limit(limit + numChars);
+      Java8Compatibility.limit(charBuffer, limit + numChars);
     }
   }
 
@@ -235,7 +235,7 @@ private static int availableCapacity(Buffer buffer) {
    * overflow must be due to a small output buffer.
    */
   private void startDraining(boolean overflow) {
-    byteBuffer.flip();
+    Java8Compatibility.flip(byteBuffer);
     if (overflow && byteBuffer.remaining() == 0) {
       byteBuffer = ByteBuffer.allocate(byteBuffer.capacity() * 2);
     } else {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Don't directly call ByteBuffer, etc. methods that have covariant returns in Java 9+.

Doing so produces a jar that doesn't work under Java 8.

This CL addresses the currently existing problematic calls (by calling the methods on the supertype Buffer instead), but we should also add safeguards.

The normal solution to this general problem is to use --release, but doing so here is complicated.

For more information, see https://github.com/google/guava/issues/3990

406a4eafa25ccd8f456622be19e2ce1e624bc227",MOE Sync 2020-08-21
3996,David P. Baker,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java', 'android/guava/src/com/google/common/util/concurrent/OverflowAvoidingLockSupport.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/ListenableFutureTask.java', 'guava/src/com/google/common/util/concurrent/OverflowAvoidingLockSupport.java']","@@ -431,7 +431,7 @@ public V get(long timeout, TimeUnit unit)
           node.setNext(oldHead);
           if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {
             while (true) {
-              LockSupport.parkNanos(this, remainingNanos);
+              OverflowAvoidingLockSupport.parkNanos(this, remainingNanos);
               // Check interruption first, if we woke up due to interruption we need to honor that.
               if (Thread.interrupted()) {
                 removeWaiter(node);, @@ -14,10 +14,17 @@
 
 package com.google.common.util.concurrent;
 
+import static java.lang.Math.min;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 import com.google.common.annotations.GwtIncompatible;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
@@ -80,6 +87,20 @@ public void addListener(Runnable listener, Executor exec) {
     executionList.add(listener, exec);
   }
 
+  @CanIgnoreReturnValue
+  @Override
+  public V get(long timeout, TimeUnit unit)
+      throws TimeoutException, InterruptedException, ExecutionException {
+
+    long timeoutNanos = unit.toNanos(timeout);
+    if (timeoutNanos <= OverflowAvoidingLockSupport.MAX_NANOSECONDS_THRESHOLD) {
+      return super.get(timeout, unit);
+    }
+    // Waiting 68 years should be enough for any program.
+    return super.get(
+        min(timeoutNanos, OverflowAvoidingLockSupport.MAX_NANOSECONDS_THRESHOLD), NANOSECONDS);
+  }
+
   /** Internal implementation detail used to invoke the listeners. */
   @Override
   protected void done() {, @@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import static java.lang.Math.min;
+
+import java.util.concurrent.locks.LockSupport;
+import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+
+/**
+ * Works around an android bug, where parking for more than INT_MAX seconds can produce an abort
+ * signal on 32 bit devices running Android Q.
+ */
+final class OverflowAvoidingLockSupport {
+  // Represents the max nanoseconds representable on a linux timespec with a 32 bit tv_sec
+  static final long MAX_NANOSECONDS_THRESHOLD = (1L + Integer.MAX_VALUE) * 1_000_000_000L - 1L;
+
+  private OverflowAvoidingLockSupport() {}
+
+  static void parkNanos(@NullableDecl Object blocker, long nanos) {
+    // Even in the extremely unlikely event that a thread unblocks itself early after only 68 years,
+    // this is indistinguishable from a spurious wakeup, which LockSupport allows.
+    LockSupport.parkNanos(blocker, min(nanos, MAX_NANOSECONDS_THRESHOLD));
+  }
+}, @@ -431,7 +431,7 @@ public V get(long timeout, TimeUnit unit)
           node.setNext(oldHead);
           if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {
             while (true) {
-              LockSupport.parkNanos(this, remainingNanos);
+              OverflowAvoidingLockSupport.parkNanos(this, remainingNanos);
               // Check interruption first, if we woke up due to interruption we need to honor that.
               if (Thread.interrupted()) {
                 removeWaiter(node);, @@ -14,10 +14,17 @@
 
 package com.google.common.util.concurrent;
 
+import static java.lang.Math.min;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 import com.google.common.annotations.GwtIncompatible;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -80,6 +87,20 @@ public void addListener(Runnable listener, Executor exec) {
     executionList.add(listener, exec);
   }
 
+  @CanIgnoreReturnValue
+  @Override
+  public V get(long timeout, TimeUnit unit)
+      throws TimeoutException, InterruptedException, ExecutionException {
+
+    long timeoutNanos = unit.toNanos(timeout);
+    if (timeoutNanos <= OverflowAvoidingLockSupport.MAX_NANOSECONDS_THRESHOLD) {
+      return super.get(timeout, unit);
+    }
+    // Waiting 68 years should be enough for any program.
+    return super.get(
+        min(timeoutNanos, OverflowAvoidingLockSupport.MAX_NANOSECONDS_THRESHOLD), NANOSECONDS);
+  }
+
   /** Internal implementation detail used to invoke the listeners. */
   @Override
   protected void done() {, @@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.util.concurrent;
+
+import static java.lang.Math.min;
+
+import java.util.concurrent.locks.LockSupport;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+/**
+ * Works around an android bug, where parking for more than INT_MAX seconds can produce an abort
+ * signal on 32 bit devices running Android Q.
+ */
+final class OverflowAvoidingLockSupport {
+  // Represents the max nanoseconds representable on a linux timespec with a 32 bit tv_sec
+  static final long MAX_NANOSECONDS_THRESHOLD = (1L + Integer.MAX_VALUE) * 1_000_000_000L - 1L;
+
+  private OverflowAvoidingLockSupport() {}
+
+  static void parkNanos(@Nullable Object blocker, long nanos) {
+    // Even in the extremely unlikely event that a thread unblocks itself early after only 68 years,
+    // this is indistinguishable from a spurious wakeup, which LockSupport allows.
+    LockSupport.parkNanos(blocker, min(nanos, MAX_NANOSECONDS_THRESHOLD));
+  }
+}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Adding SEC-CH-UA-Arch header.

Header Spec Here: https://wicg.github.io/ua-client-hints/#http-ua-hints

RELNOTES=N/A

8ed8696b2a1700bfcf5e7727f0be6141d2438e20

-------

<p> Work around an android bug in LockSupport, this time with @CanIgnoreReturnValue

a849f7f1264b586d44f2b34f274bac9f1d7eff19",MOE Sync 2020-08-24
3998,David P. Baker,"['android/guava-tests/test/com/google/common/eventbus/EventBusTest.java', 'android/guava/src/com/google/common/eventbus/Subscribe.java', 'android/guava/src/com/google/common/eventbus/SubscriberRegistry.java', 'guava-tests/test/com/google/common/eventbus/EventBusTest.java', 'guava/src/com/google/common/eventbus/Subscribe.java', 'guava/src/com/google/common/eventbus/SubscriberRegistry.java']","@@ -289,6 +289,18 @@ public void call(String s) {
     assertEquals(1, calls.get());
   }
 
+  public void testPrimitiveSubscribeFails() {
+    class SubscribesToPrimitive {
+      @Subscribe
+      public void toInt(int i) {}
+    }
+    try {
+      bus.register(new SubscribesToPrimitive());
+      fail(""should have thrown"");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   /** Records thrown exception information. */
   private static final class RecordingSubscriberExceptionHandler
       implements SubscriberExceptionHandler {, @@ -23,9 +23,10 @@
 /**
  * Marks a method as an event subscriber.
  *
- * <p>The type of event will be indicated by the method's first (and only) parameter. If this
- * annotation is applied to methods with zero parameters, or more than one parameter, the object
- * containing the method will not be able to register for event delivery from the {@link EventBus}.
+ * <p>The type of event will be indicated by the method's first (and only) parameter, which cannot
+ * be primitive. If this annotation is applied to methods with zero parameters, or more than one
+ * parameter, the object containing the method will not be able to register for event delivery from
+ * the {@link EventBus}.
  *
  * <p>Unless also annotated with @{@link AllowConcurrentEvents}, event subscriber methods will be
  * invoked serially by each event bus that they are registered with., @@ -16,6 +16,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Throwables.throwIfUnchecked;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
@@ -31,6 +32,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
+import com.google.common.primitives.Primitives;
 import com.google.common.reflect.TypeToken;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.google.j2objc.annotations.Weak;
@@ -170,7 +172,12 @@ void unregister(Object listener) {
   }
 
   private static ImmutableList<Method> getAnnotatedMethods(Class<?> clazz) {
-    return subscriberMethodsCache.getUnchecked(clazz);
+    try {
+      return subscriberMethodsCache.getUnchecked(clazz);
+    } catch (UncheckedExecutionException e) {
+      throwIfUnchecked(e.getCause());
+      throw e;
+    }
   }
 
   private static ImmutableList<Method> getAnnotatedMethodsNotCached(Class<?> clazz) {
@@ -183,11 +190,20 @@ void unregister(Object listener) {
           Class<?>[] parameterTypes = method.getParameterTypes();
           checkArgument(
               parameterTypes.length == 1,
-              ""Method %s has @Subscribe annotation but has %s parameters.""
+              ""Method %s has @Subscribe annotation but has %s parameters. ""
                   + ""Subscriber methods must have exactly 1 parameter."",
               method,
               parameterTypes.length);
 
+          checkArgument(
+              !parameterTypes[0].isPrimitive(),
+              ""@Subscribe method %s's parameter is %s. ""
+                  + ""Subscriber methods cannot accept primitives. ""
+                  + ""Consider changing the parameter to %s."",
+              method,
+              parameterTypes[0].getName(),
+              Primitives.wrap(parameterTypes[0]).getSimpleName());
+
           MethodIdentifier ident = new MethodIdentifier(method);
           if (!identifiers.containsKey(ident)) {
             identifiers.put(ident, method);, @@ -289,6 +289,18 @@ public void call(String s) {
     assertEquals(1, calls.get());
   }
 
+  public void testPrimitiveSubscribeFails() {
+    class SubscribesToPrimitive {
+      @Subscribe
+      public void toInt(int i) {}
+    }
+    try {
+      bus.register(new SubscribesToPrimitive());
+      fail(""should have thrown"");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   /** Records thrown exception information. */
   private static final class RecordingSubscriberExceptionHandler
       implements SubscriberExceptionHandler {, @@ -23,9 +23,10 @@
 /**
  * Marks a method as an event subscriber.
  *
- * <p>The type of event will be indicated by the method's first (and only) parameter. If this
- * annotation is applied to methods with zero parameters, or more than one parameter, the object
- * containing the method will not be able to register for event delivery from the {@link EventBus}.
+ * <p>The type of event will be indicated by the method's first (and only) parameter, which cannot
+ * be primitive. If this annotation is applied to methods with zero parameters, or more than one
+ * parameter, the object containing the method will not be able to register for event delivery from
+ * the {@link EventBus}.
  *
  * <p>Unless also annotated with @{@link AllowConcurrentEvents}, event subscriber methods will be
  * invoked serially by each event bus that they are registered with., @@ -16,6 +16,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Throwables.throwIfUnchecked;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.MoreObjects;
@@ -31,6 +32,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
+import com.google.common.primitives.Primitives;
 import com.google.common.reflect.TypeToken;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 import com.google.j2objc.annotations.Weak;
@@ -170,7 +172,12 @@ void unregister(Object listener) {
   }
 
   private static ImmutableList<Method> getAnnotatedMethods(Class<?> clazz) {
-    return subscriberMethodsCache.getUnchecked(clazz);
+    try {
+      return subscriberMethodsCache.getUnchecked(clazz);
+    } catch (UncheckedExecutionException e) {
+      throwIfUnchecked(e.getCause());
+      throw e;
+    }
   }
 
   private static ImmutableList<Method> getAnnotatedMethodsNotCached(Class<?> clazz) {
@@ -183,11 +190,20 @@ void unregister(Object listener) {
           Class<?>[] parameterTypes = method.getParameterTypes();
           checkArgument(
               parameterTypes.length == 1,
-              ""Method %s has @Subscribe annotation but has %s parameters.""
+              ""Method %s has @Subscribe annotation but has %s parameters. ""
                   + ""Subscriber methods must have exactly 1 parameter."",
               method,
               parameterTypes.length);
 
+          checkArgument(
+              !parameterTypes[0].isPrimitive(),
+              ""@Subscribe method %s's parameter is %s. ""
+                  + ""Subscriber methods cannot accept primitives. ""
+                  + ""Consider changing the parameter to %s."",
+              method,
+              parameterTypes[0].getName(),
+              Primitives.wrap(parameterTypes[0]).getSimpleName());
+
           MethodIdentifier ident = new MethodIdentifier(method);
           if (!identifiers.containsKey(ident)) {
             identifiers.put(ident, method);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Throw if @Subscribe is applied to a method that takes a primitive parameter.

Fixes https://github.com/google/guava/issues/3992.

RELNOTES=Prevent @Subscribe being applied to a method that takes a primitive, as that will never be called.

9fe4ecdc84e628c7da0aa68fc6257932dc9dbced",MOE Sync 2020-08-25
4000,David P. Baker,"['android/guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Files.java']","@@ -398,6 +398,11 @@ public static boolean equal(File file1, File file2) throws IOException {
    * be exploited to create security vulnerabilities, especially when executable files are to be
    * written into the directory.
    *
+   * <p>Depending on the environmment that this code is run in, the system temporary directory (and
+   * thus the directory this method creates) may be more visible that a program would like - files
+   * written to this directory may be read or overwritten by hostile programs running on the same
+   * machine.
+   *
    * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,
    * and that it will not be called thousands of times per second.
    *
@@ -406,8 +411,15 @@ public static boolean equal(File file1, File file2) throws IOException {
    *
    * @return the newly-created directory
    * @throws IllegalStateException if the directory could not be created
+   * @deprecated For Android users, see the <a
+   *     href=""https://developer.android.com/training/data-storage"" target=""_blank"">Data and File
+   *     Storage overview</a> to select an appropriate temporary directory (perhaps {@code
+   *     context.getCacheDir()}). For developers on Java 7 or later, use {@link
+   *     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link
+   *     java.nio.file.Path#toFile() toFile()} if needed.
    */
   @Beta
+  @Deprecated
   public static File createTempDir() {
     File baseDir = new File(System.getProperty(""java.io.tmpdir""));
     @SuppressWarnings(""GoodTime"") // reading system time without TimeSource, @@ -398,6 +398,11 @@ public static boolean equal(File file1, File file2) throws IOException {
    * be exploited to create security vulnerabilities, especially when executable files are to be
    * written into the directory.
    *
+   * <p>Depending on the environmment that this code is run in, the system temporary directory (and
+   * thus the directory this method creates) may be more visible that a program would like - files
+   * written to this directory may be read or overwritten by hostile programs running on the same
+   * machine.
+   *
    * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,
    * and that it will not be called thousands of times per second.
    *
@@ -406,8 +411,15 @@ public static boolean equal(File file1, File file2) throws IOException {
    *
    * @return the newly-created directory
    * @throws IllegalStateException if the directory could not be created
+   * @deprecated For Android users, see the <a
+   *     href=""https://developer.android.com/training/data-storage"" target=""_blank"">Data and File
+   *     Storage overview</a> to select an appropriate temporary directory (perhaps {@code
+   *     context.getCacheDir()}). For developers on Java 7 or later, use {@link
+   *     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link
+   *     java.nio.file.Path#toFile() toFile()} if needed.
    */
   @Beta
+  @Deprecated
   public static File createTempDir() {
     File baseDir = new File(System.getProperty(""java.io.tmpdir""));
     @SuppressWarnings(""GoodTime"") // reading system time without TimeSource, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Deprecate Files.createTempDir(), noting that better alternatives exist for Android as well as for users running Java 7 or later.

RELNOTES=`io`: Deprecated `Files.createTempDir()`.

9258dd9071c850dde0461f0f0cad81105442fdce",MOE Sync 2020-08-27
4003,Chris Povirk,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Update Public Suffix data.

The copy is typically updated whenever Chrome's copy is updated, which
is roughly every 6 weeks. Subscribe to the Chrome Milestone Calendar to see the
dates.

ac1b252294c4c5547384b86d40345e59e3dedc8a",MOE Sync 2020-08-31
4009,Nick,['guava-gwt/test/com/google/common/html/testModule.gwt.xml'],"@@ -14,7 +14,7 @@
   <inherits name=""com.google.common.html.Html""/>
       
   <inherits name=""com.google.common.truth.Truth""/>
-                    
+                     
   <entry-point class=""com.google.common.html.TestModuleEntryPoint""/>
    
 </module>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Minor whitespace-only change

19c22993e371f53321c9c1a6331f6da329860566",MOE Sync 2020-09-08
4020,Nick,"['android/guava/src/com/google/common/util/concurrent/ClosingFuture.java', 'guava/src/com/google/common/util/concurrent/ClosingFuture.java']","@@ -45,7 +45,6 @@
 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
 import com.google.common.util.concurrent.Futures.FutureCombiner;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Closeable;
 import java.io.IOException;
@@ -1148,7 +1147,6 @@ private Peeker(ImmutableList<ClosingFuture<?>> futures) {
    *           .closing(executor);
    * }</pre>
    */
-  @DoNotMock(""Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead."")
   public static class Combiner {
 
     private final CloseableList closeables = new CloseableList();, @@ -45,7 +45,6 @@
 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
 import com.google.common.util.concurrent.Futures.FutureCombiner;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.DoNotMock;
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Closeable;
 import java.util.IdentityHashMap;
@@ -1145,7 +1144,6 @@ private Peeker(ImmutableList<ClosingFuture<?>> futures) {
    *           .closing(executor);
    * }</pre>
    */
-  @DoNotMock(""Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead."")
   public static class Combiner {
 
     private final CloseableList closeables = new CloseableList();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make ClosingFuture available in open-source Guava (@Beta).

RELNOTES=`util.concurrent`: Add `ClosingFuture`.

48851566428571694e62dee9f277d9833e78f17a

-------

<p> Fix typos and remove unnecessary words.

Fixes #4012

12c9012b0bde00a99cd454f1af6d90b1e5e11508

-------

<p> Bump checker-qual from 2.11.1 to 3.5.0.

For unfortunate reasons involving internal legacy infrastructure, this is easier than merging #4018. But at least it gets us on the newest major version. That makes it easier to see that it's safe to resolve a conflict between, say, 3.5.0 and 3.6.1 by just using the newer one.

a2ad1ee1fa9fcc591edc79f5e7c160ddd19b851d

-------

<p> Remove spurious annotation to fix Travis build.

f106608d0c58c2c67dcd56e638ace73472768f65",MOE Sync 2020-09-15
4025,Nick,"['android/guava-testlib/src/com/google/common/testing/EqualsTester.java', 'android/guava-testlib/test/com/google/common/testing/EqualsTesterTest.java', 'guava-gwt/test/com/google/common/testing/EqualsTesterTest_gwt.java', 'guava-testlib/src/com/google/common/testing/EqualsTester.java', 'guava-testlib/test/com/google/common/testing/EqualsTesterTest.java']","@@ -127,6 +127,11 @@ private void testItems() {
           ""the Object#hashCode of "" + item + "" must be consistent"",
           item.hashCode(),
           item.hashCode());
+      if (!(item instanceof String)) {
+        assertTrue(
+            item + "" must not be Object#equals to its Object#toString representation"",
+            !item.equals(item.toString()));
+      }
     }
   }
 , @@ -272,6 +272,15 @@ public void testEqualityGroups() {
         .testEquals();
   }
 
+  public void testEqualityBasedOnToString() {
+    try {
+      new EqualsTester().addEqualityGroup(new EqualsBasedOnToString(""foo"")).testEquals();
+      fail();
+    } catch (AssertionFailedError e) {
+      assertTrue(e.getMessage().contains(""toString representation""));
+    }
+  }
+
   private static void assertErrorMessage(Throwable e, String message) {
     // TODO(kevinb): use a Truth assertion here
     if (!e.getMessage().contains(message)) {
@@ -422,4 +431,27 @@ public String toString() {
       return name;
     }
   }
+
+  private static final class EqualsBasedOnToString {
+    private final String s;
+
+    private EqualsBasedOnToString(String s) {
+      this.s = s;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj != null && obj.toString().equals(toString());
+    }
+
+    @Override
+    public int hashCode() {
+      return s.hashCode();
+    }
+
+    @Override
+    public String toString() {
+      return s;
+    }
+  }
 }, @@ -42,6 +42,12 @@ public void testAddTwoEqualObjectsAtOnceWithNull() throws Exception {
   testCase.testAddTwoEqualObjectsAtOnceWithNull();
 }
 
+public void testEqualityBasedOnToString() throws Exception {
+  com.google.common.testing.EqualsTesterTest testCase = new com.google.common.testing.EqualsTesterTest();
+  testCase.setUp();
+  testCase.testEqualityBasedOnToString();
+}
+
 public void testEqualityGroups() throws Exception {
   com.google.common.testing.EqualsTesterTest testCase = new com.google.common.testing.EqualsTesterTest();
   testCase.setUp();, @@ -127,6 +127,11 @@ private void testItems() {
           ""the Object#hashCode of "" + item + "" must be consistent"",
           item.hashCode(),
           item.hashCode());
+      if (!(item instanceof String)) {
+        assertTrue(
+            item + "" must not be Object#equals to its Object#toString representation"",
+            !item.equals(item.toString()));
+      }
     }
   }
 , @@ -272,6 +272,15 @@ public void testEqualityGroups() {
         .testEquals();
   }
 
+  public void testEqualityBasedOnToString() {
+    try {
+      new EqualsTester().addEqualityGroup(new EqualsBasedOnToString(""foo"")).testEquals();
+      fail();
+    } catch (AssertionFailedError e) {
+      assertTrue(e.getMessage().contains(""toString representation""));
+    }
+  }
+
   private static void assertErrorMessage(Throwable e, String message) {
     // TODO(kevinb): use a Truth assertion here
     if (!e.getMessage().contains(message)) {
@@ -422,4 +431,27 @@ public String toString() {
       return name;
     }
   }
+
+  private static final class EqualsBasedOnToString {
+    private final String s;
+
+    private EqualsBasedOnToString(String s) {
+      this.s = s;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj != null && obj.toString().equals(toString());
+    }
+
+    @Override
+    public int hashCode() {
+      return s.hashCode();
+    }
+
+    @Override
+    public String toString() {
+      return s;
+    }
+  }
 }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make EqualsTester test that non-Strings are not equal to their String representation.

RELNOTES=Make EqualsTester test that non-Strings are not equal to their String representation.

5f5a9b98d87d0439bb9670947a4bef331e8dcb4c",MOE Sync 2020-09-16
4029,Kurt Alfred Kluever,"['android/guava/src/com/google/common/util/concurrent/ClosingFuture.java', 'guava/src/com/google/common/util/concurrent/ClosingFuture.java']","@@ -45,6 +45,7 @@
 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
 import com.google.common.util.concurrent.Futures.FutureCombiner;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.DoNotMock;
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Closeable;
 import java.io.IOException;
@@ -189,6 +190,7 @@
  */
 // TODO(dpb): Consider reusing one CloseableList for the entire pipeline, modulo combinations.
 @Beta // @Beta for one release.
+@DoNotMock(""Use ClosingFuture.from(Futures.immediate*Future)"")
 // TODO(dpb): GWT compatibility.
 public final class ClosingFuture<V> {
 
@@ -1147,6 +1149,9 @@ private Peeker(ImmutableList<ClosingFuture<?>> futures) {
    *           .closing(executor);
    * }</pre>
    */
+  // TODO(cpovirk): Use simple name instead of fully qualified after we stop building with JDK 8.
+  @com.google.errorprone.annotations.DoNotMock(
+      ""Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead."")
   public static class Combiner {
 
     private final CloseableList closeables = new CloseableList();, @@ -45,6 +45,7 @@
 import com.google.common.util.concurrent.ClosingFuture.Combiner.CombiningCallable;
 import com.google.common.util.concurrent.Futures.FutureCombiner;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.DoNotMock;
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Closeable;
 import java.util.IdentityHashMap;
@@ -188,6 +189,7 @@
  */
 // TODO(dpb): Consider reusing one CloseableList for the entire pipeline, modulo combinations.
 @Beta // @Beta for one release.
+@DoNotMock(""Use ClosingFuture.from(Futures.immediate*Future)"")
 // TODO(dpb): GWT compatibility.
 public final class ClosingFuture<V> {
 
@@ -1144,6 +1146,9 @@ private Peeker(ImmutableList<ClosingFuture<?>> futures) {
    *           .closing(executor);
    * }</pre>
    */
+  // TODO(cpovirk): Use simple name instead of fully qualified after we stop building with JDK 8.
+  @com.google.errorprone.annotations.DoNotMock(
+      ""Use ClosingFuture.whenAllSucceed() or .whenAllComplete() instead."")
   public static class Combiner {
 
     private final CloseableList closeables = new CloseableList();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix AssertionError from Range.gap.

Fixes #4007, #4004

88593a07f3a04163f2c68cf323a54cd8f8efdd03

-------

<p> Fix random typos in Guava.

Fixes #4021

1102d11be3bbe534a5a569832aeb0099aa0eaa61

-------

<p> Add back web.app to public suffix list

d12e9833c5232032c8e9a0b51c9ea3b9ce5e2b9d

-------

<p> Externally restore @DoNotMock to ClosingFuture.Combiner, and externally add @DoNotMock to ClosingFuture itself.

This implements an alternative workaround for https://bugs.openjdk.java.net/browse/JDK-7101822, replacing the one submitted in CL 331770482.

7b4c82f4e436311184cfb61cd6cfd8fb85a3dbe5",MOE Sync 2020-09-17
4030,Kurt Alfred Kluever,"['android/guava/src/com/google/common/collect/ForwardingMap.java', 'guava/src/com/google/common/collect/ForwardingMap.java']","@@ -76,8 +76,8 @@ public boolean isEmpty() {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(Object object) {
-    return delegate().remove(object);
+  public V remove(Object key) {
+    return delegate().remove(key);
   }
 
   @Override, @@ -76,8 +76,8 @@ public boolean isEmpty() {
 
   @CanIgnoreReturnValue
   @Override
-  public V remove(Object object) {
-    return delegate().remove(object);
+  public V remove(Object key) {
+    return delegate().remove(key);
   }
 
   @Override, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix UnsupportedOperationException from TreeRangeSet.subRangeSet(...).add(...).

Fixes #4019, #4002

3685507ce36e24f111cabb45c6d5c5dd26565aad

-------

<p> Deal with Class#isInstance checks which are guaranteed to be false.

2fa82f2cb6e1d2f6c29b7986be6e95063b65bf71

-------

<p> Change `ForwardingMap.remove(Object)` parameter name from `object` to `key` to match `Map.remove(Object key)`.

Fixes https://github.com/google/guava/issues/4028

204904cbe79852e29aec2e461273f9b6112bd2f9",MOE Sync 2020-09-18
4035,Colin Decker,"['android/guava-tests/test/com/google/common/collect/RangeTest.java', 'guava-tests/test/com/google/common/collect/RangeTest.java']","@@ -119,6 +119,8 @@ public void testClosedOpen() {
 
   public void testIsConnected() {
     assertTrue(Range.closed(3, 5).isConnected(Range.open(5, 6)));
+    assertTrue(Range.closed(3, 5).isConnected(Range.closed(5, 6)));
+    assertTrue(Range.closed(5, 6).isConnected(Range.closed(3, 5)));
     assertTrue(Range.closed(3, 5).isConnected(Range.openClosed(5, 5)));
     assertTrue(Range.open(3, 5).isConnected(Range.closed(5, 6)));
     assertTrue(Range.closed(3, 7).isConnected(Range.open(6, 8)));, @@ -119,6 +119,8 @@ public void testClosedOpen() {
 
   public void testIsConnected() {
     assertTrue(Range.closed(3, 5).isConnected(Range.open(5, 6)));
+    assertTrue(Range.closed(3, 5).isConnected(Range.closed(5, 6)));
+    assertTrue(Range.closed(5, 6).isConnected(Range.closed(3, 5)));
     assertTrue(Range.closed(3, 5).isConnected(Range.openClosed(5, 5)));
     assertTrue(Range.open(3, 5).isConnected(Range.closed(5, 6)));
     assertTrue(Range.closed(3, 7).isConnected(Range.open(6, 8)));, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add brief test to Range for `[_, X].isConnected([X, _])`;

RELNOTES: n/a

4629a25981b1ff667315d481fc21bcb094d436dc",MOE Sync 2020-09-22
5252,Colin Decker,"['android/guava-tests/test/com/google/common/reflect/ClassPathTest.java', 'android/guava/src/com/google/common/reflect/ClassPath.java', 'guava-tests/test/com/google/common/reflect/ClassPathTest.java', 'guava/src/com/google/common/reflect/ClassPath.java']","@@ -45,6 +45,7 @@
 import java.util.HashSet;
 import java.util.Set;
 import java.util.jar.Attributes;
+import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import java.util.jar.Manifest;
 import java.util.logging.Logger;
@@ -543,18 +544,13 @@ static File pickAnyJarFile() throws IOException {
     }
 
     @Override
-    protected void scanFrom(File file, ClassLoader loader) throws IOException {
-      if (file.isDirectory()) {
-        return;
-      }
-      this.found = file;
+    void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
+      this.found = new File(file.getName());
       throw new StopScanningException();
     }
 
     @Override
-    protected void scanResource(ResourceInfo resource) throws IOException {
-      throw new IllegalStateException();
-    }
+    protected void scanResource(ResourceInfo resource) {}
 
     // Special exception just to terminate the scanning when we get any jar file to use.
     private static final class StopScanningException extends RuntimeException {}, @@ -508,7 +508,8 @@ static URL getClassPathEntry(File jarFile, String path) throws MalformedURLExcep
       return new URL(jarFile.toURI().toURL(), path);
     }
 
-    private void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
+    @VisibleForTesting
+    void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
       Enumeration<JarEntry> entries = file.entries();
       while (entries.hasMoreElements()) {
         JarEntry entry = entries.nextElement();, @@ -52,6 +52,7 @@
 import java.util.HashSet;
 import java.util.Set;
 import java.util.jar.Attributes;
+import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import java.util.jar.Manifest;
 import java.util.logging.Logger;
@@ -610,18 +611,13 @@ static File pickAnyJarFile() throws IOException {
     }
 
     @Override
-    protected void scanFrom(File file, ClassLoader loader) throws IOException {
-      if (file.isDirectory()) {
-        return;
-      }
-      this.found = file;
+    void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
+      this.found = new File(file.getName());
       throw new StopScanningException();
     }
 
     @Override
-    protected void scanResource(ResourceInfo resource) throws IOException {
-      throw new IllegalStateException();
-    }
+    protected void scanResource(ResourceInfo resource) {}
 
     // Special exception just to terminate the scanning when we get any jar file to use.
     private static final class StopScanningException extends RuntimeException {}, @@ -507,7 +507,8 @@ static URL getClassPathEntry(File jarFile, String path) throws MalformedURLExcep
       return new URL(jarFile.toURI().toURL(), path);
     }
 
-    private void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
+    @VisibleForTesting
+    void scanJarFile(ClassLoader classloader, JarFile file) throws IOException {
       Enumeration<JarEntry> entries = file.entries();
       while (entries.hasMoreElements()) {
         JarEntry entry = entries.nextElement();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Internal changes to ClassPath.

643423a88d854deb863fa08f550a6e41d2823df5

-------

<p> Internal changes to ClassPath.

b7e83b114f95f5b776ed60f5932420e5c5fc24ad

-------

<p> Remove unnecessary parens

Fixes #4036

30c69a1ff047f8dad3abef2c315c305e052da0b2

-------

<p> Also print Android test failures.

0644480db466a331b7bd9fa7a8690f37d05ddda2

-------

<p> Fix ClassPathTest on Android JDK 11.

037e10c0da8159c06fa471142ae923dceb03e4ea",MOE Sync 2020-09-29
5256,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/math/BigDecimalMathTest.java', 'guava-gwt/test/com/google/common/math/BigDecimalMathTest_gwt.java', 'guava-tests/test/com/google/common/math/BigDecimalMathTest.java']","@@ -26,7 +26,6 @@
 import static java.math.RoundingMode.UP;
 import static java.math.RoundingMode.values;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import java.math.BigDecimal;
 import java.math.MathContext;
@@ -36,9 +35,8 @@
 import java.util.Map;
 import junit.framework.TestCase;
 
-@GwtCompatible(emulated = true)
+@GwtIncompatible
 public class BigDecimalMathTest extends TestCase {
-  @GwtIncompatible
   private static final class RoundToDoubleTester {
     private final BigDecimal input;
     private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
@@ -88,12 +86,10 @@ public void test() {
     }
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_zero() {
     new RoundToDoubleTester(BigDecimal.ZERO).setExpectation(0.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_oneThird() {
     new RoundToDoubleTester(
             BigDecimal.ONE.divide(BigDecimal.valueOf(3), new MathContext(50, HALF_EVEN)))
@@ -103,7 +99,6 @@ public void testRoundToDouble_oneThird() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_halfMinDouble() {
     BigDecimal minDouble = new BigDecimal(Double.MIN_VALUE);
     BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
@@ -114,7 +109,6 @@ public void testRoundToDouble_halfMinDouble() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_halfNegativeMinDouble() {
     BigDecimal minDouble = new BigDecimal(-Double.MIN_VALUE);
     BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
@@ -125,19 +119,16 @@ public void testRoundToDouble_halfNegativeMinDouble() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_smallPositive() {
     new RoundToDoubleTester(BigDecimal.valueOf(16)).setExpectation(16.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxPreciselyRepresentable() {
     new RoundToDoubleTester(BigDecimal.valueOf(1L << 53))
         .setExpectation(Math.pow(2, 53), values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
     double twoToThe53 = Math.pow(2, 53);
     // the representable doubles are 2^53 and 2^53 + 2.
@@ -149,7 +140,6 @@ public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusOne() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -161,7 +151,6 @@ public void testRoundToDouble_twoToThe54PlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusOneHalf() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -173,7 +162,6 @@ public void testRoundToDouble_twoToThe54PlusOneHalf() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusThree() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -185,20 +173,17 @@ public void testRoundToDouble_twoToThe54PlusThree() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusFour() {
     new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 4))
         .setExpectation(Math.pow(2, 54) + 4, values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxDouble() {
     BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE);
     new RoundToDoubleTester(maxDoubleAsBD).setExpectation(Double.MAX_VALUE, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxDoublePlusOne() {
     BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE).add(BigDecimal.ONE);
     new RoundToDoubleTester(maxDoubleAsBD)
@@ -208,7 +193,6 @@ public void testRoundToDouble_maxDoublePlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_wayTooBig() {
     BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT);
     new RoundToDoubleTester(bi)
@@ -218,19 +202,16 @@ public void testRoundToDouble_wayTooBig() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_smallNegative() {
     new RoundToDoubleTester(BigDecimal.valueOf(-16)).setExpectation(-16.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minPreciselyRepresentable() {
     new RoundToDoubleTester(BigDecimal.valueOf(-1L << 53))
         .setExpectation(-Math.pow(2, 53), values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
     // the representable doubles are -2^53 and -2^53 - 2.
     // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
@@ -241,7 +222,6 @@ public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusOne() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 1))
         .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
@@ -250,7 +230,6 @@ public void testRoundToDouble_negativeTwoToThe54MinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusThree() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 3))
         .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
@@ -260,20 +239,17 @@ public void testRoundToDouble_negativeTwoToThe54MinusThree() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusFour() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 4))
         .setExpectation(-Math.pow(2, 54) - 4, values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minDouble() {
     BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE);
     new RoundToDoubleTester(minDoubleAsBD).setExpectation(-Double.MAX_VALUE, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minDoubleMinusOne() {
     BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE).subtract(BigDecimal.ONE);
     new RoundToDoubleTester(minDoubleAsBD)
@@ -283,7 +259,6 @@ public void testRoundToDouble_minDoubleMinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeWayTooBig() {
     BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT).negate();
     new RoundToDoubleTester(bi), @@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2008 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.common.math;
-public class BigDecimalMathTest_gwt extends com.google.gwt.junit.client.GWTTestCase {
-@Override public String getModuleName() {
-  return ""com.google.common.math.testModule"";
-}
-}, @@ -26,7 +26,6 @@
 import static java.math.RoundingMode.UP;
 import static java.math.RoundingMode.values;
 
-import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import java.math.BigDecimal;
 import java.math.MathContext;
@@ -36,9 +35,8 @@
 import java.util.Map;
 import junit.framework.TestCase;
 
-@GwtCompatible(emulated = true)
+@GwtIncompatible
 public class BigDecimalMathTest extends TestCase {
-  @GwtIncompatible
   private static final class RoundToDoubleTester {
     private final BigDecimal input;
     private final Map<RoundingMode, Double> expectedValues = new EnumMap<>(RoundingMode.class);
@@ -88,12 +86,10 @@ public void test() {
     }
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_zero() {
     new RoundToDoubleTester(BigDecimal.ZERO).setExpectation(0.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_oneThird() {
     new RoundToDoubleTester(
             BigDecimal.ONE.divide(BigDecimal.valueOf(3), new MathContext(50, HALF_EVEN)))
@@ -103,7 +99,6 @@ public void testRoundToDouble_oneThird() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_halfMinDouble() {
     BigDecimal minDouble = new BigDecimal(Double.MIN_VALUE);
     BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
@@ -114,7 +109,6 @@ public void testRoundToDouble_halfMinDouble() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_halfNegativeMinDouble() {
     BigDecimal minDouble = new BigDecimal(-Double.MIN_VALUE);
     BigDecimal halfMinDouble = minDouble.divide(BigDecimal.valueOf(2));
@@ -125,19 +119,16 @@ public void testRoundToDouble_halfNegativeMinDouble() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_smallPositive() {
     new RoundToDoubleTester(BigDecimal.valueOf(16)).setExpectation(16.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxPreciselyRepresentable() {
     new RoundToDoubleTester(BigDecimal.valueOf(1L << 53))
         .setExpectation(Math.pow(2, 53), values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
     double twoToThe53 = Math.pow(2, 53);
     // the representable doubles are 2^53 and 2^53 + 2.
@@ -149,7 +140,6 @@ public void testRoundToDouble_maxPreciselyRepresentablePlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusOne() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -161,7 +151,6 @@ public void testRoundToDouble_twoToThe54PlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusOneHalf() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -173,7 +162,6 @@ public void testRoundToDouble_twoToThe54PlusOneHalf() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusThree() {
     double twoToThe54 = Math.pow(2, 54);
     // the representable doubles are 2^54 and 2^54 + 4
@@ -185,20 +173,17 @@ public void testRoundToDouble_twoToThe54PlusThree() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_twoToThe54PlusFour() {
     new RoundToDoubleTester(BigDecimal.valueOf((1L << 54) + 4))
         .setExpectation(Math.pow(2, 54) + 4, values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxDouble() {
     BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE);
     new RoundToDoubleTester(maxDoubleAsBD).setExpectation(Double.MAX_VALUE, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_maxDoublePlusOne() {
     BigDecimal maxDoubleAsBD = new BigDecimal(Double.MAX_VALUE).add(BigDecimal.ONE);
     new RoundToDoubleTester(maxDoubleAsBD)
@@ -208,7 +193,6 @@ public void testRoundToDouble_maxDoublePlusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_wayTooBig() {
     BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT);
     new RoundToDoubleTester(bi)
@@ -218,19 +202,16 @@ public void testRoundToDouble_wayTooBig() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_smallNegative() {
     new RoundToDoubleTester(BigDecimal.valueOf(-16)).setExpectation(-16.0, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minPreciselyRepresentable() {
     new RoundToDoubleTester(BigDecimal.valueOf(-1L << 53))
         .setExpectation(-Math.pow(2, 53), values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
     // the representable doubles are -2^53 and -2^53 - 2.
     // -2^53-1 is halfway between, so HALF_UP will go up and HALF_DOWN will go down.
@@ -241,7 +222,6 @@ public void testRoundToDouble_minPreciselyRepresentableMinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusOne() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 1))
         .setExpectation(-Math.pow(2, 54), DOWN, CEILING, HALF_DOWN, HALF_UP, HALF_EVEN)
@@ -250,7 +230,6 @@ public void testRoundToDouble_negativeTwoToThe54MinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusThree() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 3))
         .setExpectation(-Math.pow(2, 54), DOWN, CEILING)
@@ -260,20 +239,17 @@ public void testRoundToDouble_negativeTwoToThe54MinusThree() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeTwoToThe54MinusFour() {
     new RoundToDoubleTester(BigDecimal.valueOf((-1L << 54) - 4))
         .setExpectation(-Math.pow(2, 54) - 4, values())
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minDouble() {
     BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE);
     new RoundToDoubleTester(minDoubleAsBD).setExpectation(-Double.MAX_VALUE, values()).test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_minDoubleMinusOne() {
     BigDecimal minDoubleAsBD = new BigDecimal(-Double.MAX_VALUE).subtract(BigDecimal.ONE);
     new RoundToDoubleTester(minDoubleAsBD)
@@ -283,7 +259,6 @@ public void testRoundToDouble_minDoubleMinusOne() {
         .test();
   }
 
-  @GwtIncompatible
   public void testRoundToDouble_negativeWayTooBig() {
     BigDecimal bi = BigDecimal.valueOf(2).pow(2 * Double.MAX_EXPONENT).negate();
     new RoundToDoubleTester(bi), ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fully remove GWT-RPC support externally.

Really, really closes https://github.com/google/guava/issues/3680.

Possible future work:
- Be consistent about whether we put @GwtCompatible on the remaining internal CustomFieldSerializer classes. (For those files, it probably acts only as documentation (of something that is pretty obvious :)). Our open-source build used to take action when it saw `@GwtCompatible(emulated=true)`, but (a) it doesn't anymore, (b) those files don't exist externally anymore, and (c) they weren't `emulated=true` :) I believe that our internal build requires @GwtCompatible on most files in our GWT target, but I think there's an exception for GWT-target-only sources.)
- Remove some of the GwtSerializationDependencies classes. However, some of these classe are set up as *supertypes* of our prod classes, so this would require some surgery. Keeping them is harmless: It doesn't actually make the classes GWT-serializable.
- Remove the usages of serializable=true on @GwtCompatible, at least externally but maybe just entirely.

RELNOTES=[Guava types can no longer be sent over GWT-RPC.](https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ) Even the earlier, temporary way to reenable support (`guava.gwt.emergency_reenable_rpc`) no longer has an effect.

4d2eb90089e9115cb00477b815289a2fe56e8a24

-------

<p> Mark BigDecimalMathTest as fully @GwtIncompatible.

Currently it has every member annotated as @GwtIncompatible. This works fine internally, but the external GWT tests (which we run only at release time) complain about the resulting empty BigDecimalMathTest_gwt:
https://github.com/google/guava/blob/master/guava-gwt/test/com/google/common/math/BigDecimalMathTest_gwt.java

0f9ee58d8caa8a12ac77fe01e097e39386157d2c",MOE Sync 2020-10-01
5258,Kurt Alfred Kluever,"['android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java', 'android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java', 'android/guava-tests/test/com/google/common/hash/FunnelsTest.java', 'android/guava-tests/test/com/google/common/hash/HashingInputStreamTest.java', 'android/guava-tests/test/com/google/common/hash/HashingOutputStreamTest.java', 'android/guava/src/com/google/common/hash/LittleEndianByteArray.java', 'android/guava/src/com/google/common/util/concurrent/FluentFuture.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'android/guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'android/guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java', 'futures/listenablefuture1/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava-tests/test/com/google/common/cache/ForwardingCacheTest.java', 'guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java', 'guava-tests/test/com/google/common/hash/FunnelsTest.java', 'guava-tests/test/com/google/common/hash/HashingInputStreamTest.java', 'guava-tests/test/com/google/common/hash/HashingOutputStreamTest.java', 'guava/src/com/google/common/hash/LittleEndianByteArray.java', 'guava/src/com/google/common/util/concurrent/FluentFuture.java', 'guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava/src/com/google/common/util/concurrent/UncaughtExceptionHandlers.java']","@@ -34,7 +34,6 @@
   private Cache<String, Boolean> forward;
   private Cache<String, Boolean> mock;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings({""unchecked"", ""DoNotMock""}) // mock
   @Override
   public void setUp() throws Exception {, @@ -34,7 +34,6 @@
   private LoadingCache<String, Boolean> forward;
   private LoadingCache<String, Boolean> mock;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings({""unchecked"", ""DoNotMock""}) // mock
   @Override
   public void setUp() throws Exception {, @@ -93,7 +93,6 @@ public void testForLongs_null() {
   }
 
   public void testSequential() {
-    // go/do-not-mock-common-types-lsc
     @SuppressWarnings({""unchecked"", ""DoNotMock""})
     Funnel<Object> elementFunnel = mock(Funnel.class);
     PrimitiveSink primitiveSink = mock(PrimitiveSink.class);, @@ -35,7 +35,6 @@
   private static final byte[] testBytes = new byte[] {'y', 'a', 'm', 's'};
   private ByteArrayInputStream buffer;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings(""DoNotMock"")
   @Override
   protected void setUp() throws Exception {, @@ -33,7 +33,6 @@
   private HashFunction hashFunction;
   private final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings(""DoNotMock"")
   @Override
   protected void setUp() throws Exception {, @@ -232,16 +232,16 @@ public void putLongLittleEndian(byte[] sink, int offset, long value) {
     LittleEndianBytes theGetter = JavaLittleEndianBytes.INSTANCE;
     try {
       /*
-        UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes
-        on Android when running in 32-bit mode. For maximum safety, we shouldn't use
-        Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as
-        a compromise, we enable the optimization only on platforms that we specifically know to
-        work.
-
-        In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which
-        will have an efficient native implementation in JDK 9.
-
-      */
+       * UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause
+       * crashes on Android when running in 32-bit mode. For maximum safety, we shouldn't use
+       * Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so
+       * as a compromise, we enable the optimization only on platforms that we specifically know to
+       * work.
+       *
+       * In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(),
+       * which will have an efficient native implementation in JDK 9.
+       *
+       */
       final String arch = System.getProperty(""os.arch"");
       if (""amd64"".equals(arch)) {
         theGetter =, @@ -48,7 +48,7 @@
  * debugging, and cancellation. Examples of frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <h4>{@link java.util.concurrent.CompletableFuture} / {@link java.util.concurrent.CompletionStage}, @@ -60,7 +60,7 @@
  * monitoring, debugging, and cancellation. Examples of frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <p>If you do chain your operations manually, you may want to use {@link FluentFuture}., @@ -41,7 +41,7 @@
  * frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <p>The main purpose of {@link #addListener addListener} is to support this chaining. You will, @@ -65,7 +65,6 @@ public static UncaughtExceptionHandler systemExit() {
     @Override
     public void uncaughtException(Thread t, Throwable e) {
       try {
-        // cannot use FormattingLogger due to a dependency loop
         logger.log(
             SEVERE, String.format(Locale.ROOT, ""Caught an exception in %s.  Shutting down."", t), e);
       } catch (Throwable errorInLogging) {, @@ -41,7 +41,7 @@
  * frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <p>The main purpose of {@link #addListener addListener} is to support this chaining. You will, @@ -34,7 +34,6 @@
   private Cache<String, Boolean> forward;
   private Cache<String, Boolean> mock;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings({""unchecked"", ""DoNotMock""}) // mock
   @Override
   public void setUp() throws Exception {, @@ -34,7 +34,6 @@
   private LoadingCache<String, Boolean> forward;
   private LoadingCache<String, Boolean> mock;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings({""unchecked"", ""DoNotMock""}) // mock
   @Override
   public void setUp() throws Exception {, @@ -93,7 +93,6 @@ public void testForLongs_null() {
   }
 
   public void testSequential() {
-    // go/do-not-mock-common-types-lsc
     @SuppressWarnings({""unchecked"", ""DoNotMock""})
     Funnel<Object> elementFunnel = mock(Funnel.class);
     PrimitiveSink primitiveSink = mock(PrimitiveSink.class);, @@ -35,7 +35,6 @@
   private static final byte[] testBytes = new byte[] {'y', 'a', 'm', 's'};
   private ByteArrayInputStream buffer;
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings(""DoNotMock"")
   @Override
   protected void setUp() throws Exception {, @@ -33,7 +33,6 @@
   private HashFunction hashFunction;
   private final ByteArrayOutputStream buffer = new ByteArrayOutputStream();
 
-  // go/do-not-mock-common-types-lsc
   @SuppressWarnings(""DoNotMock"")
   @Override
   protected void setUp() throws Exception {, @@ -232,16 +232,16 @@ public void putLongLittleEndian(byte[] sink, int offset, long value) {
     LittleEndianBytes theGetter = JavaLittleEndianBytes.INSTANCE;
     try {
       /*
-        UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause crashes
-        on Android when running in 32-bit mode. For maximum safety, we shouldn't use
-        Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so as
-        a compromise, we enable the optimization only on platforms that we specifically know to
-        work.
-
-        In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(), which
-        will have an efficient native implementation in JDK 9.
-
-      */
+       * UnsafeByteArray uses Unsafe.getLong() in an unsupported way, which is known to cause
+       * crashes on Android when running in 32-bit mode. For maximum safety, we shouldn't use
+       * Unsafe.getLong() at all, but the performance benefit on x86_64 is too great to ignore, so
+       * as a compromise, we enable the optimization only on platforms that we specifically know to
+       * work.
+       *
+       * In the future, the use of Unsafe.getLong() should be replaced by ByteBuffer.getLong(),
+       * which will have an efficient native implementation in JDK 9.
+       *
+       */
       final String arch = System.getProperty(""os.arch"");
       if (""amd64"".equals(arch)) {
         theGetter =, @@ -50,7 +50,7 @@
  * debugging, and cancellation. Examples of frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <h4>{@link java.util.concurrent.CompletableFuture} / {@link java.util.concurrent.CompletionStage}, @@ -62,7 +62,7 @@
  * monitoring, debugging, and cancellation. Examples of frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <p>If you do chain your operations manually, you may want to use {@link FluentFuture}., @@ -41,7 +41,7 @@
  * frameworks include:
  *
  * <ul>
- *   <li><a href=""http://dagger.dev/producers.html"">Dagger Producers</a>
+ *   <li><a href=""https://dagger.dev/producers.html"">Dagger Producers</a>
  * </ul>
  *
  * <p>The main purpose of {@link #addListener addListener} is to support this chaining. You will, @@ -65,7 +65,6 @@ public static UncaughtExceptionHandler systemExit() {
     @Override
     public void uncaughtException(Thread t, Throwable e) {
       try {
-        // cannot use FormattingLogger due to a dependency loop
         logger.log(
             SEVERE, String.format(Locale.ROOT, ""Caught an exception in %s.  Shutting down."", t), e);
       } catch (Throwable errorInLogging) {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Begin tweaking Guava sources to satisfy Copybara.

- Change from http to https (and from github.io links to guava.dev/truth.dev while I'm at it).
- Remove go/ links.
- Add whitespace around MOE directives.
- Put MOE stripping directives alone in comments, moving other comment text to a separate comment.
- One particular case of that: Put MOE intracomment stripping into HTML comments... even when it happens in non-Javadoc comments (i.e., /* */). It seems that Copybara wants for intracomment directives to stand alone in *some* kind of comment?
- Add @GoogleInternal to some files that are currently omitted from Guava simply by not being in MOE filegroup targets.

This is surely not a complete set of changes, but it's enough to get me started.

b5dce621aed0d374d3abc000eb51cb513e7b496e",MOE Sync 2020-10-02
5263,David P. Baker,"['guava-gwt/src/com/google/common/base/GwtSerializationDependencies.java', 'guava-gwt/src/com/google/common/collect/GwtSerializationDependencies.java']","@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2009 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS-IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.base;
-
-import com.google.common.annotations.GwtCompatible;
-import java.util.Set;
-import org.checkerframework.checker.nullness.qual.Nullable;
-
-/**
- * Contains dummy collection implementations to convince GWT that part of serializing a collection
- * is serializing its elements.
- *
- * <p>See {@linkplain com.google.common.collect.GwtSerializationDependencies the
- * com.google.common.collect version} for more details.
- *
- * @author Chris Povirk
- */
-@GwtCompatible
-final class GwtSerializationDependencies {
-  private GwtSerializationDependencies() {}
-
-  static final class OptionalDependencies<T> extends Optional<T> {
-    @Nullable T value;
-
-    OptionalDependencies() {
-      super();
-    }
-
-    @Override
-    public boolean isPresent() {
-      throw new AssertionError();
-    }
-
-    @Override
-    public T get() {
-      throw new AssertionError();
-    }
-
-    @Override
-    public T or(T defaultValue) {
-      throw new AssertionError();
-    }
-
-    @Override
-    public Optional<T> or(Optional<? extends T> secondChoice) {
-      throw new AssertionError();
-    }
-
-    @Override
-    public T or(Supplier<? extends T> supplier) {
-      throw new AssertionError();
-    }
-
-    @Override
-    public T orNull() {
-      throw new AssertionError();
-    }
-
-    @Override
-    public Set<T> asSet() {
-      throw new AssertionError();
-    }
-
-    @Override
-    public <V> Optional<V> transform(Function<? super T, V> function) {
-      throw new AssertionError();
-    }
-
-    @Override
-    public boolean equals(@Nullable Object object) {
-      throw new AssertionError();
-    }
-
-    @Override
-    public int hashCode() {
-      throw new AssertionError();
-    }
-
-    @Override
-    public String toString() {
-      throw new AssertionError();
-    }
-  }
-}, @@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2009 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS-IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.collect;
-
-import com.google.common.annotations.GwtCompatible;
-import java.io.Serializable;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.TreeMap;
-
-/**
- * Contains dummy collection implementations to convince GWT that part of serializing a collection
- * is serializing its elements.
- *
- * <p>Because of our use of final fields in our collections, GWT's normal heuristic for determining
- * which classes might be serialized fails. That heuristic is, roughly speaking, to look at each
- * parameter and return type of each RPC interface and to assume that implementations of those types
- * might be serialized. Those types have their own dependencies -- their fields -- which are
- * analyzed recursively and analogously.
- *
- * <p>For classes with final fields, GWT assumes that the class itself might be serialized but
- * doesn't assume the same about its final fields. To work around this, we provide dummy
- * implementations of our collections with their dependencies as non-final fields. Even though these
- * implementations are never instantiated, they are visible to GWT when it performs its
- * serialization analysis, and it assumes that their fields may be serialized.
- *
- * <p>Currently we provide dummy implementations of all the immutable collection classes necessary
- * to support declarations like {@code ImmutableMultiset<String>} in RPC interfaces. Support for
- * {@code ImmutableMultiset} in the interface is support for {@code Multiset}, so there is nothing
- * further to be done to support the new collection interfaces. It is not support, however, for an
- * RPC interface in terms of {@code HashMultiset}. It is still possible to send a {@code
- * HashMultiset} over GWT RPC; it is only the declaration of an interface in terms of {@code
- * HashMultiset} that we haven't tried to support. (We may wish to revisit this decision in the
- * future.)
- *
- * @author Chris Povirk
- */
-@GwtCompatible
-// None of these classes are instantiated, let alone serialized:
-@SuppressWarnings(""serial"")
-final class GwtSerializationDependencies {
-  private GwtSerializationDependencies() {}
-
-  static final class ImmutableListMultimapDependencies<K, V> extends ImmutableListMultimap<K, V> {
-    K key;
-    V value;
-
-    ImmutableListMultimapDependencies() {
-      super(null, 0);
-    }
-  }
-
-  // ImmutableMap is covered by ImmutableSortedMap/ImmutableBiMap.
-
-  // ImmutableMultimap is covered by ImmutableSetMultimap/ImmutableListMultimap.
-
-  static final class ImmutableSetMultimapDependencies<K, V> extends ImmutableSetMultimap<K, V> {
-    K key;
-    V value;
-
-    ImmutableSetMultimapDependencies() {
-      super(null, 0, null);
-    }
-  }
-
-  /*
-   * We support an interface declared in terms of LinkedListMultimap because it
-   * supports entry ordering not supported by other implementations.
-   */
-  static final class LinkedListMultimapDependencies<K, V> extends LinkedListMultimap<K, V> {
-    K key;
-    V value;
-
-    LinkedListMultimapDependencies() {}
-  }
-
-  static final class HashBasedTableDependencies<R, C, V> extends HashBasedTable<R, C, V> {
-    HashMap<R, HashMap<C, V>> data;
-
-    HashBasedTableDependencies() {
-      super(null, null);
-    }
-  }
-
-  static final class TreeBasedTableDependencies<R, C, V> extends TreeBasedTable<R, C, V> {
-    TreeMap<R, TreeMap<C, V>> data;
-
-    TreeBasedTableDependencies() {
-      super(null, null);
-    }
-  }
-
-  /*
-   * We don't normally need ""implements Serializable,"" but we do here. That's
-   * because ImmutableTable itself is not Serializable as of this writing. We
-   * need for GWT to believe that this dummy class is serializable, or else it
-   * won't generate serialization code for R, C, and V.
-   */
-  static final class ImmutableTableDependencies<R, C, V> extends SingletonImmutableTable<R, C, V>
-      implements Serializable {
-    R rowKey;
-    C columnKey;
-    V value;
-
-    ImmutableTableDependencies() {
-      super(null, null, null);
-    }
-  }
-
-  static final class TreeMultimapDependencies<K, V> extends TreeMultimap<K, V> {
-    Comparator<? super K> keyComparator;
-    Comparator<? super V> valueComparator;
-    K key;
-    V value;
-
-    TreeMultimapDependencies() {
-      super(null, null);
-    }
-  }
-}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove GWT tests from open source.

We will continue to run these tests internally.

I'm not sure how much value the remaining open-source GwtTestSuite file provides us. Hopefully it's at least a sanity check on .gwt.xml files. But I haven't tested by breaking a .gwt.xml file to see what happens.

5773612ad40c7ab38e2cc8e5dd5a526d5b672652

-------

<p> Tweak TODOs.

58855f44498d1dd61cfad4f812a14bac2079e71c

-------

<p> Remove a couple GwtSerializationDependencies classes from open-source Guava after all.

As noted in 0cb89dd110ce88770207889901e95ea2ac896932, this isn't necessary. As *also* noted there, we have *additional* FooGwtSerializationDependencies classes that I'm leaving in place because they are *supertypes* of the prod classes and thus harder to remove.

But I'm removing these 2 because it saves me a few lines in the Copybara config :)

(Followup after https://github.com/google/guava/issues/3680)

cb6023b3285ba8c2b6c249c7ef977df2baac2b65",MOE Sync 2020-10-05
5264,David P. Baker,['guava-gwt/pom.xml'],"@@ -89,7 +89,7 @@
       <groupId>com.google.gwt</groupId>
       <artifactId>gwt-user</artifactId>
       <version>${gwt.version}</version>
-      <scope>provided</scope>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>com.google.truth</groupId>
@@ -151,7 +151,9 @@
             <!-- 4. Don't build Javadoc for it (since that, too, would require a *non-test* dep on gwt-user. -->
             <sourceFileExclude>**/ForceGuavaCompilation*</sourceFileExclude>
           </sourceFileExcludes>
-          <!-- After removing GWT-RPC support, we will have no real classes to build Javadoc for. This would result in an empty Javadoc jar, which the Sonatype repository manager would reject. To avoid that, we've introduced a dummy class. But we made it package-private so that no one can depend on it. That in turn forced us to configure Javadoc to show package-private APIs. -->
+          <!-- The above exclusion doesn't actually matter unless I prevent Javadoc from autodiscovering the source in the sourcepath, which defaults to the source directory :\ Boo for -sourcepath. -->
+          <sourcepath>doesnotexist</sourcepath>
+          <!-- Note that we do need to build Javadoc for *some* class. Otherwise, we get an empty Javadoc jar, which the Sonatype repository manager rejects. To avoid that, we've introduced a dummy class. But we made it package-private so that no one can depend on it. That in turn forced us to configure Javadoc to show package-private APIs. -->
           <show>package</show>
         </configuration>
       </plugin>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Move gwt-user dep to test scope.

We no longer need it as a prod dependency (not even `provided`) after removing GWT-RPC support.

(Followup after https://github.com/google/guava/issues/3680)

Fixes https://github.com/google/truth/issues/637, if GitHub will let me get away with closing a Truth issue with a Guava commit :)

6a6285d1e12b8d2c62b8b752d6ee1a44f48d0dac",MOE Sync 2020-10-06
5267,David P. Baker,"['guava-testlib/test/com/google/common/collect/testing/TestModuleEntryPoint.java', 'guava-testlib/test/com/google/common/testing/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/base/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/cache/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/collect/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/escape/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/html/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/io/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/math/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/net/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/primitives/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/util/concurrent/TestModuleEntryPoint.java', 'guava-tests/test/com/google/common/xml/TestModuleEntryPoint.java']","@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.collect.testing;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.testing;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.base;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.cache;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.collect;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.escape;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.html;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.io;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.math;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.net;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.primitives;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.util.concurrent;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, @@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the ""License"");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an ""AS IS"" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.common.xml;
-
-import com.google.gwt.core.client.EntryPoint;
-
-/**
- * A dummy entry point of the test module.
- *
- * @author Hayward Chan
- */
-public class TestModuleEntryPoint implements EntryPoint {
-
-  @Override public void onModuleLoad() {
-  }
-}, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Run all zero of our GWT tests during presubmit/CI.

Unfortunately, this does *not* detect any bogus <inherits> lines in *test* .gwt.xml files (neither the individual testModule.gwt.xml files nor the top-level GuavaTests.gwt.xml).
(And bogus <inherits> lines in *prod* .gwt.xml files were already detected even before this change.)

As a result, this CL appears to be very nearly a no-op -- maybe just a verification that the no-op GWT module and entry point exist. And maybe I'll end up rolling it back if we reenable the tests externally someday. Still, for now it seems like a reasonable thing to clean up, if only to prevent me from trying to clean it up again 6 months from now :)

(Followup after https://github.com/google/guava/issues/3680)

9230b14efefc11d24c3c969f2dbae7f8595ef469

-------

<p> Check the generated PublicSuffixPatterns.java into Piper.

Copybara can't export generated files.

Also, reformat the template (and then the file) so that autoformatting the file doesn't produce diffs.

eebb75ecc2beb4ff5c95cca974d3529505e31a60

-------

<p> Omit TestModuleEntryPoint from open-source repo.

Since I've disabled GWT tests in the open-source repo, these no longer serve a purpose. (They're still listed in our testModule.gwt.xml files, but as noted in a previous commit, the GWT test infrastructure doesn't seem to care what we put in those files anymore.)

We could still include them, but they're generated during our build, so that complicates exporting them with Copybara.

5948a59b546c02d61ac9c2f590483fb4a7271ddd",MOE Sync 2020-10-08
5268,David P. Baker,"['android/guava/src/com/google/common/collect/Collections2.java', 'android/guava/src/com/google/common/collect/FluentIterable.java', 'android/guava/src/com/google/common/collect/Iterables.java', 'android/guava/src/com/google/common/collect/Lists.java', 'android/guava/src/com/google/common/collect/Queues.java', 'android/guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/Collections2.java', 'guava/src/com/google/common/collect/FluentIterable.java', 'guava/src/com/google/common/collect/Iterables.java', 'guava/src/com/google/common/collect/Lists.java', 'guava/src/com/google/common/collect/Queues.java', 'guava/src/com/google/common/collect/Sets.java']","@@ -329,11 +329,6 @@ static StringBuilder newStringBuilderForCollection(int size) {
     return new StringBuilder((int) Math.min(size * 8L, Ints.MAX_POWER_OF_TWO));
   }
 
-  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
-  static <T> Collection<T> cast(Iterable<T> iterable) {
-    return (Collection<T>) iterable;
-  }
-
   /**
    * Returns a {@link Collection} of all the permutations of the specified {@link Iterable}.
    *, @@ -794,7 +794,7 @@ public final boolean isEmpty() {
     checkNotNull(collection);
     Iterable<E> iterable = getDelegate();
     if (iterable instanceof Collection) {
-      collection.addAll(Collections2.cast(iterable));
+      collection.addAll((Collection<E>) iterable);
     } else {
       for (E item : iterable) {
         collection.add(item);, @@ -352,7 +352,7 @@ public static String toString(Iterable<?> iterable) {
   @CanIgnoreReturnValue
   public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd) {
     if (elementsToAdd instanceof Collection) {
-      Collection<? extends T> c = Collections2.cast(elementsToAdd);
+      Collection<? extends T> c = (Collection<? extends T>) elementsToAdd;
       return addTo.addAll(c);
     }
     return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());
@@ -826,7 +826,7 @@ public String toString() {
   @NullableDecl
   public static <T> T getLast(Iterable<? extends T> iterable, @NullableDecl T defaultValue) {
     if (iterable instanceof Collection) {
-      Collection<? extends T> c = Collections2.cast(iterable);
+      Collection<? extends T> c = (Collection<? extends T>) iterable;
       if (c.isEmpty()) {
         return defaultValue;
       } else if (iterable instanceof List) {, @@ -125,7 +125,7 @@ private Lists() {}
     checkNotNull(elements); // for GWT
     // Let ArrayList's sizing logic work, if possible
     return (elements instanceof Collection)
-        ? new ArrayList<>(Collections2.cast(elements))
+        ? new ArrayList<>((Collection<? extends E>) elements)
         : newArrayList(elements.iterator());
   }
 
@@ -264,7 +264,9 @@ static int computeArrayListCapacity(int arraySize) {
     // We copy elements to an ArrayList first, rather than incurring the
     // quadratic cost of adding them to the COWAL directly.
     Collection<? extends E> elementsCollection =
-        (elements instanceof Collection) ? Collections2.cast(elements) : newArrayList(elements);
+        (elements instanceof Collection)
+            ? (Collection<? extends E>) elements
+            : newArrayList(elements);
     return new CopyOnWriteArrayList<>(elementsCollection);
   }
 , @@ -74,7 +74,7 @@ private Queues() {}
    */
   public static <E> ArrayDeque<E> newArrayDeque(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new ArrayDeque<E>(Collections2.cast(elements));
+      return new ArrayDeque<E>((Collection<? extends E>) elements);
     }
     ArrayDeque<E> deque = new ArrayDeque<E>();
     Iterables.addAll(deque, elements);
@@ -97,7 +97,7 @@ private Queues() {}
   public static <E> ConcurrentLinkedQueue<E> newConcurrentLinkedQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new ConcurrentLinkedQueue<E>(Collections2.cast(elements));
+      return new ConcurrentLinkedQueue<E>((Collection<? extends E>) elements);
     }
     ConcurrentLinkedQueue<E> queue = new ConcurrentLinkedQueue<E>();
     Iterables.addAll(queue, elements);
@@ -137,7 +137,7 @@ private Queues() {}
   @GwtIncompatible // LinkedBlockingDeque
   public static <E> LinkedBlockingDeque<E> newLinkedBlockingDeque(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedBlockingDeque<E>(Collections2.cast(elements));
+      return new LinkedBlockingDeque<E>((Collection<? extends E>) elements);
     }
     LinkedBlockingDeque<E> deque = new LinkedBlockingDeque<E>();
     Iterables.addAll(deque, elements);
@@ -173,7 +173,7 @@ private Queues() {}
   @GwtIncompatible // LinkedBlockingQueue
   public static <E> LinkedBlockingQueue<E> newLinkedBlockingQueue(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedBlockingQueue<E>(Collections2.cast(elements));
+      return new LinkedBlockingQueue<E>((Collection<? extends E>) elements);
     }
     LinkedBlockingQueue<E> queue = new LinkedBlockingQueue<E>();
     Iterables.addAll(queue, elements);
@@ -207,7 +207,7 @@ private Queues() {}
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new PriorityBlockingQueue<E>(Collections2.cast(elements));
+      return new PriorityBlockingQueue<E>((Collection<? extends E>) elements);
     }
     PriorityBlockingQueue<E> queue = new PriorityBlockingQueue<E>();
     Iterables.addAll(queue, elements);
@@ -237,7 +237,7 @@ private Queues() {}
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new PriorityQueue<E>(Collections2.cast(elements));
+      return new PriorityQueue<E>((Collection<? extends E>) elements);
     }
     PriorityQueue<E> queue = new PriorityQueue<E>();
     Iterables.addAll(queue, elements);, @@ -203,7 +203,7 @@ public boolean retainAll(Collection<?> c) {
    */
   public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
     return (elements instanceof Collection)
-        ? new HashSet<E>(Collections2.cast(elements))
+        ? new HashSet<E>((Collection<? extends E>) elements)
         : newHashSet(elements.iterator());
   }
 
@@ -308,7 +308,7 @@ public boolean retainAll(Collection<?> c) {
    */
   public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedHashSet<E>(Collections2.cast(elements));
+      return new LinkedHashSet<E>((Collection<? extends E>) elements);
     }
     LinkedHashSet<E> set = newLinkedHashSet();
     Iterables.addAll(set, elements);
@@ -436,7 +436,7 @@ public boolean retainAll(Collection<?> c) {
     // quadratic cost of adding them to the COWAS directly.
     Collection<? extends E> elementsCollection =
         (elements instanceof Collection)
-            ? Collections2.cast(elements)
+            ? (Collection<? extends E>) elements
             : Lists.newArrayList(elements);
     return new CopyOnWriteArraySet<E>(elementsCollection);
   }, @@ -352,11 +352,6 @@ static StringBuilder newStringBuilderForCollection(int size) {
     return new StringBuilder((int) Math.min(size * 8L, Ints.MAX_POWER_OF_TWO));
   }
 
-  /** Used to avoid http://bugs.sun.com/view_bug.do?bug_id=6558557 */
-  static <T> Collection<T> cast(Iterable<T> iterable) {
-    return (Collection<T>) iterable;
-  }
-
   /**
    * Returns a {@link Collection} of all the permutations of the specified {@link Iterable}.
    *, @@ -786,7 +786,7 @@ public final boolean isEmpty() {
     checkNotNull(collection);
     Iterable<E> iterable = getDelegate();
     if (iterable instanceof Collection) {
-      collection.addAll(Collections2.cast(iterable));
+      collection.addAll((Collection<E>) iterable);
     } else {
       for (E item : iterable) {
         collection.add(item);, @@ -314,7 +314,7 @@ public static String toString(Iterable<?> iterable) {
   @CanIgnoreReturnValue
   public static <T> boolean addAll(Collection<T> addTo, Iterable<? extends T> elementsToAdd) {
     if (elementsToAdd instanceof Collection) {
-      Collection<? extends T> c = Collections2.cast(elementsToAdd);
+      Collection<? extends T> c = (Collection<? extends T>) elementsToAdd;
       return addTo.addAll(c);
     }
     return Iterators.addAll(addTo, checkNotNull(elementsToAdd).iterator());
@@ -814,7 +814,7 @@ public void forEach(Consumer<? super T> action) {
    */
   public static <T> @Nullable T getLast(Iterable<? extends T> iterable, @Nullable T defaultValue) {
     if (iterable instanceof Collection) {
-      Collection<? extends T> c = Collections2.cast(iterable);
+      Collection<? extends T> c = (Collection<? extends T>) iterable;
       if (c.isEmpty()) {
         return defaultValue;
       } else if (iterable instanceof List) {, @@ -126,7 +126,7 @@ private Lists() {}
     checkNotNull(elements); // for GWT
     // Let ArrayList's sizing logic work, if possible
     return (elements instanceof Collection)
-        ? new ArrayList<>(Collections2.cast(elements))
+        ? new ArrayList<>((Collection<? extends E>) elements)
         : newArrayList(elements.iterator());
   }
 
@@ -265,7 +265,9 @@ static int computeArrayListCapacity(int arraySize) {
     // We copy elements to an ArrayList first, rather than incurring the
     // quadratic cost of adding them to the COWAL directly.
     Collection<? extends E> elementsCollection =
-        (elements instanceof Collection) ? Collections2.cast(elements) : newArrayList(elements);
+        (elements instanceof Collection)
+            ? (Collection<? extends E>) elements
+            : newArrayList(elements);
     return new CopyOnWriteArrayList<>(elementsCollection);
   }
 , @@ -74,7 +74,7 @@ private Queues() {}
    */
   public static <E> ArrayDeque<E> newArrayDeque(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new ArrayDeque<E>(Collections2.cast(elements));
+      return new ArrayDeque<E>((Collection<? extends E>) elements);
     }
     ArrayDeque<E> deque = new ArrayDeque<E>();
     Iterables.addAll(deque, elements);
@@ -97,7 +97,7 @@ private Queues() {}
   public static <E> ConcurrentLinkedQueue<E> newConcurrentLinkedQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new ConcurrentLinkedQueue<E>(Collections2.cast(elements));
+      return new ConcurrentLinkedQueue<E>((Collection<? extends E>) elements);
     }
     ConcurrentLinkedQueue<E> queue = new ConcurrentLinkedQueue<E>();
     Iterables.addAll(queue, elements);
@@ -137,7 +137,7 @@ private Queues() {}
   @GwtIncompatible // LinkedBlockingDeque
   public static <E> LinkedBlockingDeque<E> newLinkedBlockingDeque(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedBlockingDeque<E>(Collections2.cast(elements));
+      return new LinkedBlockingDeque<E>((Collection<? extends E>) elements);
     }
     LinkedBlockingDeque<E> deque = new LinkedBlockingDeque<E>();
     Iterables.addAll(deque, elements);
@@ -173,7 +173,7 @@ private Queues() {}
   @GwtIncompatible // LinkedBlockingQueue
   public static <E> LinkedBlockingQueue<E> newLinkedBlockingQueue(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedBlockingQueue<E>(Collections2.cast(elements));
+      return new LinkedBlockingQueue<E>((Collection<? extends E>) elements);
     }
     LinkedBlockingQueue<E> queue = new LinkedBlockingQueue<E>();
     Iterables.addAll(queue, elements);
@@ -207,7 +207,7 @@ private Queues() {}
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new PriorityBlockingQueue<E>(Collections2.cast(elements));
+      return new PriorityBlockingQueue<E>((Collection<? extends E>) elements);
     }
     PriorityBlockingQueue<E> queue = new PriorityBlockingQueue<E>();
     Iterables.addAll(queue, elements);
@@ -237,7 +237,7 @@ private Queues() {}
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue(
       Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new PriorityQueue<E>(Collections2.cast(elements));
+      return new PriorityQueue<E>((Collection<? extends E>) elements);
     }
     PriorityQueue<E> queue = new PriorityQueue<E>();
     Iterables.addAll(queue, elements);, @@ -253,7 +253,7 @@ void add(E e) {
    */
   public static <E> HashSet<E> newHashSet(Iterable<? extends E> elements) {
     return (elements instanceof Collection)
-        ? new HashSet<E>(Collections2.cast(elements))
+        ? new HashSet<E>((Collection<? extends E>) elements)
         : newHashSet(elements.iterator());
   }
 
@@ -358,7 +358,7 @@ void add(E e) {
    */
   public static <E> LinkedHashSet<E> newLinkedHashSet(Iterable<? extends E> elements) {
     if (elements instanceof Collection) {
-      return new LinkedHashSet<E>(Collections2.cast(elements));
+      return new LinkedHashSet<E>((Collection<? extends E>) elements);
     }
     LinkedHashSet<E> set = newLinkedHashSet();
     Iterables.addAll(set, elements);
@@ -486,7 +486,7 @@ void add(E e) {
     // quadratic cost of adding them to the COWAS directly.
     Collection<? extends E> elementsCollection =
         (elements instanceof Collection)
-            ? Collections2.cast(elements)
+            ? (Collection<? extends E>) elements
             : Lists.newArrayList(elements);
     return new CopyOnWriteArraySet<E>(elementsCollection);
   }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Clarify `HashMultimap` docs about concurrency.

Closes #5266.
Fixes #3682.

e6b523481b34b2c2007046ea987bf62df92eb0f8

-------

<p> Removed all references to now useless workaround

Fixes #3679
Fixes #5265

26da0949c1cf54eb730578e75fe087f67110ee71",MOE Sync 2020-10-09
5275,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/ExecutionSequencer.java', 'guava/src/com/google/common/util/concurrent/ExecutionSequencer.java']","@@ -30,13 +30,50 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
- * Serializes execution of a set of operations. This class guarantees that a submitted callable will
- * not be called before previously submitted callables (and any {@code Future}s returned from them)
- * have completed.
+ * Serializes execution of tasks, somewhat like an ""asynchronous {@code synchronized} block."" Each
+ * {@linkplain #submit enqueued} callable will not be submitted to its associated executor until the
+ * previous callable has returned -- and, if the previous callable was an {@link AsyncCallable}, not
+ * until the {@code Future} it returned is {@linkplain Future#isDone done} (successful, failed, or
+ * cancelled).
  *
- * <p>This class implements a superset of the behavior of {@link
- * MoreExecutors#newSequentialExecutor}. If your tasks all run on the same underlying executor and
- * don't need to wait for {@code Future}s returned from {@code AsyncCallable}s, use it instead.
+ * <p>This class has limited support for cancellation and other ""early completion"":
+ *
+ * <ul>
+ *   <li>While calls to {@code submit} and {@code submitAsync} return a {@code Future} that can be
+ *       cancelled, cancellation never propagates to a task that has started to run -- neither to
+ *       the callable itself nor to any {@code Future} returned by an {@code AsyncCallable}.
+ *       (However, cancellation can prevent an <i>unstarted</i> task from running.) Therefore, the
+ *       next task will wait for any running callable (or pending {@code Future} returned by an
+ *       {@code AsyncCallable}) to complete, without interrupting it (and without calling {@code
+ *       cancel} on the {@code Future}). So beware: <i>Even if you cancel every precededing {@code
+ *       Future} returned by this class, the next task may still have to wait.</i>.
+ *   <li>Once an {@code AsyncCallable} returns a {@code Future}, this class considers that task to
+ *       be ""done"" as soon as <i>that</i> {@code Future} completes in any way. Notably, a {@code
+ *       Future} is ""completed"" even if it is cancelled while its underlying work continues on a
+ *       thread, an RPC, etc. The {@code Future} is also ""completed"" if it fails ""early"" -- for
+ *       example, if the deadline expires on a {@code Future} returned from {@link
+ *       Futures#withTimeout} while the {@code Future} it wraps continues its underlying work. So
+ *       beware: <i>Your {@code AsyncCallable} should not complete its {@code Future} until it is
+ *       safe for the next task to start.</i>
+ * </ul>
+ *
+ * <p>An additional limitation: this class serializes execution of <i>tasks</i> but not any
+ * <i>listeners</i> of those tasks.
+ *
+ * <p>This class is similar to {@link MoreExecutors#newSequentialExecutor}. This class is different
+ * in a few ways:
+ *
+ * <ul>
+ *   <li>Each task may be associated with a different executor.
+ *   <li>Tasks may be of type {@code AsyncCallable}.
+ *   <li>Running tasks <i>cannot</i> be interrupted. (Note that {@code newSequentialExecutor} does
+ *       not return {@code Future} objects, so it doesn't support interruption directly, either.
+ *       However, utilities that <i>use</i> that executor have the ability to interrupt tasks
+ *       running on it. This class, by contrast, does not expose an {@code Executor} API.)
+ * </ul>
+ *
+ * <p>If you don't need the features of this class, you may prefer {@code newSequentialExecutor} for
+ * its simplicity and ability to accommodate interruption.
  *
  * @since 26.0
  */
@@ -183,6 +220,28 @@ public void run() {
               // so when oldFuture completes it is safe to allow the next submitted task to
               // proceed. Doing this immediately here lets the next task run without waiting for
               // the cancelled task's executor to run the noop AsyncCallable.
+              //
+              // ---
+              //
+              // If the CAS fails, the provided callable already started running (or it is about
+              // to). Our contract promises:
+              //
+              // 1. not to execute a new callable until the old one has returned
+              //
+              // If we were to cancel taskFuture, that would let the next task start while the old
+              // one is still running.
+              //
+              // Now, maybe we could tweak our implementation to not start the next task until the
+              // callable actually completes. (We could detect completion in our wrapper
+              // `AsyncCallable task`.) However, our contract also promises:
+              //
+              // 2. not to cancel any Future the user returned from an AsyncCallable
+              //
+              // We promise this because, once we cancel that Future, we would no longer be able to
+              // tell when any underlying work it is doing is done. Thus, we might start a new task
+              // while that underlying work is still running.
+              //
+              // So that is why we cancel only in the case of CAS success.
               taskFuture.cancel(false);
             }
           }, @@ -30,13 +30,50 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
- * Serializes execution of a set of operations. This class guarantees that a submitted callable will
- * not be called before previously submitted callables (and any {@code Future}s returned from them)
- * have completed.
+ * Serializes execution of tasks, somewhat like an ""asynchronous {@code synchronized} block."" Each
+ * {@linkplain #submit enqueued} callable will not be submitted to its associated executor until the
+ * previous callable has returned -- and, if the previous callable was an {@link AsyncCallable}, not
+ * until the {@code Future} it returned is {@linkplain Future#isDone done} (successful, failed, or
+ * cancelled).
  *
- * <p>This class implements a superset of the behavior of {@link
- * MoreExecutors#newSequentialExecutor}. If your tasks all run on the same underlying executor and
- * don't need to wait for {@code Future}s returned from {@code AsyncCallable}s, use it instead.
+ * <p>This class has limited support for cancellation and other ""early completion"":
+ *
+ * <ul>
+ *   <li>While calls to {@code submit} and {@code submitAsync} return a {@code Future} that can be
+ *       cancelled, cancellation never propagates to a task that has started to run -- neither to
+ *       the callable itself nor to any {@code Future} returned by an {@code AsyncCallable}.
+ *       (However, cancellation can prevent an <i>unstarted</i> task from running.) Therefore, the
+ *       next task will wait for any running callable (or pending {@code Future} returned by an
+ *       {@code AsyncCallable}) to complete, without interrupting it (and without calling {@code
+ *       cancel} on the {@code Future}). So beware: <i>Even if you cancel every precededing {@code
+ *       Future} returned by this class, the next task may still have to wait.</i>.
+ *   <li>Once an {@code AsyncCallable} returns a {@code Future}, this class considers that task to
+ *       be ""done"" as soon as <i>that</i> {@code Future} completes in any way. Notably, a {@code
+ *       Future} is ""completed"" even if it is cancelled while its underlying work continues on a
+ *       thread, an RPC, etc. The {@code Future} is also ""completed"" if it fails ""early"" -- for
+ *       example, if the deadline expires on a {@code Future} returned from {@link
+ *       Futures#withTimeout} while the {@code Future} it wraps continues its underlying work. So
+ *       beware: <i>Your {@code AsyncCallable} should not complete its {@code Future} until it is
+ *       safe for the next task to start.</i>
+ * </ul>
+ *
+ * <p>An additional limitation: this class serializes execution of <i>tasks</i> but not any
+ * <i>listeners</i> of those tasks.
+ *
+ * <p>This class is similar to {@link MoreExecutors#newSequentialExecutor}. This class is different
+ * in a few ways:
+ *
+ * <ul>
+ *   <li>Each task may be associated with a different executor.
+ *   <li>Tasks may be of type {@code AsyncCallable}.
+ *   <li>Running tasks <i>cannot</i> be interrupted. (Note that {@code newSequentialExecutor} does
+ *       not return {@code Future} objects, so it doesn't support interruption directly, either.
+ *       However, utilities that <i>use</i> that executor have the ability to interrupt tasks
+ *       running on it. This class, by contrast, does not expose an {@code Executor} API.)
+ * </ul>
+ *
+ * <p>If you don't need the features of this class, you may prefer {@code newSequentialExecutor} for
+ * its simplicity and ability to accommodate interruption.
  *
  * @since 26.0
  */
@@ -183,6 +220,28 @@ public void run() {
               // so when oldFuture completes it is safe to allow the next submitted task to
               // proceed. Doing this immediately here lets the next task run without waiting for
               // the cancelled task's executor to run the noop AsyncCallable.
+              //
+              // ---
+              //
+              // If the CAS fails, the provided callable already started running (or it is about
+              // to). Our contract promises:
+              //
+              // 1. not to execute a new callable until the old one has returned
+              //
+              // If we were to cancel taskFuture, that would let the next task start while the old
+              // one is still running.
+              //
+              // Now, maybe we could tweak our implementation to not start the next task until the
+              // callable actually completes. (We could detect completion in our wrapper
+              // `AsyncCallable task`.) However, our contract also promises:
+              //
+              // 2. not to cancel any Future the user returned from an AsyncCallable
+              //
+              // We promise this because, once we cancel that Future, we would no longer be able to
+              // tell when any underlying work it is doing is done. Thus, we might start a new task
+              // while that underlying work is still running.
+              //
+              // So that is why we cancel only in the case of CAS success.
               taskFuture.cancel(false);
             }
           }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Clarify how to use `IteratorTester`

When using `IteratorTester`, IntelliJ IDEA automatically imports
`AbstractIteratorTester.KnownOrder`. However `AbstractIteratorTester`
is private, and it is not obvious that one was meant to import
`IteratorTester.KnownOrder` instead. Therefore this commit updates the
Javadoc to give an example of how to use the API properly.

Fixes #5272

c3172e1a55041b118a984bc5863082fda32d8243

-------

<p> Add a bunch of warnings to ExecutionSequencer.

See discussion on CL 335046640.

0b7dfb6ebeff542ac6d013f0a5690ccfce7a1eac",MOE Sync 2020-10-13
5277,Chris Povirk,"['android/guava-testlib/src/com/google/common/collect/testing/IteratorTester.java', 'guava-testlib/src/com/google/common/collect/testing/IteratorTester.java']","@@ -50,19 +50,21 @@
  * verify() method, which is called <em>after</em> each sequence and is guaranteed to be called
  * using the latest values obtained from {@link IteratorTester#newTargetIterator()}.
  *
- * <p>For example, to test {@link java.util.ArrayList#iterator() ArrayList.iterator()}:
+ * <p>For example, to test {@link java.util.Collections#unmodifiableList(java.util.List)
+ * Collections.unmodifiableList}'s iterator:
  *
  * <pre>{@code
  * List<String> expectedElements =
  *     Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e"");
  * List<String> actualElements =
- *     new ArrayList<>(Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
+ *     Collections.unmodifiableList(
+ *         Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
  * IteratorTester<String> iteratorTester =
  *     new IteratorTester<String>(
  *         5,
- *         IteratorFeature.MODIFIABLE,
+ *         IteratorFeature.UNMODIFIABLE,
  *         expectedElements,
- *         KnownOrder.KNOWN_ORDER) {
+ *         IteratorTester.KnownOrder.KNOWN_ORDER) {
  *       @Override
  *       protected Iterator<String> newTargetIterator() {
  *         return actualElements.iterator();
@@ -72,6 +74,9 @@
  * iteratorTester.testForEachRemaining();
  * }</pre>
  *
+ * <p><b>Note</b>: It is necessary to use {@code IteratorTester.KnownOrder} as shown above, rather
+ * than {@code KnownOrder} directly, because otherwise the code is not compilable.
+ *
  * @author Kevin Bourrillion
  * @author Chris Povirk
  */, @@ -50,19 +50,21 @@
  * verify() method, which is called <em>after</em> each sequence and is guaranteed to be called
  * using the latest values obtained from {@link IteratorTester#newTargetIterator()}.
  *
- * <p>For example, to test {@link java.util.ArrayList#iterator() ArrayList.iterator()}:
+ * <p>For example, to test {@link java.util.Collections#unmodifiableList(java.util.List)
+ * Collections.unmodifiableList}'s iterator:
  *
  * <pre>{@code
  * List<String> expectedElements =
  *     Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e"");
  * List<String> actualElements =
- *     new ArrayList<>(Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
+ *     Collections.unmodifiableList(
+ *         Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
  * IteratorTester<String> iteratorTester =
  *     new IteratorTester<String>(
  *         5,
- *         IteratorFeature.MODIFIABLE,
+ *         IteratorFeature.UNMODIFIABLE,
  *         expectedElements,
- *         KnownOrder.KNOWN_ORDER) {
+ *         IteratorTester.KnownOrder.KNOWN_ORDER) {
  *       @Override
  *       protected Iterator<String> newTargetIterator() {
  *         return actualElements.iterator();
@@ -72,6 +74,9 @@
  * iteratorTester.testForEachRemaining();
  * }</pre>
  *
+ * <p><b>Note</b>: It is necessary to use {@code IteratorTester.KnownOrder} as shown above, rather
+ * than {@code KnownOrder} directly, because otherwise the code is not compilable.
+ *
  * @author Kevin Bourrillion
  * @author Chris Povirk
  */, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Don't call toString() on the results of successful futures.

RELNOTES=AbstractFuture.toString() no longer includes the toString() of the result.

771629df701dfe565024db1cabfe19d7a5b2abfc

-------

<p> Fix example in documentation for `IteratorTester`

I made a mistake and accidentally included an example that does not
compile. Specifically, importing `KnownOrder` as-is does not compile;
instead one needs to import `IteratorTester.KnownOrder`. See #5254 for
more information.

I also changed the example to use `Collections#unmodifiableList`
rather than `ArrayList` because `ArrayList#iterator` does not satisfy
all the requirements of `IteratorFeature#MODIFIABLE`.

Fixes #5276

448afdbd4fc53f8d8f636516e54bfcbad9d6b3c0",MOE Sync 2020-10-13
5278,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/Futures.java']","@@ -974,6 +974,11 @@ private void recordCompletion() {
    * callbacks, but any callback added through this method is guaranteed to be called once the
    * computation is complete.
    *
+   * <p>Exceptions thrown by a {@code callback} will be propagated up to the executor. Any exception
+   * thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an
+   * exception thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught
+   * and logged.
+   *
    * <p>Example:
    *
    * <pre>{@code, @@ -1007,6 +1007,11 @@ private void recordCompletion() {
    * callbacks, but any callback added through this method is guaranteed to be called once the
    * computation is complete.
    *
+   * <p>Exceptions thrown by a {@code callback} will be propagated up to the executor. Any exception
+   * thrown during {@code Executor.execute} (e.g., a {@code RejectedExecutionException} or an
+   * exception thrown by {@linkplain MoreExecutors#directExecutor direct execution}) will be caught
+   * and logged.
+   *
    * <p>Example:
    *
    * <pre>{@code, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Clarify that Interner should be preferred instead of String.intern(); the existing language implies it's intended _only_ for other types.

See also https://github.com/google/guava/issues/399#issuecomment-61307754

1034a2ee444ad03ec869638efa53b3ae880c7f4d

-------

<p> Document what happens when FutureCallback throws exception.

Fixes #5250, #2058

3d573ac2514c53d678c3855b28d9223fea9c7e8f",MOE Sync 2020-10-14
5280,Chris Povirk,"['android/guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java', 'guava-tests/test/com/google/common/util/concurrent/ExecutionSequencerTest.java']","@@ -21,6 +21,7 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.base.Function;
 import com.google.common.testing.GcFinalization;
 import com.google.common.testing.TestLogHandler;
 import com.google.j2objc.annotations.J2ObjCIncompatible;
@@ -71,11 +72,6 @@ public void testCallableStartsAfterFirstFutureCompletes() {
     assertThat(secondCallable.called).isTrue();
   }
 
-  public void testCancellationNotPropagatedIfAlreadyStarted() {
-    serializer.submitAsync(firstCallable, directExecutor()).cancel(true);
-    assertThat(firstFuture.isCancelled()).isFalse();
-  }
-
   public void testCancellationDoesNotViolateSerialization() {
     @SuppressWarnings({""unused"", ""nullness""})
     Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
@@ -302,6 +298,25 @@ public Integer call() {
         .isLessThan(Thread.currentThread().getStackTrace().length + 100);
   }
 
+  private static Function<Integer, Integer> add(final int delta) {
+    return new Function<Integer, Integer>() {
+      @Override
+      public Integer apply(Integer input) {
+        return input + delta;
+      }
+    };
+  }
+
+  private static AsyncCallable<Integer> asyncAdd(
+      final ListenableFuture<Integer> future, final int delta, final Executor executor) {
+    return new AsyncCallable<Integer>() {
+      @Override
+      public ListenableFuture<Integer> call() throws Exception {
+        return Futures.transform(future, add(delta), executor);
+      }
+    };
+  }
+
   private static final class LongHolder {
     long count;
   }
@@ -391,8 +406,9 @@ public Void call() {
     }
   }
 
+  @SuppressWarnings(""ObjectToString"") // Intended behavior
   public void testToString() {
-    Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
+    Future<?> unused = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());
     Future<?> second = serializer.submitAsync(secondCallable, directExecutor());
     assertThat(secondCallable.called).isFalse();, @@ -21,6 +21,7 @@
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import com.google.common.annotations.GwtIncompatible;
+import com.google.common.base.Function;
 import com.google.common.testing.GcFinalization;
 import com.google.common.testing.TestLogHandler;
 import com.google.j2objc.annotations.J2ObjCIncompatible;
@@ -71,11 +72,6 @@ public void testCallableStartsAfterFirstFutureCompletes() {
     assertThat(secondCallable.called).isTrue();
   }
 
-  public void testCancellationNotPropagatedIfAlreadyStarted() {
-    serializer.submitAsync(firstCallable, directExecutor()).cancel(true);
-    assertThat(firstFuture.isCancelled()).isFalse();
-  }
-
   public void testCancellationDoesNotViolateSerialization() {
     @SuppressWarnings({""unused"", ""nullness""})
     Future<?> possiblyIgnoredError = serializer.submitAsync(firstCallable, directExecutor());
@@ -302,6 +298,25 @@ public Integer call() {
         .isLessThan(Thread.currentThread().getStackTrace().length + 100);
   }
 
+  private static Function<Integer, Integer> add(final int delta) {
+    return new Function<Integer, Integer>() {
+      @Override
+      public Integer apply(Integer input) {
+        return input + delta;
+      }
+    };
+  }
+
+  private static AsyncCallable<Integer> asyncAdd(
+      final ListenableFuture<Integer> future, final int delta, final Executor executor) {
+    return new AsyncCallable<Integer>() {
+      @Override
+      public ListenableFuture<Integer> call() throws Exception {
+        return Futures.transform(future, add(delta), executor);
+      }
+    };
+  }
+
   private static final class LongHolder {
     long count;
   }
@@ -391,8 +406,9 @@ public Void call() {
     }
   }
 
+  @SuppressWarnings(""ObjectToString"") // Intended behavior
   public void testToString() {
-    Future<?> first = serializer.submitAsync(firstCallable, directExecutor());
+    Future<?> unused = serializer.submitAsync(firstCallable, directExecutor());
     TestCallable secondCallable = new TestCallable(SettableFuture.<Void>create());
     Future<?> second = serializer.submitAsync(secondCallable, directExecutor());
     assertThat(secondCallable.called).isFalse();, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add tests which validate the run order of listeners on futures when the output is cancelled to test the behavior added in cl/161148771

Remove cancellation propagation test, as the intent of not propagating cancellation is to make sure run order is as expected.

If we propagate cancellations, the test fails.

c8f8cbe91a5c67d9b1f3a4ee240a48a288fadc6a",MOE Sync 2020-10-15
5283,Chris Povirk,"['android/guava/src/com/google/common/util/concurrent/ClosingFuture.java', 'guava/src/com/google/common/util/concurrent/ClosingFuture.java']","@@ -1040,6 +1040,7 @@ public void run() {
    * @return {@code false} if the step could not be cancelled, typically because it has already
    *     completed normally; {@code true} otherwise
    */
+  @CanIgnoreReturnValue
   public boolean cancel(boolean mayInterruptIfRunning) {
     logger.log(FINER, ""cancelling {0}"", this);
     boolean cancelled = future.cancel(mayInterruptIfRunning);, @@ -1039,6 +1039,7 @@ public void run() {
    * @return {@code false} if the step could not be cancelled, typically because it has already
    *     completed normally; {@code true} otherwise
    */
+  @CanIgnoreReturnValue
   public boolean cancel(boolean mayInterruptIfRunning) {
     logger.log(FINER, ""cancelling {0}"", this);
     boolean cancelled = future.cancel(mayInterruptIfRunning);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Encode all primes less-than 66 into a bitmask

Use a bitmask to make prime computation for all values less-than 66 O(1) and avoid any remainder calculations in these cases.

a2fcd41b7c10847d22943e083da450749a99c72b

-------

<p> Added `@CanIgnoreReturnValue` to `cancel`.

a4cf89bfc87cf95cdfad56d9a9c384c9e6dd0b33",MOE Sync 2020-10-16
5285,Chris Povirk,"['android/guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Files.java']","@@ -24,9 +24,9 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.TreeTraverser;
 import com.google.common.graph.SuccessorsFunction;
 import com.google.common.graph.Traverser;
 import com.google.common.hash.HashCode;
@@ -824,36 +824,6 @@ public static String getNameWithoutExtension(String file) {
     return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);
   }
 
-  /**
-   * Returns a {@link TreeTraverser} instance for {@link File} trees.
-   *
-   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no
-   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In
-   * this case, iterables created by this traverser could contain files that are outside of the
-   * given directory or even be infinite if there is a symbolic link loop.
-   *
-   * @since 15.0
-   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method
-   *     {@link #fileTraverser()} instead with the same semantics as this method.
-   */
-  @Deprecated
-  static TreeTraverser<File> fileTreeTraverser() {
-    return FILE_TREE_TRAVERSER;
-  }
-
-  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =
-      new TreeTraverser<File>() {
-        @Override
-        public Iterable<File> children(File file) {
-          return fileTreeChildren(file);
-        }
-
-        @Override
-        public String toString() {
-          return ""Files.fileTreeTraverser()"";
-        }
-      };
-
   /**
    * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser
    * starts from a {@link File} and will return all files and directories it encounters.
@@ -885,22 +855,18 @@ public String toString() {
       new SuccessorsFunction<File>() {
         @Override
         public Iterable<File> successors(File file) {
-          return fileTreeChildren(file);
+          // check isDirectory() just because it may be faster than listFiles() on a non-directory
+          if (file.isDirectory()) {
+            File[] files = file.listFiles();
+            if (files != null) {
+              return Collections.unmodifiableList(Arrays.asList(files));
+            }
+          }
+
+          return ImmutableList.of();
         }
       };
 
-  private static Iterable<File> fileTreeChildren(File file) {
-    // check isDirectory() just because it may be faster than listFiles() on a non-directory
-    if (file.isDirectory()) {
-      File[] files = file.listFiles();
-      if (files != null) {
-        return Collections.unmodifiableList(Arrays.asList(files));
-      }
-    }
-
-    return Collections.emptyList();
-  }
-
   /**
    * Returns a predicate that returns the result of {@link File#isDirectory} on input files.
    *, @@ -24,9 +24,9 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.TreeTraverser;
 import com.google.common.graph.SuccessorsFunction;
 import com.google.common.graph.Traverser;
 import com.google.common.hash.HashCode;
@@ -824,36 +824,6 @@ public static String getNameWithoutExtension(String file) {
     return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);
   }
 
-  /**
-   * Returns a {@link TreeTraverser} instance for {@link File} trees.
-   *
-   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no
-   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In
-   * this case, iterables created by this traverser could contain files that are outside of the
-   * given directory or even be infinite if there is a symbolic link loop.
-   *
-   * @since 15.0
-   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method
-   *     {@link #fileTraverser()} instead with the same semantics as this method.
-   */
-  @Deprecated
-  static TreeTraverser<File> fileTreeTraverser() {
-    return FILE_TREE_TRAVERSER;
-  }
-
-  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =
-      new TreeTraverser<File>() {
-        @Override
-        public Iterable<File> children(File file) {
-          return fileTreeChildren(file);
-        }
-
-        @Override
-        public String toString() {
-          return ""Files.fileTreeTraverser()"";
-        }
-      };
-
   /**
    * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser
    * starts from a {@link File} and will return all files and directories it encounters.
@@ -885,22 +855,18 @@ public String toString() {
       new SuccessorsFunction<File>() {
         @Override
         public Iterable<File> successors(File file) {
-          return fileTreeChildren(file);
+          // check isDirectory() just because it may be faster than listFiles() on a non-directory
+          if (file.isDirectory()) {
+            File[] files = file.listFiles();
+            if (files != null) {
+              return Collections.unmodifiableList(Arrays.asList(files));
+            }
+          }
+
+          return ImmutableList.of();
         }
       };
 
-  private static Iterable<File> fileTreeChildren(File file) {
-    // check isDirectory() just because it may be faster than listFiles() on a non-directory
-    if (file.isDirectory()) {
-      File[] files = file.listFiles();
-      if (files != null) {
-        return Collections.unmodifiableList(Arrays.asList(files));
-      }
-    }
-
-    return Collections.emptyList();
-  }
-
   /**
    * Returns a predicate that returns the result of {@link File#isDirectory} on input files.
    *, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Remove deprecated method Files.fileTreeTraverser() that isn't being used anymore.

295dd8008d06d73a99ffe076d1c302113b5a8f54",MOE Sync 2020-10-16
5286,Chris Povirk,"['android/guava-testlib/src/com/google/common/collect/testing/IteratorTester.java', 'guava-testlib/src/com/google/common/collect/testing/IteratorTester.java']","@@ -50,6 +50,9 @@
  * verify() method, which is called <em>after</em> each sequence and is guaranteed to be called
  * using the latest values obtained from {@link IteratorTester#newTargetIterator()}.
  *
+ * <p>The value you pass to the parameter {@code steps} should be greater than the length of your
+ * iterator, so that this class can check that your iterator behaves correctly when it is exhausted.
+ *
  * <p>For example, to test {@link java.util.Collections#unmodifiableList(java.util.List)
  * Collections.unmodifiableList}'s iterator:
  *
@@ -61,7 +64,7 @@
  *         Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
  * IteratorTester<String> iteratorTester =
  *     new IteratorTester<String>(
- *         5,
+ *         6,
  *         IteratorFeature.UNMODIFIABLE,
  *         expectedElements,
  *         IteratorTester.KnownOrder.KNOWN_ORDER) {
@@ -75,7 +78,7 @@
  * }</pre>
  *
  * <p><b>Note</b>: It is necessary to use {@code IteratorTester.KnownOrder} as shown above, rather
- * than {@code KnownOrder} directly, because otherwise the code is not compilable.
+ * than {@code KnownOrder} directly, because otherwise the code cannot be compiled.
  *
  * @author Kevin Bourrillion
  * @author Chris Povirk, @@ -50,6 +50,9 @@
  * verify() method, which is called <em>after</em> each sequence and is guaranteed to be called
  * using the latest values obtained from {@link IteratorTester#newTargetIterator()}.
  *
+ * <p>The value you pass to the parameter {@code steps} should be greater than the length of your
+ * iterator, so that this class can check that your iterator behaves correctly when it is exhausted.
+ *
  * <p>For example, to test {@link java.util.Collections#unmodifiableList(java.util.List)
  * Collections.unmodifiableList}'s iterator:
  *
@@ -61,7 +64,7 @@
  *         Arrays.asList(""a"", ""b"", ""c"", ""d"", ""e""));
  * IteratorTester<String> iteratorTester =
  *     new IteratorTester<String>(
- *         5,
+ *         6,
  *         IteratorFeature.UNMODIFIABLE,
  *         expectedElements,
  *         IteratorTester.KnownOrder.KNOWN_ORDER) {
@@ -75,7 +78,7 @@
  * }</pre>
  *
  * <p><b>Note</b>: It is necessary to use {@code IteratorTester.KnownOrder} as shown above, rather
- * than {@code KnownOrder} directly, because otherwise the code is not compilable.
+ * than {@code KnownOrder} directly, because otherwise the code cannot be compiled.
  *
  * @author Kevin Bourrillion
  * @author Chris Povirk, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Prepare for release 30.0.

06c1d37ea914125b88bc27d0a570df84fe900a4f

-------

<p> Remove deprecated 1-arg ServiceManager.addListener.

[]

RELNOTES=`util.concurrent`: Removed the deprecated 1-arg `ServiceManager.addListener(Listener)`. Use the 2-arg `addListener(Listener, Executor)` overload, setting the executor to `directExecutor()` for equivalent behavior.

d13ebb04258a0caecea56d908a391e7e694004b2

-------

<p> Update IteratorTester example with a greater ""steps"" value

This allows IteratorTester to check the edge case that when an iterator has been exhausted (that is, ""next"" has been called repeatedly until ""hasNext"" returns false) then calling ""next"" on the iterator again exhibits the same behavior as the user's chosen ""known good"" reference implementation.

Fixes #5281

b094a4b3f43645298a7c9bce9b5d72184d7ff4cf",MOE Sync 2020-10-16
5293,Nick,"['android/guava/src/com/google/common/reflect/ClassPath.java', 'guava/src/com/google/common/reflect/ClassPath.java']","@@ -78,14 +78,6 @@
 public final class ClassPath {
   private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
 
-  private static final Predicate<ClassInfo> IS_TOP_LEVEL =
-      new Predicate<ClassInfo>() {
-        @Override
-        public boolean apply(ClassInfo info) {
-          return info.className.indexOf('$') == -1;
-        }
-      };
-
   /** Separator for the Class-Path manifest attribute value in jar files. */
   private static final Splitter CLASS_PATH_ATTRIBUTE_SEPARATOR =
       Splitter.on("" "").omitEmptyStrings();
@@ -137,9 +129,21 @@ public static ClassPath from(ClassLoader classloader) throws IOException {
     return FluentIterable.from(resources).filter(ClassInfo.class).toSet();
   }
 
-  /** Returns all top level classes loadable from the current class path. */
+  /**
+   * Returns all top level classes loadable from the current class path. Note that ""top-level-ness""
+   * is determined heuristically by class name (see {@link ClassInfo#isTopLevel}).
+   */
   public ImmutableSet<ClassInfo> getTopLevelClasses() {
-    return FluentIterable.from(resources).filter(ClassInfo.class).filter(IS_TOP_LEVEL).toSet();
+    return FluentIterable.from(resources)
+        .filter(ClassInfo.class)
+        .filter(
+            new Predicate<ClassInfo>() {
+              @Override
+              public boolean apply(ClassInfo info) {
+                return info.isTopLevel();
+              }
+            })
+        .toSet();
   }
 
   /** Returns all top level classes whose package name is {@code packageName}. */
@@ -324,6 +328,18 @@ public String getName() {
       return className;
     }
 
+    /**
+     * Returns true if the class name ""looks to be"" top level (not nested), that is, it includes no
+     * '$' in the name, This method may return false for a top-level class that's intentionally
+     * named with the '$' character. If ths is a concern, you could use {@link #load} and then check
+     * on the loaded {@link Class} object instead.
+     *
+     * @since NEXT
+     */
+    public boolean isTopLevel() {
+      return className.indexOf('$') == -1;
+    }
+
     /**
      * Loads (but doesn't link or initialize) the class.
      *
@@ -408,7 +424,7 @@ private void scanJar(File file, ClassLoader classloader) throws IOException {
       } finally {
         try {
           jarFile.close();
-        } catch (IOException ignored) {
+        } catch (IOException ignored) { // similar to try-with-resources, but don't fail scanning
         }
       }
     }, @@ -78,14 +78,6 @@
 public final class ClassPath {
   private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
 
-  private static final Predicate<ClassInfo> IS_TOP_LEVEL =
-      new Predicate<ClassInfo>() {
-        @Override
-        public boolean apply(ClassInfo info) {
-          return info.className.indexOf('$') == -1;
-        }
-      };
-
   /** Separator for the Class-Path manifest attribute value in jar files. */
   private static final Splitter CLASS_PATH_ATTRIBUTE_SEPARATOR =
       Splitter.on("" "").omitEmptyStrings();
@@ -137,9 +129,21 @@ public static ClassPath from(ClassLoader classloader) throws IOException {
     return FluentIterable.from(resources).filter(ClassInfo.class).toSet();
   }
 
-  /** Returns all top level classes loadable from the current class path. */
+  /**
+   * Returns all top level classes loadable from the current class path. Note that ""top-level-ness""
+   * is determined heuristically by class name (see {@link ClassInfo#isTopLevel}).
+   */
   public ImmutableSet<ClassInfo> getTopLevelClasses() {
-    return FluentIterable.from(resources).filter(ClassInfo.class).filter(IS_TOP_LEVEL).toSet();
+    return FluentIterable.from(resources)
+        .filter(ClassInfo.class)
+        .filter(
+            new Predicate<ClassInfo>() {
+              @Override
+              public boolean apply(ClassInfo info) {
+                return info.isTopLevel();
+              }
+            })
+        .toSet();
   }
 
   /** Returns all top level classes whose package name is {@code packageName}. */
@@ -324,6 +328,18 @@ public String getName() {
       return className;
     }
 
+    /**
+     * Returns true if the class name ""looks to be"" top level (not nested), that is, it includes no
+     * '$' in the name, This method may return false for a top-level class that's intentionally
+     * named with the '$' character. If ths is a concern, you could use {@link #load} and then check
+     * on the loaded {@link Class} object instead.
+     *
+     * @since NEXT
+     */
+    public boolean isTopLevel() {
+      return className.indexOf('$') == -1;
+    }
+
     /**
      * Loads (but doesn't link or initialize) the class.
      *
@@ -408,7 +424,7 @@ private void scanJar(File file, ClassLoader classloader) throws IOException {
       } finally {
         try {
           jarFile.close();
-        } catch (IOException ignored) {
+        } catch (IOException ignored) { // similar to try-with-resources, but don't fail scanning
         }
       }
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Add ClassInfo.isTopLevel().

Seems like a useful method? I can't remember why I didn't add it in the first place. Perhaps just an oversight.

Partially addresses https://github.com/google/guava/issues/3349

RELNOTES=`reflect`: Added `ClassInfo.isTopLevel()`.

14173d1bd5997fab0da2e8636e3c3a78f8e7cd61",MOE Sync 2020-10-24
5294,Nick,"['android/guava/src/com/google/common/reflect/ClassPath.java', 'guava/src/com/google/common/reflect/ClassPath.java']","@@ -330,9 +330,9 @@ public String getName() {
 
     /**
      * Returns true if the class name ""looks to be"" top level (not nested), that is, it includes no
-     * '$' in the name, This method may return false for a top-level class that's intentionally
-     * named with the '$' character. If ths is a concern, you could use {@link #load} and then check
-     * on the loaded {@link Class} object instead.
+     * '$' in the name. This method may return false for a top-level class that's intentionally
+     * named with the '$' character. If this is a concern, you could use {@link #load} and then
+     * check on the loaded {@link Class} object instead.
      *
      * @since NEXT
      */, @@ -330,9 +330,9 @@ public String getName() {
 
     /**
      * Returns true if the class name ""looks to be"" top level (not nested), that is, it includes no
-     * '$' in the name, This method may return false for a top-level class that's intentionally
-     * named with the '$' character. If ths is a concern, you could use {@link #load} and then check
-     * on the loaded {@link Class} object instead.
+     * '$' in the name. This method may return false for a top-level class that's intentionally
+     * named with the '$' character. If this is a concern, you could use {@link #load} and then
+     * check on the loaded {@link Class} object instead.
      *
      * @since NEXT
      */, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Fix minor documentation typos, thanks to @Stephan202 and @jbduncan

fe37cd815ed687f7bd6881cb60717e0d641b3e1b",MOE Sync 2020-10-26
5307,Colin Decker,"['android/guava-tests/test/com/google/common/reflect/ClassPathTest.java', 'guava-tests/test/com/google/common/reflect/ClassPathTest.java']","@@ -399,7 +399,6 @@ public void testLocationsFrom_idempotentScan() throws IOException {
     assertThat(locations).isNotEmpty();
     for (ClassPath.LocationInfo location : locations) {
       ImmutableSet<ResourceInfo> resources = location.scanResources();
-      assertThat(resources).isNotEmpty();
       assertThat(location.scanResources()).containsExactlyElementsIn(resources);
     }
   }
@@ -544,7 +543,7 @@ private static URL makeJarUrlWithName(String name) throws IOException {
   private static File pickAnyJarFile() throws IOException {
     for (ClassPath.LocationInfo location :
         ClassPath.locationsFrom(ClassPathTest.class.getClassLoader())) {
-      if (!location.file().isDirectory()) {
+      if (!location.file().isDirectory() && location.file().exists()) {
         return location.file();
       }
     }, @@ -458,7 +458,6 @@ public void testLocationsFrom_idempotentScan() throws IOException {
     assertThat(locations).isNotEmpty();
     for (ClassPath.LocationInfo location : locations) {
       ImmutableSet<ResourceInfo> resources = location.scanResources();
-      assertThat(resources).isNotEmpty();
       assertThat(location.scanResources()).containsExactlyElementsIn(resources);
     }
   }
@@ -603,7 +602,7 @@ private static URL makeJarUrlWithName(String name) throws IOException {
   private static File pickAnyJarFile() throws IOException {
     for (ClassPath.LocationInfo location :
         ClassPath.locationsFrom(ClassPathTest.class.getClassLoader())) {
-      if (!location.file().isDirectory()) {
+      if (!location.file().isDirectory() && location.file().exists()) {
         return location.file();
       }
     }, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Refactor ClassPath: replace Scanner with Location class.

75c2c543c6ac64943037630cfa40945feff10f42

-------

<p> Fix documentation for HashCode.toString() that incorrectly claimed it returned in big-endian order.

The implementation of toString() goes through the bytes in the same order that asBytes() returns, so if the order of the underlying bytes is little-endian (as is the case for LongHashCode), then the string will also be little-endian, contradicting what the documentation says.

841129afbd77f8c78bb469de2ece758b418d322b

-------

<p> Optimize Hashing.crc32c() by eliminating two xors for every byte of input.

Benchmarks suggest a modest speedup around 8%.

b685bf7068044cfef0c73163408a0ccebacef203

-------

<p> Add constant for Origin Isolation header

Spec: https://github.com/WICG/origin-isolation

RELNOTES=Adds constant for the Origin-Isolation header.

f3d79119d1e1f9937f332a8c73ed1690dfbb8ffb

-------

<p> Remove outdated reference in docs

3ac6e42a8622be4b122dfd4b9eef989148141148

-------

<p> Add additional test for `Crc32cHashFunction`.

4f7e925397e6ca2b17ce3d563ba1968e94959bd1

-------

<p> Verify maximumWeight before setting

The maximumWeight builder method is the only method that does the argument verification before the assignment.
It looks like a typo, and does not affect anyone in practice, but it is still better to have the implementation uniform.

Fixes #5298

f1d40c3dd5243c5a29fe683fb42f7ff61b2a3068

-------

<p> Do 16-byte strides in CRC32C in c.g.c.hash, resulting in roughly a 3.3x speedup to 1.5 GB/s.

This is probably as good as it gets until Java 11, when we'll have access to the intrinsics that use CRC hardware when available.

6d9e9e33c6a784f86b51c3fac785532351374271

-------

<p> Rollback

*** Original change description ***

Do 16-byte strides in CRC32C in c.g.c.hash, resulting in roughly a 3.3x speedup to 1.5 GB/s.

This is probably as good as it gets until Java 11, when we'll have access to the intrinsics that use CRC hardware when available.

***

916807371db167b99bb8b591a22c9ec07fe2bac2

-------

<p> Backport `combine` to java7 for `ImmutableList` & `ImmutableSet`.

This is so that Java8 code relying on the Java7 branch of Guava can still efficiently collect Guava collections.

a275458c2601c33bfb5ba6ec54e2458feeeff06a

-------

<p> Fix `LoadingCache` minor documentation typo.

Fixes #5503.

59a9556d82fc233acf8c0a3ad00de14e02384f75

-------

<p> Added submitAsync to ClosingFuture.

RELNOTES=""Added `submitAsync(AsyncClosingCallable)` to `ClosingFuture`.""

187db6d240a896be6efb6fc98f014b9d4690fe30

-------

<p> Add `X-Request-ID` to `HttpHeaders`.

Fixes #5306.

RELNOTES=Add `X-Request-ID` to `HttpHeaders`.

0f5a31bbc213f61404189d777b2039842210cab5

-------

<p> Fix Android test failure in ClassPathTest.

Reproduced the error and verified that this change fixes it.

c1f6ac185f0e72998ed30ae72a0983804c5a4f5a",MOE Sync 2020-11-10
5308,David P. Baker,['guava/src/com/google/common/collect/HashBiMap.java'],"@@ -27,7 +27,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
+import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -88,11 +88,11 @@
     final int keyHash;
     final int valueHash;
 
-    @Nullable BiEntry<K, V> nextInKToVBucket;
-    @Nullable BiEntry<K, V> nextInVToKBucket;
+    @Weak @Nullable BiEntry<K, V> nextInKToVBucket;
+    @Weak @Nullable BiEntry<K, V> nextInVToKBucket;
 
-    @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
-    @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
+    @Weak @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
+    @Weak @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
 
     BiEntry(K key, int keyHash, V value, int valueHash) {
       super(key, value);
@@ -105,8 +105,8 @@
 
   private transient BiEntry<K, V>[] hashTableKToV;
   private transient BiEntry<K, V>[] hashTableVToK;
-  private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
-  private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
+  @Weak private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
+  @Weak private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -453,7 +453,6 @@ public void remove() {
     return new KeySet();
   }
 
-  @WeakOuter
   private final class KeySet extends Maps.KeySet<K, V> {
     KeySet() {
       super(HashBiMap.this);
@@ -625,7 +624,6 @@ public K get(@Nullable Object value) {
       return new InverseKeySet();
     }
 
-    @WeakOuter
     private final class InverseKeySet extends Maps.KeySet<V, K> {
       InverseKeySet() {
         super(Inverse.this);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Backport `combine` to java7 for `ImmutableMap`.

This is so that Java8 code relying on the Java7 branch of Guava can still efficiently collect Guava collections.

The Java8/Java7 implementations branched once again, where Java8 uses an array of Entries, whereas Java7 uses an array of alternating key/value pairs. Either way, the implementations were pretty trivial this time.

2afe372fb9fd390ceb671003588c053b7d463399

-------

<p> Backport combine to java7 for `ImmutableRangeSet`/`ImmutableRangeSet`.

This is so that Java8 code relying on the Java7 branch of Guava can still efficiently collect Guava collections.

I saved this for last, but they turned out to be the easiest to do. Tests are kind of crap, but honestly, baseline tests also seemed a little bit light to me.

a742fca6c4f0f96bfedac86b0722efec196b9052

-------

<p> Backport `combine` to java7 for Sorted collections & (Immutable)BiMap.

This is so that Java8 code relying on the Java7 branch of Guava can still efficiently collect Guava collections.

4c7fe5993f6938d60ecbf90494c93b827253101e

-------

<p> Fix memory leaks and potential crashes in HashBiMap, which occur in transpiled ObjC code.

450bf69d33c855032e3698ee96bae3994cc0377e",MOE Sync 2020-11-11
5310,David P. Baker,"['android/guava/pom.xml', 'guava-gwt/pom.xml', 'guava/pom.xml']","@@ -12,7 +12,7 @@
   <name>Guava: Google Core Libraries for Java</name>
   <description>
     Guava is a suite of core and expanded libraries that include
-    utility classes, google's collections, io classes, and much
+    utility classes, Google's collections, I/O classes, and
     much more.
   </description>
   <dependencies>, @@ -11,7 +11,7 @@
   <name>Guava GWT compatible libs</name>
   <description>
     Guava is a suite of core and expanded libraries that include
-    utility classes, google's collections, io classes, and much
+    utility classes, Google's collections, I/O classes, and
     much more.
 
     This project includes GWT-friendly sources., @@ -12,7 +12,7 @@
   <name>Guava: Google Core Libraries for Java</name>
   <description>
     Guava is a suite of core and expanded libraries that include
-    utility classes, google's collections, io classes, and much
+    utility classes, Google's collections, I/O classes, and
     much more.
   </description>
   <dependencies>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Tidy up description since this shows up in search results, Maven Central, and many other places around the web.

CL automatically created by:
    replace_string \
      'google'\''s collections, io classes, and much' \
      'Google'\''s collections, I/O classes, and'

21633ac58673b82a59930c001fdc0b1d85e30642",MOE Sync 2020-11-12
5315,benrkia ilyasse,['updaterelease.sh'],"@@ -360,13 +360,13 @@ update_config_yml() {
 
 # Generates Javadoc shortlinks for the current snapshot release.
 generate_snapshot_javadoc_shortlinks() {
-  # Creates 2 sub-folders for each non-nested class inside javadocshortcuts.
-  # This ensures that each class documentation is accessible using  https://guava.dev/ClassName
-  # or https://guava.dev/classname.
   if [[ ""$RELEASE"" != ""snapshot"" ]]; then
     return
   fi
-  for F in $(find releases/snapshot/api/docs/com/google/common -name '[A-Z]*.html' -not -path '*/class-use/*' -not -name '*.*.*'); do
+  # Creates 2 sub-folders for each non-nested class inside javadocshortcuts.
+  # This ensures that each class documentation is accessible using  https://guava.dev/ClassName
+  # or https://guava.dev/classname.
+  for F in $(find releases/snapshot-jre/api/docs/com/google/common -name '[A-Z]*.html' -not -path '*/class-use/*' -not -name '*.*.*'); do
     SHORT=$(basename $F .html)
 
     # Lowercases the 2nd sub-folder's name
@@ -376,11 +376,11 @@ generate_snapshot_javadoc_shortlinks() {
       echo ""title: $SHORT""
       echo ""permalink: /$SHORT/""
       echo ""redirect_to: https://guava.dev/$F""
-      echo ""---""
+      echo ---
     ) | tee javadocshortcuts/{$SHORT,$SHORT_LOWER}/index.md >/dev/null
 
-    # Sets the permalink value to lowercase for the 2nd sub-folder.
-    perl -pi -e '$_ = lc $_ if /^permalink/' javadocshortcuts/$SHORT_LOWER/index.md
+    # Lowercases the permalink value inside the 2nd sub-folder's index.md
+    perl -pi -e 's/^permalink.*/\L$&/' javadocshortcuts/$SHORT_LOWER/index.md
   done
 }
 , ",Fixes #4023 ,Automate Javadoc shortlinks generation
5321,David P. Baker,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Replaces cycle_finder references to ""--whitelist"" with ""--suppress-list"", and ""--blacklist"" with ""--restrict-to"".

RELNOTES=none

3bf14a6ebdcaba662e39ea1d98e20e15cf53370d

-------

<p> Add AndroidAccessToCollectors.

This adds the base Immutable collectors already in CollectCollectors, but is still lacking the Table-collections, Multi-collections, and mutable-collections.

e93c0557542e53a90ac3b5bae31a41bc102da806

-------

<p> Backport ImmutableTable.combine

That should be the last combine to backport. All remainging collectors are implemented in terms of existing collection transformations.

564439f883f709843801bb260e998ed6ac6a427d

-------

<p> Add to[Immutable]Multiset to AndroidAccessToCollectors

2a232a71cb980c689ee6b43ac241a0764d41cfbf

-------

<p> Backport combine to Immutable[List|Set]Multimap

Interestingly, ImmutableMultimap already had combine implemented by lowasser since 2017. Probably a backport oversight.

c9dd38f640734604397db8fdeea3f315afb8c487

-------

<p> Add Multimap collectors to AndroidAccessToCollectors

4a89571b10379e2e885ce221173365c7deb1b1be

-------

<p> Add TableCollectors to AndroidAccessToCollectors

7b5f741e939c80f0924bec4353d3b1f672d79eb4

-------

<p> Fix open source “No tests found in com.google.common.collect.TableCollectorsTest”

d5f07055a1a38227c98c4ec038d74ce7504b3d6f

-------

<p> Update Public Suffix data.

a132338a913fba14384234649f2a6a170f7b7dca",MOE Sync 2020-11-16
5322,David P. Baker,"['guava/src/com/google/common/collect/CollectCollectors.java', 'guava/src/com/google/common/collect/Maps.java', 'guava/src/com/google/common/collect/Sets.java']","@@ -24,6 +24,8 @@
 import com.google.common.base.Preconditions;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.EnumMap;
+import java.util.EnumSet;
 import java.util.LinkedHashMap;
 import java.util.TreeMap;
 import java.util.function.BinaryOperator;
@@ -33,6 +35,7 @@
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /** Collectors utilities for {@code common.collect} internals. */
 @GwtCompatible
@@ -85,6 +88,48 @@
         ImmutableSortedSet.Builder::build);
   }
 
+  @SuppressWarnings({""rawtypes"", ""unchecked""})
+  static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>> toImmutableEnumSet() {
+    return (Collector) EnumSetAccumulator.TO_IMMUTABLE_ENUM_SET;
+  }
+
+  private static final class EnumSetAccumulator<E extends Enum<E>> {
+    @SuppressWarnings({""rawtypes"", ""unchecked""})
+    static final Collector<Enum<?>, ?, ImmutableSet<? extends Enum<?>>> TO_IMMUTABLE_ENUM_SET =
+        (Collector)
+            Collector.<Enum, EnumSetAccumulator, ImmutableSet<?>>of(
+                EnumSetAccumulator::new,
+                EnumSetAccumulator::add,
+                EnumSetAccumulator::combine,
+                EnumSetAccumulator::toImmutableSet,
+                Collector.Characteristics.UNORDERED);
+
+    private @Nullable EnumSet<E> set;
+
+    void add(E e) {
+      if (set == null) {
+        set = EnumSet.of(e);
+      } else {
+        set.add(e);
+      }
+    }
+
+    EnumSetAccumulator<E> combine(EnumSetAccumulator<E> other) {
+      if (this.set == null) {
+        return other;
+      } else if (other.set == null) {
+        return this;
+      } else {
+        this.set.addAll(other.set);
+        return this;
+      }
+    }
+
+    ImmutableSet<E> toImmutableSet() {
+      return (set == null) ? ImmutableSet.<E>of() : ImmutableEnumSet.asImmutable(set);
+    }
+  }
+
   @GwtIncompatible
   @SuppressWarnings({""rawtypes"", ""unchecked""})
   static <E extends Comparable<? super E>>
@@ -198,6 +243,77 @@
         new Collector.Characteristics[0]);
   }
 
+  static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
+      Function<? super T, ? extends K> keyFunction,
+      Function<? super T, ? extends V> valueFunction) {
+    checkNotNull(keyFunction);
+    checkNotNull(valueFunction);
+    return Collector.of(
+        () ->
+            new EnumMapAccumulator<K, V>(
+                (v1, v2) -> {
+                  throw new IllegalArgumentException(""Multiple values for key: "" + v1 + "", "" + v2);
+                }),
+        (accum, t) -> {
+          K key = checkNotNull(keyFunction.apply(t), ""Null key for input %s"", t);
+          V newValue = checkNotNull(valueFunction.apply(t), ""Null value for input %s"", t);
+          accum.put(key, newValue);
+        },
+        EnumMapAccumulator::combine,
+        EnumMapAccumulator::toImmutableMap,
+        Collector.Characteristics.UNORDERED);
+  }
+
+  static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
+      Function<? super T, ? extends K> keyFunction,
+      Function<? super T, ? extends V> valueFunction,
+      BinaryOperator<V> mergeFunction) {
+    checkNotNull(keyFunction);
+    checkNotNull(valueFunction);
+    checkNotNull(mergeFunction);
+    // not UNORDERED because we don't know if mergeFunction is commutative
+    return Collector.of(
+        () -> new EnumMapAccumulator<K, V>(mergeFunction),
+        (accum, t) -> {
+          K key = checkNotNull(keyFunction.apply(t), ""Null key for input %s"", t);
+          V newValue = checkNotNull(valueFunction.apply(t), ""Null value for input %s"", t);
+          accum.put(key, newValue);
+        },
+        EnumMapAccumulator::combine,
+        EnumMapAccumulator::toImmutableMap);
+  }
+
+  private static class EnumMapAccumulator<K extends Enum<K>, V> {
+    private final BinaryOperator<V> mergeFunction;
+    private EnumMap<K, V> map = null;
+
+    EnumMapAccumulator(BinaryOperator<V> mergeFunction) {
+      this.mergeFunction = mergeFunction;
+    }
+
+    void put(K key, V value) {
+      if (map == null) {
+        map = new EnumMap<>(key.getDeclaringClass());
+      }
+      map.merge(key, value, mergeFunction);
+    }
+
+    EnumMapAccumulator<K, V> combine(EnumMapAccumulator<K, V> other) {
+      if (this.map == null) {
+        return other;
+      } else if (other.map == null) {
+        return this;
+      } else {
+        other.map.forEach(this::put);
+        return this;
+      }
+    }
+
+    ImmutableMap<K, V> toImmutableMap() {
+      return (map == null) ? ImmutableMap.<K, V>of() : ImmutableEnumMap.asImmutable(map);
+    }
+  }
+
   @GwtIncompatible
   static <T, K extends Comparable<? super K>, V>
       Collector<T, ?, ImmutableRangeMap<K, V>> toImmutableRangeMap(, @@ -171,37 +171,6 @@ V transform(Entry<K, V> entry) {
     return ImmutableEnumMap.asImmutable(enumMap);
   }
 
-  private static class Accumulator<K extends Enum<K>, V> {
-    private final BinaryOperator<V> mergeFunction;
-    private EnumMap<K, V> map = null;
-
-    Accumulator(BinaryOperator<V> mergeFunction) {
-      this.mergeFunction = mergeFunction;
-    }
-
-    void put(K key, V value) {
-      if (map == null) {
-        map = new EnumMap<>(key.getDeclaringClass());
-      }
-      map.merge(key, value, mergeFunction);
-    }
-
-    Accumulator<K, V> combine(Accumulator<K, V> other) {
-      if (this.map == null) {
-        return other;
-      } else if (other.map == null) {
-        return this;
-      } else {
-        other.map.forEach(this::put);
-        return this;
-      }
-    }
-
-    ImmutableMap<K, V> toImmutableMap() {
-      return (map == null) ? ImmutableMap.<K, V>of() : ImmutableEnumMap.asImmutable(map);
-    }
-  }
-
   /**
    * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys
    * and values are the result of applying the provided mapping functions to the input elements. The
@@ -219,22 +188,7 @@ void put(K key, V value) {
   public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
       java.util.function.Function<? super T, ? extends K> keyFunction,
       java.util.function.Function<? super T, ? extends V> valueFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    return Collector.of(
-        () ->
-            new Accumulator<K, V>(
-                (v1, v2) -> {
-                  throw new IllegalArgumentException(""Multiple values for key: "" + v1 + "", "" + v2);
-                }),
-        (accum, t) -> {
-          K key = checkNotNull(keyFunction.apply(t), ""Null key for input %s"", t);
-          V newValue = checkNotNull(valueFunction.apply(t), ""Null value for input %s"", t);
-          accum.put(key, newValue);
-        },
-        Accumulator::combine,
-        Accumulator::toImmutableMap,
-        Collector.Characteristics.UNORDERED);
+    return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction);
   }
 
   /**
@@ -252,19 +206,7 @@ void put(K key, V value) {
       java.util.function.Function<? super T, ? extends K> keyFunction,
       java.util.function.Function<? super T, ? extends V> valueFunction,
       BinaryOperator<V> mergeFunction) {
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
-    // not UNORDERED because we don't know if mergeFunction is commutative
-    return Collector.of(
-        () -> new Accumulator<K, V>(mergeFunction),
-        (accum, t) -> {
-          K key = checkNotNull(keyFunction.apply(t), ""Null key for input %s"", t);
-          V newValue = checkNotNull(valueFunction.apply(t), ""Null value for input %s"", t);
-          accum.put(key, newValue);
-        },
-        Accumulator::combine,
-        Accumulator::toImmutableMap);
+    return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction, mergeFunction);
   }
 
   /**, @@ -137,42 +137,6 @@ public boolean retainAll(Collection<?> c) {
     }
   }
 
-  private static final class Accumulator<E extends Enum<E>> {
-    static final Collector<Enum<?>, ?, ImmutableSet<? extends Enum<?>>> TO_IMMUTABLE_ENUM_SET =
-        (Collector)
-            Collector.<Enum, Accumulator, ImmutableSet<?>>of(
-                Accumulator::new,
-                Accumulator::add,
-                Accumulator::combine,
-                Accumulator::toImmutableSet,
-                Collector.Characteristics.UNORDERED);
-
-    private @Nullable EnumSet<E> set;
-
-    void add(E e) {
-      if (set == null) {
-        set = EnumSet.of(e);
-      } else {
-        set.add(e);
-      }
-    }
-
-    Accumulator<E> combine(Accumulator<E> other) {
-      if (this.set == null) {
-        return other;
-      } else if (other.set == null) {
-        return this;
-      } else {
-        this.set.addAll(other.set);
-        return this;
-      }
-    }
-
-    ImmutableSet<E> toImmutableSet() {
-      return (set == null) ? ImmutableSet.<E>of() : ImmutableEnumSet.asImmutable(set);
-    }
-  }
-
   /**
    * Returns a {@code Collector} that accumulates the input elements into a new {@code ImmutableSet}
    * with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the
@@ -181,7 +145,7 @@ void add(E e) {
    * @since 21.0
    */
   public static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>> toImmutableEnumSet() {
-    return (Collector) Accumulator.TO_IMMUTABLE_ENUM_SET;
+    return CollectCollectors.toImmutableEnumSet();
   }
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make toImmutableEnum[Set|Map] to AndroidAccessToCollectors

I think that’s the last of them.

The implementations I moved verbatim, and there was no change of code there.

660f036a37966bbee88b3b002d1ad9d1afa8e50e",MOE Sync 2020-11-17
5331,Chris Povirk,['guava/src/com/google/common/collect/ImmutableSortedMap.java'],"@@ -95,14 +95,8 @@
       Function<? super T, ? extends K> keyFunction,
       Function<? super T, ? extends V> valueFunction,
       BinaryOperator<V> mergeFunction) {
-    checkNotNull(comparator);
-    checkNotNull(keyFunction);
-    checkNotNull(valueFunction);
-    checkNotNull(mergeFunction);
-    return Collectors.collectingAndThen(
-        Collectors.toMap(
-            keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)),
-        ImmutableSortedMap::copyOfSorted);
+    return CollectCollectors.toImmutableSortedMap(
+        comparator, keyFunction, valueFunction, mergeFunction);
   }
 
   /*, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Make toImmutableSortedMap levarage collect collectors

b499958c1439b0c1c76732ec50daec8b46a1789b",MOE Sync 2020-11-24
5332,Chris Povirk,"['guava/src/com/google/common/collect/ImmutableList.java', 'guava/src/com/google/common/collect/ImmutableListMultimap.java', 'guava/src/com/google/common/collect/ImmutableMap.java', 'guava/src/com/google/common/collect/ImmutableMultiset.java', 'guava/src/com/google/common/collect/ImmutableRangeMap.java', 'guava/src/com/google/common/collect/ImmutableRangeSet.java', 'guava/src/com/google/common/collect/ImmutableSet.java', 'guava/src/com/google/common/collect/ImmutableSetMultimap.java', 'guava/src/com/google/common/collect/ImmutableSortedMap.java', 'guava/src/com/google/common/collect/ImmutableSortedSet.java', 'guava/src/com/google/common/collect/ImmutableTable.java', 'guava/src/com/google/common/collect/Maps.java', 'guava/src/com/google/common/collect/Multimaps.java', 'guava/src/com/google/common/collect/Multisets.java', 'guava/src/com/google/common/collect/Sets.java', 'guava/src/com/google/common/collect/Tables.java']","@@ -65,6 +65,7 @@
    * Returns a {@code Collector} that accumulates the input elements into a new {@code
    * ImmutableList}, in encounter order.
    *
+   *
    * @since 21.0
    */
   public static <E> Collector<E, ?, ImmutableList<E>> toImmutableList() {, @@ -74,6 +74,7 @@
    *         .build();
    * }</pre>
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableListMultimap<K, V>> toImmutableListMultimap(
@@ -111,6 +112,7 @@
    * }
    * }</pre>
    *
+   *
    * @since 21.0
    */
   public static <T, K, V>, @@ -74,6 +74,7 @@
    * from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which
    * throws an {@code IllegalStateException}.)
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(
@@ -90,6 +91,7 @@
    * values are merged using the specified merging function. Entries will appear in the encounter
    * order of the first occurrence of the key.
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableMap(, @@ -60,6 +60,7 @@
    * ImmutableMultiset}. Elements iterate in order by the <i>first</i> appearance of that element in
    * encounter order.
    *
+   *
    * @since 21.0
    */
   public static <E> Collector<E, ?, ImmutableMultiset<E>> toImmutableMultiset() {
@@ -75,6 +76,7 @@
    * occurrence in encounter order appears in the resulting multiset, with count equal to the sum of
    * the outputs of {@code countFunction.applyAsInt(t)} for each {@code t} mapped to that element.
    *
+   *
    * @since 22.0
    */
   public static <T, E> Collector<T, ?, ImmutableMultiset<E>> toImmutableMultiset(, @@ -53,6 +53,7 @@
    * Returns a {@code Collector} that accumulates the input elements into a new {@code
    * ImmutableRangeMap}. As in {@link Builder}, overlapping ranges are not permitted.
    *
+   *
    * @since 23.1
    */
   public static <T, K extends Comparable<? super K>, V>, @@ -60,6 +60,7 @@
    * ImmutableRangeSet}. As in {@link Builder}, overlapping ranges are not permitted and adjacent
    * ranges will be merged.
    *
+   *
    * @since 23.1
    */
   public static <E extends Comparable<? super E>>, @@ -60,6 +60,7 @@
    * the stream contains duplicates (according to {@link Object#equals(Object)}), only the first
    * duplicate in encounter order will appear in the result.
    *
+   *
    * @since 21.0
    */
   public static <E> Collector<E, ?, ImmutableSet<E>> toImmutableSet() {, @@ -79,6 +79,7 @@
    *         .build();
    * }</pre>
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(
@@ -125,6 +126,7 @@
    * }
    * }</pre>
    *
+   *
    * @since 21.0
    */
   public static <T, K, V>, @@ -70,6 +70,7 @@
    * from the {@code Collector} returned by {@link Collectors#toMap(Function, Function)}, which
    * throws an {@code IllegalStateException}.)
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(
@@ -88,6 +89,7 @@
    * merged using the specified merging function. Entries will appear in the encounter order of the
    * first occurrence of the key.
    *
+   *
    * @since 21.0
    */
   public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap(, @@ -72,6 +72,7 @@
    * <p>If the elements contain duplicates (according to the comparator), only the first duplicate
    * in encounter order will appear in the result.
    *
+   *
    * @since 21.0
    */
   public static <E> Collector<E, ?, ImmutableSortedSet<E>> toImmutableSortedSet(, @@ -55,6 +55,7 @@
    * <p>The returned {@code Collector} will throw a {@code NullPointerException} at collection time
    * if the row, column, or value functions return null on any input.
    *
+   *
    * @since 21.0
    */
   public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(
@@ -73,6 +74,7 @@
    * <p>The returned {@code Collector} will throw a {@code NullPointerException} at collection time
    * if the row, column, value, or merging functions return null on any input.
    *
+   *
    * @since 21.0
    */
   public static <T, R, C, V> Collector<T, ?, ImmutableTable<R, C, V>> toImmutableTable(, @@ -183,6 +183,7 @@ V transform(Entry<K, V> entry) {
    * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code
    * IllegalStateException}.)
    *
+   *
    * @since 21.0
    */
   public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(
@@ -200,6 +201,7 @@ V transform(Entry<K, V> entry) {
    * <p>If the mapped keys contain duplicates, the values are merged using the specified merging
    * function.
    *
+   *
    * @since 21.0
    */
   public static <T, K extends Enum<K>, V> Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(, @@ -102,6 +102,7 @@ private Multimaps() {}
    * }
    * }</pre>
    *
+   *
    * @since 21.0
    */
   public static <T, K, V, M extends Multimap<K, V>> Collector<T, ?, M> toMultimap(
@@ -142,6 +143,7 @@ private Multimaps() {}
    * }
    * }</pre>
    *
+   *
    * @since 21.0
    */
   @Beta, @@ -70,6 +70,7 @@ private Multisets() {}
    * <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to
    * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.
    *
+   *
    * @since 22.0
    */
   public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(, @@ -142,6 +142,7 @@ public boolean retainAll(Collection<?> c) {
    * with an implementation specialized for enums. Unlike {@link ImmutableSet#toImmutableSet}, the
    * resulting set will iterate over elements in their enum definition order, not encounter order.
    *
+   *
    * @since 21.0
    */
   public static <E extends Enum<E>> Collector<E, ?, ImmutableSet<E>> toImmutableEnumSet() {, @@ -60,6 +60,7 @@ private Tables() {}
    * <p>If multiple input elements map to the same row and column, an {@code IllegalStateException}
    * is thrown when the collection operation is performed.
    *
+   *
    * @since 21.0
    */
   @Beta
@@ -83,6 +84,7 @@ private Tables() {}
    * NullPointerException} on null values returned from {@code valueFunction}, and treats nulls
    * returned from {@code mergeFunction} as removals of that row/column pair.
    *
+   *
    * @since 21.0
    */
   public static <T, R, C, V, I extends Table<R, C, V>> Collector<T, ?, I> toTable(, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Internal change.

412db47018be7ccee39905468f65cd1f7b9f0eb2",MOE Sync 2020-11-24
5338,David P. Baker,"['android/guava/src/com/google/common/cache/LocalCache.java', 'android/guava/src/com/google/common/collect/ContiguousSet.java', 'guava/src/com/google/common/collect/ContiguousSet.java']","@@ -3861,8 +3861,7 @@ public V getIfPresent(Object key) {
     return value;
   }
 
-  // Only becomes available in Java 8 when it's on the interface.
-  // @Override
+  @SuppressWarnings(""MissingOverride"") // Supermethod will not exist if we build with --release 7.
   @NullableDecl
   public V getOrDefault(@NullableDecl Object key, @NullableDecl V defaultValue) {
     V result = get(key);, @@ -191,15 +191,14 @@
   /*
    * These methods perform most headSet, subSet, and tailSet logic, besides parameter validation.
    */
-  // TODO(kevinb): we can probably make these real @Overrides now
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> headSetImpl(C toElement, boolean inclusive);
 
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> subSetImpl(
       C fromElement, boolean fromInclusive, C toElement, boolean toInclusive);
 
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive);
 
   /**, @@ -191,15 +191,14 @@
   /*
    * These methods perform most headSet, subSet, and tailSet logic, besides parameter validation.
    */
-  // TODO(kevinb): we can probably make these real @Overrides now
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> headSetImpl(C toElement, boolean inclusive);
 
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> subSetImpl(
       C fromElement, boolean fromInclusive, C toElement, boolean toInclusive);
 
-  /* @Override */
+  @SuppressWarnings(""MissingOverride"") // Supermethod does not exist under GWT.
   abstract ContiguousSet<C> tailSetImpl(C fromElement, boolean inclusive);
 
   /**, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> PUBLIC: Add missing Override annotations.

da5e9d98f43b039c64a62182614f74ca188cd2ce",MOE Sync 2020-11-30
5339,David P. Baker,"['android/guava/src/com/google/common/collect/AbstractMultimap.java', 'android/guava/src/com/google/common/collect/Multimaps.java', 'guava/src/com/google/common/collect/AbstractMultimap.java', 'guava/src/com/google/common/collect/Multimaps.java']","@@ -20,6 +20,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -105,7 +106,7 @@ public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     return result;
   }
 
-  @NullableDecl private transient Collection<Entry<K, V>> entries;
+  @LazyInit @NullableDecl private transient Collection<Entry<K, V>> entries;
 
   @Override
   public Collection<Entry<K, V>> entries() {
@@ -143,7 +144,7 @@ public boolean equals(@NullableDecl Object obj) {
 
   abstract Iterator<Entry<K, V>> entryIterator();
 
-  @NullableDecl private transient Set<K> keySet;
+  @LazyInit @NullableDecl private transient Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
@@ -153,7 +154,7 @@ public boolean equals(@NullableDecl Object obj) {
 
   abstract Set<K> createKeySet();
 
-  @NullableDecl private transient Multiset<K> keys;
+  @LazyInit @NullableDecl private transient Multiset<K> keys;
 
   @Override
   public Multiset<K> keys() {
@@ -163,7 +164,7 @@ public boolean equals(@NullableDecl Object obj) {
 
   abstract Multiset<K> createKeys();
 
-  @NullableDecl private transient Collection<V> values;
+  @LazyInit @NullableDecl private transient Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -200,7 +201,7 @@ public void clear() {
     return Maps.valueIterator(entries().iterator());
   }
 
-  @NullableDecl private transient Map<K, Collection<V>> asMap;
+  @LazyInit @NullableDecl private transient Map<K, Collection<V>> asMap;
 
   @Override
   public Map<K, Collection<V>> asMap() {, @@ -29,6 +29,7 @@
 import com.google.common.base.Supplier;
 import com.google.common.collect.Maps.EntryTransformer;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.Weak;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
@@ -539,11 +540,11 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
   private static class UnmodifiableMultimap<K, V> extends ForwardingMultimap<K, V>
       implements Serializable {
     final Multimap<K, V> delegate;
-    @NullableDecl transient Collection<Entry<K, V>> entries;
-    @NullableDecl transient Multiset<K> keys;
-    @NullableDecl transient Set<K> keySet;
-    @NullableDecl transient Collection<V> values;
-    @NullableDecl transient Map<K, Collection<V>> map;
+    @LazyInit @NullableDecl transient Collection<Entry<K, V>> entries;
+    @LazyInit @NullableDecl transient Multiset<K> keys;
+    @LazyInit @NullableDecl transient Set<K> keySet;
+    @LazyInit @NullableDecl transient Collection<V> values;
+    @LazyInit @NullableDecl transient Map<K, Collection<V>> map;
 
     UnmodifiableMultimap(final Multimap<K, V> delegate) {
       this.delegate = checkNotNull(delegate);, @@ -20,6 +20,7 @@
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.WeakOuter;
 import java.util.AbstractCollection;
 import java.util.Collection;
@@ -107,7 +108,7 @@ public boolean putAll(Multimap<? extends K, ? extends V> multimap) {
     return result;
   }
 
-  private transient @Nullable Collection<Entry<K, V>> entries;
+  @LazyInit private transient @Nullable Collection<Entry<K, V>> entries;
 
   @Override
   public Collection<Entry<K, V>> entries() {
@@ -155,7 +156,7 @@ public boolean equals(@Nullable Object obj) {
         entryIterator(), size(), (this instanceof SetMultimap) ? Spliterator.DISTINCT : 0);
   }
 
-  private transient @Nullable Set<K> keySet;
+  @LazyInit private transient @Nullable Set<K> keySet;
 
   @Override
   public Set<K> keySet() {
@@ -165,7 +166,7 @@ public boolean equals(@Nullable Object obj) {
 
   abstract Set<K> createKeySet();
 
-  private transient @Nullable Multiset<K> keys;
+  @LazyInit private transient @Nullable Multiset<K> keys;
 
   @Override
   public Multiset<K> keys() {
@@ -175,7 +176,7 @@ public boolean equals(@Nullable Object obj) {
 
   abstract Multiset<K> createKeys();
 
-  private transient @Nullable Collection<V> values;
+  @LazyInit private transient @Nullable Collection<V> values;
 
   @Override
   public Collection<V> values() {
@@ -221,7 +222,7 @@ public void clear() {
     return Spliterators.spliterator(valueIterator(), size(), 0);
   }
 
-  private transient @Nullable Map<K, Collection<V>> asMap;
+  @LazyInit private transient @Nullable Map<K, Collection<V>> asMap;
 
   @Override
   public Map<K, Collection<V>> asMap() {, @@ -29,6 +29,7 @@
 import com.google.common.base.Supplier;
 import com.google.common.collect.Maps.EntryTransformer;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.Weak;
 import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
@@ -626,11 +627,11 @@ private void readObject(ObjectInputStream stream) throws IOException, ClassNotFo
   private static class UnmodifiableMultimap<K, V> extends ForwardingMultimap<K, V>
       implements Serializable {
     final Multimap<K, V> delegate;
-    transient @Nullable Collection<Entry<K, V>> entries;
-    transient @Nullable Multiset<K> keys;
-    transient @Nullable Set<K> keySet;
-    transient @Nullable Collection<V> values;
-    transient @Nullable Map<K, Collection<V>> map;
+    @LazyInit transient @Nullable Collection<Entry<K, V>> entries;
+    @LazyInit transient @Nullable Multiset<K> keys;
+    @LazyInit transient @Nullable Set<K> keySet;
+    @LazyInit transient @Nullable Collection<V> values;
+    @LazyInit transient @Nullable Map<K, Collection<V>> map;
 
     UnmodifiableMultimap(final Multimap<K, V> delegate) {
       this.delegate = checkNotNull(delegate);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Suppress TSAN errors for benign races.

Compare other usages of `@LazyInit` on collection views, such as `HashBiMap.inverse` and `AbstractTable.cellSet`.

2dd065fb4e67aa61c0db2e8851ae002e3b8959a2",MOE Sync 2020-12-02
5343,David P. Baker,['guava/src/com/google/common/collect/HashBiMap.java'],"@@ -27,7 +27,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.Weak;
+import com.google.j2objc.annotations.WeakOuter;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -88,11 +88,11 @@
     final int keyHash;
     final int valueHash;
 
-    @Weak @Nullable BiEntry<K, V> nextInKToVBucket;
-    @Weak @Nullable BiEntry<K, V> nextInVToKBucket;
+    @Nullable BiEntry<K, V> nextInKToVBucket;
+    @Nullable BiEntry<K, V> nextInVToKBucket;
 
-    @Weak @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
-    @Weak @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
+    @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
+    @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
 
     BiEntry(K key, int keyHash, V value, int valueHash) {
       super(key, value);
@@ -105,8 +105,8 @@
 
   private transient BiEntry<K, V>[] hashTableKToV;
   private transient BiEntry<K, V>[] hashTableVToK;
-  @Weak private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
-  @Weak private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
+  private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
+  private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -453,6 +453,7 @@ public void remove() {
     return new KeySet();
   }
 
+  @WeakOuter
   private final class KeySet extends Maps.KeySet<K, V> {
     KeySet() {
       super(HashBiMap.this);
@@ -624,6 +625,7 @@ public K get(@Nullable Object value) {
       return new InverseKeySet();
     }
 
+    @WeakOuter
     private final class InverseKeySet extends Maps.KeySet<V, K> {
       InverseKeySet() {
         super(Inverse.this);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Explain when StandardSystemProperty.value() can return a null value, and deprecate JAVA_EXT_DIRS.

value()'s return type has been @Nullable since 4232450e7bb7c46c08868f699323db3e787507c8, but I had forgotten the details about why, despite past CLs to update the test for specific missing keys.

I assume that we'll never actually *remove* JAVA_EXT_DIRS.

(Just slightly relevant to https://github.com/google/guava/issues/2571)

RELNOTES=`base`: Deprecated `StandardSystemProperty.JAVA_EXT_DIRS`. We do not plan to remove the API, but in recent versions of Java, that property always has a value of `null`.

5cdf73749704cdb752b922ec8c66dff2d36b22de

-------

<p> Automated rollback of 67517b5a5b7627eee39a47917197998b9f974751.

*** Reason for rollback ***

Causing Sheets iOS crash

*** Original change description ***

Fix memory leaks and potential crashes in HashBiMap, which occur in transpiled ObjC code.
Add iOS specific unit tests in XPlat, because Guava is missing infrastructure for iOS tests.

***

d2568df195c16cdbc62c6ab93ce489f9a4a81dc3",MOE Sync 2020-12-03
5347,David P. Baker,['guava/src/com/google/common/collect/HashBiMap.java'],"@@ -27,7 +27,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.LazyInit;
 import com.google.j2objc.annotations.RetainedWith;
-import com.google.j2objc.annotations.WeakOuter;
+import com.google.j2objc.annotations.Weak;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
@@ -88,11 +88,17 @@
     final int keyHash;
     final int valueHash;
 
+    // All BiEntry instances are strongly reachable from owning HashBiMap through
+    // ""HashBiMap.hashTableKToV"" and ""BiEntry.nextInKToVBucket"" references.
+    // Under that assumption, the remaining references can be safely marked as @Weak.
+    // Using @Weak is necessary to avoid retain-cycles between BiEntry instances on iOS,
+    // which would cause memory leaks when non-empty HashBiMap with cyclic BiEntry
+    // instances is deallocated.
     @Nullable BiEntry<K, V> nextInKToVBucket;
-    @Nullable BiEntry<K, V> nextInVToKBucket;
+    @Weak @Nullable BiEntry<K, V> nextInVToKBucket;
 
-    @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
-    @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
+    @Weak @Nullable BiEntry<K, V> nextInKeyInsertionOrder;
+    @Weak @Nullable BiEntry<K, V> prevInKeyInsertionOrder;
 
     BiEntry(K key, int keyHash, V value, int valueHash) {
       super(key, value);
@@ -105,8 +111,8 @@
 
   private transient BiEntry<K, V>[] hashTableKToV;
   private transient BiEntry<K, V>[] hashTableVToK;
-  private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
-  private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
+  @Weak private transient @Nullable BiEntry<K, V> firstInKeyInsertionOrder;
+  @Weak private transient @Nullable BiEntry<K, V> lastInKeyInsertionOrder;
   private transient int size;
   private transient int mask;
   private transient int modCount;
@@ -453,7 +459,6 @@ public void remove() {
     return new KeySet();
   }
 
-  @WeakOuter
   private final class KeySet extends Maps.KeySet<K, V> {
     KeySet() {
       super(HashBiMap.this);
@@ -625,7 +630,6 @@ public K get(@Nullable Object value) {
       return new InverseKeySet();
     }
 
-    @WeakOuter
     private final class InverseKeySet extends Maps.KeySet<V, K> {
       InverseKeySet() {
         super(Inverse.this);, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> System.getProperties().getProperty => System.getProperty.

My motivation was that it's slightly easier for a nullness checker to determine that System.getProperty(standardProperty) is (generally speaking) non-null. But it turns out that java.runtime.name is not a standard property!

Still, this is a slight simplification, so I guess I'm submitting.

96203a3d7a76dda7190e30d58431515fd9ad4ea3

-------

<p> Fix a bug in HashBiMap which was causing crashes in Sheets on iOS.

The crash was caused by the fact, that linked-list of BiEntry instances inside a bucket were using @Weak references, and only the first entry in the list was strongly referenced. The remaining ones were deallocated.

With this change, Sheets iOS is not crashing anymore.

847c0235ef0a768a4d19274a1fe8264bcbfc190a",MOE Sync 2020-12-04
5352,Kurt Alfred Kluever,"['android/guava-bom/pom.xml', 'guava-bom/pom.xml']","@@ -15,6 +15,7 @@
     <groupId>org.sonatype.oss</groupId>
     <artifactId>oss-parent</artifactId>
     <version>9</version>
+    <relativePath></relativePath>
   </parent>
 
   <name>Guava BOM</name>, @@ -15,6 +15,7 @@
     <groupId>org.sonatype.oss</groupId>
     <artifactId>oss-parent</artifactId>
     <version>9</version>
+    <relativePath></relativePath>
   </parent>
 
   <name>Guava BOM</name>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> First step in cleaning up PSL handling. Next stage will be to change the template to store the trie string as a separate static constant, so that I can write a unit test that verifies that.

f0c496c1a6b7a7de08f95bf750aeefc5319121d0

-------

<p> Fix `relativePath` warning for guava-bom.

Fixes #3945.
Closes #5349.

aa80e236c6251b7a8fe529abc3d10e269594baf2",MOE Sync 2020-12-10
5354,Kurt Alfred Kluever,"['android/guava/pom.xml', 'android/guava/src/com/google/common/base/Java8Usage.java', 'android/guava/src/com/google/common/base/MoreObjects.java', 'android/pom.xml', 'guava/pom.xml', 'guava/src/com/google/common/base/Java8Usage.java', 'guava/src/com/google/common/base/MoreObjects.java', 'pom.xml']","@@ -90,6 +90,42 @@
       </plugin>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <!--
+                 The execution named default-compile happens first, regardless
+                 of the order of the executions in the source file. So, because
+                 Java8Usage is a dependency of the main sources, we need to call
+                 its compilation ""default-compile,"" even though it's the special
+                 case.
+            -->
+            <id>default-compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <includes>
+                <include>**/Java8Usage.java</include>
+              </includes>
+              <!-- -source 8 -target 8 is a no-op in the mainline but matters in the backport. -->
+              <source>8</source>
+              <target>8</target>
+            </configuration>
+          </execution>
+          <execution>
+            <id>main-compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <excludes>
+                <exclude>**/Java8Usage.java</exclude>
+              </excludes>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
       <plugin>
         <artifactId>maven-source-plugin</artifactId>, @@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.base;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
+/**
+ * A class that uses a couple Java 8 features but doesn't really do anything. This lets us attempt
+ * to load it and log a warning if that fails, giving users advance notice of our dropping Java 8
+ * support.
+ */
+/*
+ * This class should be annotated @GwtCompatible. But if we annotate it @GwtCompatible, then we need
+ * to build GwtCompatible.java (-source 7 -target 7 in the Android flavor) before we build
+ * Java8Usage.java (-source 8 target 8, which we already need to build before the rest of
+ * common.base). We could configure Maven to do that, but it's easier to just skip the annotation.
+ */
+final class Java8Usage {
+  @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
+  private @interface SomeTypeAnnotation {}
+
+  @CanIgnoreReturnValue
+  static @SomeTypeAnnotation String performCheck() {
+    Runnable r = () -> {};
+    r.run();
+    return """";
+  }
+
+  private Java8Usage() {}
+}, @@ -15,10 +15,13 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.logging.Level.WARNING;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.Arrays;
+import java.util.logging.Logger;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
@@ -141,13 +144,46 @@ public static ToStringHelper toStringHelper(String className) {
    * @since 18.0 (since 2.0 as {@code Objects.ToStringHelper}).
    */
   public static final class ToStringHelper {
+    @GuardedBy(""ToStringHelper.class"")
+    private static boolean performedJava8CompatibilityCheck;
+
+    private static void java8CompatibilityCheck() {
+      @SuppressWarnings(""GuardedBy"")
+      boolean racyReadForDoubleCheckedLock = performedJava8CompatibilityCheck;
+      if (racyReadForDoubleCheckedLock) {
+        return;
+      }
+      synchronized (ToStringHelper.class) {
+        if (performedJava8CompatibilityCheck) {
+          return;
+        }
+        performedJava8CompatibilityCheck = true;
+      }
+
+      try {
+        Java8Usage.performCheck();
+      } catch (Throwable underlying) {
+        Exception toLog =
+            new Exception(
+                ""Guava will drop support for Java 7 in 2021. Please let us know if this will cause""
+                    + "" you problems: https://github.com/google/guava/issues/5269"",
+                underlying);
+        Logger.getLogger(ToStringHelper.class.getName())
+            .log(
+                WARNING,
+                ""Java 7 compatibility warning: See https://github.com/google/guava/issues/5269"",
+                toLog);
+      }
+    }
+
     private final String className;
     private final ValueHolder holderHead = new ValueHolder();
     private ValueHolder holderTail = holderHead;
     private boolean omitNullValues = false;
 
     /** Use {@link MoreObjects#toStringHelper(Object)} to create an instance. */
     private ToStringHelper(String className) {
+      java8CompatibilityCheck();
       this.className = checkNotNull(className);
     }
 , @@ -118,6 +118,16 @@
           <configuration>
             <source>1.7</source>
             <target>1.7</target>
+            <compilerArgs>
+              <!--
+                   Make includes/excludes fully work:
+                   https://issues.apache.org/jira/browse/MCOMPILER-174
+
+                   (Compare what guava-gwt has to do for maven-javadoc-plugin.)
+              -->
+              <arg>-sourcepath</arg>
+              <arg>doesnotexist</arg>
+            </compilerArgs>
           </configuration>
         </plugin>
         <plugin>, @@ -90,6 +90,42 @@
       </plugin>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <!--
+                 The execution named default-compile happens first, regardless
+                 of the order of the executions in the source file. So, because
+                 Java8Usage is a dependency of the main sources, we need to call
+                 its compilation ""default-compile,"" even though it's the special
+                 case.
+            -->
+            <id>default-compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <includes>
+                <include>**/Java8Usage.java</include>
+              </includes>
+              <!-- -source 8 -target 8 is a no-op in the mainline but matters in the backport. -->
+              <source>8</source>
+              <target>8</target>
+            </configuration>
+          </execution>
+          <execution>
+            <id>main-compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <excludes>
+                <exclude>**/Java8Usage.java</exclude>
+              </excludes>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
       <plugin>
         <artifactId>maven-source-plugin</artifactId>, @@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2020 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.base;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
+/**
+ * A class that uses a couple Java 8 features but doesn't really do anything. This lets us attempt
+ * to load it and log a warning if that fails, giving users advance notice of our dropping Java 8
+ * support.
+ */
+/*
+ * This class should be annotated @GwtCompatible. But if we annotate it @GwtCompatible, then we need
+ * to build GwtCompatible.java (-source 7 -target 7 in the Android flavor) before we build
+ * Java8Usage.java (-source 8 target 8, which we already need to build before the rest of
+ * common.base). We could configure Maven to do that, but it's easier to just skip the annotation.
+ */
+final class Java8Usage {
+  @java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)
+  @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
+  private @interface SomeTypeAnnotation {}
+
+  @CanIgnoreReturnValue
+  static @SomeTypeAnnotation String performCheck() {
+    Runnable r = () -> {};
+    r.run();
+    return """";
+  }
+
+  private Java8Usage() {}
+}, @@ -15,10 +15,13 @@
 package com.google.common.base;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.util.logging.Level.WARNING;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 import java.util.Arrays;
+import java.util.logging.Logger;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -141,13 +144,46 @@ public static ToStringHelper toStringHelper(String className) {
    * @since 18.0 (since 2.0 as {@code Objects.ToStringHelper}).
    */
   public static final class ToStringHelper {
+    @GuardedBy(""ToStringHelper.class"")
+    private static boolean performedJava8CompatibilityCheck;
+
+    private static void java8CompatibilityCheck() {
+      @SuppressWarnings(""GuardedBy"")
+      boolean racyReadForDoubleCheckedLock = performedJava8CompatibilityCheck;
+      if (racyReadForDoubleCheckedLock) {
+        return;
+      }
+      synchronized (ToStringHelper.class) {
+        if (performedJava8CompatibilityCheck) {
+          return;
+        }
+        performedJava8CompatibilityCheck = true;
+      }
+
+      try {
+        Java8Usage.performCheck();
+      } catch (Throwable underlying) {
+        Exception toLog =
+            new Exception(
+                ""Guava will drop support for Java 7 in 2021. Please let us know if this will cause""
+                    + "" you problems: https://github.com/google/guava/issues/5269"",
+                underlying);
+        Logger.getLogger(ToStringHelper.class.getName())
+            .log(
+                WARNING,
+                ""Java 7 compatibility warning: See https://github.com/google/guava/issues/5269"",
+                toLog);
+      }
+    }
+
     private final String className;
     private final ValueHolder holderHead = new ValueHolder();
     private ValueHolder holderTail = holderHead;
     private boolean omitNullValues = false;
 
     /** Use {@link MoreObjects#toStringHelper(Object)} to create an instance. */
     private ToStringHelper(String className) {
+      java8CompatibilityCheck();
       this.className = checkNotNull(className);
     }
 , @@ -119,6 +119,16 @@
           <configuration>
             <source>1.8</source>
             <target>1.8</target>
+            <compilerArgs>
+              <!--
+                   Make includes/excludes fully work:
+                   https://issues.apache.org/jira/browse/MCOMPILER-174
+
+                   (Compare what guava-gwt has to do for maven-javadoc-plugin.)
+              -->
+              <arg>-sourcepath</arg>
+              <arg>doesnotexist</arg>
+            </compilerArgs>
           </configuration>
         </plugin>
         <plugin>, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Correct a typo and some odd phrasing in the first paragraph of the javadoc for SmoothRateLimiter.

8d571ca36055d207635d84db4159607c511de649

-------

<p> Log a warning if running under a Java 7 VM.

More precisely, log a warning if lambda expressions or type annotations in our classes would produce an exception. If someone wants to use Retrolambda or a similar tool to rewrite our classes, that's fine with us if it works. And our support for Android is unchanged: The Android toolchain rewrites lambdas and removes type annotations.

This is a step toward removing Java 7 support entirely: https://github.com/google/guava/issues/5269

RELNOTES=Introduced a warning log message when running under Java 7. This warning is not _guaranteed_ to be logged when running under Java 7, so please don't rely on it as your only warning about future problems. If the warning _itself_ causes you trouble, you can eliminate it by silencing the logger for `com.google.common.base.MoreObjects$ToStringHelper` (which is used _only_ for this warning). This warning prepares for [removing support for Java 7 in 2021](https://github.com/google/guava/issues/5269). Please report any problems.

0357006a920c9cf84d47901471a525da85deba34",MOE Sync 2020-12-11
5355,Chris Povirk,"['README.md', 'android/guava/src/com/google/common/net/HttpHeaders.java', 'android/guava/src/com/google/common/reflect/ClassPath.java', 'android/guava/src/com/google/common/util/concurrent/ClosingFuture.java', 'guava-testlib/README.md', 'guava/src/com/google/common/net/HttpHeaders.java', 'guava/src/com/google/common/reflect/ClassPath.java', 'guava/src/com/google/common/util/concurrent/ClosingFuture.java']","@@ -23,7 +23,7 @@ Guava's Maven group ID is `com.google.guava`, and its artifact ID is `guava`.
 Guava provides two different ""flavors"": one for use on a (Java 8+) JRE and one
 for use on Android or Java 7 or by any library that wants to be compatible with
 either of those. These flavors are specified in the Maven version field as
-either `30.0-jre` or `30.0-android`. For more about depending on Guava, see
+either `30.1-jre` or `30.1-android`. For more about depending on Guava, see
 [using Guava in your build].
 
 To add a dependency on Guava using Maven, use the following:
@@ -32,9 +32,9 @@ To add a dependency on Guava using Maven, use the following:
 <dependency>
   <groupId>com.google.guava</groupId>
   <artifactId>guava</artifactId>
-  <version>30.0-jre</version>
+  <version>30.1-jre</version>
   <!-- or, for Android: -->
-  <version>30.0-android</version>
+  <version>30.1-android</version>
 </dependency>
 ```
 
@@ -45,16 +45,16 @@ dependencies {
   // Pick one:
 
   // 1. Use Guava in your implementation only:
-  implementation(""com.google.guava:guava:30.0-jre"")
+  implementation(""com.google.guava:guava:30.1-jre"")
 
   // 2. Use Guava types in your public API:
-  api(""com.google.guava:guava:30.0-jre"")
+  api(""com.google.guava:guava:30.1-jre"")
 
   // 3. Android - Use Guava in your implementation only:
-  implementation(""com.google.guava:guava:30.0-android"")
+  implementation(""com.google.guava:guava:30.1-android"")
 
   // 4. Android - Use Guava types in your public API:
-  api(""com.google.guava:guava:30.0-android"")
+  api(""com.google.guava:guava:30.1-android"")
 }
 ```
 , @@ -133,7 +133,7 @@ private HttpHeaders() {}
    * The HTTP <a href=""https://github.com/WICG/origin-isolation"">{@code Origin-Isolation}</a> header
    * field name.
    *
-   * @since NEXT
+   * @since 30.1
    */
   public static final String ORIGIN_ISOLATION = ""Origin-Isolation"";
   /** The HTTP {@code Proxy-Authorization} header field name. */
@@ -421,7 +421,7 @@ private ReferrerPolicyValues() {}
   /**
    * The HTTP {@code X-Request-ID} header field name.
    *
-   * @since NEXT
+   * @since 30.1
    */
   public static final String X_REQUEST_ID = ""X-Request-ID"";
   /** The HTTP {@code X-Requested-With} header field name. */, @@ -343,7 +343,7 @@ public String getName() {
      * named with the '$' character. If this is a concern, you could use {@link #load} and then
      * check on the loaded {@link Class} object instead.
      *
-     * @since NEXT
+     * @since 30.1
      */
     public boolean isTopLevel() {
       return className.indexOf('$') == -1;, @@ -264,7 +264,7 @@
    * An operation that computes a {@link ClosingFuture} of a result.
    *
    * @param <V> the type of the result
-   * @since NEXT
+   * @since 30.1
    */
   public interface AsyncClosingCallable<V extends Object> {
     /**
@@ -389,7 +389,7 @@ public void closeAsync() {
    *
    * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
    *     execution
-   * @since NEXT
+   * @since 30.1
    */
   public static <V> ClosingFuture<V> submitAsync(
       AsyncClosingCallable<V> callable, Executor executor) {, @@ -13,7 +13,7 @@ To add a dependency on Guava testlib using Maven, use the following:
 <dependency>
   <groupId>com.google.guava</groupId>
   <artifactId>guava-testlib</artifactId>
-  <version>30.0-jre</version>
+  <version>30.1-jre</version>
   <scope>test</scope>
 </dependency>
 ```
@@ -22,7 +22,7 @@ To add a dependency using Gradle:
 
 ```gradle
 dependencies {
-  test 'com.google.guava:guava-testlib:30.0-jre'
+  test 'com.google.guava:guava-testlib:30.1-jre'
 }
 ```
 , @@ -133,7 +133,7 @@ private HttpHeaders() {}
    * The HTTP <a href=""https://github.com/WICG/origin-isolation"">{@code Origin-Isolation}</a> header
    * field name.
    *
-   * @since NEXT
+   * @since 30.1
    */
   public static final String ORIGIN_ISOLATION = ""Origin-Isolation"";
   /** The HTTP {@code Proxy-Authorization} header field name. */
@@ -421,7 +421,7 @@ private ReferrerPolicyValues() {}
   /**
    * The HTTP {@code X-Request-ID} header field name.
    *
-   * @since NEXT
+   * @since 30.1
    */
   public static final String X_REQUEST_ID = ""X-Request-ID"";
   /** The HTTP {@code X-Requested-With} header field name. */, @@ -343,7 +343,7 @@ public String getName() {
      * named with the '$' character. If this is a concern, you could use {@link #load} and then
      * check on the loaded {@link Class} object instead.
      *
-     * @since NEXT
+     * @since 30.1
      */
     public boolean isTopLevel() {
       return className.indexOf('$') == -1;, @@ -261,7 +261,7 @@
    * An operation that computes a {@link ClosingFuture} of a result.
    *
    * @param <V> the type of the result
-   * @since NEXT
+   * @since 30.1
    */
   @FunctionalInterface
   public interface AsyncClosingCallable<V extends @Nullable Object> {
@@ -389,7 +389,7 @@ public void closeAsync() {
    *
    * @throws java.util.concurrent.RejectedExecutionException if the task cannot be scheduled for
    *     execution
-   * @since NEXT
+   * @since 30.1
    */
   public static <V> ClosingFuture<V> submitAsync(
       AsyncClosingCallable<V> callable, Executor executor) {, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Prepare for release 30.1.

81e941f66865d6bece7c3f09cde513a6cc50b858",MOE Sync 2020-12-14
5357,Colin Decker,['android/guava-testlib/test/com/google/common/util/concurrent/testing/TestingExecutorsTest.java'],"None, ","This code has been reviewed and submitted internally. Feel free to discuss on
the PR, and we can submit follow-up changes as necessary.

Commits:
=====
<p> Internal changes.

965731aaf97ab84a3af5c21db64e76152bcba744",MOE Sync 2020-12-16
5364,,['.travis.yml'],"@@ -25,7 +25,7 @@ after_failure:
 
 cache:
   directories:
-  - $HOME/.m2
+    - $HOME/.m2/repository
 
 env:
   global:, ","Cache only .m2/repository, not all of .m2.

Hopefully this will fix ""Could not find artifact org.apache.maven.plugins:maven-checkstyle-plugin:jar:3.1.1 in google-maven-central"" from https://github.com/google/guava/pull/5363

Compare CL 310633203 for Truth.

RELNOTES=n/a","Cache only .m2/repository, not all of .m2."
5373,,"['android/guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java', 'guava/src/com/google/thirdparty/publicsuffix/PublicSuffixPatterns.java']","None, None, ","Update Public Suffix data.

RELNOTES=n/a",Update Public Suffix data.
5415,,"['android/guava/src/com/google/common/collect/ImmutableSet.java', 'android/guava/src/com/google/common/io/BaseEncoding.java', 'android/guava/src/com/google/common/io/CharStreams.java', 'guava/src/com/google/common/collect/ImmutableSet.java', 'guava/src/com/google/common/io/BaseEncoding.java', 'guava/src/com/google/common/io/CharStreams.java']","@@ -318,7 +318,8 @@ boolean isHashCodeFast() {
   public boolean equals(@NullableDecl Object object) {
     if (object == this) {
       return true;
-    } else if (object instanceof ImmutableSet
+    }
+    if (object instanceof ImmutableSet
         && isHashCodeFast()
         && ((ImmutableSet<?>) object).isHashCodeFast()
         && hashCode() != object.hashCode()) {, @@ -190,11 +190,10 @@ public OutputStream openStream() throws IOException {
   private static byte[] extract(byte[] result, int length) {
     if (length == result.length) {
       return result;
-    } else {
-      byte[] trunc = new byte[length];
-      System.arraycopy(result, 0, trunc, 0, length);
-      return trunc;
     }
+    byte[] trunc = new byte[length];
+    System.arraycopy(result, 0, trunc, 0, length);
+    return trunc;
   }
 
   /**
@@ -517,27 +516,25 @@ private boolean hasUpperCase() {
     Alphabet upperCase() {
       if (!hasLowerCase()) {
         return this;
-      } else {
-        checkState(!hasUpperCase(), ""Cannot call upperCase() on a mixed-case alphabet"");
-        char[] upperCased = new char[chars.length];
-        for (int i = 0; i < chars.length; i++) {
-          upperCased[i] = Ascii.toUpperCase(chars[i]);
-        }
-        return new Alphabet(name + "".upperCase()"", upperCased);
       }
+      checkState(!hasUpperCase(), ""Cannot call upperCase() on a mixed-case alphabet"");
+      char[] upperCased = new char[chars.length];
+      for (int i = 0; i < chars.length; i++) {
+        upperCased[i] = Ascii.toUpperCase(chars[i]);
+      }
+      return new Alphabet(name + "".upperCase()"", upperCased);
     }
 
     Alphabet lowerCase() {
       if (!hasUpperCase()) {
         return this;
-      } else {
-        checkState(!hasLowerCase(), ""Cannot call lowerCase() on a mixed-case alphabet"");
-        char[] lowerCased = new char[chars.length];
-        for (int i = 0; i < chars.length; i++) {
-          lowerCased[i] = Ascii.toLowerCase(chars[i]);
-        }
-        return new Alphabet(name + "".lowerCase()"", lowerCased);
       }
+      checkState(!hasLowerCase(), ""Cannot call lowerCase() on a mixed-case alphabet"");
+      char[] lowerCased = new char[chars.length];
+      for (int i = 0; i < chars.length; i++) {
+        lowerCased[i] = Ascii.toLowerCase(chars[i]);
+      }
+      return new Alphabet(name + "".lowerCase()"", lowerCased);
     }
 
     public boolean matches(char c) {, @@ -77,19 +77,19 @@ public static long copy(Readable from, Appendable to) throws IOException {
       } else {
         return copyReaderToWriter((Reader) from, asWriter(to));
       }
-    } else {
-      checkNotNull(from);
-      checkNotNull(to);
-      long total = 0;
-      CharBuffer buf = createBuffer();
-      while (from.read(buf) != -1) {
-        Java8Compatibility.flip(buf);
-        to.append(buf);
-        total += buf.remaining();
-        Java8Compatibility.clear(buf);
-      }
-      return total;
     }
+
+    checkNotNull(from);
+    checkNotNull(to);
+    long total = 0;
+    CharBuffer buf = createBuffer();
+    while (from.read(buf) != -1) {
+      Java8Compatibility.flip(buf);
+      to.append(buf);
+      total += buf.remaining();
+      Java8Compatibility.clear(buf);
+    }
+    return total;
   }
 
   // TODO(lukes): consider allowing callers to pass in a buffer to use, some callers would be able, @@ -310,7 +310,8 @@ boolean isHashCodeFast() {
   public boolean equals(@Nullable Object object) {
     if (object == this) {
       return true;
-    } else if (object instanceof ImmutableSet
+    }
+    if (object instanceof ImmutableSet
         && isHashCodeFast()
         && ((ImmutableSet<?>) object).isHashCodeFast()
         && hashCode() != object.hashCode()) {, @@ -190,11 +190,10 @@ public OutputStream openStream() throws IOException {
   private static byte[] extract(byte[] result, int length) {
     if (length == result.length) {
       return result;
-    } else {
-      byte[] trunc = new byte[length];
-      System.arraycopy(result, 0, trunc, 0, length);
-      return trunc;
     }
+    byte[] trunc = new byte[length];
+    System.arraycopy(result, 0, trunc, 0, length);
+    return trunc;
   }
 
   /**
@@ -517,27 +516,25 @@ private boolean hasUpperCase() {
     Alphabet upperCase() {
       if (!hasLowerCase()) {
         return this;
-      } else {
-        checkState(!hasUpperCase(), ""Cannot call upperCase() on a mixed-case alphabet"");
-        char[] upperCased = new char[chars.length];
-        for (int i = 0; i < chars.length; i++) {
-          upperCased[i] = Ascii.toUpperCase(chars[i]);
-        }
-        return new Alphabet(name + "".upperCase()"", upperCased);
       }
+      checkState(!hasUpperCase(), ""Cannot call upperCase() on a mixed-case alphabet"");
+      char[] upperCased = new char[chars.length];
+      for (int i = 0; i < chars.length; i++) {
+        upperCased[i] = Ascii.toUpperCase(chars[i]);
+      }
+      return new Alphabet(name + "".upperCase()"", upperCased);
     }
 
     Alphabet lowerCase() {
       if (!hasUpperCase()) {
         return this;
-      } else {
-        checkState(!hasLowerCase(), ""Cannot call lowerCase() on a mixed-case alphabet"");
-        char[] lowerCased = new char[chars.length];
-        for (int i = 0; i < chars.length; i++) {
-          lowerCased[i] = Ascii.toLowerCase(chars[i]);
-        }
-        return new Alphabet(name + "".lowerCase()"", lowerCased);
       }
+      checkState(!hasLowerCase(), ""Cannot call lowerCase() on a mixed-case alphabet"");
+      char[] lowerCased = new char[chars.length];
+      for (int i = 0; i < chars.length; i++) {
+        lowerCased[i] = Ascii.toLowerCase(chars[i]);
+      }
+      return new Alphabet(name + "".lowerCase()"", lowerCased);
     }
 
     public boolean matches(char c) {, @@ -77,19 +77,19 @@ public static long copy(Readable from, Appendable to) throws IOException {
       } else {
         return copyReaderToWriter((Reader) from, asWriter(to));
       }
-    } else {
-      checkNotNull(from);
-      checkNotNull(to);
-      long total = 0;
-      CharBuffer buf = createBuffer();
-      while (from.read(buf) != -1) {
-        Java8Compatibility.flip(buf);
-        to.append(buf);
-        total += buf.remaining();
-        Java8Compatibility.clear(buf);
-      }
-      return total;
     }
+
+    checkNotNull(from);
+    checkNotNull(to);
+    long total = 0;
+    CharBuffer buf = createBuffer();
+    while (from.read(buf) != -1) {
+      Java8Compatibility.flip(buf);
+      to.append(buf);
+      total += buf.remaining();
+      Java8Compatibility.clear(buf);
+    }
+    return total;
   }
 
   // TODO(lukes): consider allowing callers to pass in a buffer to use, some callers would be able, ","Remove redundant `else` blocks.

Fixes #3974.

RELNOTES=n/a",Remove redundant `else` blocks.
5431,,"['android/guava/src/com/google/common/util/concurrent/AggregateFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFuture.java']","@@ -222,11 +222,12 @@ private void handleException(Throwable throwable) {
     }
   }
 
-  private static void log(Throwable throwable) {
+  private void log(Throwable throwable) {
     String message =
         (throwable instanceof Error)
             ? ""Input Future failed with Error""
-            : ""Got more than one input Future failure. Logging failures after the first"";
+            : ""An additional input failed after the first. Logging it after adding the first""
+                + "" failure as a suppressed exception."";
     logger.log(SEVERE, message, throwable);
   }
 , @@ -222,11 +222,12 @@ private void handleException(Throwable throwable) {
     }
   }
 
-  private static void log(Throwable throwable) {
+  private void log(Throwable throwable) {
     String message =
         (throwable instanceof Error)
             ? ""Input Future failed with Error""
-            : ""Got more than one input Future failure. Logging failures after the first"";
+            : ""An additional input failed after the first. Logging it after adding the first""
+                + "" failure as a suppressed exception."";
     logger.log(SEVERE, message, throwable);
   }
 , ","Internal change.

RELNOTES=n/a",Internal change.
5436,,"['README.md', 'guava-testlib/README.md']","@@ -23,7 +23,7 @@ Guava's Maven group ID is `com.google.guava`, and its artifact ID is `guava`.
 Guava provides two different ""flavors"": one for use on a (Java 8+) JRE and one
 for use on Android or Java 7 or by any library that wants to be compatible with
 either of those. These flavors are specified in the Maven version field as
-either `30.1-jre` or `30.1-android`. For more about depending on Guava, see
+either `30.1.1-jre` or `30.1.1-android`. For more about depending on Guava, see
 [using Guava in your build].
 
 To add a dependency on Guava using Maven, use the following:
@@ -32,9 +32,9 @@ To add a dependency on Guava using Maven, use the following:
 <dependency>
   <groupId>com.google.guava</groupId>
   <artifactId>guava</artifactId>
-  <version>30.1-jre</version>
+  <version>30.1.1-jre</version>
   <!-- or, for Android: -->
-  <version>30.1-android</version>
+  <version>30.1.1-android</version>
 </dependency>
 ```
 
@@ -45,16 +45,16 @@ dependencies {
   // Pick one:
 
   // 1. Use Guava in your implementation only:
-  implementation(""com.google.guava:guava:30.1-jre"")
+  implementation(""com.google.guava:guava:30.1.1-jre"")
 
   // 2. Use Guava types in your public API:
-  api(""com.google.guava:guava:30.1-jre"")
+  api(""com.google.guava:guava:30.1.1-jre"")
 
   // 3. Android - Use Guava in your implementation only:
-  implementation(""com.google.guava:guava:30.1-android"")
+  implementation(""com.google.guava:guava:30.1.1-android"")
 
   // 4. Android - Use Guava types in your public API:
-  api(""com.google.guava:guava:30.1-android"")
+  api(""com.google.guava:guava:30.1.1-android"")
 }
 ```
 , @@ -13,7 +13,7 @@ To add a dependency on Guava testlib using Maven, use the following:
 <dependency>
   <groupId>com.google.guava</groupId>
   <artifactId>guava-testlib</artifactId>
-  <version>30.1-jre</version>
+  <version>30.1.1-jre</version>
   <scope>test</scope>
 </dependency>
 ```
@@ -22,7 +22,7 @@ To add a dependency using Gradle:
 
 ```gradle
 dependencies {
-  test 'com.google.guava:guava-testlib:30.1-jre'
+  test 'com.google.guava:guava-testlib:30.1.1-jre'
 }
 ```
 , ","Prepare for release 30.1.1.

RELNOTES=n/a",Prepare for release 30.1.1.
5437,,['README.md'],"@@ -111,10 +111,10 @@ flavor.
 5.  Our classes are not designed to protect against a malicious caller. You
     should not use them for communication between trusted and untrusted code.
 
-6.  For the mainline flavor, we unit-test the libraries using only OpenJDK 1.8
-    on Linux. Some features, especially in `com.google.common.io`, may not work
-    correctly in other environments. For the Android flavor, our unit tests run
-    on API level 15 (Ice Cream Sandwich).
+6.  For the mainline flavor, we test the libraries using only OpenJDK 8 and
+    OpenJDK 11 on Linux. Some features, especially in `com.google.common.io`,
+    may not work correctly in other environments. For the Android flavor, our
+    unit tests also run on API level 15 (Ice Cream Sandwich).
 
 [guava-snapshot-api-docs]: https://guava.dev/releases/snapshot-jre/api/docs/
 [guava-snapshot-api-diffs]: https://guava.dev/releases/snapshot-jre/api/diffs/, ","Document that we test under both JDK8 and JDK11 (and that we do that for the Android flavor, too).

RELNOTES=n/a","Document that we test under both JDK8 and JDK11 (and that we do that for the Android flavor, too)."
5443,,['README.md'],"@@ -101,8 +101,10 @@ flavor.
     plans to start removing things again, but officially, we're leaving our
     options open in case of surprises (like, say, a serious security problem).
 
-3.  Guava has one dependency that is needed at runtime:
-    `com.google.guava:failureaccess:1.0.1`
+3.  Guava has one dependency that is needed for linkage at runtime:
+    `com.google.guava:failureaccess:1.0.1`. It also has
+    [some annotation-only dependencies][guava-deps], which we discuss in more
+    detail at that link.
 
 4.  Serialized forms of ALL objects are subject to change unless noted
     otherwise. Do not persist these and assume they can be read by a future
@@ -125,3 +127,4 @@ flavor.
 
 [using Guava in your build]: https://github.com/google/guava/wiki/UseGuavaInYourBuild
 [repackage]: https://github.com/google/guava/wiki/UseGuavaInYourBuild#what-if-i-want-to-use-beta-apis-from-a-library-that-people-use-as-a-dependency
+[guava-deps]: https://github.com/google/guava/wiki/UseGuavaInYourBuild#what-about-guavas-own-dependencies, ","Clarify docs about annotation-only dependencies.

RELNOTES=n/a",Clarify docs about annotation-only dependencies.
5452,,"['android/guava/src/com/google/common/graph/ForwardingGraph.java', 'android/guava/src/com/google/common/graph/ForwardingNetwork.java', 'android/guava/src/com/google/common/graph/ForwardingValueGraph.java', 'android/guava/src/com/google/common/graph/Graphs.java', 'android/guava/src/com/google/common/graph/ImmutableGraph.java', 'android/guava/src/com/google/common/graph/StandardMutableGraph.java', 'guava/src/com/google/common/graph/ForwardingGraph.java', 'guava/src/com/google/common/graph/ForwardingNetwork.java', 'guava/src/com/google/common/graph/ForwardingValueGraph.java', 'guava/src/com/google/common/graph/Graphs.java', 'guava/src/com/google/common/graph/ImmutableGraph.java', 'guava/src/com/google/common/graph/StandardMutableGraph.java']","@@ -26,7 +26,7 @@
  */
 abstract class ForwardingGraph<N> extends AbstractGraph<N> {
 
-  protected abstract BaseGraph<N> delegate();
+  abstract BaseGraph<N> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -27,7 +27,7 @@
  */
 abstract class ForwardingNetwork<N, E> extends AbstractNetwork<N, E> {
 
-  protected abstract Network<N, E> delegate();
+  abstract Network<N, E> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -28,7 +28,7 @@
  */
 abstract class ForwardingValueGraph<N, V> extends AbstractValueGraph<N, V> {
 
-  protected abstract ValueGraph<N, V> delegate();
+  abstract ValueGraph<N, V> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -265,7 +265,7 @@ private static boolean canTraverseWithoutReusingEdge(
     }
 
     @Override
-    protected Graph<N> delegate() {
+    Graph<N> delegate() {
       return graph;
     }
 
@@ -327,7 +327,7 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
     }
 
     @Override
-    protected ValueGraph<N, V> delegate() {
+    ValueGraph<N, V> delegate() {
       return graph;
     }
 
@@ -382,7 +382,7 @@ public V edgeValueOrDefault(EndpointPair<N> endpoints, @NullableDecl V defaultVa
     }
 
     @Override
-    protected Network<N, E> delegate() {
+    Network<N, E> delegate() {
       return network;
     }
 , @@ -100,7 +100,7 @@
   }
 
   @Override
-  protected BaseGraph<N> delegate() {
+  BaseGraph<N> delegate() {
     return backingGraph;
   }
 , @@ -37,7 +37,7 @@
   }
 
   @Override
-  protected BaseGraph<N> delegate() {
+  BaseGraph<N> delegate() {
     return backingValueGraph;
   }
 , @@ -26,7 +26,7 @@
  */
 abstract class ForwardingGraph<N> extends AbstractGraph<N> {
 
-  protected abstract BaseGraph<N> delegate();
+  abstract BaseGraph<N> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -28,7 +28,7 @@
  */
 abstract class ForwardingNetwork<N, E> extends AbstractNetwork<N, E> {
 
-  protected abstract Network<N, E> delegate();
+  abstract Network<N, E> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -29,7 +29,7 @@
  */
 abstract class ForwardingValueGraph<N, V> extends AbstractValueGraph<N, V> {
 
-  protected abstract ValueGraph<N, V> delegate();
+  abstract ValueGraph<N, V> delegate();
 
   @Override
   public Set<N> nodes() {, @@ -263,7 +263,7 @@ private static boolean canTraverseWithoutReusingEdge(
     }
 
     @Override
-    protected Graph<N> delegate() {
+    Graph<N> delegate() {
       return graph;
     }
 
@@ -325,7 +325,7 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
     }
 
     @Override
-    protected ValueGraph<N, V> delegate() {
+    ValueGraph<N, V> delegate() {
       return graph;
     }
 
@@ -388,7 +388,7 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {
     }
 
     @Override
-    protected Network<N, E> delegate() {
+    Network<N, E> delegate() {
       return network;
     }
 , @@ -100,7 +100,7 @@
   }
 
   @Override
-  protected BaseGraph<N> delegate() {
+  BaseGraph<N> delegate() {
     return backingGraph;
   }
 , @@ -37,7 +37,7 @@
   }
 
   @Override
-  protected BaseGraph<N> delegate() {
+  BaseGraph<N> delegate() {
     return backingValueGraph;
   }
 , ","Mark `Abstract*.delegate` methods in `graph` as package-private.

The method was exposing the package-private `BaseGraph` type through the public type `ImmutableGraph`.

(But it was exposing it only as `protected`, and no one could subclass `ImmutableGraph` outside the package. So this should be mostly academic.)

Fixes https://github.com/google/guava/issues/5450

RELNOTES=n/a",Mark `Abstract*.delegate` methods in `graph` as package-private.
5486,,"['android/guava/src/com/google/common/base/Converter.java', 'android/guava/src/com/google/common/base/NullnessCasts.java', 'guava/src/com/google/common/base/Converter.java', 'guava/src/com/google/common/base/NullnessCasts.java']","@@ -14,6 +14,7 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -23,7 +24,7 @@
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}
@@ -113,11 +114,36 @@
  * @since 16.0
  */
 @GwtCompatible
+@ElementTypesAreNonnullByDefault
+/*
+ * 1. The type parameter is <T> rather than <T extends @Nullable> so that we can use T in the
+ * doForward and doBackward methods to indicate that the parameter cannot be null. (We also take
+ * advantage of that for convertAll, as discussed on that method.)
+ *
+ * 2. The supertype of this class could be `Function<@Nullable A, @Nullable B>`, since
+ * Converter.apply (like Converter.convert) is capable of accepting null inputs. However, a
+ * supertype of `Function<A, B>` turns out to be massively more useful to callers in practice: They
+ * want their output to be non-null in operations like `stream.map(myConverter)`, and we can
+ * guarantee that as long as we also require the input type to be non-null[*] (which is a
+ * requirement that existing callers already fulfill).
+ *
+ * Disclaimer: Part of the reason that callers are so well adapted to `Function<A, B>` may be that
+ * that is how the signature looked even prior to this comment! So naturally any change can break
+ * existing users, but it can't *fix* existing users because any users who needed
+ * `Function<@Nullable A, @Nullable B>` already had to find a workaround. Still, there is a *ton* of
+ * fallout from trying to switch. I would be shocked if the switch would offer benefits to anywhere
+ * near enough users to justify the costs.
+ *
+ * Fortunately, if anyone does want to use a Converter as a `Function<@Nullable A, @Nullable B>`,
+ * it's easy to get one: `converter::convert`.
+ *
+ * [*] In annotating this class, we're ignoring LegacyConverter.
+ */
 public abstract class Converter<A, B> implements Function<A, B> {
   private final boolean handleNullAutomatically;
 
   // We lazily cache the reverse view to avoid allocating on every call to reverse().
-  @LazyInit @RetainedWith @NullableDecl private transient Converter<B, A> reverse;
+  @LazyInit @RetainedWith @CheckForNull private transient Converter<B, A> reverse;
 
   /** Constructor for use by subclasses. */
   protected Converter() {
@@ -164,31 +190,67 @@ protected Converter() {
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
   @CanIgnoreReturnValue
-  @NullableDecl
-  public final B convert(@NullableDecl A a) {
+  @CheckForNull
+  public final B convert(@CheckForNull A a) {
     return correctedDoForward(a);
   }
 
-  @NullableDecl
-  B correctedDoForward(@NullableDecl A a) {
+  @CheckForNull
+  B correctedDoForward(@CheckForNull A a) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return a == null ? null : checkNotNull(doForward(a));
     } else {
-      return doForward(a);
+      return unsafeDoForward(a);
     }
   }
 
-  @NullableDecl
-  A correctedDoBackward(@NullableDecl B b) {
+  @CheckForNull
+  A correctedDoBackward(@CheckForNull B b) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return b == null ? null : checkNotNull(doBackward(b));
     } else {
-      return doBackward(b);
+      return unsafeDoBackward(b);
     }
   }
 
+  /*
+   * LegacyConverter violates the contract of Converter by allowing its doForward and doBackward
+   * methods to accept null. We could avoid having unchecked casts in Converter.java itself if we
+   * could perform a cast to LegacyConverter, but we can't because it's an internal-only class.
+   *
+   * TODO(cpovirk): So make it part of the open-source build, albeit package-private there?
+   *
+   * So we use uncheckedCastNullableTToT here. This is a weird usage of that method: The method is
+   * documented as being for use with type parameters that have parametric nullness. But Converter's
+   * type parameters do not. Still, we use it here so that we can suppress a warning at a smaller
+   * level than the whole method but without performing a runtime null check. That way, we can still
+   * pass null inputs to LegacyConverter, and it can violate the contract of Converter.
+   *
+   * TODO(cpovirk): Could this be simplified if we modified implementations of LegacyConverter to
+   * override methods (probably called ""unsafeDoForward"" and ""unsafeDoBackward"") with the same
+   * signatures as the methods below, rather than overriding the same doForward and doBackward
+   * methods as implementations of normal converters do?
+   *
+   * But no matter what we do, it's worth remembering that the resulting code is going to be unsound
+   * in the presence of LegacyConverter, at least in the case of Converter.apply and convertAll (and
+   * for any checkers that apply @PolyNull-like semantics to Converter.convert). So maybe we don't
+   * want to think too hard about how to prevent our checkers from issuing errors related to
+   * LegacyConverter, since it turns out that LegacyConverter does violate the assumptions we make
+   * elsewhere.
+   */
+
+  @CheckForNull
+  private B unsafeDoForward(@CheckForNull A a) {
+    return doForward(uncheckedCastNullableTToT(a));
+  }
+
+  @CheckForNull
+  private A unsafeDoBackward(@CheckForNull B b) {
+    return doBackward(uncheckedCastNullableTToT(b));
+  }
+
   /**
    * Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The
    * conversion is done lazily.
@@ -198,6 +260,16 @@ A correctedDoBackward(@NullableDecl B b) {
    * element.
    */
   @CanIgnoreReturnValue
+  /*
+   * Just as Converter could implement `Function<@Nullable A, @Nullable B>` instead of `Function<A,
+   * B>`, convertAll could accept and return iterables with nullable element types. In both cases,
+   * we've chosen to instead use a signature that benefits existing users -- and is still safe.
+   *
+   * For convertAll, I haven't looked as closely at *how* much existing users benefit, so we should
+   * keep an eye out for problems that new users encounter. Note also that convertAll could support
+   * both use cases by using @PolyNull. (By contrast, we can't use @PolyNull for our superinterface
+   * (`implements Function<@PolyNull A, @PolyNull B>`), at least as far as I know.)
+   */
   public Iterable<B> convertAll(final Iterable<? extends A> fromIterable) {
     checkNotNull(fromIterable, ""fromIterable"");
     return new Iterable<B>() {
@@ -212,6 +284,8 @@ public boolean hasNext() {
           }
 
           @Override
+          @SuppressWarnings(""nullness"") // See code comments on convertAll and Converter.apply.
+          @CheckForNull
           public B next() {
             return convert(fromIterator.next());
           }
@@ -265,14 +339,14 @@ protected B doBackward(A a) {
     }
 
     @Override
-    @NullableDecl
-    A correctedDoForward(@NullableDecl B b) {
+    @CheckForNull
+    A correctedDoForward(@CheckForNull B b) {
       return original.correctedDoBackward(b);
     }
 
     @Override
-    @NullableDecl
-    B correctedDoBackward(@NullableDecl A a) {
+    @CheckForNull
+    B correctedDoBackward(@CheckForNull A a) {
       return original.correctedDoForward(a);
     }
 
@@ -282,7 +356,7 @@ B correctedDoBackward(@NullableDecl A a) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof ReverseConverter) {
         ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;
         return this.original.equals(that.original);
@@ -347,19 +421,19 @@ protected A doBackward(C c) {
     }
 
     @Override
-    @NullableDecl
-    C correctedDoForward(@NullableDecl A a) {
+    @CheckForNull
+    C correctedDoForward(@CheckForNull A a) {
       return second.correctedDoForward(first.correctedDoForward(a));
     }
 
     @Override
-    @NullableDecl
-    A correctedDoBackward(@NullableDecl C c) {
+    @CheckForNull
+    A correctedDoBackward(@CheckForNull C c) {
       return first.correctedDoBackward(second.correctedDoBackward(c));
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof ConverterComposition) {
         ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;
         return this.first.equals(that.first) && this.second.equals(that.second);
@@ -386,8 +460,39 @@ public String toString() {
   @Deprecated
   @Override
   @CanIgnoreReturnValue
-  @NullableDecl
-  public final B apply(@NullableDecl A a) {
+  /*
+   * Even though we implement `Function<A, B>` instead of `Function<@Nullable A, @Nullable B>` (as
+   * discussed in a code comment at the top of the class), we declare our override of Function.apply
+   * to accept and return null. This requires a suppression, but it's safe:
+   *
+   * - Callers who use Converter as a Function<A, B> will neither pass null nor have it returned to
+   *   them. (Or, if they're not using nullness checking, they might be able to pass null and thus
+   *   have null returned to them. But our signature isn't making their existing nullness type error
+   *   any worse.)
+   * - In the relatively unlikely event that anyone calls Converter.apply directly, that caller is
+   *   allowed to pass null but is also forced to deal with a potentially null return.
+   * - Perhaps more important than actual *callers* of this method are various tools that look at
+   *   bytecode. Notably, NullPointerTester expects a method to throw NPE when passed null unless it
+   *   is annotated in a way that identifies its parameter type as potentially including null. (And
+   *   this method does not throw NPE -- nor do we want to enact a dangerous change to make it begin
+   *   doing so.) We can even imagine tools that rewrite bytecode to insert null checks before and
+   *   after calling methods with allegedly non-nullable parameters[*]. If we didn't annotate the
+   *   parameter and return type here, then anyone who used such a tool (and managed to pass null to
+   *   this method, presumably because that user doesn't run a normal nullness checker) could see
+   *   NullPointerException.
+   *
+   * [*] Granted, such tools could conceivably be smart enough to recognize that the apply() method
+   * on a a Function<Foo, Bar> should never allow null inputs and never produce null outputs even if
+   * this specific subclass claims otherwise. Such tools might still produce NPE for calls to this
+   * method. And that is one reason that we should be nervous about ""lying"" by extending Function<A,
+   * B> in the first place. But for now, we're giving it a try, since extending Function<@Nullable
+   * A, @Nullable B> will cause issues *today*, whereas extending Function<A, B> causes problems in
+   * various hypothetical futures. (Plus, a tool that were that smart would likely already introduce
+   * problems with LegacyConverter.)
+   */
+  @SuppressWarnings(""nullness"")
+  @CheckForNull
+  public final B apply(@CheckForNull A a) {
     return convert(a);
   }
 
@@ -403,7 +508,7 @@ public final B apply(@NullableDecl A a) {
    * interchangeable.
    */
   @Override
-  public boolean equals(@NullableDecl Object object) {
+  public boolean equals(@CheckForNull Object object) {
     return super.equals(object);
   }
 
@@ -452,7 +557,7 @@ protected A doBackward(B b) {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof FunctionBasedConverter) {
         FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;
         return this.forwardFunction.equals(that.forwardFunction), @@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.base;
+
+import com.google.common.annotations.GwtCompatible;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+/** A utility method to perform unchecked casts to suppress errors produced by nullness analyses. */
+@GwtCompatible
+@ElementTypesAreNonnullByDefault
+final class NullnessCasts {
+  /**
+   * Accepts a {@code @Nullable T} and returns a plain {@code T}, without performing any check that
+   * that conversion is safe.
+   *
+   * <p>This method is intended to help with usages of type parameters that have {@linkplain
+   * ParametricNullness parametric nullness}. If a type parameter instead ranges over only non-null
+   * types (or if the type is a non-variable type, like {@code String}), then code should almost
+   * never use this method, preferring instead to call {@code requireNonNull} so as to benefit from
+   * its runtime check.
+   *
+   * <p>An example use case for this method is in implementing an {@code Iterator<T>} whose {@code
+   * next} field is lazily initialized. The type of that field would be {@code @Nullable T}, and the
+   * code would be responsible for populating a ""real"" {@code T} (which might still be the value
+   * {@code null}!) before returning it to callers. Depending on how the code is structured, a
+   * nullness analysis might not understand that the field has been populated. To avoid that problem
+   * without having to add {@code @SuppressWarnings}, the code can call this method.
+   *
+   * <p>Why <i>not</i> just add {@code SuppressWarnings}? The problem is that this method is
+   * typically useful for {@code return} statements. That leaves the code with two options: Either
+   * add the suppression to the whole method (which turns off checking for a large section of code),
+   * or extract a variable, and put the suppression on that. However, a local variable typically
+   * doesn't work: Because nullness analyses typically infer the nullness of local variables,
+   * there's no way to assign a {@code @Nullable T} to a field {@code T foo;} and instruct the
+   * analysis that that means ""plain {@code T}"" rather than the inferred type {@code @Nullable T}.
+   * (Even if supported added {@code @NonNull}, that would not help, since the problem case
+   * addressed by this method is the case in which {@code T} has parametric nullness -- and thus its
+   * value may be legitimately {@code null}.)
+   */
+  @ParametricNullness
+  @SuppressWarnings(""nullness"")
+  static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
+    return t;
+  }
+
+  private NullnessCasts() {}
+}, @@ -14,6 +14,7 @@
 
 package com.google.common.base;
 
+import static com.google.common.base.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -23,7 +24,7 @@
 import com.google.j2objc.annotations.RetainedWith;
 import java.io.Serializable;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A function from {@code A} to {@code B} with an associated <i>reverse</i> function from {@code B}
@@ -113,11 +114,36 @@
  * @since 16.0
  */
 @GwtCompatible
+@ElementTypesAreNonnullByDefault
+/*
+ * 1. The type parameter is <T> rather than <T extends @Nullable> so that we can use T in the
+ * doForward and doBackward methods to indicate that the parameter cannot be null. (We also take
+ * advantage of that for convertAll, as discussed on that method.)
+ *
+ * 2. The supertype of this class could be `Function<@Nullable A, @Nullable B>`, since
+ * Converter.apply (like Converter.convert) is capable of accepting null inputs. However, a
+ * supertype of `Function<A, B>` turns out to be massively more useful to callers in practice: They
+ * want their output to be non-null in operations like `stream.map(myConverter)`, and we can
+ * guarantee that as long as we also require the input type to be non-null[*] (which is a
+ * requirement that existing callers already fulfill).
+ *
+ * Disclaimer: Part of the reason that callers are so well adapted to `Function<A, B>` may be that
+ * that is how the signature looked even prior to this comment! So naturally any change can break
+ * existing users, but it can't *fix* existing users because any users who needed
+ * `Function<@Nullable A, @Nullable B>` already had to find a workaround. Still, there is a *ton* of
+ * fallout from trying to switch. I would be shocked if the switch would offer benefits to anywhere
+ * near enough users to justify the costs.
+ *
+ * Fortunately, if anyone does want to use a Converter as a `Function<@Nullable A, @Nullable B>`,
+ * it's easy to get one: `converter::convert`.
+ *
+ * [*] In annotating this class, we're ignoring LegacyConverter.
+ */
 public abstract class Converter<A, B> implements Function<A, B> {
   private final boolean handleNullAutomatically;
 
   // We lazily cache the reverse view to avoid allocating on every call to reverse().
-  @LazyInit @RetainedWith private transient @Nullable Converter<B, A> reverse;
+  @LazyInit @RetainedWith @CheckForNull private transient Converter<B, A> reverse;
 
   /** Constructor for use by subclasses. */
   protected Converter() {
@@ -164,30 +190,67 @@ protected Converter() {
    * @return the converted value; is null <i>if and only if</i> {@code a} is null
    */
   @CanIgnoreReturnValue
-  public final @Nullable B convert(@Nullable A a) {
+  @CheckForNull
+  public final B convert(@CheckForNull A a) {
     return correctedDoForward(a);
   }
 
-  @Nullable
-  B correctedDoForward(@Nullable A a) {
+  @CheckForNull
+  B correctedDoForward(@CheckForNull A a) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return a == null ? null : checkNotNull(doForward(a));
     } else {
-      return doForward(a);
+      return unsafeDoForward(a);
     }
   }
 
-  @Nullable
-  A correctedDoBackward(@Nullable B b) {
+  @CheckForNull
+  A correctedDoBackward(@CheckForNull B b) {
     if (handleNullAutomatically) {
       // TODO(kevinb): we shouldn't be checking for a null result at runtime. Assert?
       return b == null ? null : checkNotNull(doBackward(b));
     } else {
-      return doBackward(b);
+      return unsafeDoBackward(b);
     }
   }
 
+  /*
+   * LegacyConverter violates the contract of Converter by allowing its doForward and doBackward
+   * methods to accept null. We could avoid having unchecked casts in Converter.java itself if we
+   * could perform a cast to LegacyConverter, but we can't because it's an internal-only class.
+   *
+   * TODO(cpovirk): So make it part of the open-source build, albeit package-private there?
+   *
+   * So we use uncheckedCastNullableTToT here. This is a weird usage of that method: The method is
+   * documented as being for use with type parameters that have parametric nullness. But Converter's
+   * type parameters do not. Still, we use it here so that we can suppress a warning at a smaller
+   * level than the whole method but without performing a runtime null check. That way, we can still
+   * pass null inputs to LegacyConverter, and it can violate the contract of Converter.
+   *
+   * TODO(cpovirk): Could this be simplified if we modified implementations of LegacyConverter to
+   * override methods (probably called ""unsafeDoForward"" and ""unsafeDoBackward"") with the same
+   * signatures as the methods below, rather than overriding the same doForward and doBackward
+   * methods as implementations of normal converters do?
+   *
+   * But no matter what we do, it's worth remembering that the resulting code is going to be unsound
+   * in the presence of LegacyConverter, at least in the case of Converter.apply and convertAll (and
+   * for any checkers that apply @PolyNull-like semantics to Converter.convert). So maybe we don't
+   * want to think too hard about how to prevent our checkers from issuing errors related to
+   * LegacyConverter, since it turns out that LegacyConverter does violate the assumptions we make
+   * elsewhere.
+   */
+
+  @CheckForNull
+  private B unsafeDoForward(@CheckForNull A a) {
+    return doForward(uncheckedCastNullableTToT(a));
+  }
+
+  @CheckForNull
+  private A unsafeDoBackward(@CheckForNull B b) {
+    return doBackward(uncheckedCastNullableTToT(b));
+  }
+
   /**
    * Returns an iterable that applies {@code convert} to each element of {@code fromIterable}. The
    * conversion is done lazily.
@@ -197,6 +260,16 @@ A correctedDoBackward(@Nullable B b) {
    * element.
    */
   @CanIgnoreReturnValue
+  /*
+   * Just as Converter could implement `Function<@Nullable A, @Nullable B>` instead of `Function<A,
+   * B>`, convertAll could accept and return iterables with nullable element types. In both cases,
+   * we've chosen to instead use a signature that benefits existing users -- and is still safe.
+   *
+   * For convertAll, I haven't looked as closely at *how* much existing users benefit, so we should
+   * keep an eye out for problems that new users encounter. Note also that convertAll could support
+   * both use cases by using @PolyNull. (By contrast, we can't use @PolyNull for our superinterface
+   * (`implements Function<@PolyNull A, @PolyNull B>`), at least as far as I know.)
+   */
   public Iterable<B> convertAll(final Iterable<? extends A> fromIterable) {
     checkNotNull(fromIterable, ""fromIterable"");
     return new Iterable<B>() {
@@ -211,6 +284,8 @@ public boolean hasNext() {
           }
 
           @Override
+          @SuppressWarnings(""nullness"") // See code comments on convertAll and Converter.apply.
+          @CheckForNull
           public B next() {
             return convert(fromIterator.next());
           }
@@ -264,14 +339,14 @@ protected B doBackward(A a) {
     }
 
     @Override
-    @Nullable
-    A correctedDoForward(@Nullable B b) {
+    @CheckForNull
+    A correctedDoForward(@CheckForNull B b) {
       return original.correctedDoBackward(b);
     }
 
     @Override
-    @Nullable
-    B correctedDoBackward(@Nullable A a) {
+    @CheckForNull
+    B correctedDoBackward(@CheckForNull A a) {
       return original.correctedDoForward(a);
     }
 
@@ -281,7 +356,7 @@ B correctedDoBackward(@Nullable A a) {
     }
 
     @Override
-    public boolean equals(@Nullable Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof ReverseConverter) {
         ReverseConverter<?, ?> that = (ReverseConverter<?, ?>) object;
         return this.original.equals(that.original);
@@ -346,19 +421,19 @@ protected A doBackward(C c) {
     }
 
     @Override
-    @Nullable
-    C correctedDoForward(@Nullable A a) {
+    @CheckForNull
+    C correctedDoForward(@CheckForNull A a) {
       return second.correctedDoForward(first.correctedDoForward(a));
     }
 
     @Override
-    @Nullable
-    A correctedDoBackward(@Nullable C c) {
+    @CheckForNull
+    A correctedDoBackward(@CheckForNull C c) {
       return first.correctedDoBackward(second.correctedDoBackward(c));
     }
 
     @Override
-    public boolean equals(@Nullable Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof ConverterComposition) {
         ConverterComposition<?, ?, ?> that = (ConverterComposition<?, ?, ?>) object;
         return this.first.equals(that.first) && this.second.equals(that.second);
@@ -385,7 +460,39 @@ public String toString() {
   @Deprecated
   @Override
   @CanIgnoreReturnValue
-  public final @Nullable B apply(@Nullable A a) {
+  /*
+   * Even though we implement `Function<A, B>` instead of `Function<@Nullable A, @Nullable B>` (as
+   * discussed in a code comment at the top of the class), we declare our override of Function.apply
+   * to accept and return null. This requires a suppression, but it's safe:
+   *
+   * - Callers who use Converter as a Function<A, B> will neither pass null nor have it returned to
+   *   them. (Or, if they're not using nullness checking, they might be able to pass null and thus
+   *   have null returned to them. But our signature isn't making their existing nullness type error
+   *   any worse.)
+   * - In the relatively unlikely event that anyone calls Converter.apply directly, that caller is
+   *   allowed to pass null but is also forced to deal with a potentially null return.
+   * - Perhaps more important than actual *callers* of this method are various tools that look at
+   *   bytecode. Notably, NullPointerTester expects a method to throw NPE when passed null unless it
+   *   is annotated in a way that identifies its parameter type as potentially including null. (And
+   *   this method does not throw NPE -- nor do we want to enact a dangerous change to make it begin
+   *   doing so.) We can even imagine tools that rewrite bytecode to insert null checks before and
+   *   after calling methods with allegedly non-nullable parameters[*]. If we didn't annotate the
+   *   parameter and return type here, then anyone who used such a tool (and managed to pass null to
+   *   this method, presumably because that user doesn't run a normal nullness checker) could see
+   *   NullPointerException.
+   *
+   * [*] Granted, such tools could conceivably be smart enough to recognize that the apply() method
+   * on a a Function<Foo, Bar> should never allow null inputs and never produce null outputs even if
+   * this specific subclass claims otherwise. Such tools might still produce NPE for calls to this
+   * method. And that is one reason that we should be nervous about ""lying"" by extending Function<A,
+   * B> in the first place. But for now, we're giving it a try, since extending Function<@Nullable
+   * A, @Nullable B> will cause issues *today*, whereas extending Function<A, B> causes problems in
+   * various hypothetical futures. (Plus, a tool that were that smart would likely already introduce
+   * problems with LegacyConverter.)
+   */
+  @SuppressWarnings(""nullness"")
+  @CheckForNull
+  public final B apply(@CheckForNull A a) {
     return convert(a);
   }
 
@@ -401,7 +508,7 @@ public String toString() {
    * interchangeable.
    */
   @Override
-  public boolean equals(@Nullable Object object) {
+  public boolean equals(@CheckForNull Object object) {
     return super.equals(object);
   }
 
@@ -450,7 +557,7 @@ protected A doBackward(B b) {
     }
 
     @Override
-    public boolean equals(@Nullable Object object) {
+    public boolean equals(@CheckForNull Object object) {
       if (object instanceof FunctionBasedConverter) {
         FunctionBasedConverter<?, ?> that = (FunctionBasedConverter<?, ?>) object;
         return this.forwardFunction.equals(that.forwardFunction), @@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.google.common.base;
+
+import com.google.common.annotations.GwtCompatible;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+/** A utility method to perform unchecked casts to suppress errors produced by nullness analyses. */
+@GwtCompatible
+@ElementTypesAreNonnullByDefault
+final class NullnessCasts {
+  /**
+   * Accepts a {@code @Nullable T} and returns a plain {@code T}, without performing any check that
+   * that conversion is safe.
+   *
+   * <p>This method is intended to help with usages of type parameters that have {@linkplain
+   * ParametricNullness parametric nullness}. If a type parameter instead ranges over only non-null
+   * types (or if the type is a non-variable type, like {@code String}), then code should almost
+   * never use this method, preferring instead to call {@code requireNonNull} so as to benefit from
+   * its runtime check.
+   *
+   * <p>An example use case for this method is in implementing an {@code Iterator<T>} whose {@code
+   * next} field is lazily initialized. The type of that field would be {@code @Nullable T}, and the
+   * code would be responsible for populating a ""real"" {@code T} (which might still be the value
+   * {@code null}!) before returning it to callers. Depending on how the code is structured, a
+   * nullness analysis might not understand that the field has been populated. To avoid that problem
+   * without having to add {@code @SuppressWarnings}, the code can call this method.
+   *
+   * <p>Why <i>not</i> just add {@code SuppressWarnings}? The problem is that this method is
+   * typically useful for {@code return} statements. That leaves the code with two options: Either
+   * add the suppression to the whole method (which turns off checking for a large section of code),
+   * or extract a variable, and put the suppression on that. However, a local variable typically
+   * doesn't work: Because nullness analyses typically infer the nullness of local variables,
+   * there's no way to assign a {@code @Nullable T} to a field {@code T foo;} and instruct the
+   * analysis that that means ""plain {@code T}"" rather than the inferred type {@code @Nullable T}.
+   * (Even if supported added {@code @NonNull}, that would not help, since the problem case
+   * addressed by this method is the case in which {@code T} has parametric nullness -- and thus its
+   * value may be legitimately {@code null}.)
+   */
+  @ParametricNullness
+  @SuppressWarnings(""nullness"")
+  static <T extends @Nullable Object> T uncheckedCastNullableTToT(@CheckForNull T t) {
+    return t;
+  }
+
+  private NullnessCasts() {}
+}, ","Annotate Converter for nullness.

RELNOTES=n/a",Annotate Converter for nullness.
5497,,['.github/workflows/ci.yml'],"@@ -27,7 +27,7 @@ jobs:
       - name: 'Check out repository'
         uses: actions/checkout@v2
       - name: 'Cache local Maven repository'
-        uses: actions/cache@v2.1.4
+        uses: actions/cache@v2.1.5
         with:
           path: ~/.m2/repository
           key: maven-${{ hashFiles('**/pom.xml') }}
@@ -59,7 +59,7 @@ jobs:
       - name: 'Check out repository'
         uses: actions/checkout@v2
       - name: 'Cache local Maven repository'
-        uses: actions/cache@v2.1.4
+        uses: actions/cache@v2.1.5
         with:
           path: ~/.m2/repository
           key: maven-${{ hashFiles('**/pom.xml') }}
@@ -88,7 +88,7 @@ jobs:
       - name: 'Check out repository'
         uses: actions/checkout@v2
       - name: 'Cache local Maven repository'
-        uses: actions/cache@v2.1.4
+        uses: actions/cache@v2.1.5
         with:
           path: ~/.m2/repository
           key: maven-${{ hashFiles('**/pom.xml') }}, ","Bump actions/cache from v2.1.4 to v2.1.5

Bumps [actions/cache](https://github.com/actions/cache) from v2.1.4 to v2.1.5.
- [Release notes](https://github.com/actions/cache/releases)
- [Commits](https://github.com/actions/cache/compare/v2.1.4...1a9e2138d905efd099035b49d8b7a3888c653ca8)

Signed-off-by: dependabot[bot] <support@github.com>

Fixes #5488

RELNOTES=n/a",Bump actions/cache from v2.1.4 to v2.1.5
5500,,"['android/guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'android/guava/src/com/google/common/util/concurrent/AggregateFutureState.java', 'android/guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java', 'android/guava/src/com/google/common/util/concurrent/ForwardingFuture.java', 'android/guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'android/guava/src/com/google/common/util/concurrent/ImmediateFuture.java', 'android/guava/src/com/google/common/util/concurrent/InterruptibleTask.java', 'android/guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java', 'android/guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'android/guava/src/com/google/common/util/concurrent/ListenableFutureTask.java', 'android/guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java', 'android/guava/src/com/google/common/util/concurrent/ServiceManager.java', 'android/guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java', 'futures/listenablefuture1/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava/src/com/google/common/util/concurrent/AbstractFuture.java', 'guava/src/com/google/common/util/concurrent/AggregateFutureState.java', 'guava/src/com/google/common/util/concurrent/CycleDetectingLockFactory.java', 'guava/src/com/google/common/util/concurrent/ForwardingFuture.java', 'guava/src/com/google/common/util/concurrent/ForwardingListenableFuture.java', 'guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/ImmediateFuture.java', 'guava/src/com/google/common/util/concurrent/InterruptibleTask.java', 'guava/src/com/google/common/util/concurrent/JdkFutureAdapters.java', 'guava/src/com/google/common/util/concurrent/ListenableFuture.java', 'guava/src/com/google/common/util/concurrent/ListenableFutureTask.java', 'guava/src/com/google/common/util/concurrent/ListenableScheduledFuture.java', 'guava/src/com/google/common/util/concurrent/ServiceManager.java', 'guava/src/com/google/common/util/concurrent/TrustedListenableFutureTask.java']","@@ -64,7 +64,8 @@
  * @author Luke Sandberg
  * @since 1.0
  */
-@SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
+// we use non-short circuiting comparisons intentionally
+@SuppressWarnings({""ShortCircuitBoolean"", ""ShouldNotSubclass""})
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 public abstract class AbstractFuture<V> extends InternalFutureFailureAccess
@@ -816,7 +817,7 @@ protected boolean setFuture(ListenableFuture<? extends V> future) {
         }
         return false;
       }
-      SetFuture valueToSet = new SetFuture<V>(this, future);
+      SetFuture<V> valueToSet = new SetFuture<V>(this, future);
       if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
         // the listener is responsible for calling completeWithFuture, directExecutor is appropriate
         // since all we are doing is unpacking a completed future which should be fast.
@@ -1247,6 +1248,7 @@ private static void executeListener(Runnable runnable, Executor executor) {
    * <p>Static initialization of this class will fail if the {@link sun.misc.Unsafe} object cannot
    * be accessed.
    */
+  @SuppressWarnings(""sunapi"")
   private static final class UnsafeAtomicHelper extends AtomicHelper {
     static final sun.misc.Unsafe UNSAFE;
     static final long LISTENERS_OFFSET;
@@ -1325,6 +1327,7 @@ boolean casValue(AbstractFuture<?> future, Object expect, Object update) {
   }
 
   /** {@link AtomicHelper} based on {@link AtomicReferenceFieldUpdater}. */
+  @SuppressWarnings(""rawtypes"")
   private static final class SafeAtomicHelper extends AtomicHelper {
     final AtomicReferenceFieldUpdater<Waiter, Thread> waiterThreadUpdater;
     final AtomicReferenceFieldUpdater<Waiter, Waiter> waiterNextUpdater;, @@ -54,7 +54,7 @@
     try {
       helper =
           new SafeAtomicHelper(
-              newUpdater(AggregateFutureState.class, (Class) Set.class, ""seenExceptions""),
+              newUpdater(AggregateFutureState.class, Set.class, ""seenExceptions""),
               newUpdater(AggregateFutureState.class, ""remaining""));
     } catch (Throwable reflectionFailure) {
       // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause
@@ -144,40 +144,45 @@ final void clearSeenExceptions() {
   private abstract static class AtomicHelper {
     /** Atomic compare-and-set of the {@link AggregateFutureState#seenExceptions} field. */
     abstract void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update);
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update);
 
     /** Atomic decrement-and-get of the {@link AggregateFutureState#remaining} field. */
-    abstract int decrementAndGetRemainingCount(AggregateFutureState state);
+    abstract int decrementAndGetRemainingCount(AggregateFutureState<?> state);
   }
 
   private static final class SafeAtomicHelper extends AtomicHelper {
-    final AtomicReferenceFieldUpdater<AggregateFutureState, Set<Throwable>> seenExceptionsUpdater;
+    final AtomicReferenceFieldUpdater<AggregateFutureState<?>, Set<Throwable>>
+        seenExceptionsUpdater;
 
-    final AtomicIntegerFieldUpdater<AggregateFutureState> remainingCountUpdater;
+    final AtomicIntegerFieldUpdater<AggregateFutureState<?>> remainingCountUpdater;
 
+    @SuppressWarnings({""rawtypes"", ""unchecked""}) // Unavoidable with reflection API
     SafeAtomicHelper(
         AtomicReferenceFieldUpdater seenExceptionsUpdater,
         AtomicIntegerFieldUpdater remainingCountUpdater) {
-      this.seenExceptionsUpdater = seenExceptionsUpdater;
-      this.remainingCountUpdater = remainingCountUpdater;
+      this.seenExceptionsUpdater =
+          (AtomicReferenceFieldUpdater<AggregateFutureState<?>, Set<Throwable>>)
+              seenExceptionsUpdater;
+      this.remainingCountUpdater =
+          (AtomicIntegerFieldUpdater<AggregateFutureState<?>>) remainingCountUpdater;
     }
 
     @Override
     void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update) {
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update) {
       seenExceptionsUpdater.compareAndSet(state, expect, update);
     }
 
     @Override
-    int decrementAndGetRemainingCount(AggregateFutureState state) {
+    int decrementAndGetRemainingCount(AggregateFutureState<?> state) {
       return remainingCountUpdater.decrementAndGet(state);
     }
   }
 
   private static final class SynchronizedAtomicHelper extends AtomicHelper {
     @Override
     void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update) {
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update) {
       synchronized (state) {
         if (state.seenExceptions == expect) {
           state.seenExceptions = update;
@@ -186,7 +191,7 @@ void compareAndSetSeenExceptions(
     }
 
     @Override
-    int decrementAndGetRemainingCount(AggregateFutureState state) {
+    int decrementAndGetRemainingCount(AggregateFutureState<?> state) {
       synchronized (state) {
         return --state.remaining;
       }, @@ -268,7 +268,8 @@ public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean
   }
 
   // A static mapping from an Enum type to its set of LockGraphNodes.
-  private static final ConcurrentMap<Class<? extends Enum>, Map<? extends Enum, LockGraphNode>>
+  private static final ConcurrentMap<
+          Class<? extends Enum<?>>, Map<? extends Enum<?>, LockGraphNode>>
       lockGraphNodesPerType = new MapMaker().weakKeys().makeMap();
 
   /** Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}. */
@@ -283,13 +284,15 @@ public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean
     return new WithExplicitOrdering<E>(policy, lockGraphNodes);
   }
 
-  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(Class<? extends Enum> clazz) {
-    Map<? extends Enum, LockGraphNode> existing = lockGraphNodesPerType.get(clazz);
+  @SuppressWarnings(""unchecked"")
+  private static <E extends Enum<E>> Map<? extends E, LockGraphNode> getOrCreateNodes(
+      Class<E> clazz) {
+    Map<E, LockGraphNode> existing = (Map<E, LockGraphNode>) lockGraphNodesPerType.get(clazz);
     if (existing != null) {
       return existing;
     }
-    Map<? extends Enum, LockGraphNode> created = createNodes(clazz);
-    existing = lockGraphNodesPerType.putIfAbsent(clazz, created);
+    Map<E, LockGraphNode> created = createNodes(clazz);
+    existing = (Map<E, LockGraphNode>) lockGraphNodesPerType.putIfAbsent(clazz, created);
     return MoreObjects.firstNonNull(existing, created);
   }
 , @@ -35,6 +35,7 @@
  */
 @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
 @GwtCompatible
+@SuppressWarnings(""ShouldNotSubclass"")
 public abstract class ForwardingFuture<V> extends ForwardingObject implements Future<V> {
   /** Constructor for use by subclasses. */
   protected ForwardingFuture() {}, @@ -29,6 +29,7 @@
  * @author Shardul Deo
  * @since 4.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
 @GwtCompatible
 public abstract class ForwardingListenableFuture<V> extends ForwardingFuture<V>, @@ -470,6 +470,7 @@ public void run() {
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""ShouldNotSubclass"")
   public static <I, O> Future<O> lazyTransform(
       final Future<I> input, final Function<? super I, ? extends O> function) {
     checkNotNull(input);
@@ -834,17 +835,7 @@ protected void afterDone() {
   @Beta
   public static <T> ImmutableList<ListenableFuture<T>> inCompletionOrder(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
-    // Can't use Iterables.toArray because it's not gwt compatible
-    final Collection<ListenableFuture<? extends T>> collection;
-    if (futures instanceof Collection) {
-      collection = (Collection<ListenableFuture<? extends T>>) futures;
-    } else {
-      collection = ImmutableList.copyOf(futures);
-    }
-    @SuppressWarnings(""unchecked"")
-    ListenableFuture<? extends T>[] copy =
-        (ListenableFuture<? extends T>[])
-            collection.toArray(new ListenableFuture[collection.size()]);
+    ListenableFuture<? extends T>[] copy = gwtCompatibleToArray(futures);
     final InCompletionOrderState<T> state = new InCompletionOrderState<>(copy);
     ImmutableList.Builder<AbstractFuture<T>> delegatesBuilder = ImmutableList.builder();
     for (int i = 0; i < copy.length; i++) {
@@ -869,6 +860,19 @@ public void run() {
     return delegatesCast;
   }
 
+  /** Can't use Iterables.toArray because it's not gwt compatible */
+  @SuppressWarnings(""unchecked"")
+  private static <T> ListenableFuture<? extends T>[] gwtCompatibleToArray(
+      Iterable<? extends ListenableFuture<? extends T>> futures) {
+    final Collection<ListenableFuture<? extends T>> collection;
+    if (futures instanceof Collection) {
+      collection = (Collection<ListenableFuture<? extends T>>) futures;
+    } else {
+      collection = ImmutableList.copyOf(futures);
+    }
+    return (ListenableFuture<? extends T>[]) collection.toArray(new ListenableFuture<?>[0]);
+  }
+
   // This can't be a TrustedFuture, because TrustedFuture has clever optimizations that
   // mean cancel won't be called if this Future is passed into setFuture, and then
   // cancelled., @@ -28,6 +28,7 @@
 /** Implementation of {@link Futures#immediateFuture}. */
 @GwtCompatible
 // TODO(cpovirk): Make this final (but that may break Mockito spy calls).
+@SuppressWarnings(""ShouldNotSubclass"")
 class ImmediateFuture<V> implements ListenableFuture<V> {
   static final ListenableFuture<?> NULL = new ImmediateFuture<>(null);
 , @@ -22,6 +22,7 @@
 import java.util.concurrent.locks.LockSupport;
 import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
+@SuppressWarnings(""ShouldNotSubclass"")
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause, @@ -93,6 +93,7 @@
    * <p>If the delegate future is interrupted or throws an unexpected unchecked exception, the
    * listeners will not be invoked.
    */
+  @SuppressWarnings(""ShouldNotSubclass"")
   private static class ListenableFutureAdapter<V> extends ForwardingFuture<V>
       implements ListenableFuture<V> {
 , @@ -99,6 +99,7 @@
  * @author Nishant Thakkar
  * @since 1.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @DoNotMock(""Use the methods in Futures (like immediateFuture) or SettableFuture"")
 public interface ListenableFuture<V> extends Future<V> {
   /**, @@ -40,6 +40,7 @@
  * @author Sven Mawson
  * @since 1.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @GwtIncompatible
 public class ListenableFutureTask<V> extends FutureTask<V> implements ListenableFuture<V> {
   // TODO(cpovirk): explore ways of making ListenableFutureTask final. There are some valid reasons, @@ -26,4 +26,5 @@
  */
 @Beta
 @GwtCompatible
+@SuppressWarnings(""ShouldNotSubclass"")
 public interface ListenableScheduledFuture<V> extends ScheduledFuture<V>, ListenableFuture<V> {}, @@ -822,5 +822,6 @@ protected void doStop() {
   }
 
   /** This is never thrown but only used for logging. */
+  @SuppressWarnings(""ShouldNotSubclass"")
   private static final class EmptyServiceManagerWarning extends Throwable {}
 }, @@ -73,7 +73,7 @@
 
   @Override
   public void run() {
-    InterruptibleTask localTask = task;
+    InterruptibleTask<?> localTask = task;
     if (localTask != null) {
       localTask.run();
     }
@@ -89,7 +89,7 @@ protected void afterDone() {
     super.afterDone();
 
     if (wasInterrupted()) {
-      InterruptibleTask localTask = task;
+      InterruptibleTask<?> localTask = task;
       if (localTask != null) {
         localTask.interruptTask();
       }
@@ -100,7 +100,7 @@ protected void afterDone() {
 
   @Override
   protected String pendingToString() {
-    InterruptibleTask localTask = task;
+    InterruptibleTask<?> localTask = task;
     if (localTask != null) {
       return ""task=["" + localTask + ""]"";
     }, @@ -99,6 +99,7 @@
  * @author Nishant Thakkar
  * @since 1.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @DoNotMock(""Use the methods in Futures (like immediateFuture) or SettableFuture"")
 public interface ListenableFuture<V> extends Future<V> {
   /**, @@ -64,7 +64,8 @@
  * @author Luke Sandberg
  * @since 1.0
  */
-@SuppressWarnings(""ShortCircuitBoolean"") // we use non-short circuiting comparisons intentionally
+// we use non-short circuiting comparisons intentionally
+@SuppressWarnings({""ShortCircuitBoolean"", ""ShouldNotSubclass""})
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 public abstract class AbstractFuture<V> extends InternalFutureFailureAccess
@@ -816,7 +817,7 @@ protected boolean setFuture(ListenableFuture<? extends V> future) {
         }
         return false;
       }
-      SetFuture valueToSet = new SetFuture<V>(this, future);
+      SetFuture<V> valueToSet = new SetFuture<V>(this, future);
       if (ATOMIC_HELPER.casValue(this, null, valueToSet)) {
         // the listener is responsible for calling completeWithFuture, directExecutor is appropriate
         // since all we are doing is unpacking a completed future which should be fast.
@@ -1245,6 +1246,7 @@ private static void executeListener(Runnable runnable, Executor executor) {
    * <p>Static initialization of this class will fail if the {@link sun.misc.Unsafe} object cannot
    * be accessed.
    */
+  @SuppressWarnings(""sunapi"")
   private static final class UnsafeAtomicHelper extends AtomicHelper {
     static final sun.misc.Unsafe UNSAFE;
     static final long LISTENERS_OFFSET;
@@ -1323,6 +1325,7 @@ boolean casValue(AbstractFuture<?> future, Object expect, Object update) {
   }
 
   /** {@link AtomicHelper} based on {@link AtomicReferenceFieldUpdater}. */
+  @SuppressWarnings(""rawtypes"")
   private static final class SafeAtomicHelper extends AtomicHelper {
     final AtomicReferenceFieldUpdater<Waiter, Thread> waiterThreadUpdater;
     final AtomicReferenceFieldUpdater<Waiter, Waiter> waiterNextUpdater;, @@ -54,7 +54,7 @@
     try {
       helper =
           new SafeAtomicHelper(
-              newUpdater(AggregateFutureState.class, (Class) Set.class, ""seenExceptions""),
+              newUpdater(AggregateFutureState.class, Set.class, ""seenExceptions""),
               newUpdater(AggregateFutureState.class, ""remaining""));
     } catch (Throwable reflectionFailure) {
       // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause
@@ -144,40 +144,45 @@ final void clearSeenExceptions() {
   private abstract static class AtomicHelper {
     /** Atomic compare-and-set of the {@link AggregateFutureState#seenExceptions} field. */
     abstract void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update);
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update);
 
     /** Atomic decrement-and-get of the {@link AggregateFutureState#remaining} field. */
-    abstract int decrementAndGetRemainingCount(AggregateFutureState state);
+    abstract int decrementAndGetRemainingCount(AggregateFutureState<?> state);
   }
 
   private static final class SafeAtomicHelper extends AtomicHelper {
-    final AtomicReferenceFieldUpdater<AggregateFutureState, Set<Throwable>> seenExceptionsUpdater;
+    final AtomicReferenceFieldUpdater<AggregateFutureState<?>, Set<Throwable>>
+        seenExceptionsUpdater;
 
-    final AtomicIntegerFieldUpdater<AggregateFutureState> remainingCountUpdater;
+    final AtomicIntegerFieldUpdater<AggregateFutureState<?>> remainingCountUpdater;
 
+    @SuppressWarnings({""rawtypes"", ""unchecked""}) // Unavoidable with reflection API
     SafeAtomicHelper(
         AtomicReferenceFieldUpdater seenExceptionsUpdater,
         AtomicIntegerFieldUpdater remainingCountUpdater) {
-      this.seenExceptionsUpdater = seenExceptionsUpdater;
-      this.remainingCountUpdater = remainingCountUpdater;
+      this.seenExceptionsUpdater =
+          (AtomicReferenceFieldUpdater<AggregateFutureState<?>, Set<Throwable>>)
+              seenExceptionsUpdater;
+      this.remainingCountUpdater =
+          (AtomicIntegerFieldUpdater<AggregateFutureState<?>>) remainingCountUpdater;
     }
 
     @Override
     void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update) {
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update) {
       seenExceptionsUpdater.compareAndSet(state, expect, update);
     }
 
     @Override
-    int decrementAndGetRemainingCount(AggregateFutureState state) {
+    int decrementAndGetRemainingCount(AggregateFutureState<?> state) {
       return remainingCountUpdater.decrementAndGet(state);
     }
   }
 
   private static final class SynchronizedAtomicHelper extends AtomicHelper {
     @Override
     void compareAndSetSeenExceptions(
-        AggregateFutureState state, Set<Throwable> expect, Set<Throwable> update) {
+        AggregateFutureState<?> state, Set<Throwable> expect, Set<Throwable> update) {
       synchronized (state) {
         if (state.seenExceptions == expect) {
           state.seenExceptions = update;
@@ -186,7 +191,7 @@ void compareAndSetSeenExceptions(
     }
 
     @Override
-    int decrementAndGetRemainingCount(AggregateFutureState state) {
+    int decrementAndGetRemainingCount(AggregateFutureState<?> state) {
       synchronized (state) {
         return --state.remaining;
       }, @@ -268,7 +268,8 @@ public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean
   }
 
   // A static mapping from an Enum type to its set of LockGraphNodes.
-  private static final ConcurrentMap<Class<? extends Enum>, Map<? extends Enum, LockGraphNode>>
+  private static final ConcurrentMap<
+          Class<? extends Enum<?>>, Map<? extends Enum<?>, LockGraphNode>>
       lockGraphNodesPerType = new MapMaker().weakKeys().makeMap();
 
   /** Creates a {@code CycleDetectingLockFactory.WithExplicitOrdering<E>}. */
@@ -283,13 +284,15 @@ public ReentrantReadWriteLock newReentrantReadWriteLock(String lockName, boolean
     return new WithExplicitOrdering<E>(policy, lockGraphNodes);
   }
 
-  private static Map<? extends Enum, LockGraphNode> getOrCreateNodes(Class<? extends Enum> clazz) {
-    Map<? extends Enum, LockGraphNode> existing = lockGraphNodesPerType.get(clazz);
+  @SuppressWarnings(""unchecked"")
+  private static <E extends Enum<E>> Map<? extends E, LockGraphNode> getOrCreateNodes(
+      Class<E> clazz) {
+    Map<E, LockGraphNode> existing = (Map<E, LockGraphNode>) lockGraphNodesPerType.get(clazz);
     if (existing != null) {
       return existing;
     }
-    Map<? extends Enum, LockGraphNode> created = createNodes(clazz);
-    existing = lockGraphNodesPerType.putIfAbsent(clazz, created);
+    Map<E, LockGraphNode> created = createNodes(clazz);
+    existing = (Map<E, LockGraphNode>) lockGraphNodesPerType.putIfAbsent(clazz, created);
     return MoreObjects.firstNonNull(existing, created);
   }
 , @@ -35,6 +35,7 @@
  */
 @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
 @GwtCompatible
+@SuppressWarnings(""ShouldNotSubclass"")
 public abstract class ForwardingFuture<V> extends ForwardingObject implements Future<V> {
   /** Constructor for use by subclasses. */
   protected ForwardingFuture() {}, @@ -29,6 +29,7 @@
  * @author Shardul Deo
  * @since 4.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @CanIgnoreReturnValue // TODO(cpovirk): Consider being more strict.
 @GwtCompatible
 public abstract class ForwardingListenableFuture<V> extends ForwardingFuture<V>, @@ -503,6 +503,7 @@ public void run() {
    */
   @Beta
   @GwtIncompatible // TODO
+  @SuppressWarnings(""ShouldNotSubclass"")
   public static <I, O> Future<O> lazyTransform(
       final Future<I> input, final Function<? super I, ? extends O> function) {
     checkNotNull(input);
@@ -867,17 +868,7 @@ protected void afterDone() {
   @Beta
   public static <T> ImmutableList<ListenableFuture<T>> inCompletionOrder(
       Iterable<? extends ListenableFuture<? extends T>> futures) {
-    // Can't use Iterables.toArray because it's not gwt compatible
-    final Collection<ListenableFuture<? extends T>> collection;
-    if (futures instanceof Collection) {
-      collection = (Collection<ListenableFuture<? extends T>>) futures;
-    } else {
-      collection = ImmutableList.copyOf(futures);
-    }
-    @SuppressWarnings(""unchecked"")
-    ListenableFuture<? extends T>[] copy =
-        (ListenableFuture<? extends T>[])
-            collection.toArray(new ListenableFuture[collection.size()]);
+    ListenableFuture<? extends T>[] copy = gwtCompatibleToArray(futures);
     final InCompletionOrderState<T> state = new InCompletionOrderState<>(copy);
     ImmutableList.Builder<AbstractFuture<T>> delegatesBuilder = ImmutableList.builder();
     for (int i = 0; i < copy.length; i++) {
@@ -902,6 +893,19 @@ public void run() {
     return delegatesCast;
   }
 
+  /** Can't use Iterables.toArray because it's not gwt compatible */
+  @SuppressWarnings(""unchecked"")
+  private static <T> ListenableFuture<? extends T>[] gwtCompatibleToArray(
+      Iterable<? extends ListenableFuture<? extends T>> futures) {
+    final Collection<ListenableFuture<? extends T>> collection;
+    if (futures instanceof Collection) {
+      collection = (Collection<ListenableFuture<? extends T>>) futures;
+    } else {
+      collection = ImmutableList.copyOf(futures);
+    }
+    return (ListenableFuture<? extends T>[]) collection.toArray(new ListenableFuture<?>[0]);
+  }
+
   // This can't be a TrustedFuture, because TrustedFuture has clever optimizations that
   // mean cancel won't be called if this Future is passed into setFuture, and then
   // cancelled., @@ -28,6 +28,7 @@
 /** Implementation of {@link Futures#immediateFuture}. */
 @GwtCompatible
 // TODO(cpovirk): Make this final (but that may break Mockito spy calls).
+@SuppressWarnings(""ShouldNotSubclass"")
 class ImmediateFuture<V> implements ListenableFuture<V> {
   static final ListenableFuture<?> NULL = new ImmediateFuture<>(null);
 , @@ -22,6 +22,7 @@
 import java.util.concurrent.locks.LockSupport;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
+@SuppressWarnings(""ShouldNotSubclass"")
 @GwtCompatible(emulated = true)
 @ReflectionSupport(value = ReflectionSupport.Level.FULL)
 // Some Android 5.0.x Samsung devices have bugs in JDK reflection APIs that cause, @@ -93,6 +93,7 @@
    * <p>If the delegate future is interrupted or throws an unexpected unchecked exception, the
    * listeners will not be invoked.
    */
+  @SuppressWarnings(""ShouldNotSubclass"")
   private static class ListenableFutureAdapter<V> extends ForwardingFuture<V>
       implements ListenableFuture<V> {
 , @@ -99,6 +99,7 @@
  * @author Nishant Thakkar
  * @since 1.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @DoNotMock(""Use the methods in Futures (like immediateFuture) or SettableFuture"")
 public interface ListenableFuture<V> extends Future<V> {
   /**, @@ -40,6 +40,7 @@
  * @author Sven Mawson
  * @since 1.0
  */
+@SuppressWarnings(""ShouldNotSubclass"")
 @GwtIncompatible
 public class ListenableFutureTask<V> extends FutureTask<V> implements ListenableFuture<V> {
   // TODO(cpovirk): explore ways of making ListenableFutureTask final. There are some valid reasons, @@ -26,4 +26,5 @@
  */
 @Beta
 @GwtCompatible
+@SuppressWarnings(""ShouldNotSubclass"")
 public interface ListenableScheduledFuture<V> extends ScheduledFuture<V>, ListenableFuture<V> {}, @@ -874,8 +874,10 @@ protected void doStop() {
   }
 
   /** This is never thrown but only used for logging. */
+  @SuppressWarnings(""ShouldNotSubclass"")
   private static final class EmptyServiceManagerWarning extends Throwable {}
 
+  @SuppressWarnings(""ShouldNotSubclass"")
   private static final class FailedService extends Throwable {
     FailedService(Service service) {
       super(, @@ -73,7 +73,7 @@
 
   @Override
   public void run() {
-    InterruptibleTask localTask = task;
+    InterruptibleTask<?> localTask = task;
     if (localTask != null) {
       localTask.run();
     }
@@ -89,7 +89,7 @@ protected void afterDone() {
     super.afterDone();
 
     if (wasInterrupted()) {
-      InterruptibleTask localTask = task;
+      InterruptibleTask<?> localTask = task;
       if (localTask != null) {
         localTask.interruptTask();
       }
@@ -100,7 +100,7 @@ protected void afterDone() {
 
   @Override
   protected String pendingToString() {
-    InterruptibleTask localTask = task;
+    InterruptibleTask<?> localTask = task;
     if (localTask != null) {
       return ""task=["" + localTask + ""]"";
     }, ","Suppress or fix all compiler warnings in util/concurrent

RELNOTES=n/a",Suppress or fix all compiler warnings in util/concurrent
5501,,"['android/guava/src/com/google/common/reflect/AbstractInvocationHandler.java', 'android/guava/src/com/google/common/reflect/ClassPath.java', 'android/guava/src/com/google/common/reflect/Element.java', 'android/guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java', 'android/guava/src/com/google/common/reflect/Invokable.java', 'android/guava/src/com/google/common/reflect/Parameter.java', 'android/guava/src/com/google/common/reflect/ParametricNullness.java', 'android/guava/src/com/google/common/reflect/Reflection.java', 'android/guava/src/com/google/common/reflect/TypeCapture.java', 'android/guava/src/com/google/common/reflect/TypeParameter.java', 'android/guava/src/com/google/common/reflect/TypeResolver.java', 'android/guava/src/com/google/common/reflect/TypeToken.java', 'android/guava/src/com/google/common/reflect/TypeVisitor.java', 'android/guava/src/com/google/common/reflect/Types.java', 'guava/src/com/google/common/reflect/AbstractInvocationHandler.java', 'guava/src/com/google/common/reflect/ClassPath.java', 'guava/src/com/google/common/reflect/Element.java', 'guava/src/com/google/common/reflect/ElementTypesAreNonnullByDefault.java', 'guava/src/com/google/common/reflect/Invokable.java', 'guava/src/com/google/common/reflect/Parameter.java', 'guava/src/com/google/common/reflect/ParametricNullness.java', 'guava/src/com/google/common/reflect/Reflection.java', 'guava/src/com/google/common/reflect/TypeCapture.java', 'guava/src/com/google/common/reflect/TypeParameter.java', 'guava/src/com/google/common/reflect/TypeResolver.java', 'guava/src/com/google/common/reflect/TypeToken.java', 'guava/src/com/google/common/reflect/TypeVisitor.java', 'guava/src/com/google/common/reflect/Types.java']","@@ -19,7 +19,8 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Abstract implementation of {@link InvocationHandler} that handles {@link Object#equals}, {@link
@@ -39,6 +40,8 @@
  * @since 12.0
  */
 @Beta
+// TODO(cpovirk): after adding @Nullable below
+@ElementTypesAreNonnullByDefault
 public abstract class AbstractInvocationHandler implements InvocationHandler {
 
   private static final Object[] NO_ARGS = {};
@@ -59,7 +62,8 @@
    * </ul>
    */
   @Override
-  public final Object invoke(Object proxy, Method method, @NullableDecl Object[] args)
+  @CheckForNull
+  public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
       throws Throwable {
     if (args == null) {
       args = NO_ARGS;
@@ -94,8 +98,9 @@ public final Object invoke(Object proxy, Method method, @NullableDecl Object[] a
    * <p>Unlike {@link #invoke}, {@code args} will never be null. When the method has no parameter,
    * an empty array is passed in.
    */
-  protected abstract Object handleInvocation(Object proxy, Method method, Object[] args)
-      throws Throwable;
+  @CheckForNull
+  protected abstract Object handleInvocation(
+      Object proxy, Method method, /* TODO(cpovirk): @Nullable */ Object[] args) throws Throwable;
 
   /**
    * By default delegates to {@link Object#equals} so instances are only equal if they are
@@ -109,7 +114,7 @@ protected abstract Object handleInvocation(Object proxy, Method method, Object[]
    * <p>Subclasses can override this method to provide custom equality.
    */
   @Override
-  public boolean equals(Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     return super.equals(obj);
   }
 , @@ -51,7 +51,7 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Scans the source of a {@link ClassLoader} and finds all loadable classes and resources.
@@ -72,6 +72,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class ClassPath {
   private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
 
@@ -265,7 +266,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof ResourceInfo) {
         ResourceInfo that = (ResourceInfo) obj;
         return resourceName.equals(that.resourceName) && loader == that.loader;
@@ -297,8 +298,13 @@ public String toString() {
     /**
      * Returns the package name of the class, without attempting to load the class.
      *
-     * <p>Behaves identically to {@link Package#getName()} but does not require the class (or
-     * package) to be loaded.
+     * <p>Behaves similarly to {@code class.getPackage().}{@link Package#getName() getName()} but
+     * does not require the class (or package) to be loaded.
+     *
+     * <p>But note that this method may behave differently for a class in the default package: For
+     * such classes, this method always returns an empty string. But under some version of Java,
+     * {@code class.getPackage().getName()} produces a {@code NullPointerException} because {@code
+     * class.getPackage()} returns {@code null}.
      */
     public String getPackageName() {
       return Reflection.getPackageName(className);
@@ -307,8 +313,11 @@ public String getPackageName() {
     /**
      * Returns the simple name of the underlying class as given in the source code.
      *
-     * <p>Behaves identically to {@link Class#getSimpleName()} but does not require the class to be
+     * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be
      * loaded.
+     *
+     * <p>But note that this class uses heuristics to identify the simple name. See a related
+     * discussion in <a href=""https://github.com/google/guava/issues/3349"">issue 3349</a>.
      */
     public String getSimpleName() {
       int lastDollarSign = className.lastIndexOf('$');
@@ -531,7 +540,7 @@ private void scanDirectory(
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof LocationInfo) {
         LocationInfo that = (LocationInfo) obj;
         return home.equals(that.home) && classloader.equals(that.classloader);
@@ -559,7 +568,7 @@ public String toString() {
    */
   @VisibleForTesting
   static ImmutableSet<File> getClassPathFromManifest(
-      File jarFile, @NullableDecl Manifest manifest) {
+      File jarFile, @CheckForNull Manifest manifest) {
     if (manifest == null) {
       return ImmutableSet.of();
     }, @@ -23,14 +23,15 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Represents either a {@link Field}, a {@link Method} or a {@link Constructor}. Provides
  * convenience methods such as {@link #isPublic} and {@link #isPackagePrivate}.
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 class Element extends AccessibleObject implements Member {
 
   private final AccessibleObject accessibleObject;
@@ -52,6 +53,7 @@ public final boolean isAnnotationPresent(Class<? extends Annotation> annotationC
   }
 
   @Override
+  @CheckForNull
   public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
     return accessibleObject.getAnnotation(annotationClass);
   }
@@ -158,7 +160,7 @@ final boolean isTransient() {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj instanceof Element) {
       Element that = (Element) obj;
       return getOwnerType().equals(that.getOwnerType()) && member.equals(that.member);, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.reflect;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -30,7 +30,8 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Wrapper around either a {@link Method} or a {@link Constructor}. Convenience API is provided to
@@ -55,6 +56,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public abstract class Invokable<T, R> extends Element implements GenericDeclaration {
 
   <M extends AccessibleObject & Member> Invokable(M member) {
@@ -93,10 +95,11 @@
    *     invocation conversion.
    * @throws InvocationTargetException if the underlying method or constructor throws an exception.
    */
-  // All subclasses are owned by us and we'll make sure to get the R type right.
-  @SuppressWarnings(""unchecked"")
+  // All subclasses are owned by us and we'll make sure to get the R type right, including nullness.
+  @SuppressWarnings({""unchecked"", ""nullness""})
   @CanIgnoreReturnValue
-  public final R invoke(@NullableDecl T receiver, Object... args)
+  @CheckForNull
+  public final R invoke(@CheckForNull T receiver, @Nullable Object... args)
       throws InvocationTargetException, IllegalAccessException {
     return (R) invokeInternal(receiver, checkNotNull(args));
   }
@@ -173,7 +176,8 @@ public final R invoke(@NullableDecl T receiver, Object... args)
     return (TypeToken<T>) TypeToken.of(getDeclaringClass());
   }
 
-  abstract Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+  @CheckForNull
+  abstract Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
       throws InvocationTargetException, IllegalAccessException;
 
   abstract Type[] getGenericParameterTypes();
@@ -195,7 +199,8 @@ abstract Object invokeInternal(@NullableDecl Object receiver, Object[] args)
     }
 
     @Override
-    final Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+    @CheckForNull
+    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       return method.invoke(receiver, args);
     }
@@ -249,7 +254,7 @@ public final boolean isVarArgs() {
     }
 
     @Override
-    final Object invokeInternal(@NullableDecl Object receiver, Object[] args)
+    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       try {
         return constructor.newInstance(args);, @@ -21,7 +21,7 @@
 import com.google.common.collect.ImmutableList;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Represents a method or constructor parameter.
@@ -30,6 +30,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class Parameter implements AnnotatedElement {
 
   private final Invokable<?, ?> declaration;
@@ -61,7 +62,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   }
 
   @Override
-  @NullableDecl
+  @CheckForNull
   public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     for (Annotation annotation : annotations) {
@@ -92,7 +93,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
 
   /** @since 18.0 */
   // @Override on JDK8
-  @NullableDecl
+  @CheckForNull
   public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     return FluentIterable.from(annotations).filter(annotationType).first().orNull();
@@ -105,7 +106,7 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   }
 
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj instanceof Parameter) {
       Parameter that = (Parameter) obj;
       return position == that.position && declaration.equals(that.declaration);, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.reflect;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -27,6 +27,7 @@
  * @since 12.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class Reflection {
 
   /**, @@ -24,6 +24,7 @@
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 abstract class TypeCapture<T> {
 
   /** Returns the captured type. */, @@ -19,7 +19,7 @@
 import com.google.common.annotations.Beta;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Captures a free type variable that can be used in {@link TypeToken#where}. For example:
@@ -35,6 +35,17 @@
  * @since 12.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
+/*
+ * A nullable bound would let users create a TypeParameter instance for a parameter with a nullable
+ * bound. However, it would also let them create `new TypeParameter<@Nullable T>() {}`, which
+ * wouldn't behave as users might expect. Additionally, it's not clear how the TypeToken API could
+ * support even a ""normal"" `TypeParameter<T>` when `<T>` has a nullable bound. (See the discussion
+ * on TypeToken.where.) So, in the interest of failing fast and encouraging the user to switch to a
+ * non-null bound if possible, let's require a non-null bound here.
+ *
+ * TODO(cpovirk): Elaborate on ""wouldn't behave as users might expect.""
+ */
 public abstract class TypeParameter<T> extends TypeCapture<T> {
 
   final TypeVariable<?> typeVariable;
@@ -51,7 +62,7 @@ public final int hashCode() {
   }
 
   @Override
-  public final boolean equals(@NullableDecl Object o) {
+  public final boolean equals(@CheckForNull Object o) {
     if (o instanceof TypeParameter) {
       TypeParameter<?> that = (TypeParameter<?>) o;
       return typeVariable.equals(that.typeVariable);, @@ -35,7 +35,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * An object of this class encapsulates type mappings from type variables. Mappings are established
@@ -52,6 +52,7 @@
  * @since 15.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class TypeResolver {
 
   private final TypeTable typeTable;
@@ -527,7 +528,8 @@ private WildcardCapturer notForTypeVariable() {
       return new WildcardCapturer(id);
     }
 
-    private Type captureNullable(@NullableDecl Type type) {
+    @CheckForNull
+    private Type captureNullable(@CheckForNull Type type) {
       if (type == null) {
         return null;
       }
@@ -561,7 +563,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof TypeVariableKey) {
         TypeVariableKey that = (TypeVariableKey) obj;
         return equalsTypeVariable(that.var);
@@ -576,6 +578,7 @@ public String toString() {
     }
 
     /** Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable. */
+    @CheckForNull
     static TypeVariableKey forLookup(Type t) {
       if (t instanceof TypeVariable) {
         return new TypeVariableKey((TypeVariable<?>) t);, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.VisibleForTesting;
@@ -46,7 +47,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Type} with generics.
@@ -98,15 +99,16 @@
  */
 @Beta
 @SuppressWarnings(""serial"") // SimpleTypeToken is the serialized form.
+@ElementTypesAreNonnullByDefault
 public abstract class TypeToken<T> extends TypeCapture<T> implements Serializable {
 
   private final Type runtimeType;
 
   /** Resolver for resolving parameter and field types with {@link #runtimeType} as context. */
-  @NullableDecl private transient TypeResolver invariantTypeResolver;
+  @CheckForNull private transient TypeResolver invariantTypeResolver;
 
   /** Resolver for resolving covariant types with {@link #runtimeType} as context. */
-  @NullableDecl private transient TypeResolver covariantTypeResolver;
+  @CheckForNull private transient TypeResolver covariantTypeResolver;
 
   /**
    * Constructs a new type token of {@code T}.
@@ -220,6 +222,17 @@ public final Type getType() {
    * @param typeParam the parameter type variable
    * @param typeArg the actual type to substitute
    */
+  /*
+   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters
+   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends
+   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still
+   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull
+   * X> if we support such a thing? It would be weird or misleading for users to be able to pass
+   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but
+   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.
+   *
+   * TODO(cpovirk): Elaborate on this / merge with other comment?
+   */
   public final <X> TypeToken<T> where(TypeParameter<X> typeParam, TypeToken<X> typeArg) {
     TypeResolver resolver =
         new TypeResolver()
@@ -248,6 +261,10 @@ public final Type getType() {
    * @param typeParam the parameter type variable
    * @param typeArg the actual type to substitute
    */
+  /*
+   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters
+   * that have nullable bounds? See discussion on the other overload of this method.
+   */
   public final <X> TypeToken<T> where(TypeParameter<X> typeParam, Class<X> typeArg) {
     return where(typeParam, of(typeArg));
   }
@@ -288,7 +305,7 @@ public final Type getType() {
    * if the bound is a class or extends from a class. This means that the returned type could be a
    * type variable too.
    */
-  @NullableDecl
+  @CheckForNull
   final TypeToken<? super T> getGenericSuperclass() {
     if (runtimeType instanceof TypeVariable) {
       // First bound is always the super class, if one exists.
@@ -307,7 +324,7 @@ public final Type getType() {
     return superToken;
   }
 
-  @NullableDecl
+  @CheckForNull
   private TypeToken<? super T> boundAsSuperclass(Type bound) {
     TypeToken<?> token = of(bound);
     if (token.getRawType().isInterface()) {
@@ -560,7 +577,7 @@ private boolean isWrapper() {
    * Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},
    * {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.
    */
-  @NullableDecl
+  @CheckForNull
   public final TypeToken<?> getComponentType() {
     Type componentType = Types.getComponentType(runtimeType);
     if (componentType == null) {
@@ -655,7 +672,7 @@ public String toString() {
    */
   public class TypeSet extends ForwardingSet<TypeToken<? super T>> implements Serializable {
 
-    @NullableDecl private transient ImmutableSet<TypeToken<? super T>> types;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> types;
 
     TypeSet() {}
 
@@ -701,7 +718,7 @@ public TypeSet classes() {
   private final class InterfaceSet extends TypeSet {
 
     private final transient TypeSet allTypes;
-    @NullableDecl private transient ImmutableSet<TypeToken<? super T>> interfaces;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> interfaces;
 
     InterfaceSet(TypeSet allTypes) {
       this.allTypes = allTypes;
@@ -754,7 +771,7 @@ private Object readResolve() {
 
   private final class ClassSet extends TypeSet {
 
-    @NullableDecl private transient ImmutableSet<TypeToken<? super T>> classes;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> classes;
 
     @Override
     protected Set<TypeToken<? super T>> delegate() {
@@ -819,7 +836,7 @@ public boolean apply(TypeToken<?> type) {
    * Returns true if {@code o} is another {@code TypeToken} that represents the same {@link Type}.
    */
   @Override
-  public boolean equals(@NullableDecl Object o) {
+  public boolean equals(@CheckForNull Object o) {
     if (o instanceof TypeToken) {
       TypeToken<?> that = (TypeToken<?>) o;
       return runtimeType.equals(that.runtimeType);
@@ -1133,7 +1150,7 @@ private boolean isOwnedBySubtypeOf(Type supertype) {
    * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class}, or
    * null otherwise.
    */
-  @NullableDecl
+  @CheckForNull
   private Type getOwnerTypeIfPresent() {
     if (runtimeType instanceof ParameterizedType) {
       return ((ParameterizedType) runtimeType).getOwnerType();
@@ -1223,11 +1240,19 @@ private TypeResolver getInvariantTypeResolver() {
     // with component type, we have lost generic type information
     // Use raw type so that compiler allows us to call getSupertype()
     @SuppressWarnings(""rawtypes"")
-    TypeToken componentType =
-        checkNotNull(getComponentType(), ""%s isn't a super type of %s"", supertype, this);
+    TypeToken componentType = getComponentType();
+    // TODO(cpovirk): checkArgument?
+    if (componentType == null) {
+      throw new IllegalArgumentException(supertype + "" isn't a super type of "" + this);
+    }
     // array is covariant. component type is super type, so is the array type.
     @SuppressWarnings(""unchecked"") // going from raw type back to generics
-    TypeToken<?> componentSupertype = componentType.getSupertype(supertype.getComponentType());
+    /*
+     * requireNonNull is safe because we call getArraySupertype only after checking
+     * supertype.isArray().
+     */
+    TypeToken<?> componentSupertype =
+        componentType.getSupertype(requireNonNull(supertype.getComponentType()));
     @SuppressWarnings(""unchecked"") // component type is super type, so is array type.
     TypeToken<? super T> result =
         (TypeToken<? super T>)
@@ -1237,8 +1262,14 @@ private TypeResolver getInvariantTypeResolver() {
   }
 
   private TypeToken<? extends T> getArraySubtype(Class<?> subclass) {
+    Class<?> subclassComponentType = subclass.getComponentType();
+    if (subclassComponentType == null) {
+      throw new IllegalArgumentException(subclass + "" does not appear to be a subtype of "" + this);
+    }
     // array is covariant. component type is subtype, so is the array type.
-    TypeToken<?> componentSubtype = getComponentType().getSubtype(subclass.getComponentType());
+    // requireNonNull is safe because we call getArraySubtype only when isArray().
+    TypeToken<?> componentSubtype =
+        requireNonNull(getComponentType()).getSubtype(subclassComponentType);
     @SuppressWarnings(""unchecked"") // component type is subtype, so is array type.
     TypeToken<? extends T> result =
         (TypeToken<? extends T>)
@@ -1311,7 +1342,7 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
           }
 
           @Override
-          @NullableDecl
+          @CheckForNull
           TypeToken<?> getSuperclass(TypeToken<?> type) {
             return type.getGenericSuperclass();
           }
@@ -1330,7 +1361,7 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
           }
 
           @Override
-          @NullableDecl
+          @CheckForNull
           Class<?> getSuperclass(Class<?> type) {
             return type.getSuperclass();
           }
@@ -1402,7 +1433,9 @@ private int collectTypes(K type, Map<? super K, Integer> map) {
           new Ordering<K>() {
             @Override
             public int compare(K left, K right) {
-              return valueComparator.compare(map.get(left), map.get(right));
+              // requireNonNull is safe because we are passing keys in the map.
+              return valueComparator.compare(
+                  requireNonNull(map.get(left)), requireNonNull(map.get(right)));
             }
           };
       return keyOrdering.immutableSortedCopy(map.keySet());
@@ -1412,7 +1445,7 @@ public int compare(K left, K right) {
 
     abstract Iterable<? extends K> getInterfaces(K type);
 
-    @NullableDecl
+    @CheckForNull
     abstract K getSuperclass(K type);
 
     private static class ForwardingTypeCollector<K> extends TypeCollector<K> {
@@ -1434,6 +1467,7 @@ public int compare(K left, K right) {
       }
 
       @Override
+      @CheckForNull
       K getSuperclass(K type) {
         return delegate.getSuperclass(type);
       }, @@ -21,6 +21,7 @@
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Set;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Based on what a {@link Type} is, dispatch it to the corresponding {@code visit*} method. By
@@ -53,6 +54,7 @@
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 abstract class TypeVisitor {
 
   private final Set<Type> visited = Sets.newHashSet();
@@ -61,7 +63,7 @@
    * Visits the given types. Null types are ignored. This allows subclasses to call {@code
    * visit(parameterizedType.getOwnerType())} safely without having to check nulls.
    */
-  public final void visit(Type... types) {
+  public final void visit(@Nullable Type... types) {
     for (Type type : types) {
       if (type == null || !visited.add(type)) {
         // null owner type, or already visited;, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.transform;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
@@ -44,13 +45,15 @@
 import java.util.Collection;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicReference;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities for working with {@link Type}.
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 final class Types {
 
   /** Class#toString without the ""class "" and ""interface "" prefixes */
@@ -86,7 +89,7 @@ static Type newArrayType(Type componentType) {
    * {@code ownerType}.
    */
   static ParameterizedType newParameterizedTypeWithOwner(
-      @NullableDecl Type ownerType, Class<?> rawType, Type... arguments) {
+      @CheckForNull Type ownerType, Class<?> rawType, Type... arguments) {
     if (ownerType == null) {
       return newParameterizedType(rawType, arguments);
     }
@@ -106,14 +109,14 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
   private enum ClassOwnership {
     OWNED_BY_ENCLOSING_CLASS {
       @Override
-      @NullableDecl
+      @CheckForNull
       Class<?> getOwnerType(Class<?> rawType) {
         return rawType.getEnclosingClass();
       }
     },
     LOCAL_CLASS_HAS_NO_OWNER {
       @Override
-      @NullableDecl
+      @CheckForNull
       Class<?> getOwnerType(Class<?> rawType) {
         if (rawType.isLocalClass()) {
           return null;
@@ -123,15 +126,17 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
       }
     };
 
-    @NullableDecl
+    @CheckForNull
     abstract Class<?> getOwnerType(Class<?> rawType);
 
     static final ClassOwnership JVM_BEHAVIOR = detectJvmBehavior();
 
     private static ClassOwnership detectJvmBehavior() {
       class LocalClass<T> {}
       Class<?> subclass = new LocalClass<String>() {}.getClass();
-      ParameterizedType parameterizedType = (ParameterizedType) subclass.getGenericSuperclass();
+      // requireNonNull is safe because we're examining a type that's known to have a superclass.
+      ParameterizedType parameterizedType =
+          requireNonNull((ParameterizedType) subclass.getGenericSuperclass());
       for (ClassOwnership behavior : ClassOwnership.values()) {
         if (behavior.getOwnerType(LocalClass.class) == parameterizedType.getOwnerType()) {
           return behavior;
@@ -172,10 +177,10 @@ static String toString(Type type) {
     return (type instanceof Class) ? ((Class<?>) type).getName() : type.toString();
   }
 
-  @NullableDecl
+  @CheckForNull
   static Type getComponentType(Type type) {
     checkNotNull(type);
-    final AtomicReference<Type> result = new AtomicReference<>();
+    final AtomicReference<@Nullable Type> result = new AtomicReference<>();
     new TypeVisitor() {
       @Override
       void visitTypeVariable(TypeVariable<?> t) {
@@ -204,7 +209,7 @@ void visitClass(Class<?> t) {
    * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null
    * otherwise.
    */
-  @NullableDecl
+  @CheckForNull
   private static Type subtypeOfComponentType(Type[] bounds) {
     for (Type bound : bounds) {
       Type componentType = getComponentType(bound);
@@ -247,7 +252,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof GenericArrayType) {
         GenericArrayType that = (GenericArrayType) obj;
         return Objects.equal(getGenericComponentType(), that.getGenericComponentType());
@@ -260,11 +265,11 @@ public boolean equals(Object obj) {
 
   private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
 
-    @NullableDecl private final Type ownerType;
+    @CheckForNull private final Type ownerType;
     private final ImmutableList<Type> argumentsList;
     private final Class<?> rawType;
 
-    ParameterizedTypeImpl(@NullableDecl Type ownerType, Class<?> rawType, Type[] typeArguments) {
+    ParameterizedTypeImpl(@CheckForNull Type ownerType, Class<?> rawType, Type[] typeArguments) {
       checkNotNull(rawType);
       checkArgument(typeArguments.length == rawType.getTypeParameters().length);
       disallowPrimitiveType(typeArguments, ""type parameter"");
@@ -284,6 +289,7 @@ public Type getRawType() {
     }
 
     @Override
+    @CheckForNull
     public Type getOwnerType() {
       return ownerType;
     }
@@ -310,7 +316,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (!(other instanceof ParameterizedType)) {
         return false;
       }
@@ -386,7 +392,9 @@ public boolean equals(Object other) {
     }
 
     @Override
-    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+    @CheckForNull
+    public Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
+        throws Throwable {
       String methodName = method.getName();
       Method typeVariableMethod = typeVariableMethods.get(methodName);
       if (typeVariableMethod == null) {
@@ -441,7 +449,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY) {
         // equal only to our TypeVariable implementation with identical bounds
         if (obj != null
@@ -490,7 +498,7 @@ public boolean equals(Object obj) {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof WildcardType) {
         WildcardType that = (WildcardType) obj;
         return lowerBounds.equals(Arrays.asList(that.getLowerBounds())), @@ -19,6 +19,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.Arrays;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -39,6 +40,8 @@
  * @since 12.0
  */
 @Beta
+// TODO(cpovirk): after adding @Nullable below
+@ElementTypesAreNonnullByDefault
 public abstract class AbstractInvocationHandler implements InvocationHandler {
 
   private static final Object[] NO_ARGS = {};
@@ -59,7 +62,8 @@
    * </ul>
    */
   @Override
-  public final Object invoke(Object proxy, Method method, Object @Nullable [] args)
+  @CheckForNull
+  public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
       throws Throwable {
     if (args == null) {
       args = NO_ARGS;
@@ -94,8 +98,9 @@ public final Object invoke(Object proxy, Method method, Object @Nullable [] args
    * <p>Unlike {@link #invoke}, {@code args} will never be null. When the method has no parameter,
    * an empty array is passed in.
    */
-  protected abstract Object handleInvocation(Object proxy, Method method, Object[] args)
-      throws Throwable;
+  @CheckForNull
+  protected abstract Object handleInvocation(
+      Object proxy, Method method, /* TODO(cpovirk): @Nullable */ Object[] args) throws Throwable;
 
   /**
    * By default delegates to {@link Object#equals} so instances are only equal if they are
@@ -109,7 +114,7 @@ protected abstract Object handleInvocation(Object proxy, Method method, Object[]
    * <p>Subclasses can override this method to provide custom equality.
    */
   @Override
-  public boolean equals(Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     return super.equals(obj);
   }
 , @@ -51,7 +51,7 @@
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Scans the source of a {@link ClassLoader} and finds all loadable classes and resources.
@@ -72,6 +72,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class ClassPath {
   private static final Logger logger = Logger.getLogger(ClassPath.class.getName());
 
@@ -265,7 +266,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof ResourceInfo) {
         ResourceInfo that = (ResourceInfo) obj;
         return resourceName.equals(that.resourceName) && loader == that.loader;
@@ -297,8 +298,13 @@ public String toString() {
     /**
      * Returns the package name of the class, without attempting to load the class.
      *
-     * <p>Behaves identically to {@link Package#getName()} but does not require the class (or
-     * package) to be loaded.
+     * <p>Behaves similarly to {@code class.getPackage().}{@link Package#getName() getName()} but
+     * does not require the class (or package) to be loaded.
+     *
+     * <p>But note that this method may behave differently for a class in the default package: For
+     * such classes, this method always returns an empty string. But under some version of Java,
+     * {@code class.getPackage().getName()} produces a {@code NullPointerException} because {@code
+     * class.getPackage()} returns {@code null}.
      */
     public String getPackageName() {
       return Reflection.getPackageName(className);
@@ -307,8 +313,11 @@ public String getPackageName() {
     /**
      * Returns the simple name of the underlying class as given in the source code.
      *
-     * <p>Behaves identically to {@link Class#getSimpleName()} but does not require the class to be
+     * <p>Behaves similarly to {@link Class#getSimpleName()} but does not require the class to be
      * loaded.
+     *
+     * <p>But note that this class uses heuristics to identify the simple name. See a related
+     * discussion in <a href=""https://github.com/google/guava/issues/3349"">issue 3349</a>.
      */
     public String getSimpleName() {
       int lastDollarSign = className.lastIndexOf('$');
@@ -531,7 +540,7 @@ private void scanDirectory(
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof LocationInfo) {
         LocationInfo that = (LocationInfo) obj;
         return home.equals(that.home) && classloader.equals(that.classloader);
@@ -558,7 +567,8 @@ public String toString() {
    * an empty set will be returned.
    */
   @VisibleForTesting
-  static ImmutableSet<File> getClassPathFromManifest(File jarFile, @Nullable Manifest manifest) {
+  static ImmutableSet<File> getClassPathFromManifest(
+      File jarFile, @CheckForNull Manifest manifest) {
     if (manifest == null) {
       return ImmutableSet.of();
     }, @@ -23,14 +23,15 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Represents either a {@link Field}, a {@link Method} or a {@link Constructor}. Provides
  * convenience methods such as {@link #isPublic} and {@link #isPackagePrivate}.
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 class Element extends AccessibleObject implements Member {
 
   private final AccessibleObject accessibleObject;
@@ -52,6 +53,7 @@ public final boolean isAnnotationPresent(Class<? extends Annotation> annotationC
   }
 
   @Override
+  @CheckForNull
   public final <A extends Annotation> A getAnnotation(Class<A> annotationClass) {
     return accessibleObject.getAnnotation(annotationClass);
   }
@@ -158,7 +160,7 @@ final boolean isTransient() {
   }
 
   @Override
-  public boolean equals(@Nullable Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj instanceof Element) {
       Element that = (Element) obj;
       return getOwnerType().equals(that.getOwnerType()) && member.equals(that.member);, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.reflect;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -31,6 +31,7 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.Arrays;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -56,6 +57,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public abstract class Invokable<T, R> extends Element implements GenericDeclaration {
 
   <M extends AccessibleObject & Member> Invokable(M member) {
@@ -94,10 +96,11 @@
    *     invocation conversion.
    * @throws InvocationTargetException if the underlying method or constructor throws an exception.
    */
-  // All subclasses are owned by us and we'll make sure to get the R type right.
-  @SuppressWarnings(""unchecked"")
+  // All subclasses are owned by us and we'll make sure to get the R type right, including nullness.
+  @SuppressWarnings({""unchecked"", ""nullness""})
   @CanIgnoreReturnValue
-  public final R invoke(@Nullable T receiver, Object... args)
+  @CheckForNull
+  public final R invoke(@CheckForNull T receiver, @Nullable Object... args)
       throws InvocationTargetException, IllegalAccessException {
     return (R) invokeInternal(receiver, checkNotNull(args));
   }
@@ -177,7 +180,8 @@ public final R invoke(@Nullable T receiver, Object... args)
     return (TypeToken<T>) TypeToken.of(getDeclaringClass());
   }
 
-  abstract Object invokeInternal(@Nullable Object receiver, Object[] args)
+  @CheckForNull
+  abstract Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
       throws InvocationTargetException, IllegalAccessException;
 
   abstract Type[] getGenericParameterTypes();
@@ -203,7 +207,8 @@ abstract Object invokeInternal(@Nullable Object receiver, Object[] args)
     }
 
     @Override
-    final Object invokeInternal(@Nullable Object receiver, Object[] args)
+    @CheckForNull
+    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       return method.invoke(receiver, args);
     }
@@ -267,7 +272,7 @@ public final boolean isVarArgs() {
     }
 
     @Override
-    final Object invokeInternal(@Nullable Object receiver, Object[] args)
+    final Object invokeInternal(@CheckForNull Object receiver, @Nullable Object[] args)
         throws InvocationTargetException, IllegalAccessException {
       try {
         return constructor.newInstance(args);, @@ -22,7 +22,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.AnnotatedType;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Represents a method or constructor parameter.
@@ -31,6 +31,7 @@
  * @since 14.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class Parameter implements AnnotatedElement {
 
   private final Invokable<?, ?> declaration;
@@ -68,7 +69,8 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   }
 
   @Override
-  public <A extends Annotation> @Nullable A getAnnotation(Class<A> annotationType) {
+  @CheckForNull
+  public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     for (Annotation annotation : annotations) {
       if (annotationType.isInstance(annotation)) {
@@ -100,7 +102,8 @@ public boolean isAnnotationPresent(Class<? extends Annotation> annotationType) {
   /** @since 18.0 */
   // @Override on JDK8
   @Override
-  public <A extends Annotation> @Nullable A getDeclaredAnnotation(Class<A> annotationType) {
+  @CheckForNull
+  public <A extends Annotation> A getDeclaredAnnotation(Class<A> annotationType) {
     checkNotNull(annotationType);
     return FluentIterable.from(annotations).filter(annotationType).first().orNull();
   }
@@ -119,7 +122,7 @@ public AnnotatedType getAnnotatedType() {
   }
 
   @Override
-  public boolean equals(@Nullable Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj instanceof Parameter) {
       Parameter that = (Parameter) obj;
       return position == that.position && declaration.equals(that.declaration);, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.reflect;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -27,6 +27,7 @@
  * @since 12.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class Reflection {
 
   /**, @@ -24,6 +24,7 @@
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 abstract class TypeCapture<T> {
 
   /** Returns the captured type. */, @@ -19,7 +19,7 @@
 import com.google.common.annotations.Beta;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Captures a free type variable that can be used in {@link TypeToken#where}. For example:
@@ -35,6 +35,17 @@
  * @since 12.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
+/*
+ * A nullable bound would let users create a TypeParameter instance for a parameter with a nullable
+ * bound. However, it would also let them create `new TypeParameter<@Nullable T>() {}`, which
+ * wouldn't behave as users might expect. Additionally, it's not clear how the TypeToken API could
+ * support even a ""normal"" `TypeParameter<T>` when `<T>` has a nullable bound. (See the discussion
+ * on TypeToken.where.) So, in the interest of failing fast and encouraging the user to switch to a
+ * non-null bound if possible, let's require a non-null bound here.
+ *
+ * TODO(cpovirk): Elaborate on ""wouldn't behave as users might expect.""
+ */
 public abstract class TypeParameter<T> extends TypeCapture<T> {
 
   final TypeVariable<?> typeVariable;
@@ -51,7 +62,7 @@ public final int hashCode() {
   }
 
   @Override
-  public final boolean equals(@Nullable Object o) {
+  public final boolean equals(@CheckForNull Object o) {
     if (o instanceof TypeParameter) {
       TypeParameter<?> that = (TypeParameter<?>) o;
       return typeVariable.equals(that.typeVariable);, @@ -35,7 +35,7 @@
 import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * An object of this class encapsulates type mappings from type variables. Mappings are established
@@ -52,6 +52,7 @@
  * @since 15.0
  */
 @Beta
+@ElementTypesAreNonnullByDefault
 public final class TypeResolver {
 
   private final TypeTable typeTable;
@@ -527,7 +528,8 @@ private WildcardCapturer notForTypeVariable() {
       return new WildcardCapturer(id);
     }
 
-    private Type captureNullable(@Nullable Type type) {
+    @CheckForNull
+    private Type captureNullable(@CheckForNull Type type) {
       if (type == null) {
         return null;
       }
@@ -561,7 +563,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof TypeVariableKey) {
         TypeVariableKey that = (TypeVariableKey) obj;
         return equalsTypeVariable(that.var);
@@ -576,6 +578,7 @@ public String toString() {
     }
 
     /** Wraps {@code t} in a {@code TypeVariableKey} if it's a type variable. */
+    @CheckForNull
     static TypeVariableKey forLookup(Type t) {
       if (t instanceof TypeVariable) {
         return new TypeVariableKey((TypeVariable<?>) t);, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.VisibleForTesting;
@@ -46,7 +47,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Type} with generics.
@@ -98,15 +99,16 @@
  */
 @Beta
 @SuppressWarnings(""serial"") // SimpleTypeToken is the serialized form.
+@ElementTypesAreNonnullByDefault
 public abstract class TypeToken<T> extends TypeCapture<T> implements Serializable {
 
   private final Type runtimeType;
 
   /** Resolver for resolving parameter and field types with {@link #runtimeType} as context. */
-  private transient @Nullable TypeResolver invariantTypeResolver;
+  @CheckForNull private transient TypeResolver invariantTypeResolver;
 
   /** Resolver for resolving covariant types with {@link #runtimeType} as context. */
-  private transient @Nullable TypeResolver covariantTypeResolver;
+  @CheckForNull private transient TypeResolver covariantTypeResolver;
 
   /**
    * Constructs a new type token of {@code T}.
@@ -220,6 +222,17 @@ public final Type getType() {
    * @param typeParam the parameter type variable
    * @param typeArg the actual type to substitute
    */
+  /*
+   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters
+   * that have nullable bounds? Unfortunately, if we change the parameter to TypeParameter<? extends
+   * @Nullable X>, then users might pass a TypeParameter<Y>, where Y is a subtype of X, while still
+   * passing a TypeToken<X>. This would be invalid. Maybe we could accept a TypeParameter<@PolyNull
+   * X> if we support such a thing? It would be weird or misleading for users to be able to pass
+   * `new TypeParameter<@Nullable T>() {}` and have it act as a plain `TypeParameter<T>`, but
+   * hopefully no one would do that, anyway. See also the comment on TypeParameter itself.
+   *
+   * TODO(cpovirk): Elaborate on this / merge with other comment?
+   */
   public final <X> TypeToken<T> where(TypeParameter<X> typeParam, TypeToken<X> typeArg) {
     TypeResolver resolver =
         new TypeResolver()
@@ -248,6 +261,10 @@ public final Type getType() {
    * @param typeParam the parameter type variable
    * @param typeArg the actual type to substitute
    */
+  /*
+   * TODO(cpovirk): Is there any way for us to support TypeParameter instances for type parameters
+   * that have nullable bounds? See discussion on the other overload of this method.
+   */
   public final <X> TypeToken<T> where(TypeParameter<X> typeParam, Class<X> typeArg) {
     return where(typeParam, of(typeArg));
   }
@@ -288,7 +305,8 @@ public final Type getType() {
    * if the bound is a class or extends from a class. This means that the returned type could be a
    * type variable too.
    */
-  final @Nullable TypeToken<? super T> getGenericSuperclass() {
+  @CheckForNull
+  final TypeToken<? super T> getGenericSuperclass() {
     if (runtimeType instanceof TypeVariable) {
       // First bound is always the super class, if one exists.
       return boundAsSuperclass(((TypeVariable<?>) runtimeType).getBounds()[0]);
@@ -306,7 +324,8 @@ public final Type getType() {
     return superToken;
   }
 
-  private @Nullable TypeToken<? super T> boundAsSuperclass(Type bound) {
+  @CheckForNull
+  private TypeToken<? super T> boundAsSuperclass(Type bound) {
     TypeToken<?> token = of(bound);
     if (token.getRawType().isInterface()) {
       return null;
@@ -558,7 +577,8 @@ private boolean isWrapper() {
    * Returns the array component type if this type represents an array ({@code int[]}, {@code T[]},
    * {@code <? extends Map<String, Integer>[]>} etc.), or else {@code null} is returned.
    */
-  public final @Nullable TypeToken<?> getComponentType() {
+  @CheckForNull
+  public final TypeToken<?> getComponentType() {
     Type componentType = Types.getComponentType(runtimeType);
     if (componentType == null) {
       return null;
@@ -652,7 +672,7 @@ public String toString() {
    */
   public class TypeSet extends ForwardingSet<TypeToken<? super T>> implements Serializable {
 
-    private transient @Nullable ImmutableSet<TypeToken<? super T>> types;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> types;
 
     TypeSet() {}
 
@@ -698,7 +718,7 @@ public TypeSet classes() {
   private final class InterfaceSet extends TypeSet {
 
     private final transient TypeSet allTypes;
-    private transient @Nullable ImmutableSet<TypeToken<? super T>> interfaces;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> interfaces;
 
     InterfaceSet(TypeSet allTypes) {
       this.allTypes = allTypes;
@@ -751,7 +771,7 @@ private Object readResolve() {
 
   private final class ClassSet extends TypeSet {
 
-    private transient @Nullable ImmutableSet<TypeToken<? super T>> classes;
+    @CheckForNull private transient ImmutableSet<TypeToken<? super T>> classes;
 
     @Override
     protected Set<TypeToken<? super T>> delegate() {
@@ -816,7 +836,7 @@ public boolean apply(TypeToken<?> type) {
    * Returns true if {@code o} is another {@code TypeToken} that represents the same {@link Type}.
    */
   @Override
-  public boolean equals(@Nullable Object o) {
+  public boolean equals(@CheckForNull Object o) {
     if (o instanceof TypeToken) {
       TypeToken<?> that = (TypeToken<?>) o;
       return runtimeType.equals(that.runtimeType);
@@ -1130,7 +1150,8 @@ private boolean isOwnedBySubtypeOf(Type supertype) {
    * Returns the owner type of a {@link ParameterizedType} or enclosing class of a {@link Class}, or
    * null otherwise.
    */
-  private @Nullable Type getOwnerTypeIfPresent() {
+  @CheckForNull
+  private Type getOwnerTypeIfPresent() {
     if (runtimeType instanceof ParameterizedType) {
       return ((ParameterizedType) runtimeType).getOwnerType();
     } else if (runtimeType instanceof Class<?>) {
@@ -1219,11 +1240,19 @@ private TypeResolver getInvariantTypeResolver() {
     // with component type, we have lost generic type information
     // Use raw type so that compiler allows us to call getSupertype()
     @SuppressWarnings(""rawtypes"")
-    TypeToken componentType =
-        checkNotNull(getComponentType(), ""%s isn't a super type of %s"", supertype, this);
+    TypeToken componentType = getComponentType();
+    // TODO(cpovirk): checkArgument?
+    if (componentType == null) {
+      throw new IllegalArgumentException(supertype + "" isn't a super type of "" + this);
+    }
     // array is covariant. component type is super type, so is the array type.
     @SuppressWarnings(""unchecked"") // going from raw type back to generics
-    TypeToken<?> componentSupertype = componentType.getSupertype(supertype.getComponentType());
+    /*
+     * requireNonNull is safe because we call getArraySupertype only after checking
+     * supertype.isArray().
+     */
+    TypeToken<?> componentSupertype =
+        componentType.getSupertype(requireNonNull(supertype.getComponentType()));
     @SuppressWarnings(""unchecked"") // component type is super type, so is array type.
     TypeToken<? super T> result =
         (TypeToken<? super T>)
@@ -1233,8 +1262,14 @@ private TypeResolver getInvariantTypeResolver() {
   }
 
   private TypeToken<? extends T> getArraySubtype(Class<?> subclass) {
+    Class<?> subclassComponentType = subclass.getComponentType();
+    if (subclassComponentType == null) {
+      throw new IllegalArgumentException(subclass + "" does not appear to be a subtype of "" + this);
+    }
     // array is covariant. component type is subtype, so is the array type.
-    TypeToken<?> componentSubtype = getComponentType().getSubtype(subclass.getComponentType());
+    // requireNonNull is safe because we call getArraySubtype only when isArray().
+    TypeToken<?> componentSubtype =
+        requireNonNull(getComponentType()).getSubtype(subclassComponentType);
     @SuppressWarnings(""unchecked"") // component type is subtype, so is array type.
     TypeToken<? extends T> result =
         (TypeToken<? extends T>)
@@ -1307,7 +1342,7 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
           }
 
           @Override
-          @Nullable
+          @CheckForNull
           TypeToken<?> getSuperclass(TypeToken<?> type) {
             return type.getGenericSuperclass();
           }
@@ -1326,7 +1361,7 @@ private static Type newArrayClassOrGenericArrayType(Type componentType) {
           }
 
           @Override
-          @Nullable
+          @CheckForNull
           Class<?> getSuperclass(Class<?> type) {
             return type.getSuperclass();
           }
@@ -1398,7 +1433,9 @@ private int collectTypes(K type, Map<? super K, Integer> map) {
           new Ordering<K>() {
             @Override
             public int compare(K left, K right) {
-              return valueComparator.compare(map.get(left), map.get(right));
+              // requireNonNull is safe because we are passing keys in the map.
+              return valueComparator.compare(
+                  requireNonNull(map.get(left)), requireNonNull(map.get(right)));
             }
           };
       return keyOrdering.immutableSortedCopy(map.keySet());
@@ -1408,7 +1445,8 @@ public int compare(K left, K right) {
 
     abstract Iterable<? extends K> getInterfaces(K type);
 
-    abstract @Nullable K getSuperclass(K type);
+    @CheckForNull
+    abstract K getSuperclass(K type);
 
     private static class ForwardingTypeCollector<K> extends TypeCollector<K> {
 
@@ -1429,6 +1467,7 @@ public int compare(K left, K right) {
       }
 
       @Override
+      @CheckForNull
       K getSuperclass(K type) {
         return delegate.getSuperclass(type);
       }, @@ -21,6 +21,7 @@
 import java.lang.reflect.TypeVariable;
 import java.lang.reflect.WildcardType;
 import java.util.Set;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Based on what a {@link Type} is, dispatch it to the corresponding {@code visit*} method. By
@@ -53,6 +54,7 @@
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 abstract class TypeVisitor {
 
   private final Set<Type> visited = Sets.newHashSet();
@@ -61,7 +63,7 @@
    * Visits the given types. Null types are ignored. This allows subclasses to call {@code
    * visit(parameterizedType.getOwnerType())} safely without having to check nulls.
    */
-  public final void visit(Type... types) {
+  public final void visit(@Nullable Type... types) {
     for (Type type : types) {
       if (type == null || !visited.add(type)) {
         // null owner type, or already visited;, @@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.transform;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Function;
@@ -44,13 +45,15 @@
 import java.util.Collection;
 import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Utilities for working with {@link Type}.
  *
  * @author Ben Yu
  */
+@ElementTypesAreNonnullByDefault
 final class Types {
 
   /** Class#toString without the ""class "" and ""interface "" prefixes */
@@ -86,7 +89,7 @@ static Type newArrayType(Type componentType) {
    * {@code ownerType}.
    */
   static ParameterizedType newParameterizedTypeWithOwner(
-      @Nullable Type ownerType, Class<?> rawType, Type... arguments) {
+      @CheckForNull Type ownerType, Class<?> rawType, Type... arguments) {
     if (ownerType == null) {
       return newParameterizedType(rawType, arguments);
     }
@@ -106,14 +109,14 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
   private enum ClassOwnership {
     OWNED_BY_ENCLOSING_CLASS {
       @Override
-      @Nullable
+      @CheckForNull
       Class<?> getOwnerType(Class<?> rawType) {
         return rawType.getEnclosingClass();
       }
     },
     LOCAL_CLASS_HAS_NO_OWNER {
       @Override
-      @Nullable
+      @CheckForNull
       Class<?> getOwnerType(Class<?> rawType) {
         if (rawType.isLocalClass()) {
           return null;
@@ -123,14 +126,17 @@ static ParameterizedType newParameterizedType(Class<?> rawType, Type... argument
       }
     };
 
-    abstract @Nullable Class<?> getOwnerType(Class<?> rawType);
+    @CheckForNull
+    abstract Class<?> getOwnerType(Class<?> rawType);
 
     static final ClassOwnership JVM_BEHAVIOR = detectJvmBehavior();
 
     private static ClassOwnership detectJvmBehavior() {
       class LocalClass<T> {}
       Class<?> subclass = new LocalClass<String>() {}.getClass();
-      ParameterizedType parameterizedType = (ParameterizedType) subclass.getGenericSuperclass();
+      // requireNonNull is safe because we're examining a type that's known to have a superclass.
+      ParameterizedType parameterizedType =
+          requireNonNull((ParameterizedType) subclass.getGenericSuperclass());
       for (ClassOwnership behavior : ClassOwnership.values()) {
         if (behavior.getOwnerType(LocalClass.class) == parameterizedType.getOwnerType()) {
           return behavior;
@@ -171,9 +177,10 @@ static String toString(Type type) {
     return (type instanceof Class) ? ((Class<?>) type).getName() : type.toString();
   }
 
-  static @Nullable Type getComponentType(Type type) {
+  @CheckForNull
+  static Type getComponentType(Type type) {
     checkNotNull(type);
-    final AtomicReference<Type> result = new AtomicReference<>();
+    final AtomicReference<@Nullable Type> result = new AtomicReference<>();
     new TypeVisitor() {
       @Override
       void visitTypeVariable(TypeVariable<?> t) {
@@ -202,7 +209,8 @@ void visitClass(Class<?> t) {
    * Returns {@code ? extends X} if any of {@code bounds} is a subtype of {@code X[]}; or null
    * otherwise.
    */
-  private static @Nullable Type subtypeOfComponentType(Type[] bounds) {
+  @CheckForNull
+  private static Type subtypeOfComponentType(Type[] bounds) {
     for (Type bound : bounds) {
       Type componentType = getComponentType(bound);
       if (componentType != null) {
@@ -244,7 +252,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof GenericArrayType) {
         GenericArrayType that = (GenericArrayType) obj;
         return Objects.equal(getGenericComponentType(), that.getGenericComponentType());
@@ -257,11 +265,11 @@ public boolean equals(Object obj) {
 
   private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {
 
-    private final @Nullable Type ownerType;
+    @CheckForNull private final Type ownerType;
     private final ImmutableList<Type> argumentsList;
     private final Class<?> rawType;
 
-    ParameterizedTypeImpl(@Nullable Type ownerType, Class<?> rawType, Type[] typeArguments) {
+    ParameterizedTypeImpl(@CheckForNull Type ownerType, Class<?> rawType, Type[] typeArguments) {
       checkNotNull(rawType);
       checkArgument(typeArguments.length == rawType.getTypeParameters().length);
       disallowPrimitiveType(typeArguments, ""type parameter"");
@@ -281,6 +289,7 @@ public Type getRawType() {
     }
 
     @Override
+    @CheckForNull
     public Type getOwnerType() {
       return ownerType;
     }
@@ -307,7 +316,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (!(other instanceof ParameterizedType)) {
         return false;
       }
@@ -383,7 +392,9 @@ public boolean equals(Object other) {
     }
 
     @Override
-    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+    @CheckForNull
+    public Object invoke(Object proxy, Method method, @CheckForNull @Nullable Object[] args)
+        throws Throwable {
       String methodName = method.getName();
       Method typeVariableMethod = typeVariableMethods.get(methodName);
       if (typeVariableMethod == null) {
@@ -438,7 +449,7 @@ public int hashCode() {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY) {
         // equal only to our TypeVariable implementation with identical bounds
         if (obj != null
@@ -487,7 +498,7 @@ public boolean equals(Object obj) {
     }
 
     @Override
-    public boolean equals(Object obj) {
+    public boolean equals(@CheckForNull Object obj) {
       if (obj instanceof WildcardType) {
         WildcardType that = (WildcardType) obj;
         return lowerBounds.equals(Arrays.asList(that.getLowerBounds())), ","Annotate most of `reflect` for nullness.

And add some documentation relevant to https://github.com/google/guava/issues/3349

RELNOTES=n/a",Annotate most of `reflect` for nullness.
5503,,"['guava/src/com/google/common/collect/Multimaps.java', 'guava/src/com/google/common/collect/Multisets.java', 'guava/src/com/google/common/collect/Tables.java']","@@ -103,6 +103,10 @@ private Multimaps() {}
    * }
    * }</pre>
    *
+   * <p>To collect to an {@link ImmutableMultimap}, use either {@link
+   * ImmutableSetMultimap#toImmutableSetMultimap} or {@link
+   * ImmutableListMultimap#toImmutableListMultimap}.
+   *
    * @since 21.0
    */
   public static <T, K, V, M extends Multimap<K, V>> Collector<T, ?, M> toMultimap(, @@ -70,6 +70,9 @@ private Multisets() {}
    * <p>Note that {@code stream.collect(toMultiset(function, e -> 1, supplier))} is equivalent to
    * {@code stream.map(function).collect(Collectors.toCollection(supplier))}.
    *
+   * <p>To collect to an {@link ImmutableMultiset}, use {@link
+   * ImmutableMultiset#toImmutableMultiset}.
+   *
    * @since 22.0
    */
   public static <T, E, M extends Multiset<E>> Collector<T, ?, M> toMultiset(, @@ -60,6 +60,8 @@ private Tables() {}
    * <p>If multiple input elements map to the same row and column, an {@code IllegalStateException}
    * is thrown when the collection operation is performed.
    *
+   * <p>To collect to an {@link ImmutableTable}, use {@link ImmutableTable#toImmutableTable}.
+   *
    * @since 21.0
    */
   @Beta, ","Link to the immutable collectors from the utility classes.

RELNOTES=n/a",Link to the immutable collectors from the utility classes.
5505,,"['android/guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java', 'guava/src/com/google/common/util/concurrent/AtomicDoubleArray.java']","@@ -96,7 +96,7 @@ public final double get(int i) {
   }
 
   /**
-   * Sets the element at position {@code i} to the given value.
+   * Atomically sets the element at position {@code i} to the given value.
    *
    * @param i the index
    * @param newValue the new value, @@ -96,7 +96,7 @@ public final double get(int i) {
   }
 
   /**
-   * Sets the element at position {@code i} to the given value.
+   * Atomically sets the element at position {@code i} to the given value.
    *
    * @param i the index
    * @param newValue the new value, ","clarify `AtomicDoubleArray.set()` javadocs.

RELNOTES=n/a",clarify `AtomicDoubleArray.set()` javadocs.
5511,,"['android/guava-testlib/src/com/google/common/testing/NullPointerTester.java', 'android/guava-tests/test/com/google/common/io/ByteSourceTester.java', 'android/guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'android/guava/src/com/google/common/eventbus/SubscriberExceptionContext.java', 'android/guava/src/com/google/common/io/ByteSource.java', 'android/guava/src/com/google/common/math/DoubleMath.java', 'android/guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'android/guava/src/com/google/common/util/concurrent/Futures.java', 'android/guava/src/com/google/common/util/concurrent/ListenerCallQueue.java', 'guava-testlib/src/com/google/common/testing/NullPointerTester.java', 'guava-tests/test/com/google/common/io/ByteSourceTester.java', 'guava/src/com/google/common/base/FinalizableReferenceQueue.java', 'guava/src/com/google/common/collect/CollectCollectors.java', 'guava/src/com/google/common/eventbus/SubscriberExceptionContext.java', 'guava/src/com/google/common/io/ByteSource.java', 'guava/src/com/google/common/math/DoubleMath.java', 'guava/src/com/google/common/util/concurrent/AbstractScheduledService.java', 'guava/src/com/google/common/util/concurrent/Futures.java', 'guava/src/com/google/common/util/concurrent/ListenerCallQueue.java']","@@ -491,7 +491,7 @@ private boolean isIgnored(Member member) {
   }
 
   /**
-   * Returns true if the the given member is a method that overrides {@link Object#equals(Object)}.
+   * Returns true if the given member is a method that overrides {@link Object#equals(Object)}.
    *
    * <p>The documentation for {@link Object#equals} says it should accept null, so don't require an
    * explicit {@code @NullableDecl} annotation (see <a, @@ -38,7 +38,7 @@
 /**
  * A generator of {@code TestSuite} instances for testing {@code ByteSource} implementations.
  * Generates tests of a all methods on a {@code ByteSource} given various inputs the source is
- * expected to contain as well as as sub-suites for testing the {@code CharSource} view and {@code
+ * expected to contain as well as sub-suites for testing the {@code CharSource} view and {@code
  * slice()} views in the same way.
  *
  * @author Colin Decker, @@ -37,7 +37,7 @@
  * finalized. If this object is garbage collected earlier, the backing thread will not invoke {@code
  * finalizeReferent()} on the remaining references.
  *
- * <p>As an example of how this is used, imagine you have a class {@code MyServer} that creates a a
+ * <p>As an example of how this is used, imagine you have a class {@code MyServer} that creates a
  * {@link java.net.ServerSocket ServerSocket}, and you would like to ensure that the {@code
  * ServerSocket} is closed even if the {@code MyServer} object is garbage-collected without calling
  * its {@code close} method. You <em>could</em> use a finalizer to accomplish this, but that has a, @@ -31,7 +31,7 @@
 
   /**
    * @param eventBus The {@link EventBus} that handled the event and the subscriber. Useful for
-   *     broadcasting a a new event based on the error.
+   *     broadcasting a new event based on the error.
    * @param event The event object that caused the subscriber to throw.
    * @param subscriber The source subscriber context.
    * @param subscriberMethod the subscribed method.
@@ -46,7 +46,7 @@
 
   /**
    * @return The {@link EventBus} that handled the event and the subscriber. Useful for broadcasting
-   *     a a new event based on the error.
+   *     a new event based on the error.
    */
   public EventBus getEventBus() {
     return eventBus;, @@ -428,7 +428,7 @@ public static ByteSource concat(ByteSource... sources) {
    * Returns a view of the given byte array as a {@link ByteSource}. To view only a specific range
    * in the array, use {@code ByteSource.wrap(b).slice(offset, length)}.
    *
-   * <p>Note that the given byte array may be be passed directly to methods on, for example, {@code
+   * <p>Note that the given byte array may be passed directly to methods on, for example, {@code
    * OutputStream} (when {@code copyTo(OutputStream)} is called on the resulting {@code
    * ByteSource}). This could allow a malicious {@code OutputStream} implementation to modify the
    * contents of the array, but provides better performance in the normal case., @@ -432,7 +432,7 @@ public static double mean(double... values) {
   @Deprecated
   public static double mean(int... values) {
     checkArgument(values.length > 0, ""Cannot take mean of 0 values"");
-    // The upper bound on the the length of an array and the bounds on the int values mean that, in
+    // The upper bound on the length of an array and the bounds on the int values mean that, in
     // this case only, we can compute the sum as a long without risking overflow or loss of
     // precision. So we do that, as it's slightly quicker than the Knuth algorithm.
     long sum = 0;, @@ -316,9 +316,9 @@ protected void shutDown() throws Exception {}
    * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}
    * instance. This method is guaranteed to only be called once.
    *
-   * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread thread
-   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}. Also,
-   * the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service
+   * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread pool
+   * that sets the name of the thread to the {@linkplain #serviceName() service name}. Also, the
+   * pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service
    * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED
    * fails}.
    */, @@ -1261,7 +1261,7 @@ private static void wrapAndThrowUnchecked(Throwable cause) {
    * the computation -- makes sense, and if we don't convert it, the user still has to write a
    * try-catch block.
    *
-   * If you think you would use this method, let us know. You might also also look into the
+   * If you think you would use this method, let us know. You might also look into the
    * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html
    */
 }, @@ -123,7 +123,7 @@ public void dispatch() {
 
   /**
    * A special purpose queue/executor that dispatches listener events serially on a configured
-   * executor. Each event event can be added and dispatched as separate phases.
+   * executor. Each event can be added and dispatched as separate phases.
    *
    * <p>This class is very similar to {@link SequentialExecutor} with the exception that events can
    * be added without necessarily executing immediately., @@ -539,7 +539,7 @@ private boolean isIgnored(Member member) {
   }
 
   /**
-   * Returns true if the the given member is a method that overrides {@link Object#equals(Object)}.
+   * Returns true if the given member is a method that overrides {@link Object#equals(Object)}.
    *
    * <p>The documentation for {@link Object#equals} says it should accept null, so don't require an
    * explicit {@code @Nullable} annotation (see <a, @@ -38,7 +38,7 @@
 /**
  * A generator of {@code TestSuite} instances for testing {@code ByteSource} implementations.
  * Generates tests of a all methods on a {@code ByteSource} given various inputs the source is
- * expected to contain as well as as sub-suites for testing the {@code CharSource} view and {@code
+ * expected to contain as well as sub-suites for testing the {@code CharSource} view and {@code
  * slice()} views in the same way.
  *
  * @author Colin Decker, @@ -37,7 +37,7 @@
  * finalized. If this object is garbage collected earlier, the backing thread will not invoke {@code
  * finalizeReferent()} on the remaining references.
  *
- * <p>As an example of how this is used, imagine you have a class {@code MyServer} that creates a a
+ * <p>As an example of how this is used, imagine you have a class {@code MyServer} that creates a
  * {@link java.net.ServerSocket ServerSocket}, and you would like to ensure that the {@code
  * ServerSocket} is closed even if the {@code MyServer} object is garbage-collected without calling
  * its {@code close} method. You <em>could</em> use a finalizer to accomplish this, but that has a, @@ -205,7 +205,7 @@ void add(E e) {
     checkNotNull(valueFunction);
     /*
      * We will always fail if there are duplicate keys, and the keys are always sorted by
-     * the Comparator, so the entries can come in in arbitrary order -- so we report UNORDERED.
+     * the Comparator, so the entries can come in an arbitrary order -- so we report UNORDERED.
      */
     return Collector.of(
         () -> new ImmutableSortedMap.Builder<K, V>(comparator),, @@ -31,7 +31,7 @@
 
   /**
    * @param eventBus The {@link EventBus} that handled the event and the subscriber. Useful for
-   *     broadcasting a a new event based on the error.
+   *     broadcasting a new event based on the error.
    * @param event The event object that caused the subscriber to throw.
    * @param subscriber The source subscriber context.
    * @param subscriberMethod the subscribed method.
@@ -46,7 +46,7 @@
 
   /**
    * @return The {@link EventBus} that handled the event and the subscriber. Useful for broadcasting
-   *     a a new event based on the error.
+   *     a new event based on the error.
    */
   public EventBus getEventBus() {
     return eventBus;, @@ -428,7 +428,7 @@ public static ByteSource concat(ByteSource... sources) {
    * Returns a view of the given byte array as a {@link ByteSource}. To view only a specific range
    * in the array, use {@code ByteSource.wrap(b).slice(offset, length)}.
    *
-   * <p>Note that the given byte array may be be passed directly to methods on, for example, {@code
+   * <p>Note that the given byte array may be passed directly to methods on, for example, {@code
    * OutputStream} (when {@code copyTo(OutputStream)} is called on the resulting {@code
    * ByteSource}). This could allow a malicious {@code OutputStream} implementation to modify the
    * contents of the array, but provides better performance in the normal case., @@ -432,7 +432,7 @@ public static double mean(double... values) {
   @Deprecated
   public static double mean(int... values) {
     checkArgument(values.length > 0, ""Cannot take mean of 0 values"");
-    // The upper bound on the the length of an array and the bounds on the int values mean that, in
+    // The upper bound on the length of an array and the bounds on the int values mean that, in
     // this case only, we can compute the sum as a long without risking overflow or loss of
     // precision. So we do that, as it's slightly quicker than the Knuth algorithm.
     long sum = 0;, @@ -345,9 +345,9 @@ protected void shutDown() throws Exception {}
    * fails}. Subclasses may override this method to supply a custom {@link ScheduledExecutorService}
    * instance. This method is guaranteed to only be called once.
    *
-   * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread thread
-   * pool that sets the name of the thread to the {@linkplain #serviceName() service name}. Also,
-   * the pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service
+   * <p>By default this returns a new {@link ScheduledExecutorService} with a single thread pool
+   * that sets the name of the thread to the {@linkplain #serviceName() service name}. Also, the
+   * pool will be {@linkplain ScheduledExecutorService#shutdown() shut down} when the service
    * {@linkplain Service.State#TERMINATED terminates} or {@linkplain Service.State#TERMINATED
    * fails}.
    */, @@ -1345,7 +1345,7 @@ private static void wrapAndThrowUnchecked(Throwable cause) {
    * the computation -- makes sense, and if we don't convert it, the user still has to write a
    * try-catch block.
    *
-   * If you think you would use this method, let us know. You might also also look into the
+   * If you think you would use this method, let us know. You might also look into the
    * Fork-Join framework: http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html
    */
 }, @@ -123,7 +123,7 @@ public void dispatch() {
 
   /**
    * A special purpose queue/executor that dispatches listener events serially on a configured
-   * executor. Each event event can be added and dispatched as separate phases.
+   * executor. Each event can be added and dispatched as separate phases.
    *
    * <p>This class is very similar to {@link SequentialExecutor} with the exception that events can
    * be added without necessarily executing immediately., ","fix javadoc typos

RELNOTES=n/a",fix javadoc typos
5512,,"['android/guava/src/com/google/common/cache/CacheBuilder.java', 'guava/src/com/google/common/cache/CacheBuilder.java']","@@ -62,7 +62,8 @@
  *
  * <ul>
  *   <li>automatic loading of entries into the cache
- *   <li>least-recently-used eviction when a maximum size is exceeded
+ *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is
+ *       divided into segments, each of which does LRU internally)
  *   <li>time-based expiration of entries, measured since last access or last write
  *   <li>keys automatically wrapped in {@code WeakReference}
  *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}, @@ -61,7 +61,8 @@
  *
  * <ul>
  *   <li>automatic loading of entries into the cache
- *   <li>least-recently-used eviction when a maximum size is exceeded
+ *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is
+ *       divided into segments, each of which does LRU internally)
  *   <li>time-based expiration of entries, measured since last access or last write
  *   <li>keys automatically wrapped in {@code WeakReference}
  *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}, ","Clarify LRU behavior of `CacheBuilder`.

RELNOTES=n/a",Clarify LRU behavior of `CacheBuilder`.
5533,,"['android/guava/src/com/google/common/io/AppendableWriter.java', 'guava/src/com/google/common/io/AppendableWriter.java']","@@ -68,13 +68,15 @@ public void write(int c) throws IOException {
   }
 
   @Override
-  public void write(@NullableDecl String str) throws IOException {
+  public void write(String str) throws IOException {
+    checkNotNull(str);
     checkNotClosed();
     target.append(str);
   }
 
   @Override
-  public void write(@NullableDecl String str, int off, int len) throws IOException {
+  public void write(String str, int off, int len) throws IOException {
+    checkNotNull(str);
     checkNotClosed();
     // tricky: append takes start, end pair...
     target.append(str, off, off + len);, @@ -68,13 +68,15 @@ public void write(int c) throws IOException {
   }
 
   @Override
-  public void write(@Nullable String str) throws IOException {
+  public void write(String str) throws IOException {
+    checkNotNull(str);
     checkNotClosed();
     target.append(str);
   }
 
   @Override
-  public void write(@Nullable String str, int off, int len) throws IOException {
+  public void write(String str, int off, int len) throws IOException {
+    checkNotNull(str);
     checkNotClosed();
     // tricky: append takes start, end pair...
     target.append(str, off, off + len);, ","Reject `null` in `CharStreams.asWriter(appendable).write(string[, ...])`.

This brings its behavior in line with other `Writer` implementations. Unfortunately, the docs don't describe this behavior:

https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/io/Writer.html#write(java.lang.String)

Note also that this behavior differs from the behavior of `Writer.append(null)`, which is to write the four characters ""null."" That behavior is itself poorly documented, since the docs for `append(CharSequence)` claim that it is equivalent to `out.write(csq.toString())`, which would throw NPE... though at least *that* is contradicted in the `@param` tag. (The difference between `write` and `append` presumably arises from inheriting `append` from the newer `Appendable` API.)

RELNOTES=`io`: Changed `CharStreams.asWriter(appendable).write(string[, ...])` to reject a null `string`.","Reject `null` in `CharStreams.asWriter(appendable).write(string[, ...])`."
5534,,['guava/src/com/google/common/io/MoreFiles.java'],"@@ -803,16 +803,47 @@ private static void throwDeleteFailed(Path path, Collection<IOException> excepti
 
   private static @Nullable NoSuchFileException pathNotFound(
       Path path, Collection<IOException> exceptions) {
-    if (exceptions.size() == 1) {
-      IOException exception = getOnlyElement(exceptions);
-      if (exception instanceof NoSuchFileException) {
-        NoSuchFileException noSuchFileException = (NoSuchFileException) exception;
-        if (noSuchFileException
-            .getFile()
-            .equals(getParentPath(path).resolve(path.getFileName()).toString())) {
-          return noSuchFileException;
-        }
-      }
+    if (exceptions.size() != 1) {
+      return null;
+    }
+    IOException exception = getOnlyElement(exceptions);
+    if (!(exception instanceof NoSuchFileException)) {
+      return null;
+    }
+    NoSuchFileException noSuchFileException = (NoSuchFileException) exception;
+    String exceptionFile = noSuchFileException.getFile();
+    if (exceptionFile == null) {
+      /*
+       * It's not clear whether this happens in practice, especially with the filesystem
+       * implementations that are built into java.nio.
+       */
+      return null;
+    }
+    Path parentPath = getParentPath(path);
+    if (parentPath == null) {
+      /*
+       * This is probably impossible:
+       *
+       * - In deleteRecursively, we require the path argument to have a parent.
+       *
+       * - In deleteDirectoryContents, the path argument may have no parent. Fortunately, all the
+       *   *other* paths we process will be descendants of that. That leaves only the original path
+       *   argument for us to consider. And the only place we call pathNotFound is from
+       *   throwDeleteFailed, and the other place that we call throwDeleteFailed inside
+       *   deleteDirectoryContents is when an exception is thrown during the recusive steps. Any
+       *   failure during the initial lookup of the path argument itself is rethrown directly. So
+       *   any exception that we're seeing here is from a descendant, which naturally has a parent.
+       *   I think.
+       *
+       * Still, if this can happen somehow (a weird filesystem implementation that lets callers
+       * change its working directly concurrently with a call to deleteDirectoryContents?), it makes
+       * more sense for us to fall back to a generic FileSystemException (by returning null here)
+       * than to dereference parentPath and end up producing NullPointerException.
+       */
+      return null;
+    }
+    if (exceptionFile.equals(parentPath.resolve(path.getFileName()).toString())) {
+      return noSuchFileException;
     }
     return null;
   }, ","Avoid unlikely NullPointerException in deleteDirectoryContents and deleteRecursively.

RELNOTES=n/a",Avoid unlikely NullPointerException in deleteDirectoryContents and deleteRecursively.
5536,,"['android/guava-tests/test/com/google/common/io/ByteSourceTest.java', 'android/guava-tests/test/com/google/common/io/CharSourceTest.java', 'android/guava-tests/test/com/google/common/io/CloserTest.java', 'android/guava-tests/test/com/google/common/io/PatternFilenameFilterTest.java', 'android/guava/src/com/google/common/io/AppendableWriter.java', 'android/guava/src/com/google/common/io/BaseEncoding.java', 'android/guava/src/com/google/common/io/ByteArrayDataInput.java', 'android/guava/src/com/google/common/io/ByteArrayDataOutput.java', 'android/guava/src/com/google/common/io/ByteProcessor.java', 'android/guava/src/com/google/common/io/ByteSink.java', 'android/guava/src/com/google/common/io/ByteSource.java', 'android/guava/src/com/google/common/io/ByteStreams.java', 'android/guava/src/com/google/common/io/CharSequenceReader.java', 'android/guava/src/com/google/common/io/CharSink.java', 'android/guava/src/com/google/common/io/CharSource.java', 'android/guava/src/com/google/common/io/CharStreams.java', 'android/guava/src/com/google/common/io/Closeables.java', 'android/guava/src/com/google/common/io/Closer.java', 'android/guava/src/com/google/common/io/CountingInputStream.java', 'android/guava/src/com/google/common/io/CountingOutputStream.java', 'android/guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java', 'android/guava/src/com/google/common/io/FileBackedOutputStream.java', 'android/guava/src/com/google/common/io/FileWriteMode.java', 'android/guava/src/com/google/common/io/Files.java', 'android/guava/src/com/google/common/io/Flushables.java', 'android/guava/src/com/google/common/io/Java8Compatibility.java', 'android/guava/src/com/google/common/io/LineBuffer.java', 'android/guava/src/com/google/common/io/LineProcessor.java', 'android/guava/src/com/google/common/io/LineReader.java', 'android/guava/src/com/google/common/io/LittleEndianDataInputStream.java', 'android/guava/src/com/google/common/io/LittleEndianDataOutputStream.java', 'android/guava/src/com/google/common/io/MultiInputStream.java', 'android/guava/src/com/google/common/io/MultiReader.java', 'android/guava/src/com/google/common/io/ParametricNullness.java', 'android/guava/src/com/google/common/io/PatternFilenameFilter.java', 'android/guava/src/com/google/common/io/ReaderInputStream.java', 'android/guava/src/com/google/common/io/Resources.java', 'guava-tests/test/com/google/common/io/ByteSourceTest.java', 'guava-tests/test/com/google/common/io/CharSourceTest.java', 'guava-tests/test/com/google/common/io/CloserTest.java', 'guava-tests/test/com/google/common/io/PatternFilenameFilterTest.java', 'guava/src/com/google/common/io/AppendableWriter.java', 'guava/src/com/google/common/io/BaseEncoding.java', 'guava/src/com/google/common/io/ByteArrayDataInput.java', 'guava/src/com/google/common/io/ByteArrayDataOutput.java', 'guava/src/com/google/common/io/ByteProcessor.java', 'guava/src/com/google/common/io/ByteSink.java', 'guava/src/com/google/common/io/ByteSource.java', 'guava/src/com/google/common/io/ByteStreams.java', 'guava/src/com/google/common/io/CharSequenceReader.java', 'guava/src/com/google/common/io/CharSink.java', 'guava/src/com/google/common/io/CharSource.java', 'guava/src/com/google/common/io/CharStreams.java', 'guava/src/com/google/common/io/Closeables.java', 'guava/src/com/google/common/io/Closer.java', 'guava/src/com/google/common/io/CountingInputStream.java', 'guava/src/com/google/common/io/CountingOutputStream.java', 'guava/src/com/google/common/io/ElementTypesAreNonnullByDefault.java', 'guava/src/com/google/common/io/FileBackedOutputStream.java', 'guava/src/com/google/common/io/FileWriteMode.java', 'guava/src/com/google/common/io/Files.java', 'guava/src/com/google/common/io/Flushables.java', 'guava/src/com/google/common/io/InsecureRecursiveDeleteException.java', 'guava/src/com/google/common/io/Java8Compatibility.java', 'guava/src/com/google/common/io/LineBuffer.java', 'guava/src/com/google/common/io/LineProcessor.java', 'guava/src/com/google/common/io/LineReader.java', 'guava/src/com/google/common/io/LittleEndianDataInputStream.java', 'guava/src/com/google/common/io/LittleEndianDataOutputStream.java', 'guava/src/com/google/common/io/MoreFiles.java', 'guava/src/com/google/common/io/MultiInputStream.java', 'guava/src/com/google/common/io/MultiReader.java', 'guava/src/com/google/common/io/ParametricNullness.java', 'guava/src/com/google/common/io/PatternFilenameFilter.java', 'guava/src/com/google/common/io/ReaderInputStream.java', 'guava/src/com/google/common/io/RecursiveDeleteOption.java', 'guava/src/com/google/common/io/Resources.java']","@@ -30,6 +30,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.hash.Hashing;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.primitives.UnsignedBytes;
 import com.google.common.testing.TestLogHandler;
 import java.io.ByteArrayOutputStream;
@@ -395,7 +396,7 @@ public void testConcat_infiniteIterable() throws IOException {
       ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);
 
   public void testCopyExceptions() {
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (Closer.create().suppressor instanceof LoggingSuppressor) {
       // test that exceptions are logged
 
       TestLogHandler logHandler = new TestLogHandler();, @@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.testing.TestLogHandler;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -258,7 +259,7 @@ public void testConcat_infiniteIterable() throws IOException {
       ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);
 
   public void testCopyExceptions() {
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (Closer.create().suppressor instanceof LoggingSuppressor) {
       // test that exceptions are logged
 
       TestLogHandler logHandler = new TestLogHandler();, @@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.testing.TestLogHandler;
 import java.io.Closeable;
 import java.io.IOException;
@@ -311,13 +312,12 @@ public static void testLoggingSuppressor() throws IOException {
   }
 
   public static void testSuppressingSuppressorIfPossible() throws IOException {
+    Closer closer = Closer.create();
     // can't test the JDK7 suppressor when not running on JDK7
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (closer.suppressor instanceof LoggingSuppressor) {
       return;
     }
 
-    Closer closer = new Closer(new Closer.SuppressingSuppressor());
-
     IOException thrownException = new IOException();
     IOException c1Exception = new IOException();
     RuntimeException c2Exception = new RuntimeException();, @@ -16,6 +16,8 @@
 
 package com.google.common.io;
 
+import com.google.common.testing.NullPointerTester;
+import com.google.common.testing.NullPointerTester.Visibility;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.util.regex.PatternSyntaxException;
@@ -46,4 +48,15 @@ public void testAccept() {
     // Show that dir is ignored
     assertTrue(filter.accept(null, ""a""));
   }
+
+  public void testNulls() throws Exception {
+    NullPointerTester tester = new NullPointerTester();
+
+    tester.testConstructors(PatternFilenameFilter.class, Visibility.PACKAGE);
+    tester.testStaticMethods(PatternFilenameFilter.class, Visibility.PACKAGE); // currently none
+
+    // The reason that we skip this method is discussed in a comment on the method.
+    tester.ignore(PatternFilenameFilter.class.getMethod(""accept"", File.class, String.class));
+    tester.testInstanceMethods(new PatternFilenameFilter("".*""), Visibility.PACKAGE);
+  }
 }, @@ -21,7 +21,7 @@
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Writer that places all output on an {@link Appendable} target. If the target is {@link Flushable}
@@ -32,6 +32,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 class AppendableWriter extends Writer {
   private final Appendable target;
   private boolean closed;
@@ -106,14 +107,14 @@ public Writer append(char c) throws IOException {
   }
 
   @Override
-  public Writer append(@NullableDecl CharSequence charSeq) throws IOException {
+  public Writer append(@CheckForNull CharSequence charSeq) throws IOException {
     checkNotClosed();
     target.append(charSeq);
     return this;
   }
 
   @Override
-  public Writer append(@NullableDecl CharSequence charSeq, int start, int end) throws IOException {
+  public Writer append(@CheckForNull CharSequence charSeq, int start, int end) throws IOException {
     checkNotClosed();
     target.append(charSeq, start, end);
     return this;, @@ -35,7 +35,7 @@
 import java.io.Reader;
 import java.io.Writer;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII
@@ -122,6 +122,7 @@
  * @since 14.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public abstract class BaseEncoding {
   // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.
 
@@ -547,7 +548,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (other instanceof Alphabet) {
         Alphabet that = (Alphabet) other;
         return Arrays.equals(this.chars, that.chars);
@@ -565,13 +566,13 @@ public int hashCode() {
     // TODO(lowasser): provide a useful toString
     final Alphabet alphabet;
 
-    @NullableDecl final Character paddingChar;
+    @CheckForNull final Character paddingChar;
 
-    StandardBaseEncoding(String name, String alphabetChars, @NullableDecl Character paddingChar) {
+    StandardBaseEncoding(String name, String alphabetChars, @CheckForNull Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    StandardBaseEncoding(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    StandardBaseEncoding(Alphabet alphabet, @CheckForNull Character paddingChar) {
       this.alphabet = checkNotNull(alphabet);
       checkArgument(
           paddingChar == null || !alphabet.matches(paddingChar),
@@ -829,8 +830,8 @@ public BaseEncoding withSeparator(String separator, int afterEveryChars) {
       return new SeparatedBaseEncoding(this, separator, afterEveryChars);
     }
 
-    @LazyInit @NullableDecl private transient BaseEncoding upperCase;
-    @LazyInit @NullableDecl private transient BaseEncoding lowerCase;
+    @LazyInit @CheckForNull private transient BaseEncoding upperCase;
+    @LazyInit @CheckForNull private transient BaseEncoding lowerCase;
 
     @Override
     public BaseEncoding upperCase() {
@@ -852,7 +853,7 @@ public BaseEncoding lowerCase() {
       return result;
     }
 
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new StandardBaseEncoding(alphabet, paddingChar);
     }
 
@@ -871,7 +872,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@NullableDecl Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (other instanceof StandardBaseEncoding) {
         StandardBaseEncoding that = (StandardBaseEncoding) other;
         return this.alphabet.equals(that.alphabet)
@@ -928,17 +929,17 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new Base16Encoding(alphabet);
     }
   }
 
   static final class Base64Encoding extends StandardBaseEncoding {
-    Base64Encoding(String name, String alphabetChars, @NullableDecl Character paddingChar) {
+    Base64Encoding(String name, String alphabetChars, @CheckForNull Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    private Base64Encoding(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    private Base64Encoding(Alphabet alphabet, @CheckForNull Character paddingChar) {
       super(alphabet, paddingChar);
       checkArgument(alphabet.chars.length == 64);
     }
@@ -985,7 +986,7 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @NullableDecl Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new Base64Encoding(alphabet, paddingChar);
     }
   }
@@ -1036,13 +1037,12 @@ public Appendable append(char c) throws IOException {
       }
 
       @Override
-      public Appendable append(@NullableDecl CharSequence chars, int off, int len)
-          throws IOException {
+      public Appendable append(@CheckForNull CharSequence chars, int off, int len) {
         throw new UnsupportedOperationException();
       }
 
       @Override
-      public Appendable append(@NullableDecl CharSequence chars) throws IOException {
+      public Appendable append(@CheckForNull CharSequence chars) {
         throw new UnsupportedOperationException();
       }
     };, @@ -18,6 +18,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.DataInput;
 import java.io.IOException;
+import javax.annotation.CheckForNull;
 
 /**
  * An extension of {@code DataInput} for reading from in-memory byte arrays; its methods offer
@@ -32,6 +33,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public interface ByteArrayDataInput extends DataInput {
   @Override
   void readFully(byte b[]);
@@ -86,6 +88,7 @@
 
   @CanIgnoreReturnValue // to skip a line
   @Override
+  @CheckForNull
   String readLine();
 
   @CanIgnoreReturnValue // to skip a field, @@ -26,6 +26,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public interface ByteArrayDataOutput extends DataOutput {
   @Override
   void write(int b);, @@ -19,6 +19,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.DoNotMock;
 import java.io.IOException;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback interface to process bytes from a stream.
@@ -32,7 +33,8 @@
 @Beta
 @DoNotMock(""Implement it normally"")
 @GwtIncompatible
-public interface ByteProcessor<T> {
+@ElementTypesAreNonnullByDefault
+public interface ByteProcessor<T extends @Nullable Object> {
   /**
    * This method will be called for each chunk of bytes in an input stream. The implementation
    * should process the bytes from {@code buf[off]} through {@code buf[off + len - 1]} (inclusive).
@@ -46,5 +48,6 @@
   boolean processBytes(byte[] buf, int off, int len) throws IOException;
 
   /** Return the result of processing all the bytes. */
+  @ParametricNullness
   T getResult();
 }, @@ -46,6 +46,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class ByteSink {
 
   /** Constructor for use by subclasses. */, @@ -40,6 +40,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of bytes, such as a file. Unlike an {@link InputStream}, a {@code ByteSource}
@@ -73,6 +74,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class ByteSource {
 
   /** Constructor for use by subclasses. */
@@ -314,7 +316,7 @@ public long copyTo(ByteSink sink) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public <T> T read(ByteProcessor<T> processor) throws IOException {
+  public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -618,7 +620,8 @@ public long size() {
 
     @SuppressWarnings(""CheckReturnValue"") // it doesn't matter what processBytes returns here
     @Override
-    public <T> T read(ByteProcessor<T> processor) throws IOException {
+    @ParametricNullness
+    public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
       processor.processBytes(bytes, offset, length);
       return processor.getResult();
     }, @@ -41,6 +41,8 @@
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Queue;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -50,6 +52,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class ByteStreams {
 
   private static final int BUFFER_SIZE = 8192;
@@ -438,6 +441,7 @@ public double readDouble() {
     }
 
     @Override
+    @CheckForNull
     public String readLine() {
       try {
         return input.readLine();
@@ -869,7 +873,9 @@ private static long skipSafely(InputStream in, long n) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readBytes(InputStream input, ByteProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readBytes(
+      InputStream input, ByteProcessor<T> processor) throws IOException {
     checkNotNull(input);
     checkNotNull(processor);
 , @@ -17,11 +17,13 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.Reader;
 import java.nio.CharBuffer;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Reader} that reads the characters in a {@link CharSequence}. Like {@code StringReader},
@@ -31,9 +33,10 @@
  */
 // TODO(cgdecker): make this public? as a type, or a method in CharStreams?
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class CharSequenceReader extends Reader {
 
-  private CharSequence seq;
+  @CheckForNull private CharSequence seq;
   private int pos;
   private int mark;
 
@@ -53,13 +56,27 @@ private boolean hasRemaining() {
   }
 
   private int remaining() {
+    requireNonNull(seq); // safe as long as we call this only after checkOpen
     return seq.length() - pos;
   }
 
+  /*
+   * To avoid the need to call requireNonNull so much, we could consider more clever approaches,
+   * such as:
+   *
+   * - Make checkOpen return the non-null `seq`. Then callers can assign that to a local variable or
+   *   even back to `this.seq`. However, that may suggest that we're defending against concurrent
+   *   mutation, which is not an actual risk because we use `synchronized`.
+   * - Make `remaining` require a non-null `seq` argument. But this is a bit weird because the
+   *   method, while it would avoid the instance field `seq` would still access the instance field
+   *   `pos`.
+   */
+
   @Override
   public synchronized int read(CharBuffer target) throws IOException {
     checkNotNull(target);
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     if (!hasRemaining()) {
       return -1;
     }
@@ -73,13 +90,15 @@ public synchronized int read(CharBuffer target) throws IOException {
   @Override
   public synchronized int read() throws IOException {
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     return hasRemaining() ? seq.charAt(pos++) : -1;
   }
 
   @Override
   public synchronized int read(char[] cbuf, int off, int len) throws IOException {
     checkPositionIndexes(off, off + len, cbuf.length);
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     if (!hasRemaining()) {
       return -1;
     }, @@ -48,6 +48,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class CharSink {
 
   /** Constructor for use by subclasses. */, @@ -34,7 +34,8 @@
 import java.nio.charset.Charset;
 import java.util.Iterator;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of characters, such as a text file. Unlike a {@link Reader}, a {@code
@@ -76,6 +77,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class CharSource {
 
   /** Constructor for use by subclasses. */
@@ -260,7 +262,7 @@ public String read() throws IOException {
    *
    * @throws IOException if an I/O error occurs while reading from this source
    */
-  @NullableDecl
+  @CheckForNull
   public String readFirstLine() throws IOException {
     Closer closer = Closer.create();
     try {
@@ -317,7 +319,8 @@ public String readFirstLine() throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public <T> T readLines(LineProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -520,6 +523,7 @@ protected String computeNext() {
     }
 
     @Override
+    @CheckForNull
     public String readFirstLine() {
       Iterator<String> lines = linesIterator();
       return lines.hasNext() ? lines.next() : null;
@@ -531,7 +535,8 @@ public String readFirstLine() {
     }
 
     @Override
-    public <T> T readLines(LineProcessor<T> processor) throws IOException {
+    @ParametricNullness
+    public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
       Iterator<String> lines = linesIterator();
       while (lines.hasNext()) {
         if (!processor.processLine(lines.next())) {, @@ -28,7 +28,8 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with character streams.
@@ -45,6 +46,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CharStreams {
 
   // 2K chars (4K bytes)
@@ -215,7 +217,9 @@ private static StringBuilder toStringBuilder(Readable r) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(Readable readable, LineProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readLines(
+      Readable readable, LineProcessor<T> processor) throws IOException {
     checkNotNull(readable);
     checkNotNull(processor);
 
@@ -307,12 +311,12 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(@NullableDecl CharSequence csq) {
+    public Writer append(@CheckForNull CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(@NullableDecl CharSequence csq, int start, int end) {
+    public Writer append(@CheckForNull CharSequence csq, int start, int end) {
       checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }, @@ -23,7 +23,7 @@
 import java.io.Reader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * Utility methods for working with {@link Closeable} objects.
@@ -33,6 +33,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Closeables {
   @VisibleForTesting static final Logger logger = Logger.getLogger(Closeables.class.getName());
 
@@ -69,7 +70,7 @@ private Closeables() {}
    * @throws IOException if {@code swallowIOException} is false and {@code close} throws an {@code
    *     IOException}.
    */
-  public static void close(@NullableDecl Closeable closeable, boolean swallowIOException)
+  public static void close(@CheckForNull Closeable closeable, boolean swallowIOException)
       throws IOException {
     if (closeable == null) {
       return;
@@ -99,7 +100,7 @@ public static void close(@NullableDecl Closeable closeable, boolean swallowIOExc
    *     does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@NullableDecl InputStream inputStream) {
+  public static void closeQuietly(@CheckForNull InputStream inputStream) {
     try {
       close(inputStream, true);
     } catch (IOException impossible) {
@@ -120,7 +121,7 @@ public static void closeQuietly(@NullableDecl InputStream inputStream) {
    * @param reader the reader to be closed, or {@code null} in which case this method does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@NullableDecl Reader reader) {
+  public static void closeQuietly(@CheckForNull Reader reader) {
     try {
       close(reader, true);
     } catch (IOException impossible) {, @@ -27,7 +27,8 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.logging.Level;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A {@link Closeable} that collects {@code Closeable} resources and closes them all when it is
@@ -88,13 +89,16 @@
 // Coffee's for {@link Closer closers} only.
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Closer implements Closeable {
 
   /** The suppressor implementation to use for the current Java version. */
-  private static final Suppressor SUPPRESSOR =
-      SuppressingSuppressor.isAvailable()
-          ? SuppressingSuppressor.INSTANCE
-          : LoggingSuppressor.INSTANCE;
+  private static final Suppressor SUPPRESSOR;
+
+  static {
+    SuppressingSuppressor suppressingSuppressor = SuppressingSuppressor.tryCreate();
+    SUPPRESSOR = suppressingSuppressor == null ? LoggingSuppressor.INSTANCE : suppressingSuppressor;
+  }
 
   /** Creates a new {@link Closer}. */
   public static Closer create() {
@@ -105,7 +109,7 @@ public static Closer create() {
 
   // only need space for 2 elements in most cases, so try to use the smallest array possible
   private final Deque<Closeable> stack = new ArrayDeque<>(4);
-  @NullableDecl private Throwable thrown;
+  @CheckForNull private Throwable thrown;
 
   @VisibleForTesting
   Closer(Suppressor suppressor) {
@@ -120,7 +124,10 @@ public static Closer create() {
    */
   // close. this word no longer has any meaning to me.
   @CanIgnoreReturnValue
-  public <C extends Closeable> C register(@NullableDecl C closeable) {
+  @ParametricNullness
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @ParametricNullness.
+  public <C extends @Nullable Closeable> C register(
+      /* TODO(cpovirk): change to @ParametricNullness */ @CheckForNull C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }
@@ -257,21 +264,21 @@ public void suppress(Closeable closeable, Throwable thrown, Throwable suppressed
    */
   @VisibleForTesting
   static final class SuppressingSuppressor implements Suppressor {
-
-    static final SuppressingSuppressor INSTANCE = new SuppressingSuppressor();
-
-    static boolean isAvailable() {
-      return addSuppressed != null;
-    }
-
-    static final Method addSuppressed = addSuppressedMethodOrNull();
-
-    private static Method addSuppressedMethodOrNull() {
+    @CheckForNull
+    static SuppressingSuppressor tryCreate() {
+      Method addSuppressed;
       try {
-        return Throwable.class.getMethod(""addSuppressed"", Throwable.class);
+        addSuppressed = Throwable.class.getMethod(""addSuppressed"", Throwable.class);
       } catch (Throwable e) {
         return null;
       }
+      return new SuppressingSuppressor(addSuppressed);
+    }
+
+    private final Method addSuppressed;
+
+    private SuppressingSuppressor(Method addSuppressed) {
+      this.addSuppressed = addSuppressed;
     }
 
     @Override, @@ -30,6 +30,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CountingInputStream extends FilterInputStream {
 
   private long count;, @@ -28,6 +28,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CountingOutputStream extends FilterOutputStream {
 
   private long count;, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.io;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -14,6 +14,7 @@
 
 package com.google.common.io;
 
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -27,7 +28,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
@@ -51,20 +52,22 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class FileBackedOutputStream extends OutputStream {
   private final int fileThreshold;
   private final boolean resetOnFinalize;
   private final ByteSource source;
-  @NullableDecl private final File parentDirectory;
+  @CheckForNull private final File parentDirectory;
 
   @GuardedBy(""this"")
   private OutputStream out;
 
   @GuardedBy(""this"")
+  @CheckForNull
   private MemoryOutput memory;
 
   @GuardedBy(""this"")
-  @NullableDecl
+  @CheckForNull
   private File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
@@ -80,6 +83,7 @@ int getCount() {
 
   /** Returns the file holding the data (possibly null). */
   @VisibleForTesting
+  @CheckForNull
   synchronized File getFile() {
     return file;
   }
@@ -107,7 +111,7 @@ public FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize) {
   }
 
   private FileBackedOutputStream(
-      int fileThreshold, boolean resetOnFinalize, @NullableDecl File parentDirectory) {
+      int fileThreshold, boolean resetOnFinalize, @CheckForNull File parentDirectory) {
     this.fileThreshold = fileThreshold;
     this.resetOnFinalize = resetOnFinalize;
     this.parentDirectory = parentDirectory;
@@ -155,6 +159,8 @@ private synchronized InputStream openInputStream() throws IOException {
     if (file != null) {
       return new FileInputStream(file);
     } else {
+      // requireNonNull is safe because we always have either `file` or `memory`.
+      requireNonNull(memory);
       return new ByteArrayInputStream(memory.getBuffer(), 0, memory.getCount());
     }
   }
@@ -218,7 +224,7 @@ public synchronized void flush() throws IOException {
    */
   @GuardedBy(""this"")
   private void update(int len) throws IOException {
-    if (file == null && (memory.getCount() + len > fileThreshold)) {
+    if (memory != null && (memory.getCount() + len > fileThreshold)) {
       File temp = File.createTempFile(""FileBackedOutputStream"", null, parentDirectory);
       if (resetOnFinalize) {
         // Finalizers are not guaranteed to be called on system shutdown;, @@ -23,6 +23,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public enum FileWriteMode {
   /** Specifies that writes to the opened file should append to the end of the file. */
   APPEND, @@ -52,6 +52,8 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with {@linkplain File files}.
@@ -64,6 +66,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Files {
 
   /** Maximum loop count when creating temp directories. */
@@ -529,6 +532,7 @@ public static void move(File from, File to) throws IOException {
    */
   @Beta
   @Deprecated
+  @CheckForNull
   public
   static String readFirstLine(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).readFirstLine();
@@ -588,8 +592,10 @@ public boolean processLine(String line) {
   @Beta
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
+  @ParametricNullness
   public
-  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {
+  static <T extends @Nullable Object> T readLines(
+      File file, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(file, charset).readLines(callback);
   }
 
@@ -608,8 +614,10 @@ public boolean processLine(String line) {
   @Beta
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
+  @ParametricNullness
   public
-  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
+  static <T extends @Nullable Object> T readBytes(File file, ByteProcessor<T> processor)
+      throws IOException {
     return asByteSource(file).read(processor);
   }
 , @@ -29,6 +29,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Flushables {
   private static final Logger logger = Logger.getLogger(Flushables.class.getName());
 , @@ -22,6 +22,7 @@
  * https://github.com/google/guava/issues/3990
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class Java8Compatibility {
   static void clear(Buffer b) {
     b.clear();, @@ -30,6 +30,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 abstract class LineBuffer {
   /** Holds partial line contents. */
   private StringBuilder line = new StringBuilder();, @@ -18,6 +18,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback to be used with the streaming {@code readLines} methods.
@@ -30,7 +31,8 @@
  */
 @Beta
 @GwtIncompatible
-public interface LineProcessor<T> {
+@ElementTypesAreNonnullByDefault
+public interface LineProcessor<T extends @Nullable Object> {
 
   /**
    * This method will be called once for each line.
@@ -42,5 +44,6 @@
   boolean processLine(String line) throws IOException;
 
   /** Return the result of processing all the lines. */
+  @ParametricNullness
   T getResult();
 }, @@ -25,7 +25,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayDeque;
 import java.util.Queue;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A class for reading lines of text. Provides the same functionality as {@link
@@ -37,9 +37,10 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LineReader {
   private final Readable readable;
-  @NullableDecl private final Reader reader;
+  @CheckForNull private final Reader reader;
   private final CharBuffer cbuf = createBuffer();
   private final char[] buf = cbuf.array();
 
@@ -68,6 +69,8 @@ public LineReader(Readable readable) {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // to skip a line
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @CheckForNull.
+  // TODO(cpovirk): @CheckForNull
   public String readLine() throws IOException {
     while (lines.peek() == null) {
       Java8Compatibility.clear(cbuf);, @@ -41,6 +41,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LittleEndianDataInputStream extends FilterInputStream implements DataInput {
 
   /**, @@ -37,6 +37,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LittleEndianDataOutputStream extends FilterOutputStream implements DataOutput {
 
   /**, @@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * An {@link InputStream} that concatenates multiple substreams. At most one stream will be open at
@@ -30,10 +30,11 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class MultiInputStream extends InputStream {
 
   private Iterator<? extends ByteSource> it;
-  @NullableDecl private InputStream in;
+  @CheckForNull private InputStream in;
 
   /**
    * Creates a new instance.
@@ -90,7 +91,8 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl byte[] b, int off, int len) throws IOException {
+  public int read(byte[] b, int off, int len) throws IOException {
+    checkNotNull(b);
     while (in != null) {
       int result = in.read(b, off, len);
       if (result != -1) {, @@ -14,12 +14,14 @@
 
 package com.google.common.io;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Reader} that concatenates multiple readers.
@@ -28,9 +30,10 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 class MultiReader extends Reader {
   private final Iterator<? extends CharSource> it;
-  @NullableDecl private Reader current;
+  @CheckForNull private Reader current;
 
   MultiReader(Iterator<? extends CharSource> readers) throws IOException {
     this.it = readers;
@@ -46,7 +49,8 @@ private void advance() throws IOException {
   }
 
   @Override
-  public int read(@NullableDecl char[] cbuf, int off, int len) throws IOException {
+  public int read(char[] cbuf, int off, int len) throws IOException {
+    checkNotNull(cbuf);
     if (current == null) {
       return -1;
     }, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.io;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -21,7 +21,7 @@
 import java.io.FilenameFilter;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * File name filter that only accepts files matching a regular expression. This class is thread-safe
@@ -32,6 +32,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PatternFilenameFilter implements FilenameFilter {
 
   private final Pattern pattern;
@@ -55,8 +56,25 @@ public PatternFilenameFilter(Pattern pattern) {
     this.pattern = Preconditions.checkNotNull(pattern);
   }
 
+  /*
+   * Our implementation works fine with a null `dir`. However, there's nothing in the documentation
+   * of the supertype that suggests that implementations are expected to tolerate null. That said, I
+   * see calls in Google code that pass a null `dir` to a FilenameFilter.... So let's declare the
+   * parameter as non-nullable (since passing null to a FilenameFilter is unsafe in general), but if
+   * someone still manages to pass null, let's continue to have the method work.
+   *
+   * (OK, I haven't done that yet, but I will when I follow through on the TODO below after updating
+   * callers.)
+   *
+   * (PatternFilenameFilter is of course one of those classes that shouldn't be a publicly visible
+   * class to begin with but rather something returned from a static factory method whose declared
+   * return type is plain FilenameFilter. If we made such a change, then the annotation we choose
+   * here would have no significance to end users, who would be forced to conform to the signature
+   * used in FilenameFilter.)
+   */
   @Override
-  public boolean accept(@NullableDecl File dir, String fileName) {
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with removal of @CheckForNull.
+  public boolean accept(/* TODO(cpovirk): remove */ @CheckForNull File dir, String fileName) {
     return pattern.matcher(fileName).matches();
   }
 }, @@ -44,6 +44,7 @@
  * @author Chris Nokleberg
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class ReaderInputStream extends InputStream {
   private final Reader reader;
   private final CharsetEncoder encoder;, @@ -29,6 +29,7 @@
 import java.net.URL;
 import java.nio.charset.Charset;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with resources in the classpath. Note that even though these
@@ -44,6 +45,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Resources {
   private Resources() {}
 
@@ -121,8 +123,9 @@ public static String toString(URL url, Charset charset) throws IOException {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(URL url, Charset charset, LineProcessor<T> callback)
-      throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readLines(
+      URL url, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(url, charset).readLines(callback);
   }
 , @@ -30,6 +30,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.hash.Hashing;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.primitives.UnsignedBytes;
 import com.google.common.testing.TestLogHandler;
 import java.io.ByteArrayOutputStream;
@@ -395,7 +396,7 @@ public void testConcat_infiniteIterable() throws IOException {
       ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);
 
   public void testCopyExceptions() {
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (Closer.create().suppressor instanceof LoggingSuppressor) {
       // test that exceptions are logged
 
       TestLogHandler logHandler = new TestLogHandler();, @@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.testing.TestLogHandler;
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -288,7 +289,7 @@ public void testConcat_infiniteIterable() throws IOException {
       ImmutableSet.of(BROKEN_CLOSE_SINK, BROKEN_OPEN_SINK, BROKEN_WRITE_SINK);
 
   public void testCopyExceptions() {
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (Closer.create().suppressor instanceof LoggingSuppressor) {
       // test that exceptions are logged
 
       TestLogHandler logHandler = new TestLogHandler();, @@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import com.google.common.io.Closer.LoggingSuppressor;
 import com.google.common.testing.TestLogHandler;
 import java.io.Closeable;
 import java.io.IOException;
@@ -311,13 +312,12 @@ public static void testLoggingSuppressor() throws IOException {
   }
 
   public static void testSuppressingSuppressorIfPossible() throws IOException {
+    Closer closer = Closer.create();
     // can't test the JDK7 suppressor when not running on JDK7
-    if (!Closer.SuppressingSuppressor.isAvailable()) {
+    if (closer.suppressor instanceof LoggingSuppressor) {
       return;
     }
 
-    Closer closer = new Closer(new Closer.SuppressingSuppressor());
-
     IOException thrownException = new IOException();
     IOException c1Exception = new IOException();
     RuntimeException c2Exception = new RuntimeException();, @@ -16,6 +16,8 @@
 
 package com.google.common.io;
 
+import com.google.common.testing.NullPointerTester;
+import com.google.common.testing.NullPointerTester.Visibility;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.util.regex.PatternSyntaxException;
@@ -46,4 +48,15 @@ public void testAccept() {
     // Show that dir is ignored
     assertTrue(filter.accept(null, ""a""));
   }
+
+  public void testNulls() throws Exception {
+    NullPointerTester tester = new NullPointerTester();
+
+    tester.testConstructors(PatternFilenameFilter.class, Visibility.PACKAGE);
+    tester.testStaticMethods(PatternFilenameFilter.class, Visibility.PACKAGE); // currently none
+
+    // The reason that we skip this method is discussed in a comment on the method.
+    tester.ignore(PatternFilenameFilter.class.getMethod(""accept"", File.class, String.class));
+    tester.testInstanceMethods(new PatternFilenameFilter("".*""), Visibility.PACKAGE);
+  }
 }, @@ -21,7 +21,7 @@
 import java.io.Flushable;
 import java.io.IOException;
 import java.io.Writer;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Writer that places all output on an {@link Appendable} target. If the target is {@link Flushable}
@@ -32,6 +32,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 class AppendableWriter extends Writer {
   private final Appendable target;
   private boolean closed;
@@ -106,14 +107,14 @@ public Writer append(char c) throws IOException {
   }
 
   @Override
-  public Writer append(@Nullable CharSequence charSeq) throws IOException {
+  public Writer append(@CheckForNull CharSequence charSeq) throws IOException {
     checkNotClosed();
     target.append(charSeq);
     return this;
   }
 
   @Override
-  public Writer append(@Nullable CharSequence charSeq, int start, int end) throws IOException {
+  public Writer append(@CheckForNull CharSequence charSeq, int start, int end) throws IOException {
     checkNotClosed();
     target.append(charSeq, start, end);
     return this;, @@ -35,7 +35,7 @@
 import java.io.Reader;
 import java.io.Writer;
 import java.util.Arrays;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII
@@ -122,6 +122,7 @@
  * @since 14.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public abstract class BaseEncoding {
   // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.
 
@@ -547,7 +548,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@Nullable Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (other instanceof Alphabet) {
         Alphabet that = (Alphabet) other;
         return Arrays.equals(this.chars, that.chars);
@@ -565,13 +566,13 @@ public int hashCode() {
     // TODO(lowasser): provide a useful toString
     final Alphabet alphabet;
 
-    final @Nullable Character paddingChar;
+    @CheckForNull final Character paddingChar;
 
-    StandardBaseEncoding(String name, String alphabetChars, @Nullable Character paddingChar) {
+    StandardBaseEncoding(String name, String alphabetChars, @CheckForNull Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    StandardBaseEncoding(Alphabet alphabet, @Nullable Character paddingChar) {
+    StandardBaseEncoding(Alphabet alphabet, @CheckForNull Character paddingChar) {
       this.alphabet = checkNotNull(alphabet);
       checkArgument(
           paddingChar == null || !alphabet.matches(paddingChar),
@@ -829,8 +830,8 @@ public BaseEncoding withSeparator(String separator, int afterEveryChars) {
       return new SeparatedBaseEncoding(this, separator, afterEveryChars);
     }
 
-    @LazyInit private transient @Nullable BaseEncoding upperCase;
-    @LazyInit private transient @Nullable BaseEncoding lowerCase;
+    @LazyInit @CheckForNull private transient BaseEncoding upperCase;
+    @LazyInit @CheckForNull private transient BaseEncoding lowerCase;
 
     @Override
     public BaseEncoding upperCase() {
@@ -852,7 +853,7 @@ public BaseEncoding lowerCase() {
       return result;
     }
 
-    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new StandardBaseEncoding(alphabet, paddingChar);
     }
 
@@ -871,7 +872,7 @@ public String toString() {
     }
 
     @Override
-    public boolean equals(@Nullable Object other) {
+    public boolean equals(@CheckForNull Object other) {
       if (other instanceof StandardBaseEncoding) {
         StandardBaseEncoding that = (StandardBaseEncoding) other;
         return this.alphabet.equals(that.alphabet)
@@ -928,17 +929,17 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new Base16Encoding(alphabet);
     }
   }
 
   static final class Base64Encoding extends StandardBaseEncoding {
-    Base64Encoding(String name, String alphabetChars, @Nullable Character paddingChar) {
+    Base64Encoding(String name, String alphabetChars, @CheckForNull Character paddingChar) {
       this(new Alphabet(name, alphabetChars.toCharArray()), paddingChar);
     }
 
-    private Base64Encoding(Alphabet alphabet, @Nullable Character paddingChar) {
+    private Base64Encoding(Alphabet alphabet, @CheckForNull Character paddingChar) {
       super(alphabet, paddingChar);
       checkArgument(alphabet.chars.length == 64);
     }
@@ -985,7 +986,7 @@ int decodeTo(byte[] target, CharSequence chars) throws DecodingException {
     }
 
     @Override
-    BaseEncoding newInstance(Alphabet alphabet, @Nullable Character paddingChar) {
+    BaseEncoding newInstance(Alphabet alphabet, @CheckForNull Character paddingChar) {
       return new Base64Encoding(alphabet, paddingChar);
     }
   }
@@ -1036,12 +1037,12 @@ public Appendable append(char c) throws IOException {
       }
 
       @Override
-      public Appendable append(@Nullable CharSequence chars, int off, int len) throws IOException {
+      public Appendable append(@CheckForNull CharSequence chars, int off, int len) {
         throw new UnsupportedOperationException();
       }
 
       @Override
-      public Appendable append(@Nullable CharSequence chars) throws IOException {
+      public Appendable append(@CheckForNull CharSequence chars) {
         throw new UnsupportedOperationException();
       }
     };, @@ -18,6 +18,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.DataInput;
 import java.io.IOException;
+import javax.annotation.CheckForNull;
 
 /**
  * An extension of {@code DataInput} for reading from in-memory byte arrays; its methods offer
@@ -32,6 +33,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public interface ByteArrayDataInput extends DataInput {
   @Override
   void readFully(byte b[]);
@@ -86,6 +88,7 @@
 
   @CanIgnoreReturnValue // to skip a line
   @Override
+  @CheckForNull
   String readLine();
 
   @CanIgnoreReturnValue // to skip a field, @@ -26,6 +26,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public interface ByteArrayDataOutput extends DataOutput {
   @Override
   void write(int b);, @@ -19,6 +19,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.DoNotMock;
 import java.io.IOException;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback interface to process bytes from a stream.
@@ -32,7 +33,8 @@
 @Beta
 @DoNotMock(""Implement it normally"")
 @GwtIncompatible
-public interface ByteProcessor<T> {
+@ElementTypesAreNonnullByDefault
+public interface ByteProcessor<T extends @Nullable Object> {
   /**
    * This method will be called for each chunk of bytes in an input stream. The implementation
    * should process the bytes from {@code buf[off]} through {@code buf[off + len - 1]} (inclusive).
@@ -46,5 +48,6 @@
   boolean processBytes(byte[] buf, int off, int len) throws IOException;
 
   /** Return the result of processing all the bytes. */
+  @ParametricNullness
   T getResult();
 }, @@ -46,6 +46,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class ByteSink {
 
   /** Constructor for use by subclasses. */, @@ -40,6 +40,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A readable source of bytes, such as a file. Unlike an {@link InputStream}, a {@code ByteSource}
@@ -73,6 +74,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class ByteSource {
 
   /** Constructor for use by subclasses. */
@@ -314,7 +316,7 @@ public long copyTo(ByteSink sink) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public <T> T read(ByteProcessor<T> processor) throws IOException {
+  public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -618,7 +620,8 @@ public long size() {
 
     @SuppressWarnings(""CheckReturnValue"") // it doesn't matter what processBytes returns here
     @Override
-    public <T> T read(ByteProcessor<T> processor) throws IOException {
+    @ParametricNullness
+    public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
       processor.processBytes(bytes, offset, length);
       return processor.getResult();
     }, @@ -41,6 +41,8 @@
 import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.Queue;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with byte arrays and I/O streams.
@@ -50,6 +52,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class ByteStreams {
 
   private static final int BUFFER_SIZE = 8192;
@@ -438,6 +441,7 @@ public double readDouble() {
     }
 
     @Override
+    @CheckForNull
     public String readLine() {
       try {
         return input.readLine();
@@ -869,7 +873,9 @@ private static long skipSafely(InputStream in, long n) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readBytes(InputStream input, ByteProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readBytes(
+      InputStream input, ByteProcessor<T> processor) throws IOException {
     checkNotNull(input);
     checkNotNull(processor);
 , @@ -17,11 +17,13 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndexes;
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtIncompatible;
 import java.io.IOException;
 import java.io.Reader;
 import java.nio.CharBuffer;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Reader} that reads the characters in a {@link CharSequence}. Like {@code StringReader},
@@ -31,9 +33,10 @@
  */
 // TODO(cgdecker): make this public? as a type, or a method in CharStreams?
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class CharSequenceReader extends Reader {
 
-  private CharSequence seq;
+  @CheckForNull private CharSequence seq;
   private int pos;
   private int mark;
 
@@ -53,13 +56,27 @@ private boolean hasRemaining() {
   }
 
   private int remaining() {
+    requireNonNull(seq); // safe as long as we call this only after checkOpen
     return seq.length() - pos;
   }
 
+  /*
+   * To avoid the need to call requireNonNull so much, we could consider more clever approaches,
+   * such as:
+   *
+   * - Make checkOpen return the non-null `seq`. Then callers can assign that to a local variable or
+   *   even back to `this.seq`. However, that may suggest that we're defending against concurrent
+   *   mutation, which is not an actual risk because we use `synchronized`.
+   * - Make `remaining` require a non-null `seq` argument. But this is a bit weird because the
+   *   method, while it would avoid the instance field `seq` would still access the instance field
+   *   `pos`.
+   */
+
   @Override
   public synchronized int read(CharBuffer target) throws IOException {
     checkNotNull(target);
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     if (!hasRemaining()) {
       return -1;
     }
@@ -73,13 +90,15 @@ public synchronized int read(CharBuffer target) throws IOException {
   @Override
   public synchronized int read() throws IOException {
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     return hasRemaining() ? seq.charAt(pos++) : -1;
   }
 
   @Override
   public synchronized int read(char[] cbuf, int off, int len) throws IOException {
     checkPositionIndexes(off, off + len, cbuf.length);
     checkOpen();
+    requireNonNull(seq); // safe because of checkOpen
     if (!hasRemaining()) {
       return -1;
     }, @@ -51,6 +51,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class CharSink {
 
   /** Constructor for use by subclasses. */, @@ -39,6 +39,7 @@
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.stream.Stream;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -81,6 +82,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class CharSource {
 
   /** Constructor for use by subclasses. */
@@ -307,7 +309,8 @@ public String read() throws IOException {
    *
    * @throws IOException if an I/O error occurs while reading from this source
    */
-  public @Nullable String readFirstLine() throws IOException {
+  @CheckForNull
+  public String readFirstLine() throws IOException {
     Closer closer = Closer.create();
     try {
       BufferedReader reader = closer.register(openBufferedStream());
@@ -363,7 +366,8 @@ public String read() throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public <T> T readLines(LineProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
     checkNotNull(processor);
 
     Closer closer = Closer.create();
@@ -594,6 +598,7 @@ protected String computeNext() {
     }
 
     @Override
+    @CheckForNull
     public String readFirstLine() {
       Iterator<String> lines = linesIterator();
       return lines.hasNext() ? lines.next() : null;
@@ -605,7 +610,8 @@ public String readFirstLine() {
     }
 
     @Override
-    public <T> T readLines(LineProcessor<T> processor) throws IOException {
+    @ParametricNullness
+    public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
       Iterator<String> lines = linesIterator();
       while (lines.hasNext()) {
         if (!processor.processLine(lines.next())) {, @@ -28,6 +28,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -45,6 +46,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CharStreams {
 
   // 2K chars (4K bytes)
@@ -215,7 +217,9 @@ private static StringBuilder toStringBuilder(Readable r) throws IOException {
    */
   @Beta
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(Readable readable, LineProcessor<T> processor) throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readLines(
+      Readable readable, LineProcessor<T> processor) throws IOException {
     checkNotNull(readable);
     checkNotNull(processor);
 
@@ -307,12 +311,12 @@ public void write(String str, int off, int len) {
     }
 
     @Override
-    public Writer append(@Nullable CharSequence csq) {
+    public Writer append(@CheckForNull CharSequence csq) {
       return this;
     }
 
     @Override
-    public Writer append(@Nullable CharSequence csq, int start, int end) {
+    public Writer append(@CheckForNull CharSequence csq, int start, int end) {
       checkPositionIndexes(start, end, csq == null ? ""null"".length() : csq.length());
       return this;
     }, @@ -23,7 +23,7 @@
 import java.io.Reader;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Utility methods for working with {@link Closeable} objects.
@@ -33,6 +33,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Closeables {
   @VisibleForTesting static final Logger logger = Logger.getLogger(Closeables.class.getName());
 
@@ -69,7 +70,7 @@ private Closeables() {}
    * @throws IOException if {@code swallowIOException} is false and {@code close} throws an {@code
    *     IOException}.
    */
-  public static void close(@Nullable Closeable closeable, boolean swallowIOException)
+  public static void close(@CheckForNull Closeable closeable, boolean swallowIOException)
       throws IOException {
     if (closeable == null) {
       return;
@@ -99,7 +100,7 @@ public static void close(@Nullable Closeable closeable, boolean swallowIOExcepti
    *     does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@Nullable InputStream inputStream) {
+  public static void closeQuietly(@CheckForNull InputStream inputStream) {
     try {
       close(inputStream, true);
     } catch (IOException impossible) {
@@ -120,7 +121,7 @@ public static void closeQuietly(@Nullable InputStream inputStream) {
    * @param reader the reader to be closed, or {@code null} in which case this method does nothing
    * @since 17.0
    */
-  public static void closeQuietly(@Nullable Reader reader) {
+  public static void closeQuietly(@CheckForNull Reader reader) {
     try {
       close(reader, true);
     } catch (IOException impossible) {, @@ -27,6 +27,7 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.logging.Level;
+import javax.annotation.CheckForNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -88,13 +89,16 @@
 // Coffee's for {@link Closer closers} only.
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Closer implements Closeable {
 
   /** The suppressor implementation to use for the current Java version. */
-  private static final Suppressor SUPPRESSOR =
-      SuppressingSuppressor.isAvailable()
-          ? SuppressingSuppressor.INSTANCE
-          : LoggingSuppressor.INSTANCE;
+  private static final Suppressor SUPPRESSOR;
+
+  static {
+    SuppressingSuppressor suppressingSuppressor = SuppressingSuppressor.tryCreate();
+    SUPPRESSOR = suppressingSuppressor == null ? LoggingSuppressor.INSTANCE : suppressingSuppressor;
+  }
 
   /** Creates a new {@link Closer}. */
   public static Closer create() {
@@ -105,7 +109,7 @@ public static Closer create() {
 
   // only need space for 2 elements in most cases, so try to use the smallest array possible
   private final Deque<Closeable> stack = new ArrayDeque<>(4);
-  private @Nullable Throwable thrown;
+  @CheckForNull private Throwable thrown;
 
   @VisibleForTesting
   Closer(Suppressor suppressor) {
@@ -120,7 +124,10 @@ public static Closer create() {
    */
   // close. this word no longer has any meaning to me.
   @CanIgnoreReturnValue
-  public <C extends Closeable> C register(@Nullable C closeable) {
+  @ParametricNullness
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @ParametricNullness.
+  public <C extends @Nullable Closeable> C register(
+      /* TODO(cpovirk): change to @ParametricNullness */ @CheckForNull C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }
@@ -257,21 +264,21 @@ public void suppress(Closeable closeable, Throwable thrown, Throwable suppressed
    */
   @VisibleForTesting
   static final class SuppressingSuppressor implements Suppressor {
-
-    static final SuppressingSuppressor INSTANCE = new SuppressingSuppressor();
-
-    static boolean isAvailable() {
-      return addSuppressed != null;
-    }
-
-    static final Method addSuppressed = addSuppressedMethodOrNull();
-
-    private static Method addSuppressedMethodOrNull() {
+    @CheckForNull
+    static SuppressingSuppressor tryCreate() {
+      Method addSuppressed;
       try {
-        return Throwable.class.getMethod(""addSuppressed"", Throwable.class);
+        addSuppressed = Throwable.class.getMethod(""addSuppressed"", Throwable.class);
       } catch (Throwable e) {
         return null;
       }
+      return new SuppressingSuppressor(addSuppressed);
+    }
+
+    private final Method addSuppressed;
+
+    private SuppressingSuppressor(Method addSuppressed) {
+      this.addSuppressed = addSuppressed;
     }
 
     @Override, @@ -30,6 +30,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CountingInputStream extends FilterInputStream {
 
   private long count;, @@ -28,6 +28,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class CountingOutputStream extends FilterOutputStream {
 
   private long count;, @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.io;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -14,6 +14,7 @@
 
 package com.google.common.io;
 
+import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
@@ -27,7 +28,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * An {@link OutputStream} that starts buffering to a byte array, but switches to file buffering
@@ -51,20 +52,23 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class FileBackedOutputStream extends OutputStream {
   private final int fileThreshold;
   private final boolean resetOnFinalize;
   private final ByteSource source;
-  @Nullable private final File parentDirectory;
+  @CheckForNull private final File parentDirectory;
 
   @GuardedBy(""this"")
   private OutputStream out;
 
   @GuardedBy(""this"")
+  @CheckForNull
   private MemoryOutput memory;
 
   @GuardedBy(""this"")
-  private @Nullable File file;
+  @CheckForNull
+  private File file;
 
   /** ByteArrayOutputStream that exposes its internals. */
   private static class MemoryOutput extends ByteArrayOutputStream {
@@ -79,6 +83,7 @@ int getCount() {
 
   /** Returns the file holding the data (possibly null). */
   @VisibleForTesting
+  @CheckForNull
   synchronized File getFile() {
     return file;
   }
@@ -106,7 +111,7 @@ public FileBackedOutputStream(int fileThreshold, boolean resetOnFinalize) {
   }
 
   private FileBackedOutputStream(
-      int fileThreshold, boolean resetOnFinalize, @Nullable File parentDirectory) {
+      int fileThreshold, boolean resetOnFinalize, @CheckForNull File parentDirectory) {
     this.fileThreshold = fileThreshold;
     this.resetOnFinalize = resetOnFinalize;
     this.parentDirectory = parentDirectory;
@@ -154,6 +159,8 @@ private synchronized InputStream openInputStream() throws IOException {
     if (file != null) {
       return new FileInputStream(file);
     } else {
+      // requireNonNull is safe because we always have either `file` or `memory`.
+      requireNonNull(memory);
       return new ByteArrayInputStream(memory.getBuffer(), 0, memory.getCount());
     }
   }
@@ -217,7 +224,7 @@ public synchronized void flush() throws IOException {
    */
   @GuardedBy(""this"")
   private void update(int len) throws IOException {
-    if (file == null && (memory.getCount() + len > fileThreshold)) {
+    if (memory != null && (memory.getCount() + len > fileThreshold)) {
       File temp = File.createTempFile(""FileBackedOutputStream"", null, parentDirectory);
       if (resetOnFinalize) {
         // Finalizers are not guaranteed to be called on system shutdown;, @@ -23,6 +23,7 @@
  * @author Colin Decker
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public enum FileWriteMode {
   /** Specifies that writes to the opened file should append to the end of the file. */
   APPEND, @@ -52,6 +52,8 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.CheckForNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with {@linkplain File files}.
@@ -64,6 +66,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Files {
 
   /** Maximum loop count when creating temp directories. */
@@ -529,6 +532,7 @@ public static void move(File from, File to) throws IOException {
    */
   @Beta
   @Deprecated
+  @CheckForNull
   public
   static String readFirstLine(File file, Charset charset) throws IOException {
     return asCharSource(file, charset).readFirstLine();
@@ -588,8 +592,10 @@ public boolean processLine(String line) {
   @Beta
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
+  @ParametricNullness
   public
-  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {
+  static <T extends @Nullable Object> T readLines(
+      File file, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(file, charset).readLines(callback);
   }
 
@@ -608,8 +614,10 @@ public boolean processLine(String line) {
   @Beta
   @Deprecated
   @CanIgnoreReturnValue // some processors won't return a useful result
+  @ParametricNullness
   public
-  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {
+  static <T extends @Nullable Object> T readBytes(File file, ByteProcessor<T> processor)
+      throws IOException {
     return asByteSource(file).read(processor);
   }
 , @@ -29,6 +29,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Flushables {
   private static final Logger logger = Logger.getLogger(Flushables.class.getName());
 , @@ -21,7 +21,7 @@
 import com.google.j2objc.annotations.J2ObjCIncompatible;
 import java.nio.file.FileSystemException;
 import java.nio.file.SecureDirectoryStream;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Exception indicating that a recursive delete can't be performed because the file system does not
@@ -38,9 +38,10 @@
 @Beta
 @GwtIncompatible
 @J2ObjCIncompatible // java.nio.file
+@ElementTypesAreNonnullByDefault
 public final class InsecureRecursiveDeleteException extends FileSystemException {
 
-  public InsecureRecursiveDeleteException(@Nullable String file) {
+  public InsecureRecursiveDeleteException(@CheckForNull String file) {
     super(file, null, ""unable to guarantee security of recursive delete"");
   }
 }, @@ -22,6 +22,7 @@
  * https://github.com/google/guava/issues/3990
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class Java8Compatibility {
   static void clear(Buffer b) {
     b.clear();, @@ -30,6 +30,7 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 abstract class LineBuffer {
   /** Holds partial line contents. */
   private StringBuilder line = new StringBuilder();, @@ -18,6 +18,7 @@
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A callback to be used with the streaming {@code readLines} methods.
@@ -30,7 +31,8 @@
  */
 @Beta
 @GwtIncompatible
-public interface LineProcessor<T> {
+@ElementTypesAreNonnullByDefault
+public interface LineProcessor<T extends @Nullable Object> {
 
   /**
    * This method will be called once for each line.
@@ -42,5 +44,6 @@
   boolean processLine(String line) throws IOException;
 
   /** Return the result of processing all the lines. */
+  @ParametricNullness
   T getResult();
 }, @@ -25,7 +25,7 @@
 import java.nio.CharBuffer;
 import java.util.ArrayDeque;
 import java.util.Queue;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A class for reading lines of text. Provides the same functionality as {@link
@@ -37,9 +37,10 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LineReader {
   private final Readable readable;
-  private final @Nullable Reader reader;
+  @CheckForNull private final Reader reader;
   private final CharBuffer cbuf = createBuffer();
   private final char[] buf = cbuf.array();
 
@@ -68,6 +69,8 @@ public LineReader(Readable readable) {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // to skip a line
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @CheckForNull.
+  // TODO(cpovirk): @CheckForNull
   public String readLine() throws IOException {
     while (lines.peek() == null) {
       Java8Compatibility.clear(cbuf);, @@ -41,6 +41,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LittleEndianDataInputStream extends FilterInputStream implements DataInput {
 
   /**, @@ -37,6 +37,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class LittleEndianDataOutputStream extends FilterOutputStream implements DataOutput {
 
   /**, @@ -54,7 +54,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * Static utilities for use with {@link Path} instances, intended to complement {@link Files}.
@@ -69,6 +69,7 @@
 @Beta
 @GwtIncompatible
 @J2ObjCIncompatible // java.nio.file
+@ElementTypesAreNonnullByDefault
 public final class MoreFiles {
 
   private MoreFiles() {}
@@ -613,7 +614,8 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure recursive delete using {@code SecureDirectoryStream}. Returns a collection of exceptions
    * that occurred or null if no exceptions were thrown.
    */
-  private static @Nullable Collection<IOException> deleteRecursivelySecure(
+  @CheckForNull
+  private static Collection<IOException> deleteRecursivelySecure(
       SecureDirectoryStream<Path> dir, Path path) {
     Collection<IOException> exceptions = null;
     try {
@@ -641,7 +643,8 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Secure method for deleting the contents of a directory using {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  private static @Nullable Collection<IOException> deleteDirectoryContentsSecure(
+  @CheckForNull
+  private static Collection<IOException> deleteDirectoryContentsSecure(
       SecureDirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
     try {
@@ -659,7 +662,8 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * Insecure recursive delete for file systems that don't support {@code SecureDirectoryStream}.
    * Returns a collection of exceptions that occurred or null if no exceptions were thrown.
    */
-  private static @Nullable Collection<IOException> deleteRecursivelyInsecure(Path path) {
+  @CheckForNull
+  private static Collection<IOException> deleteRecursivelyInsecure(Path path) {
     Collection<IOException> exceptions = null;
     try {
       if (Files.isDirectory(path, NOFOLLOW_LINKS)) {
@@ -685,7 +689,8 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * support {@code SecureDirectoryStream}. Returns a collection of exceptions that occurred or null
    * if no exceptions were thrown.
    */
-  private static @Nullable Collection<IOException> deleteDirectoryContentsInsecure(
+  @CheckForNull
+  private static Collection<IOException> deleteDirectoryContentsInsecure(
       DirectoryStream<Path> dir) {
     Collection<IOException> exceptions = null;
     try {
@@ -704,7 +709,8 @@ public static void deleteDirectoryContents(Path path, RecursiveDeleteOption... o
    * path, this is simple. Otherwise, we need to do some trickier things. Returns null if the path
    * is a root or is the empty path.
    */
-  private static @Nullable Path getParentPath(Path path) {
+  @CheckForNull
+  private static Path getParentPath(Path path) {
     Path parent = path.getParent();
 
     // Paths that have a parent:
@@ -750,7 +756,7 @@ private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] optio
    * the collection.
    */
   private static Collection<IOException> addException(
-      @Nullable Collection<IOException> exceptions, IOException e) {
+      @CheckForNull Collection<IOException> exceptions, IOException e) {
     if (exceptions == null) {
       exceptions = new ArrayList<>(); // don't need Set semantics
     }
@@ -763,8 +769,10 @@ private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] optio
    * null, the other collection is returned. Otherwise, the elements of {@code other} are added to
    * {@code exceptions} and {@code exceptions} is returned.
    */
-  private static @Nullable Collection<IOException> concat(
-      @Nullable Collection<IOException> exceptions, @Nullable Collection<IOException> other) {
+  @CheckForNull
+  private static Collection<IOException> concat(
+      @CheckForNull Collection<IOException> exceptions,
+      @CheckForNull Collection<IOException> other) {
     if (exceptions == null) {
       return other;
     } else if (other != null) {
@@ -801,8 +809,8 @@ private static void throwDeleteFailed(Path path, Collection<IOException> excepti
     throw deleteFailed;
   }
 
-  private static @Nullable NoSuchFileException pathNotFound(
-      Path path, Collection<IOException> exceptions) {
+  @CheckForNull
+  private static NoSuchFileException pathNotFound(Path path, Collection<IOException> exceptions) {
     if (exceptions.size() != 1) {
       return null;
     }
@@ -830,7 +838,7 @@ private static void throwDeleteFailed(Path path, Collection<IOException> excepti
        *   *other* paths we process will be descendants of that. That leaves only the original path
        *   argument for us to consider. And the only place we call pathNotFound is from
        *   throwDeleteFailed, and the other place that we call throwDeleteFailed inside
-       *   deleteDirectoryContents is when an exception is thrown during the recusive steps. Any
+       *   deleteDirectoryContents is when an exception is thrown during the recursive steps. Any
        *   failure during the initial lookup of the path argument itself is rethrown directly. So
        *   any exception that we're seeing here is from a descendant, which naturally has a parent.
        *   I think., @@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * An {@link InputStream} that concatenates multiple substreams. At most one stream will be open at
@@ -30,10 +30,11 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class MultiInputStream extends InputStream {
 
   private Iterator<? extends ByteSource> it;
-  private @Nullable InputStream in;
+  @CheckForNull private InputStream in;
 
   /**
    * Creates a new instance.
@@ -90,7 +91,8 @@ public int read() throws IOException {
   }
 
   @Override
-  public int read(byte @Nullable [] b, int off, int len) throws IOException {
+  public int read(byte[] b, int off, int len) throws IOException {
+    checkNotNull(b);
     while (in != null) {
       int result = in.read(b, off, len);
       if (result != -1) {, @@ -14,12 +14,14 @@
 
 package com.google.common.io;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.base.Preconditions;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A {@link Reader} that concatenates multiple readers.
@@ -28,9 +30,10 @@
  * @since 1.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 class MultiReader extends Reader {
   private final Iterator<? extends CharSource> it;
-  private @Nullable Reader current;
+  @CheckForNull private Reader current;
 
   MultiReader(Iterator<? extends CharSource> readers) throws IOException {
     this.it = readers;
@@ -46,7 +49,8 @@ private void advance() throws IOException {
   }
 
   @Override
-  public int read(char @Nullable [] cbuf, int off, int len) throws IOException {
+  public int read(char[] cbuf, int off, int len) throws IOException {
+    checkNotNull(cbuf);
     if (current == null) {
       return -1;
     }, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.io;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -21,7 +21,7 @@
 import java.io.FilenameFilter;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * File name filter that only accepts files matching a regular expression. This class is thread-safe
@@ -32,6 +32,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PatternFilenameFilter implements FilenameFilter {
 
   private final Pattern pattern;
@@ -55,8 +56,25 @@ public PatternFilenameFilter(Pattern pattern) {
     this.pattern = Preconditions.checkNotNull(pattern);
   }
 
+  /*
+   * Our implementation works fine with a null `dir`. However, there's nothing in the documentation
+   * of the supertype that suggests that implementations are expected to tolerate null. That said, I
+   * see calls in Google code that pass a null `dir` to a FilenameFilter.... So let's declare the
+   * parameter as non-nullable (since passing null to a FilenameFilter is unsafe in general), but if
+   * someone still manages to pass null, let's continue to have the method work.
+   *
+   * (OK, I haven't done that yet, but I will when I follow through on the TODO below after updating
+   * callers.)
+   *
+   * (PatternFilenameFilter is of course one of those classes that shouldn't be a publicly visible
+   * class to begin with but rather something returned from a static factory method whose declared
+   * return type is plain FilenameFilter. If we made such a change, then the annotation we choose
+   * here would have no significance to end users, who would be forced to conform to the signature
+   * used in FilenameFilter.)
+   */
   @Override
-  public boolean accept(@Nullable File dir, String fileName) {
+  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with removal of @CheckForNull.
+  public boolean accept(/* TODO(cpovirk): remove */ @CheckForNull File dir, String fileName) {
     return pattern.matcher(fileName).matches();
   }
 }, @@ -44,6 +44,7 @@
  * @author Chris Nokleberg
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class ReaderInputStream extends InputStream {
   private final Reader reader;
   private final CharsetEncoder encoder;, @@ -31,6 +31,7 @@
 @Beta
 @GwtIncompatible
 @J2ObjCIncompatible // java.nio.file
+@ElementTypesAreNonnullByDefault
 public enum RecursiveDeleteOption {
   /**
    * Specifies that the recursive delete should not throw an exception when it can't be guaranteed, @@ -29,6 +29,7 @@
 import java.net.URL;
 import java.nio.charset.Charset;
 import java.util.List;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Provides utility methods for working with resources in the classpath. Note that even though these
@@ -44,6 +45,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Resources {
   private Resources() {}
 
@@ -121,8 +123,9 @@ public static String toString(URL url, Charset charset) throws IOException {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // some processors won't return a useful result
-  public static <T> T readLines(URL url, Charset charset, LineProcessor<T> callback)
-      throws IOException {
+  @ParametricNullness
+  public static <T extends @Nullable Object> T readLines(
+      URL url, Charset charset, LineProcessor<T> callback) throws IOException {
     return asCharSource(url, charset).readLines(callback);
   }
 , ","Annotate `io` for nullness.

RELNOTES=n/a",Annotate `io` for nullness.
5538,,"['android/guava-tests/test/com/google/common/math/MathPreconditionsTest.java', 'android/guava/src/com/google/common/math/BigDecimalMath.java', 'android/guava/src/com/google/common/math/BigIntegerMath.java', 'android/guava/src/com/google/common/math/DoubleMath.java', 'android/guava/src/com/google/common/math/DoubleUtils.java', 'android/guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java', 'android/guava/src/com/google/common/math/IntMath.java', 'android/guava/src/com/google/common/math/LinearTransformation.java', 'android/guava/src/com/google/common/math/LongMath.java', 'android/guava/src/com/google/common/math/MathPreconditions.java', 'android/guava/src/com/google/common/math/PairedStats.java', 'android/guava/src/com/google/common/math/PairedStatsAccumulator.java', 'android/guava/src/com/google/common/math/ParametricNullness.java', 'android/guava/src/com/google/common/math/Quantiles.java', 'android/guava/src/com/google/common/math/Stats.java', 'android/guava/src/com/google/common/math/StatsAccumulator.java', 'android/guava/src/com/google/common/math/ToDoubleRounder.java', 'guava-tests/test/com/google/common/math/MathPreconditionsTest.java', 'guava/src/com/google/common/math/BigDecimalMath.java', 'guava/src/com/google/common/math/BigIntegerMath.java', 'guava/src/com/google/common/math/DoubleMath.java', 'guava/src/com/google/common/math/DoubleUtils.java', 'guava/src/com/google/common/math/ElementTypesAreNonnullByDefault.java', 'guava/src/com/google/common/math/IntMath.java', 'guava/src/com/google/common/math/LinearTransformation.java', 'guava/src/com/google/common/math/LongMath.java', 'guava/src/com/google/common/math/MathPreconditions.java', 'guava/src/com/google/common/math/PairedStats.java', 'guava/src/com/google/common/math/PairedStatsAccumulator.java', 'guava/src/com/google/common/math/ParametricNullness.java', 'guava/src/com/google/common/math/Quantiles.java', 'guava/src/com/google/common/math/Stats.java', 'guava/src/com/google/common/math/StatsAccumulator.java', 'guava/src/com/google/common/math/ToDoubleRounder.java']","@@ -289,4 +289,15 @@ public void testCheckNoOverflow_failure() {
       assertThat(expected).hasMessageThat().contains(""testCheckNoOverflow_failure(0, 0)"");
     }
   }
+
+  public void testNulls() {
+    /*
+     * Don't bother testing. All non-primitive parameters are used only to construct error messages.
+     * We never want to pass null for them, so we haven't annotated them to say that null is
+     * allowed. But at the same time, it seems wasteful to bother inserting the checkNotNull calls
+     * that NullPointerTester wants.
+     *
+     * (This empty method disables the automatic null testing provided by PackageSanityTests.)
+     */
+  }
 }, @@ -25,6 +25,7 @@
  * @since 30.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public class BigDecimalMath {
   private BigDecimalMath() {}
 , @@ -48,6 +48,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class BigIntegerMath {
   /**
    * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to, @@ -46,6 +46,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class DoubleMath {
   /*
    * This method returns a value y such that rounding y DOWN (towards zero) gives the same result as, @@ -33,6 +33,7 @@
  * @author Louis Wasserman
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class DoubleUtils {
   private DoubleUtils() {}
 , @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.math;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -48,6 +48,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class IntMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 , @@ -21,6 +21,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.concurrent.LazyInit;
+import javax.annotation.CheckForNull;
 
 /**
  * The representation of a linear transformation between real numbers {@code x} and {@code y}.
@@ -35,6 +36,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class LinearTransformation {
 
   /**
@@ -161,7 +163,7 @@ public static LinearTransformation forNaN() {
     final double slope;
     final double yIntercept;
 
-    @LazyInit LinearTransformation inverse;
+    @CheckForNull @LazyInit LinearTransformation inverse;
 
     RegularLinearTransformation(double slope, double yIntercept) {
       this.slope = slope;
@@ -219,7 +221,7 @@ private LinearTransformation createInverse() {
 
     final double x;
 
-    @LazyInit LinearTransformation inverse;
+    @CheckForNull @LazyInit LinearTransformation inverse;
 
     VerticalLinearTransformation(double x) {
       this.x = x;, @@ -49,6 +49,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class LongMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 , @@ -18,7 +18,6 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
 import java.math.RoundingMode;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
 
 /**
  * A collection of preconditions for math functions.
@@ -27,50 +26,51 @@
  */
 @GwtCompatible
 @CanIgnoreReturnValue
+@ElementTypesAreNonnullByDefault
 final class MathPreconditions {
-  static int checkPositive(@NullableDecl String role, int x) {
+  static int checkPositive(String role, int x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static long checkPositive(@NullableDecl String role, long x) {
+  static long checkPositive(String role, long x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static BigInteger checkPositive(@NullableDecl String role, BigInteger x) {
+  static BigInteger checkPositive(String role, BigInteger x) {
     if (x.signum() <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static int checkNonNegative(@NullableDecl String role, int x) {
+  static int checkNonNegative(String role, int x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static long checkNonNegative(@NullableDecl String role, long x) {
+  static long checkNonNegative(String role, long x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static BigInteger checkNonNegative(@NullableDecl String role, BigInteger x) {
+  static BigInteger checkNonNegative(String role, BigInteger x) {
     if (x.signum() < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static double checkNonNegative(@NullableDecl String role, double x) {
+  static double checkNonNegative(String role, double x) {
     if (!(x >= 0)) { // not x < 0, to work with NaN.
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }, @@ -28,7 +28,7 @@
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * An immutable value object capturing some basic statistics about a collection of paired double
@@ -39,6 +39,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PairedStats implements Serializable {
 
   private final Stats xStats;
@@ -213,7 +214,7 @@ public LinearTransformation leastSquaresFit() {
    * guarantees {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj == null) {
       return false;
     }, @@ -32,6 +32,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PairedStatsAccumulator {
 
   // These fields must satisfy the requirements of PairedStats' constructor as well as those of the, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.math;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -128,6 +128,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Quantiles {
 
   /** Specifies the computation of a median (i.e. the 1st 2-quantile). */, @@ -32,7 +32,7 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.util.Iterator;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+import javax.annotation.CheckForNull;
 
 /**
  * A bundle of statistical summary values -- sum, count, mean/average, min and max, and several
@@ -60,6 +60,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Stats implements Serializable {
 
   private final long count;
@@ -340,7 +341,7 @@ public double max() {
    * {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@NullableDecl Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj == null) {
       return false;
     }, @@ -34,6 +34,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class StatsAccumulator {
 
   // These fields must satisfy the requirements of Stats' constructor as well as those of the stat, @@ -25,6 +25,7 @@
  * a {@link RoundingMode}.
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
   /**
    * Returns x rounded to either the greatest double less than or equal to the precise value of x,, @@ -289,4 +289,15 @@ public void testCheckNoOverflow_failure() {
       assertThat(expected).hasMessageThat().contains(""testCheckNoOverflow_failure(0, 0)"");
     }
   }
+
+  public void testNulls() {
+    /*
+     * Don't bother testing. All non-primitive parameters are used only to construct error messages.
+     * We never want to pass null for them, so we haven't annotated them to say that null is
+     * allowed. But at the same time, it seems wasteful to bother inserting the checkNotNull calls
+     * that NullPointerTester wants.
+     *
+     * (This empty method disables the automatic null testing provided by PackageSanityTests.)
+     */
+  }
 }, @@ -25,6 +25,7 @@
  * @since 30.0
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public class BigDecimalMath {
   private BigDecimalMath() {}
 , @@ -48,6 +48,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class BigIntegerMath {
   /**
    * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to, @@ -46,6 +46,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class DoubleMath {
   /*
    * This method returns a value y such that rounding y DOWN (towards zero) gives the same result as, @@ -33,6 +33,7 @@
  * @author Louis Wasserman
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 final class DoubleUtils {
   private DoubleUtils() {}
 , @@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.math;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Marks all ""top-level"" types as non-null in a way that is recognized by Kotlin. Note that this
+ * unfortunately includes type-variable usages, so we also provide {@link ParametricNullness} to
+ * ""undo"" it as best we can.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target(TYPE)
+@TypeQualifierDefault({FIELD, METHOD, PARAMETER})
+@Nonnull
+@interface ElementTypesAreNonnullByDefault {}, @@ -48,6 +48,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class IntMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 , @@ -21,6 +21,7 @@
 import com.google.common.annotations.Beta;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.errorprone.annotations.concurrent.LazyInit;
+import javax.annotation.CheckForNull;
 
 /**
  * The representation of a linear transformation between real numbers {@code x} and {@code y}.
@@ -35,6 +36,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public abstract class LinearTransformation {
 
   /**
@@ -161,7 +163,7 @@ public static LinearTransformation forNaN() {
     final double slope;
     final double yIntercept;
 
-    @LazyInit LinearTransformation inverse;
+    @CheckForNull @LazyInit LinearTransformation inverse;
 
     RegularLinearTransformation(double slope, double yIntercept) {
       this.slope = slope;
@@ -219,7 +221,7 @@ private LinearTransformation createInverse() {
 
     final double x;
 
-    @LazyInit LinearTransformation inverse;
+    @CheckForNull @LazyInit LinearTransformation inverse;
 
     VerticalLinearTransformation(double x) {
       this.x = x;, @@ -49,6 +49,7 @@
  * @since 11.0
  */
 @GwtCompatible(emulated = true)
+@ElementTypesAreNonnullByDefault
 public final class LongMath {
   // NOTE: Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||
 , @@ -18,7 +18,6 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.math.BigInteger;
 import java.math.RoundingMode;
-import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A collection of preconditions for math functions.
@@ -27,50 +26,51 @@
  */
 @GwtCompatible
 @CanIgnoreReturnValue
+@ElementTypesAreNonnullByDefault
 final class MathPreconditions {
-  static int checkPositive(@Nullable String role, int x) {
+  static int checkPositive(String role, int x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static long checkPositive(@Nullable String role, long x) {
+  static long checkPositive(String role, long x) {
     if (x <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static BigInteger checkPositive(@Nullable String role, BigInteger x) {
+  static BigInteger checkPositive(String role, BigInteger x) {
     if (x.signum() <= 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be > 0"");
     }
     return x;
   }
 
-  static int checkNonNegative(@Nullable String role, int x) {
+  static int checkNonNegative(String role, int x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static long checkNonNegative(@Nullable String role, long x) {
+  static long checkNonNegative(String role, long x) {
     if (x < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static BigInteger checkNonNegative(@Nullable String role, BigInteger x) {
+  static BigInteger checkNonNegative(String role, BigInteger x) {
     if (x.signum() < 0) {
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }
     return x;
   }
 
-  static double checkNonNegative(@Nullable String role, double x) {
+  static double checkNonNegative(String role, double x) {
     if (!(x >= 0)) { // not x < 0, to work with NaN.
       throw new IllegalArgumentException(role + "" ("" + x + "") must be >= 0"");
     }, @@ -28,7 +28,7 @@
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * An immutable value object capturing some basic statistics about a collection of paired double
@@ -39,6 +39,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PairedStats implements Serializable {
 
   private final Stats xStats;
@@ -213,7 +214,7 @@ public LinearTransformation leastSquaresFit() {
    * guarantees {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@Nullable Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj == null) {
       return false;
     }, @@ -32,6 +32,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class PairedStatsAccumulator {
 
   // These fields must satisfy the requirements of PairedStats' constructor as well as those of the, @@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2021 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.math;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.annotation.meta.When.UNKNOWN;
+
+import com.google.common.annotations.GwtCompatible;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierNickname;
+
+/**
+ * Marks a ""top-level"" type-variable usage as (a) a Kotlin platform type when the type argument is
+ * non-nullable and (b) nullable when the type argument is nullable. This is the closest we can get
+ * to ""non-nullable when non-nullable; nullable when nullable"" (like the Android <a
+ * href=""https://android.googlesource.com/platform/libcore/+/master/luni/src/main/java/libcore/util/NullFromTypeParam.java"">{@code
+ * NullFromTypeParam}</a>). We use this to ""undo"" {@link ElementTypesAreNonnullByDefault}.
+ */
+@GwtCompatible
+@Retention(RUNTIME)
+@Target({FIELD, METHOD, PARAMETER})
+@TypeQualifierNickname
+@Nonnull(when = UNKNOWN)
+@interface ParametricNullness {}, @@ -128,6 +128,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Quantiles {
 
   /** Specifies the computation of a median (i.e. the 1st 2-quantile). */, @@ -36,7 +36,7 @@
 import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import javax.annotation.CheckForNull;
 
 /**
  * A bundle of statistical summary values -- sum, count, mean/average, min and max, and several
@@ -64,6 +64,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class Stats implements Serializable {
 
   private final long count;
@@ -416,7 +417,7 @@ public double max() {
    * {@code strictfp}-like semantics.)
    */
   @Override
-  public boolean equals(@Nullable Object obj) {
+  public boolean equals(@CheckForNull Object obj) {
     if (obj == null) {
       return false;
     }, @@ -37,6 +37,7 @@
  */
 @Beta
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 public final class StatsAccumulator {
 
   // These fields must satisfy the requirements of Stats' constructor as well as those of the stat, @@ -25,6 +25,7 @@
  * a {@link RoundingMode}.
  */
 @GwtIncompatible
+@ElementTypesAreNonnullByDefault
 abstract class ToDoubleRounder<X extends Number & Comparable<X>> {
   /**
    * Returns x rounded to either the greatest double less than or equal to the precise value of x,, ","Annotate `math` for nullness.

RELNOTES=n/a",Annotate `math` for nullness.
5539,,"['android/guava/src/com/google/common/base/Throwables.java', 'android/guava/src/com/google/common/io/Closer.java', 'android/guava/src/com/google/common/io/LineReader.java', 'android/guava/src/com/google/common/io/PatternFilenameFilter.java', 'android/guava/src/com/google/common/reflect/AbstractInvocationHandler.java', 'guava/src/com/google/common/base/Throwables.java', 'guava/src/com/google/common/io/Closer.java', 'guava/src/com/google/common/io/LineReader.java', 'guava/src/com/google/common/io/PatternFilenameFilter.java', 'guava/src/com/google/common/reflect/AbstractInvocationHandler.java']","@@ -46,7 +46,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-@ElementTypesAreNonnullByDefault
+// TODO(b/147136275): After adding @CheckForNull below, add @ElementTypesAreNonnullByDefault.
 public final class Throwables {
   private Throwables() {}
 
@@ -333,7 +333,7 @@ public static Throwable getRootCause(Throwable throwable) {
   @Beta
   @GwtIncompatible // Class.cast(Object)
   @SuppressWarnings(""nullness"")
-  // TODO(cpovirk): Add @CheckForNull after updating callers.
+  // TODO(b/147136275): After updating callers, add @CheckForNull, and remove @SuppressWarnings.
   public static <X extends Throwable> X getCauseAs(
       Throwable throwable, Class<X> expectedCauseType) {
     try {, @@ -125,9 +125,10 @@ public static Closer create() {
   // close. this word no longer has any meaning to me.
   @CanIgnoreReturnValue
   @ParametricNullness
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @ParametricNullness.
+  @SuppressWarnings(""nullness"")
   public <C extends @Nullable Closeable> C register(
-      /* TODO(cpovirk): change to @ParametricNullness */ @CheckForNull C closeable) {
+      // TODO(b/147136275): Replace @CheckForNull with @ParametricNullness, and remove suppression.
+      @CheckForNull C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }, @@ -37,7 +37,7 @@
  */
 @Beta
 @GwtIncompatible
-@ElementTypesAreNonnullByDefault
+// TODO(b/147136275): After adding @CheckForNull below, add @ElementTypesAreNonnullByDefault.
 public final class LineReader {
   private final Readable readable;
   @CheckForNull private final Reader reader;
@@ -69,8 +69,8 @@ public LineReader(Readable readable) {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // to skip a line
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @CheckForNull.
-  // TODO(cpovirk): @CheckForNull
+  @SuppressWarnings(""nullness"")
+  // TODO(b/147136275): After updating callers, add @CheckForNull, and remove @SuppressWarnings.
   public String readLine() throws IOException {
     while (lines.peek() == null) {
       Java8Compatibility.clear(cbuf);, @@ -73,8 +73,10 @@ public PatternFilenameFilter(Pattern pattern) {
    * used in FilenameFilter.)
    */
   @Override
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with removal of @CheckForNull.
-  public boolean accept(/* TODO(cpovirk): remove */ @CheckForNull File dir, String fileName) {
+  @SuppressWarnings(""nullness"")
+  public boolean accept(
+      // TODO(b/147136275): Remove @CheckForNull, and remove suppression.
+      @CheckForNull File dir, String fileName) {
     return pattern.matcher(fileName).matches();
   }
 }, @@ -40,7 +40,7 @@
  * @since 12.0
  */
 @Beta
-// TODO(cpovirk): after adding @Nullable below
+// TODO(b/147136275): After adding @Nullable below, add .
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractInvocationHandler implements InvocationHandler {
 
@@ -100,7 +100,8 @@ public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable
    */
   @CheckForNull
   protected abstract Object handleInvocation(
-      Object proxy, Method method, /* TODO(cpovirk): @Nullable */ Object[] args) throws Throwable;
+      Object proxy, Method method, /* TODO(b/147136275): Add @Nullable. */ Object[] args)
+      throws Throwable;
 
   /**
    * By default delegates to {@link Object#equals} so instances are only equal if they are, @@ -46,7 +46,7 @@
  * @since 1.0
  */
 @GwtCompatible(emulated = true)
-@ElementTypesAreNonnullByDefault
+// TODO(b/147136275): After adding @CheckForNull below, add @ElementTypesAreNonnullByDefault.
 public final class Throwables {
   private Throwables() {}
 
@@ -333,7 +333,7 @@ public static Throwable getRootCause(Throwable throwable) {
   @Beta
   @GwtIncompatible // Class.cast(Object)
   @SuppressWarnings(""nullness"")
-  // TODO(cpovirk): Add @CheckForNull after updating callers.
+  // TODO(b/147136275): After updating callers, add @CheckForNull, and remove @SuppressWarnings.
   public static <X extends Throwable> X getCauseAs(
       Throwable throwable, Class<X> expectedCauseType) {
     try {, @@ -125,9 +125,10 @@ public static Closer create() {
   // close. this word no longer has any meaning to me.
   @CanIgnoreReturnValue
   @ParametricNullness
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @ParametricNullness.
+  @SuppressWarnings(""nullness"")
   public <C extends @Nullable Closeable> C register(
-      /* TODO(cpovirk): change to @ParametricNullness */ @CheckForNull C closeable) {
+      // TODO(b/147136275): Replace @CheckForNull with @ParametricNullness, and remove suppression.
+      @CheckForNull C closeable) {
     if (closeable != null) {
       stack.addFirst(closeable);
     }, @@ -37,7 +37,7 @@
  */
 @Beta
 @GwtIncompatible
-@ElementTypesAreNonnullByDefault
+// TODO(b/147136275): After adding @CheckForNull below, add @ElementTypesAreNonnullByDefault.
 public final class LineReader {
   private final Readable readable;
   @CheckForNull private final Reader reader;
@@ -69,8 +69,8 @@ public LineReader(Readable readable) {
    * @throws IOException if an I/O error occurs
    */
   @CanIgnoreReturnValue // to skip a line
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with change to @CheckForNull.
-  // TODO(cpovirk): @CheckForNull
+  @SuppressWarnings(""nullness"")
+  // TODO(b/147136275): After updating callers, add @CheckForNull, and remove @SuppressWarnings.
   public String readLine() throws IOException {
     while (lines.peek() == null) {
       Java8Compatibility.clear(cbuf);, @@ -73,8 +73,10 @@ public PatternFilenameFilter(Pattern pattern) {
    * used in FilenameFilter.)
    */
   @Override
-  @SuppressWarnings(""nullness"") // TODO(cpovirk): Remove with removal of @CheckForNull.
-  public boolean accept(/* TODO(cpovirk): remove */ @CheckForNull File dir, String fileName) {
+  @SuppressWarnings(""nullness"")
+  public boolean accept(
+      // TODO(b/147136275): Remove @CheckForNull, and remove suppression.
+      @CheckForNull File dir, String fileName) {
     return pattern.matcher(fileName).matches();
   }
 }, @@ -40,7 +40,7 @@
  * @since 12.0
  */
 @Beta
-// TODO(cpovirk): after adding @Nullable below
+// TODO(b/147136275): After adding @Nullable below, add .
 @ElementTypesAreNonnullByDefault
 public abstract class AbstractInvocationHandler implements InvocationHandler {
 
@@ -100,7 +100,8 @@ public final Object invoke(Object proxy, Method method, @CheckForNull @Nullable
    */
   @CheckForNull
   protected abstract Object handleInvocation(
-      Object proxy, Method method, /* TODO(cpovirk): @Nullable */ Object[] args) throws Throwable;
+      Object proxy, Method method, /* TODO(b/147136275): Add @Nullable. */ Object[] args)
+      throws Throwable;
 
   /**
    * By default delegates to {@link Object#equals} so instances are only equal if they are, ","Comment out @ElementTypesAreNonnullByDefault in classes that are missing `@CheckReturnValue` for at least one location.

Also, standardize TODOs.

RELNOTES=n/a",Comment out @ElementTypesAreNonnullByDefault in classes that are missing `@CheckReturnValue` for at least one location.
5556,,"['android/guava/src/com/google/common/base/Functions.java', 'android/guava/src/com/google/common/base/Predicates.java', 'guava/src/com/google/common/base/Functions.java', 'guava/src/com/google/common/base/Predicates.java']","@@ -361,12 +361,12 @@ public String toString() {
    *
    * @since 10.0
    */
-  public static <T> Function<Object, T> forSupplier(Supplier<T> supplier) {
-    return new SupplierFunction<T>(supplier);
+  public static <F, T> Function<F, T> forSupplier(Supplier<T> supplier) {
+    return new SupplierFunction<>(supplier);
   }
 
   /** @see Functions#forSupplier */
-  private static class SupplierFunction<T> implements Function<Object, T>, Serializable {
+  private static class SupplierFunction<F, T> implements Function<F, T>, Serializable {
 
     private final Supplier<T> supplier;
 
@@ -375,14 +375,14 @@ private SupplierFunction(Supplier<T> supplier) {
     }
 
     @Override
-    public T apply(@NullableDecl Object input) {
+    public T apply(@NullableDecl F input) {
       return supplier.get();
     }
 
     @Override
     public boolean equals(@NullableDecl Object obj) {
       if (obj instanceof SupplierFunction) {
-        SupplierFunction<?> that = (SupplierFunction<?>) obj;
+        SupplierFunction<?, ?> that = (SupplierFunction<?, ?>) obj;
         return this.supplier.equals(that.supplier);
       }
       return false;, @@ -169,8 +169,8 @@ private Predicates() {}
    * instances {@code Lists.newArrayList(1)} and {@code Arrays.asList(1)}.
    */
   @GwtIncompatible // Class.isInstance
-  public static Predicate<Object> instanceOf(Class<?> clazz) {
-    return new InstanceOfPredicate(clazz);
+  public static <T> Predicate<T> instanceOf(Class<?> clazz) {
+    return new InstanceOfPredicate<T>(clazz);
   }
 
   /**
@@ -472,15 +472,15 @@ public String toString() {
 
   /** @see Predicates#instanceOf(Class) */
   @GwtIncompatible // Class.isInstance
-  private static class InstanceOfPredicate implements Predicate<Object>, Serializable {
+  private static class InstanceOfPredicate<T> implements Predicate<T>, Serializable {
     private final Class<?> clazz;
 
     private InstanceOfPredicate(Class<?> clazz) {
       this.clazz = checkNotNull(clazz);
     }
 
     @Override
-    public boolean apply(@NullableDecl Object o) {
+    public boolean apply(@NullableDecl T o) {
       return clazz.isInstance(o);
     }
 
@@ -492,7 +492,7 @@ public int hashCode() {
     @Override
     public boolean equals(@NullableDecl Object obj) {
       if (obj instanceof InstanceOfPredicate) {
-        InstanceOfPredicate that = (InstanceOfPredicate) obj;
+        InstanceOfPredicate<?> that = (InstanceOfPredicate<?>) obj;
         return clazz == that.clazz;
       }
       return false;, @@ -359,12 +359,12 @@ public String toString() {
    *
    * @since 10.0
    */
-  public static <T> Function<Object, T> forSupplier(Supplier<T> supplier) {
-    return new SupplierFunction<T>(supplier);
+  public static <F, T> Function<F, T> forSupplier(Supplier<T> supplier) {
+    return new SupplierFunction<>(supplier);
   }
 
   /** @see Functions#forSupplier */
-  private static class SupplierFunction<T> implements Function<Object, T>, Serializable {
+  private static class SupplierFunction<F, T> implements Function<F, T>, Serializable {
 
     private final Supplier<T> supplier;
 
@@ -373,14 +373,14 @@ private SupplierFunction(Supplier<T> supplier) {
     }
 
     @Override
-    public T apply(@Nullable Object input) {
+    public T apply(@Nullable F input) {
       return supplier.get();
     }
 
     @Override
     public boolean equals(@Nullable Object obj) {
       if (obj instanceof SupplierFunction) {
-        SupplierFunction<?> that = (SupplierFunction<?>) obj;
+        SupplierFunction<?, ?> that = (SupplierFunction<?, ?>) obj;
         return this.supplier.equals(that.supplier);
       }
       return false;, @@ -169,8 +169,8 @@ private Predicates() {}
    * instances {@code Lists.newArrayList(1)} and {@code Arrays.asList(1)}.
    */
   @GwtIncompatible // Class.isInstance
-  public static Predicate<Object> instanceOf(Class<?> clazz) {
-    return new InstanceOfPredicate(clazz);
+  public static <T> Predicate<T> instanceOf(Class<?> clazz) {
+    return new InstanceOfPredicate<T>(clazz);
   }
 
   /**
@@ -472,15 +472,15 @@ public String toString() {
 
   /** @see Predicates#instanceOf(Class) */
   @GwtIncompatible // Class.isInstance
-  private static class InstanceOfPredicate implements Predicate<Object>, Serializable {
+  private static class InstanceOfPredicate<T> implements Predicate<T>, Serializable {
     private final Class<?> clazz;
 
     private InstanceOfPredicate(Class<?> clazz) {
       this.clazz = checkNotNull(clazz);
     }
 
     @Override
-    public boolean apply(@Nullable Object o) {
+    public boolean apply(@Nullable T o) {
       return clazz.isInstance(o);
     }
 
@@ -492,7 +492,7 @@ public int hashCode() {
     @Override
     public boolean equals(@Nullable Object obj) {
       if (obj instanceof InstanceOfPredicate) {
-        InstanceOfPredicate that = (InstanceOfPredicate) obj;
+        InstanceOfPredicate<?> that = (InstanceOfPredicate<?>) obj;
         return clazz == that.clazz;
       }
       return false;, ","Generalize `Function` and `Predicate` factories to let callers specify the desired input type.

RELNOTES=`base`: Changed `Functions.forSupplier` and `Predicates.instanceOf` to accept an additional type argument to specify the input type for the returned `Function`/`Predicate`. The flexibility we're adding should typically not be necessary if users follow the [PECS](https://stackoverflow.com/a/2723538/28465) principle, but it can be useful in some cases, particularly around nullness analysis. Note that this change may require updates to callers' source code (to specify an additional type argument). Still, it maintains _binary_ compatibility.",Generalize `Function` and `Predicate` factories to let callers specify the desired input type.
5572,,"['android/guava/src/com/google/common/collect/Queues.java', 'android/guava/src/com/google/common/graph/EndpointPair.java', 'guava/src/com/google/common/collect/Queues.java', 'guava/src/com/google/common/graph/EndpointPair.java']","@@ -188,7 +188,8 @@ private Queues() {}
    * Creates an empty {@code PriorityBlockingQueue} with the ordering given by its elements' natural
    * ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   @GwtIncompatible // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue() {
@@ -201,7 +202,8 @@ private Queues() {}
    * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
    * this priority queue will be ordered according to the same ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   @GwtIncompatible // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue(
@@ -220,7 +222,8 @@ private Queues() {}
    * Creates an empty {@code PriorityQueue} with the ordering given by its elements' natural
    * ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue() {
     return new PriorityQueue<E>();
@@ -232,7 +235,8 @@ private Queues() {}
    * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
    * this priority queue will be ordered according to the same ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue(
       Iterable<? extends E> elements) {, @@ -104,7 +104,7 @@ public final N nodeV() {
    * Returns the node that is adjacent to {@code node} along the origin edge.
    *
    * @throws IllegalArgumentException if this {@link EndpointPair} does not contain {@code node}
-   * @since 20.0 (requires that the argument have type {@code N} since 31.0)
+   * @since 20.0 (but the argument type was changed from {@code Object} to {@code N} in 31.0)
    */
   public final N adjacentNode(N node) {
     if (node.equals(nodeU)) {, @@ -188,7 +188,8 @@ private Queues() {}
    * Creates an empty {@code PriorityBlockingQueue} with the ordering given by its elements' natural
    * ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   @GwtIncompatible // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue() {
@@ -201,7 +202,8 @@ private Queues() {}
    * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
    * this priority queue will be ordered according to the same ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   @GwtIncompatible // PriorityBlockingQueue
   public static <E extends Comparable> PriorityBlockingQueue<E> newPriorityBlockingQueue(
@@ -220,7 +222,8 @@ private Queues() {}
    * Creates an empty {@code PriorityQueue} with the ordering given by its elements' natural
    * ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue() {
     return new PriorityQueue<E>();
@@ -232,7 +235,8 @@ private Queues() {}
    * <p><b>Note:</b> If the specified iterable is a {@code SortedSet} or a {@code PriorityQueue},
    * this priority queue will be ordered according to the same ordering.
    *
-   * @since 11.0 (requires that {@code E} be {@code Comparable} since 15.0).
+   * @since 11.0 (but the bound of {@code E} was changed from {@code Object} to {@code Comparable}
+   *     in 15.0)
    */
   public static <E extends Comparable> PriorityQueue<E> newPriorityQueue(
       Iterable<? extends E> elements) {, @@ -104,7 +104,7 @@ public final N nodeV() {
    * Returns the node that is adjacent to {@code node} along the origin edge.
    *
    * @throws IllegalArgumentException if this {@link EndpointPair} does not contain {@code node}
-   * @since 20.0 (requires that the argument have type {@code N} since 31.0)
+   * @since 20.0 (but the argument type was changed from {@code Object} to {@code N} in 31.0)
    */
   public final N adjacentNode(N node) {
     if (node.equals(nodeU)) {, ","Clarify comments discussed in https://github.com/google/guava/pull/5546#discussion_r626856415.

RELNOTES=n/a",Clarify comments discussed in https://github.com/google/guava/pull/5546#discussion_r626856415.
5582,,"['android/guava/src/com/google/common/cache/CacheBuilder.java', 'guava/src/com/google/common/cache/CacheBuilder.java']","@@ -75,7 +75,7 @@
  * href=""https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncLoadingCache.html#get(K)"">{@code
  * AsyncLoadingCache.get}</a> returns a {@code CompletableFuture}, and implementations of <a
  * href=""https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncCacheLoader.html#asyncLoad(K,java.util.concurrent.Executor)"">{@code
- * AsyncLoadingCache.asyncLoad}</a> must return a {@code CompletableFuture}. Users of Guava's {@link
+ * AsyncCacheLoader.asyncLoad}</a> must return a {@code CompletableFuture}. Users of Guava's {@link
  * com.google.common.util.concurrent.ListenableFuture} can adapt between the two {@code Future}
  * types by using <a href=""https://github.com/lukas-krecan/future-converter#java8-guava"">{@code
  * net.javacrumbs.futureconverter.java8guava.FutureConverter}</a>., @@ -74,7 +74,7 @@
  * href=""https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncLoadingCache.html#get(K)"">{@code
  * AsyncLoadingCache.get}</a> returns a {@code CompletableFuture}, and implementations of <a
  * href=""https://www.javadoc.io/doc/com.github.ben-manes.caffeine/caffeine/latest/com.github.benmanes.caffeine/com/github/benmanes/caffeine/cache/AsyncCacheLoader.html#asyncLoad(K,java.util.concurrent.Executor)"">{@code
- * AsyncLoadingCache.asyncLoad}</a> must return a {@code CompletableFuture}. Users of Guava's {@link
+ * AsyncCacheLoader.asyncLoad}</a> must return a {@code CompletableFuture}. Users of Guava's {@link
  * com.google.common.util.concurrent.ListenableFuture} can adapt between the two {@code Future}
  * types by using <a href=""https://github.com/lukas-krecan/future-converter#java8-guava"">{@code
  * net.javacrumbs.futureconverter.java8guava.FutureConverter}</a>., ","Fix typo noted by @ben-manes in https://github.com/google/guava/commit/ce4bad32a3f15ffb21cc2a13e6db4ad03f915033#r51511526.

RELNOTES=n/a",Fix typo noted by @ben-manes in https://github.com/google/guava/commit/ce4bad32a3f15ffb21cc2a13e6db4ad03f915033#r51511526.
5583,,"['android/guava/src/com/google/common/base/Stopwatch.java', 'guava-tests/test/com/google/common/base/StopwatchJavaTimeTest.java', 'guava-tests/test/com/google/common/base/StopwatchTest.java']","@@ -85,7 +85,7 @@
  * @author Kevin Bourrillion
  * @since 10.0
  */
-@GwtCompatible
+@GwtCompatible(emulated = true)
 @SuppressWarnings(""GoodTime"") // lots of violations
 @ElementTypesAreNonnullByDefault
 public final class Stopwatch {, @@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2008 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.common.base;
+
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.testing.FakeTicker;
+import java.time.Duration;
+import junit.framework.TestCase;
+
+/** Unit test for the {@code java.time} support in {@link Stopwatch}. */
+@GwtIncompatible
+public class StopwatchJavaTimeTest extends TestCase {
+  private final FakeTicker ticker = new FakeTicker();
+  private final Stopwatch stopwatch = new Stopwatch(ticker);
+
+  public void testElapsed_duration() {
+    stopwatch.start();
+    ticker.advance(999999);
+    assertEquals(Duration.ofNanos(999999), stopwatch.elapsed());
+    ticker.advance(1);
+    assertEquals(Duration.ofMillis(1), stopwatch.elapsed());
+  }
+}, @@ -21,9 +21,7 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 import com.google.common.annotations.GwtCompatible;
-import com.google.common.annotations.GwtIncompatible;
 import com.google.common.testing.FakeTicker;
-import java.time.Duration;
 import junit.framework.TestCase;
 
 /**
@@ -168,15 +166,6 @@ public void testElapsed_millis() {
     assertEquals(1, stopwatch.elapsed(MILLISECONDS));
   }
 
-  @GwtIncompatible
-  public void testElapsed_duration() {
-    stopwatch.start();
-    ticker.advance(999999);
-    assertEquals(Duration.ofNanos(999999), stopwatch.elapsed());
-    ticker.advance(1);
-    assertEquals(Duration.ofMillis(1), stopwatch.elapsed());
-  }
-
   public void testToString() {
     stopwatch.start();
     assertEquals(""0.000 ns"", stopwatch.toString());, ","Split `java.time` tests out of `StopwatchTest`.

RELNOTES=n/a",Split `java.time` tests out of `StopwatchTest`.
5584,,"['android/guava/src/com/google/common/util/concurrent/AbstractService.java', 'android/guava/src/com/google/common/util/concurrent/Service.java', 'guava/src/com/google/common/util/concurrent/AbstractService.java', 'guava/src/com/google/common/util/concurrent/Service.java']","@@ -171,7 +171,7 @@ public boolean isSatisfied() {
 
     @Override
     public boolean isSatisfied() {
-      return state().isTerminal();
+      return state().compareTo(TERMINATED) >= 0;
     }
   }
 , @@ -176,61 +176,28 @@
    */
   enum State {
     /** A service in this state is inactive. It does minimal work and consumes minimal resources. */
-    NEW {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    NEW,
 
     /** A service in this state is transitioning to {@link #RUNNING}. */
-    STARTING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    STARTING,
 
     /** A service in this state is operational. */
-    RUNNING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    RUNNING,
 
     /** A service in this state is transitioning to {@link #TERMINATED}. */
-    STOPPING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    STOPPING,
 
     /**
      * A service in this state has completed execution normally. It does minimal work and consumes
      * minimal resources.
      */
-    TERMINATED {
-      @Override
-      boolean isTerminal() {
-        return true;
-      }
-    },
+    TERMINATED,
 
     /**
      * A service in this state has encountered a problem and may not be operational. It cannot be
      * started nor stopped.
      */
-    FAILED {
-      @Override
-      boolean isTerminal() {
-        return true;
-      }
-    };
-
-    /** Returns true if this state is terminal. */
-    abstract boolean isTerminal();
+    FAILED,
   }
 
   /**, @@ -172,7 +172,7 @@ public boolean isSatisfied() {
 
     @Override
     public boolean isSatisfied() {
-      return state().isTerminal();
+      return state().compareTo(TERMINATED) >= 0;
     }
   }
 , @@ -207,61 +207,28 @@ default void awaitTerminated(Duration timeout) throws TimeoutException {
    */
   enum State {
     /** A service in this state is inactive. It does minimal work and consumes minimal resources. */
-    NEW {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    NEW,
 
     /** A service in this state is transitioning to {@link #RUNNING}. */
-    STARTING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    STARTING,
 
     /** A service in this state is operational. */
-    RUNNING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    RUNNING,
 
     /** A service in this state is transitioning to {@link #TERMINATED}. */
-    STOPPING {
-      @Override
-      boolean isTerminal() {
-        return false;
-      }
-    },
+    STOPPING,
 
     /**
      * A service in this state has completed execution normally. It does minimal work and consumes
      * minimal resources.
      */
-    TERMINATED {
-      @Override
-      boolean isTerminal() {
-        return true;
-      }
-    },
+    TERMINATED,
 
     /**
      * A service in this state has encountered a problem and may not be operational. It cannot be
      * started nor stopped.
      */
-    FAILED {
-      @Override
-      boolean isTerminal() {
-        return true;
-      }
-    };
-
-    /** Returns true if this state is terminal. */
-    abstract boolean isTerminal();
+    FAILED,
   }
 
   /**, ","Remove `Service.State.isTerminal()`.

It was only referenced in one place. Since we guarantee that transitions between the states in the `Service.State` enum are always from an earlier to a later value, we know that the terminal states must be last. So it's enough to compare with the first terminal state, `TERMINATED`. The code in question already does something very similar with the `RUNNING` state a few lines earlier.

RELNOTES=n/a",Remove `Service.State.isTerminal()`.
